diff --git a/#id.h# b/#id.h#
deleted file mode 100644
index bcb9a3e..0000000
--- a/#id.h#
+++ /dev/null
@@ -1,163 +0,0 @@
-/* DO NOT EDIT THIS FILE DIRECTLY */
-/**********************************************************************
-
-  id.h - 
-
-  $Author: nobu $
-  created at: Sun Oct 19 21:12:51 2008
-
-  Copyright (C) 2007 Koichi Sasada
-
-**********************************************************************/
-
-#ifndef RUBY_ID_H
-#define RUBY_ID_H
-
-#define ID_SCOPE_SHIFT 3
-#define ID_SCOPE_MASK 0x07
-#define ID_LOCAL      0x00
-#define ID_INSTANCE   0x01
-#define ID_GLOBAL     0x03
-#define ID_ATTRSET    0x04
-#define ID_CONST      0x05
-#define ID_CLASS      0x06
-#define ID_JUNK       0x07
-#define ID_INTERNAL   ID_JUNK
-
-#ifdef USE_PARSE_H
-#include "parse.h"
-#endif
-
-#define symIFUNC ID2SYM(idIFUNC)
-#define symCFUNC ID2SYM(idCFUNC)
-
-#if !defined tLAST_TOKEN && defined YYTOKENTYPE
-#define tLAST_TOKEN tLAST_TOKEN
-#endif
-
-enum ruby_method_ids {
-#ifndef tLAST_TOKEN
-  tUPLUS = 322,
-    tUMINUS = 323,
-    tPOW = 324,
-    tCMP = 325,
-    tEQ = 326,
-    tEQQ = 327,
-    tNEQ = 328,
-    tGEQ = 329,
-    tLEQ = 330,
-    tANDOP = 331,
-    tOROP = 332,
-    tMATCH = 333,
-    tNMATCH = 334,
-    tDOT2 = 335,
-    tDOT3 = 336,
-    tAREF = 337,
-    tASET = 338,
-    tLSHFT = 339,
-    tRSHFT = 340,
-    tLAMBDA = 353,
-    idNULL = 366,
-    idRespond_to = 367,
-    idIFUNC = 368,
-    idCFUNC = 369,
-    idThrowState = 370,
-    id_core_set_method_alias = 371,
-    id_core_set_variable_alias = 372,
-    id_core_undef_method = 373,
-    id_core_define_method = 374,
-    id_core_define_singleton_method = 375,
-    id_core_set_postexe = 376,
-    tLAST_TOKEN = 377,
-#endif
-    idPLUS = '+',
-    idMINUS = '-',
-    idMULT = '*',
-    idDIV = '/',
-    idMOD = '%',
-    idLT = '<',
-    idLTLT = tLSHFT,
-    idLE = tLEQ,
-    idGT = '>',
-    idGE = tGEQ,
-    idEq = tEQ,
-    idEqq = tEQQ,
-    idNeq = tNEQ,
-    idNot = '!',
-    idBackquote = '`',
-    idEqTilde = tMATCH,
-    idAREF = tAREF,
-    idASET = tASET,
-    idLAST_TOKEN = tLAST_TOKEN >> ID_SCOPE_SHIFT,
-    tIntern,
-    tMethodMissing,
-    tLength,
-    tGets,
-    tSucc,
-    tEach,
-    tLambda,
-    tSend,
-    t__send__,
-    tInitialize,
-#if SUPPORT_JOKE
-    tBitblt,
-    tAnswer,
-#endif
-    tLAST_ID,
-#define TOKEN2ID(n) id##n = ((t##n<<ID_SCOPE_SHIFT)|ID_LOCAL)
-#if SUPPORT_JOKE
-    TOKEN2ID(Bitblt),
-    TOKEN2ID(Answer),
-#endif
-    TOKEN2ID(Intern),
-    TOKEN2ID(MethodMissing),
-    TOKEN2ID(Length),
-    TOKEN2ID(Gets),
-    TOKEN2ID(Succ),
-    TOKEN2ID(Each),
-    TOKEN2ID(Lambda),
-    TOKEN2ID(Send),
-    TOKEN2ID(__send__),
-    TOKEN2ID(Initialize)
-};
-
-#ifdef tLAST_TOKEN
-struct ruby_method_ids_check {
-#define ruby_method_id_check_for(name, value) \
-    int checking_for_##name[name == value ? 1 : -1]
-ruby_method_id_check_for(tUPLUS, 322);
-ruby_method_id_check_for(tUMINUS, 323);
-ruby_method_id_check_for(tPOW, 324);
-ruby_method_id_check_for(tCMP, 325);
-ruby_method_id_check_for(tEQ, 326);
-ruby_method_id_check_for(tEQQ, 327);
-ruby_method_id_check_for(tNEQ, 328);
-ruby_method_id_check_for(tGEQ, 329);
-ruby_method_id_check_for(tLEQ, 330);
-ruby_method_id_check_for(tANDOP, 331);
-ruby_method_id_check_for(tOROP, 332);
-ruby_method_id_check_for(tMATCH, 333);
-ruby_method_id_check_for(tNMATCH, 334);
-ruby_method_id_check_for(tDOT2, 335);
-ruby_method_id_check_for(tDOT3, 336);
-ruby_method_id_check_for(tAREF, 337);
-ruby_method_id_check_for(tASET, 338);
-ruby_method_id_check_for(tLSHFT, 339);
-ruby_method_id_check_for(tRSHFT, 340);
-ruby_method_id_check_for(tLAMBDA, 353);
-ruby_method_id_check_for(idNULL, 366);
-ruby_method_id_check_for(idRespond_to, 367);
-ruby_method_id_check_for(idIFUNC, 368);
-ruby_method_id_check_for(idCFUNC, 369);
-ruby_method_id_check_for(idThrowState, 370);
-ruby_method_id_check_for(id_core_set_method_alias, 371);
-ruby_method_id_check_for(id_core_set_variable_alias, 372);
-ruby_method_id_check_for(id_core_undef_method, 373);
-ruby_method_id_check_for(id_core_define_method, 374);
-ruby_method_id_check_for(id_core_define_singleton_method, 375);
-ruby_method_id_cck_for(id_core_set_postexe, 376);
-ruby_method_id_check_for(tLAST_TOKEN, 377);
-};
-#endif
-
-#endif /* RUBY_ID_H */
diff --git a/.#id.h b/.#id.h
deleted file mode 120000
index 706d78a..0000000
--- a/.#id.h
+++ /dev/null
@@ -1 +0,0 @@
-masahiro@malaptop.19845:1251433649
\ No newline at end of file
diff --git a/array.c b/array.c
index 8f7dcaf..47f64e4 100644
--- a/array.c
+++ b/array.c
@@ -27,6 +27,7 @@ static ID id_cmp;
 #define ARY_DEFAULT_SIZE 16
 #define ARY_MAX_SIZE (LONG_MAX / sizeof(VALUE))
 
+
 void
 rb_mem_clear(register VALUE *mem, register long size)
 {
@@ -2650,6 +2651,25 @@ rb_ary_rassoc(VALUE ary, VALUE value)
     }
     return Qnil;
 }
+VALUE patern_match(VALUE obj1, VALUE obj2){
+  VALUE result;
+  if (obj1 == obj2) return Qtrue;
+  result = rb_funcall(obj1, rb_intern("p-match"), 1, obj2);
+  if (RTEST(result)) return Qtrue;
+  return Qfalse;
+}
+static VALUE
+recursive_patern(VALUE ary1, VALUE ary2, int recur)
+{
+    long i;
+
+    if (recur) return Qtrue; /* Subtle! */
+    for (i=0; i<RARRAY_LEN(ary1); i++) {
+	if (!patern_match(rb_ary_elt(ary1, i), rb_ary_elt(ary2, i)))
+	    return Qfalse;
+    }
+    return Qtrue;
+}
 
 static VALUE
 recursive_equal(VALUE ary1, VALUE ary2, int recur)
@@ -2677,7 +2697,19 @@ recursive_equal(VALUE ary1, VALUE ary2, int recur)
  *     [ "a", "c", 7 ] == [ "a", "d", "f" ]   #=> false
  *
  */
-
+static VALUE
+rb_patern_match(VALUE ary1, VALUE ary2)
+{
+  if(ary1 == ary2) return Qtrue;
+  if(TYPE(ary2) != T_ARRAY) {
+    if (!rb_respond_to(ary2, rb_intern("to_ary"))) {
+      return Qfalse;
+    }
+    return rb_equal(ary2, ary1);
+  }
+  if (RARRAY_LEN(ary1) != RARRAY_LEN(ary2)) return Qfalse;
+  return rb_exec_recursive_paired(recursive_patern, ary1, ary2, ary2);
+}
 static VALUE
 rb_ary_equal(VALUE ary1, VALUE ary2)
 {
@@ -3801,6 +3833,7 @@ Init_Array(void)
     rb_define_method(rb_cArray, "frozen?",  rb_ary_frozen_p, 0);
 
     rb_define_method(rb_cArray, "==", rb_ary_equal, 1);
+    rb_define_method(rb_cArray, "patern-match",rb_patern_match,1);
     rb_define_method(rb_cArray, "eql?", rb_ary_eql, 1);
     rb_define_method(rb_cArray, "hash", rb_ary_hash, 0);
 
diff --git a/array.o b/array.o
index b4a73e6..c4e8aae 100644
Binary files a/array.o and b/array.o differ
diff --git a/class.o b/class.o
index b661cdd..5f9735c 100644
Binary files a/class.o and b/class.o differ
diff --git a/compile.c b/compile.c
index f35deb1..4b65423 100644
--- a/compile.c
+++ b/compile.c
@@ -2229,6 +2229,111 @@ compile_branch_condition(rb_iseq_t *iseq, LINK_ANCHOR *ret, NODE * cond,
     }
     return COMPILE_OK;
 }
+static void var2sym(NODE* n){
+  //unsigned long flag=n->flags;
+  switch(nd_type(n)-1){
+   case NODE_CALL:
+   case NODE_VCALL:
+   case NODE_FCALL:
+   case NODE_ATTRASGN:
+     n->u1.value = ID2SYM(n->nd_mid);
+    break;
+   default:
+    n->u1.value = ID2SYM(n->nd_vid);
+  }
+  n->flags = 0;
+  n->flags |= T_NODE;
+  nd_set_type(n, NODE_LIT);
+
+  /*if(flag==NODE_FCALL){
+    n->u1.value = ID2SYM(n->nd_mid);
+    printf("id: %s\n", rb_id2name(n->nd_mid));
+  }else{
+    n->u1.value = ID2SYM(n->nd_vid);
+    }*/
+  n->u2.value = 0;
+  n->u3.value = 0;
+}
+static int
+compile_patern_array_(rb_iseq_t *iseq, LINK_ANCHOR *ret, NODE* node_root,
+	       VALUE opt_p, int poped)
+{
+    NODE *node = node_root;
+    int len = node->nd_alen, line = nd_line(node), i=0;
+    DECL_ANCHOR(anchor);
+    
+    INIT_ANCHOR(anchor);
+    
+    if (nd_type(node) != NODE_ZARRAY) {
+	while (node) {
+	    if (nd_type(node) != NODE_ARRAY) {
+		rb_bug("compile_array: This node is not NODE_ARRAY, but %s",
+		       ruby_node_name(nd_type(node)));
+	    }
+	    
+	    i++;
+	    
+	   switch(nd_type(node->nd_head)-1){
+	    case NODE_LVAR:
+	      //case NODE_CALL:
+	      // case NODE_VCALL:
+	      case NODE_FCALL:
+	      //case NODE_ATTRASGN:
+	      
+	      var2sym(node->nd_head);
+	    default:
+	      COMPILE_(anchor, "array element", node->nd_head, poped);
+	    }
+
+	    /*if(nd_type(node->nd_head)-1==NODE_LVAR){
+	      
+	      //printf("id: %s\n", rb_id2name(node->nd_head->nd_vid));
+	      var2sym(node->nd_head);
+	      
+	      //ADD_INSN1(anchor, nd_line(node->nd_head), putobject, ID2SYM(node->nd_head->nd_vid));
+	      COMPILE_(anchor, "array element", node->nd_head, poped);
+	    }else{
+	      printf("test\n");
+	      COMPILE_(anchor, "array element", node->nd_head, poped);
+	      }*/
+
+
+	    if (opt_p && nd_type(node->nd_head) != NODE_LIT) {
+		opt_p = Qfalse;
+	    }
+	    node = node->nd_next;
+	}
+    }
+
+    if (len != i) {
+	if (0) {
+	    rb_bug("node error: compile_array (%d: %d-%d)",
+		   (int)nd_line(node_root), len, i);
+	}
+	len = i;
+    }
+
+    if (opt_p == Qtrue) {
+	if (!poped) {
+	    VALUE ary = rb_ary_tmp_new(len);
+	    node = node_root;
+	    while (node) {
+		rb_ary_push(ary, node->nd_head->nd_lit);
+		node = node->nd_next;
+	    }
+
+	    iseq_add_mark_object_compile_time(iseq, ary);
+	    ADD_INSN1(ret, nd_line(node_root), duparray, ary);
+	}
+    }
+    else {
+	if (!poped) {
+	    ADD_INSN1(anchor, line, newarray, INT2FIX(len));
+	}
+	APPEND_LIST(ret, anchor);
+    }
+    return len;
+}
 
 static int
 compile_array_(rb_iseq_t *iseq, LINK_ANCHOR *ret, NODE* node_root,
@@ -2237,7 +2342,7 @@ compile_array_(rb_iseq_t *iseq, LINK_ANCHOR *ret, NODE* node_root,
     NODE *node = node_root;
     int len = node->nd_alen, line = nd_line(node), i=0;
     DECL_ANCHOR(anchor);
-
+    
     INIT_ANCHOR(anchor);
     if (nd_type(node) != NODE_ZARRAY) {
 	while (node) {
@@ -2309,6 +2414,40 @@ case_when_optimizable_literal(NODE * node)
 }
 
 static VALUE
+when_vals_ar(rb_iseq_t *iseq, LINK_ANCHOR *cond_seq, NODE *vals, LABEL *l1, VALUE sp_lit)
+{
+
+    while (vals) {
+	VALUE lit;
+	NODE* val;
+
+	val = vals->nd_head;
+
+	if (sp_lit &&
+	    (lit = case_when_optimizable_literal(val)) != Qfalse) {
+	    rb_ary_push(sp_lit, lit);
+	    rb_ary_push(sp_lit, (VALUE)(l1) | 1);
+	}
+	else {
+	    sp_lit = Qfalse;
+	}
+	if(nd_type(val)== NODE_ARRAY){
+	  compile_patern_array_(iseq, cond_seq, val, Qtrue, 0);
+	}else{
+	  COMPILE(cond_seq, "when cond", val);
+        }
+	
+	ADD_INSN1(cond_seq, nd_line(val), topn, INT2FIX(1));
+	//ADD_SEND(cond_seq, nd_line(val), ID2SYM(idEqq), INT2FIX(1));
+	ADD_SEND(cond_seq, nd_line(val), ID2SYM(rb_intern("patern-match")), INT2FIX(1));
+	
+	ADD_INSNL(cond_seq, nd_line(val), branchif, l1);
+	vals = vals->nd_next;
+    }
+    return sp_lit;
+}
+
+static VALUE
 when_vals(rb_iseq_t *iseq, LINK_ANCHOR *cond_seq, NODE *vals, LABEL *l1, VALUE special_literals)
 {
     while (vals) {
@@ -3004,6 +3143,103 @@ iseq_compile_each(rb_iseq_t *iseq, LINK_ANCHOR *ret, NODE * node, int poped)
 
 	break;
       }
+      case NODE_PATERN:{
+	NODE *vals;
+	NODE *tempnode = node;
+	LABEL *endlabel, *elselabel;
+	DECL_ANCHOR(head);
+	DECL_ANCHOR(body_seq);
+	DECL_ANCHOR(cond_seq);
+	VALUE special_literals = rb_ary_tmp_new(1);
+
+	INIT_ANCHOR(head);
+	INIT_ANCHOR(body_seq);
+	INIT_ANCHOR(cond_seq);
+	if (node->nd_head == 0) {
+	    COMPILE_(ret, "when", node->nd_body, poped);
+	    break;
+	}
+	COMPILE(head, "match base", node->nd_head);
+
+	node = node->nd_body;
+	type = nd_type(node);
+
+	if (type != NODE_WHEN) {
+	    COMPILE_ERROR((ERROR_ARGS "NODE_PATERN: unexpected node. must be NODE_WHEN, but %s", ruby_node_name(type)));
+	}
+
+	endlabel = NEW_LABEL(nd_line(node));
+	elselabel = NEW_LABEL(nd_line(node));
+
+	ADD_SEQ(ret, head);	/* case VAL */
+
+	while (type == NODE_WHEN) {
+	    LABEL *l1;
+
+	    l1 = NEW_LABEL(nd_line(node));
+	    ADD_LABEL(body_seq, l1);
+	    ADD_INSN(body_seq, nd_line(node), pop);
+	    COMPILE_(body_seq, "when body", node->nd_body, poped);
+	    ADD_INSNL(body_seq, nd_line(node), jump, endlabel);
+
+	    vals = node->nd_head;
+	    if (vals) {
+		switch (nd_type(vals)) {
+		  case NODE_ARRAY:
+		    special_literals = when_vals_ar(iseq, cond_seq, vals, l1, special_literals);
+		    break;
+		  case NODE_SPLAT:
+		  case NODE_ARGSCAT:
+		  case NODE_ARGSPUSH:
+		    special_literals = 0;
+		    COMPILE(cond_seq, "when/cond splat", vals);
+		    ADD_INSN1(cond_seq, nd_line(vals), checkincludearray, Qtrue);
+		    ADD_INSNL(cond_seq, nd_line(vals), branchif, l1);
+		    break;
+		  default:
+		    rb_bug("NODE_PATERN: unknown node (%s)",
+			   ruby_node_name(nd_type(vals)));
+		}
+	    }
+	    else {
+		rb_bug("NODE_PATERN: must be NODE_ARRAY, but 0");
+	    }
+
+	    node = node->nd_next;
+	    if (!node) {
+		break;
+	    }
+	    type = nd_type(node);
+	}
+	/* else */
+	if (node) {
+	    ADD_LABEL(cond_seq, elselabel);
+	    ADD_INSN(cond_seq, nd_line(node), pop);
+	    COMPILE_(cond_seq, "else", node, poped);
+	    ADD_INSNL(cond_seq, nd_line(node), jump, endlabel);
+	}
+	else {
+	    debugs("== else (implicit)\n");
+	    ADD_LABEL(cond_seq, elselabel);
+	    ADD_INSN(cond_seq, nd_line(tempnode), pop);
+	    if (!poped) {
+		ADD_INSN(cond_seq, nd_line(tempnode), putnil);
+	    }
+	    ADD_INSNL(cond_seq, nd_line(tempnode), jump, endlabel);
+	}
+
+	if (special_literals) {
+	    ADD_INSN(ret, nd_line(tempnode), dup);
+	    ADD_INSN2(ret, nd_line(tempnode), opt_case_dispatch,
+		      special_literals, elselabel);
+	    iseq_add_mark_object_compile_time(iseq, special_literals);
+	}
+
+	ADD_SEQ(ret, cond_seq);
+	ADD_SEQ(ret, body_seq);
+	ADD_LABEL(ret, endlabel);
+	break;
+      }
       case NODE_CASE:{
 	NODE *vals;
 	NODE *tempnode = node;
@@ -4266,7 +4502,7 @@ iseq_compile_each(rb_iseq_t *iseq, LINK_ANCHOR *ret, NODE * node, int poped)
 	if (!poped) {
 	    ID id = node->nd_vid;
 	    int idx = iseq->local_iseq->local_size - get_local_var_idx(iseq, id);
-
+	    
 	    debugs("id: %s idx: %d\n", rb_id2name(id), idx);
 	    ADD_INSN1(ret, nd_line(node), getlocal, INT2FIX(idx));
 	}
diff --git a/compile.o b/compile.o
index ef9a816..0141bba 100644
Binary files a/compile.o and b/compile.o differ
diff --git a/cont.o b/cont.o
index 5b27c86..4e8e4f4 100644
Binary files a/cont.o and b/cont.o differ
diff --git a/debug.o b/debug.o
index 9625a4b..53aeab5 100644
Binary files a/debug.o and b/debug.o differ
diff --git a/defs/keywords b/defs/keywords
index af92959..22beced 100644
--- a/defs/keywords
+++ b/defs/keywords
@@ -16,7 +16,7 @@ and, {keyword_and, keyword_and}, EXPR_VALUE
 begin, {keyword_begin, keyword_begin}, EXPR_BEG
 break, {keyword_break, keyword_break}, EXPR_MID
 case, {keyword_case, keyword_case}, EXPR_VALUE
-match, {keyword_match, keyword_match}, EXPR_VALUE
+match, {keyword_patern, keyword_patern}, EXPR_VALUE
 class, {keyword_class, keyword_class}, EXPR_CLASS
 def, {keyword_def, keyword_def}, EXPR_FNAME
 defined?, {keyword_defined, keyword_defined}, EXPR_ARG
diff --git a/defs/lex.c.src b/defs/lex.c.src
index af92959..22beced 100644
--- a/defs/lex.c.src
+++ b/defs/lex.c.src
@@ -16,7 +16,7 @@ and, {keyword_and, keyword_and}, EXPR_VALUE
 begin, {keyword_begin, keyword_begin}, EXPR_BEG
 break, {keyword_break, keyword_break}, EXPR_MID
 case, {keyword_case, keyword_case}, EXPR_VALUE
-match, {keyword_match, keyword_match}, EXPR_VALUE
+match, {keyword_patern, keyword_patern}, EXPR_VALUE
 class, {keyword_class, keyword_class}, EXPR_CLASS
 def, {keyword_def, keyword_def}, EXPR_FNAME
 defined?, {keyword_defined, keyword_defined}, EXPR_ARG
diff --git a/enum.o b/enum.o
index c3d0b7a..8af57a2 100644
Binary files a/enum.o and b/enum.o differ
diff --git a/error.o b/error.o
index c97138d..e983c7d 100644
Binary files a/error.o and b/error.o differ
diff --git a/eval.o b/eval.o
index 224bfb9..df4ebf7 100644
Binary files a/eval.o and b/eval.o differ
diff --git a/gc.o b/gc.o
index a6c8e50..0227000 100644
Binary files a/gc.o and b/gc.o differ
diff --git a/iseq.c b/iseq.c
index 74b5680..287465c 100644
--- a/iseq.c
+++ b/iseq.c
@@ -333,6 +333,7 @@ rb_iseq_new_with_bopt_and_opt(NODE *node, VALUE name, VALUE filename,
     iseq->self = self;
 
     prepare_iseq_build(iseq, name, filename, parent, type, bopt, option);
+   
     rb_iseq_compile_node(self, node);
     cleanup_iseq_build(iseq);
     return self;
diff --git a/iseq.o b/iseq.o
index 5e19145..8a4e977 100644
Binary files a/iseq.o and b/iseq.o differ
diff --git a/lex.c.blt b/lex.c.blt
index a398556..253f201 100644
--- a/lex.c.blt
+++ b/lex.c.blt
@@ -176,7 +176,7 @@ rb_reserved_word (str, len)
 #line 32 "defs/keywords"
       {"module", {keyword_module, keyword_module}, EXPR_VALUE},
 #line 19 "defs/keywords"
-      {"match", {keyword_match, keyword_match}, EXPR_VALUE},
+      {"match", {keyword_patern, keyword_patern}, EXPR_VALUE},
 #line 16 "defs/keywords"
       {"begin", {keyword_begin, keyword_begin}, EXPR_BEG},
 #line 10 "defs/keywords"
diff --git a/load.o b/load.o
index 2b7572b..5cb4a91 100644
Binary files a/load.o and b/load.o differ
diff --git a/match.rb b/match.rb
index 52d0565..199deb6 100644
--- a/match.rb
+++ b/match.rb
@@ -1,14 +1,13 @@
 # -*- coding: utf-8  -*
 x=6
-match [1,2,3,9,4,5,6] #今のRubyで実行できるけど
+
+match [1,2,3,8,4,5,6] #今のRubyで実行できるけど
   when [1,2,3,x,4,5,6]
+    puts    $x
     puts "にゃー" #ここには来ない
   when [1,2,3,9,4,5,x]
-    y=10
     puts "わん" #ここに来る
-  when 5
-   
+  else
 end
 
-puts y
-puts RubyVM::InstructionSequence.compile_file(__FILE__).disasm
+#puts RubyVM::InstructionSequence.compile_file(__FILE__).disasm
diff --git a/node.h b/node.h
index 3e8277a..0755f28 100644
--- a/node.h
+++ b/node.h
@@ -34,8 +34,8 @@ enum node_type {
 #define NODE_IF          NODE_IF
     NODE_CASE,
 #define NODE_CASE        NODE_CASE
-    NODE_MATCH,
-#define NODE_MATCH       NODE_MATCH
+    NODE_PATERN,
+#define NODE_PATERN       NODE_PATERN
     NODE_WHEN,
 #define NODE_WHEN        NODE_WHEN
     NODE_OPT_N,
@@ -368,7 +368,7 @@ typedef struct RNode {
 #define NEW_IF(c,t,e) NEW_NODE(NODE_IF,c,t,e)
 #define NEW_UNLESS(c,t,e) NEW_IF(c,e,t)
 #define NEW_CASE(h,b) NEW_NODE(NODE_CASE,h,b,0)
-#define NEW_MATCH(h,b) NEW_NODE(NODE_MATCH,h,b,0)
+#define NEW_PATERN(h,b) NEW_NODE(NODE_PATERN,h,b,0)
 #define NEW_WHEN(c,t,e) NEW_NODE(NODE_WHEN,c,t,e)
 #define NEW_OPT_N(b) NEW_NODE(NODE_OPT_N,0,b,0)
 #define NEW_WHILE(c,b,n) NEW_NODE(NODE_WHILE,c,b,n)
diff --git a/object.c b/object.c
index c68e04c..e9e952d 100644
--- a/object.c
+++ b/object.c
@@ -31,7 +31,7 @@ VALUE rb_cNilClass;
 VALUE rb_cTrueClass;
 VALUE rb_cFalseClass;
 
-static ID id_eq, id_eql, id_match, id_inspect, id_init_copy;
+static ID id_peq, id_eq, id_eql, id_match, id_inspect, id_init_copy, id_patern_match;
 
 /*
  *  call-seq:
@@ -41,12 +41,26 @@ static ID id_eq, id_eql, id_match, id_inspect, id_init_copy;
  *  as calling  <code>#==</code>, but typically overridden by descendents
  *  to provide meaningful semantics in <code>case</code> statements.
  */
+VALUE
+rb_pmatch(VALUE obj1, VALUE obj2){
+  if (obj1 == obj2) return Qtrue;
+  return Qfalse;
+}
+
+VALUE
+rb_patern_match(VALUE obj1, VALUE obj2)
+{
+  VALUE result;
+  if (obj1 == obj2) return Qtrue;
+  result = rb_funcall(obj1, id_peq, 1, obj2);
+  if (RTEST(result)) return Qtrue;
+  return Qfalse;
+}
 
 VALUE
 rb_equal(VALUE obj1, VALUE obj2)
 {
     VALUE result;
-
     if (obj1 == obj2) return Qtrue;
     result = rb_funcall(obj1, id_eq, 1, obj2);
     if (RTEST(result)) return Qtrue;
@@ -2513,6 +2527,8 @@ Init_Object(void)
 
     rb_define_method(rb_mKernel, "nil?", rb_false, 0);
     rb_define_method(rb_mKernel, "===", rb_equal, 1); 
+    rb_define_method(rb_mKernel, "patern-match", rb_patern_match, 1);
+    rb_define_method(rb_mKernel, "p-match", rb_pmatch, 1);
     rb_define_method(rb_mKernel, "=~", rb_obj_match, 1);
     rb_define_method(rb_mKernel, "!~", rb_obj_not_match, 1);
     rb_define_method(rb_mKernel, "eql?", rb_obj_equal, 1);
@@ -2650,8 +2666,10 @@ Init_Object(void)
     rb_undef_method(CLASS_OF(rb_cFalseClass), "new");
     rb_define_global_const("FALSE", Qfalse);
 
+    id_peq = rb_intern("p-match");
     id_eq = rb_intern("==");
     id_eql = rb_intern("eql?");
+    id_patern_match = rb_intern("patern-match");
     id_match = rb_intern("=~");
     id_inspect = rb_intern("inspect");
     id_init_copy = rb_intern("initialize_copy");
diff --git a/object.o b/object.o
index c443082..62386e4 100644
Binary files a/object.o and b/object.o differ
diff --git a/parse.o b/parse.o
index 8acec31..b14c625 100644
Binary files a/parse.o and b/parse.o differ
diff --git a/parse.y b/parse.y
index a70a0a1..1d1fe97 100644
--- a/parse.y
+++ b/parse.y
@@ -473,7 +473,7 @@ static int lvar_defined_gen(struct parser_params*, ID);
 #endif
 #define nd_paren(node) (char)((node)->u2.id >> CHAR_BIT*2)
 #define nd_nest u3.cnt
-
+int patern_match_set=0;
 /****** Ripper *******/
 
 #ifdef RIPPER
@@ -622,7 +622,7 @@ static void token_info_pop(struct parser_params*, const char *token);
 	keyword_elsif
 	keyword_else
 	keyword_case
-        keyword_match
+        keyword_patern
 	keyword_when
 	keyword_while
 	keyword_until
@@ -658,6 +658,7 @@ static void token_info_pop(struct parser_params*, const char *token);
 	keyword__LINE__
 	keyword__FILE__
 	keyword__ENCODING__
+        
 
 %token <id>   tIDENTIFIER tFID tGVAR tIVAR tCONSTANT tCVAR tLABEL
 %token <node> tINTEGER tFLOAT tSTRING_CONTENT tCHAR
@@ -669,10 +670,10 @@ static void token_info_pop(struct parser_params*, const char *token);
 %type <node> words qwords word_list qword_list word
 %type <node> literal numeric dsym cpath
 %type <node> top_compstmt top_stmts top_stmt
-%type <node> bodystmt compstmt stmts stmt expr arg primary command command_call method_call
-%type <node> expr_value arg_value primary_value
-%type <node> if_tail opt_else case_body cases opt_rescue exc_list exc_var opt_ensure
-%type <node> args call_args opt_call_args
+%type <node> bodystmt compstmt stmts stmt expr parg arg mprimary primary command command_call method_call
+%type <node> expr_value parg_value arg_value primary_value
+%type <node> if_tail opt_else patern_body matches case_body cases opt_rescue exc_list exc_var opt_ensure k_patern_when
+%type <node> args call_args opt_call_args patern_args
 %type <node> paren_args opt_paren_args
 %type <node> command_args aref_args opt_block_arg block_arg var_ref var_lhs
 %type <node> mrhs superclass block_call block_command
@@ -1839,7 +1840,7 @@ op		: '|'		{ ifndef_ripper($$ = '|'); }
 reswords	: keyword__LINE__ | keyword__FILE__ | keyword__ENCODING__
 		| keyword_BEGIN | keyword_END
 		| keyword_alias | keyword_and | keyword_begin
-		| keyword_break | keyword_case| keyword_match | keyword_class 
+		| keyword_break | keyword_case| keyword_patern | keyword_class 
                 | keyword_def
 		| keyword_defined | keyword_do | keyword_else | keyword_elsif
 		| keyword_end | keyword_ensure | keyword_false
@@ -1850,7 +1851,11 @@ reswords	: keyword__LINE__ | keyword__FILE__ | keyword__ENCODING__
 		| keyword_when | keyword_yield | keyword_if | keyword_unless
 		| keyword_while | keyword_until
 		;
-
+parg            : mprimary
+		    {
+			$$ = $1;
+		    }
+		; 
 arg		: lhs '=' arg
 		    {
 		    /*%%%*/
@@ -2325,7 +2330,17 @@ arg		: lhs '=' arg
 			$$ = $1;
 		    }
 		;
-
+parg_value     : parg
+                    {
+		    /*%%%*/
+			value_expr($1);
+			$$ = $1;
+		        if (!$$) $$ = NEW_NIL();
+		    /*%
+			$$ = $1;
+		    %*/
+		    }
+		;
 arg_value	: arg
 		    {
 		    /*%%%*/
@@ -2458,6 +2473,16 @@ opt_block_arg	: ',' block_arg
 			$$ = 0;
 		    }
 		;
+patern_args     : parg_value
+                    {
+		    /*%%%*/
+		      patern_match_set=0;
+			$$ = NEW_LIST($1);
+		    /*%
+			$$ = arg_add(arg_new(), $1);
+		    %*/
+		    }
+                ;
 
 args		: arg_value
 		    {
@@ -2543,7 +2568,20 @@ mrhs		: args ',' arg_value
 		    %*/
 		    }
 		;
-
+mprimary        : tLBRACK aref_args ']'
+		    {
+		    /*%%%*/
+			if ($2 == 0) {
+			    $$ = NEW_ZARRAY(); /* zero length array*/
+			}
+			else {
+			    $$ = $2;
+			}
+		    /*%
+			$$ = dispatch1(array, escape_Qundef($2));
+		    %*/
+		    }
+                ;
 primary		: literal
 		| strings
 		| xstring
@@ -2555,6 +2593,7 @@ primary		: literal
 		| tFID
 		    {
 		    /*%%%*/
+		     
 			$$ = NEW_FCALL($1, 0);
 		    /*%
 			$$ = method_arg(dispatch1(fcall, $1), arg_new());
@@ -2700,6 +2739,7 @@ primary		: literal
 		| operation brace_block
 		    {
 		    /*%%%*/
+		       
 			$2->nd_iter = NEW_FCALL($1, 0);
 			$$ = $2;
 			fixpos($2->nd_iter, $2);
@@ -2770,12 +2810,12 @@ primary		: literal
 			$$ = dispatch2(until, $3, $6);
 		    %*/
 		    }
-                | k_match expr_value opt_terms
-                  case_body
+                | k_patern expr_value opt_terms
+                  patern_body
                   k_end
                     {
 		    /*%%%*/
-			$$ = NEW_CASE($2, $4);
+			$$ = NEW_PATERN($2, $4);
 			fixpos($$, $2);
 		    /*%
 			$$ = dispatch2(case, $2, $4);
@@ -3075,7 +3115,7 @@ k_case		: keyword_case
 			if (RTEST(ruby_verbose)) token_info_push(parser, "case");
 #endif
 		    }
-k_match         : keyword_match
+k_patern         : keyword_patern
                   {
 #ifndef RIPPER
                   if (RTEST(ruby_verbose)) token_info_push(parser, "match");
@@ -3589,6 +3629,7 @@ block_call	: command do_block
 method_call	: operation paren_args
 		    {
 		    /*%%%*/
+		      
 			$$ = NEW_FCALL($1, $2);
 			fixpos($$, $2);
 		    /*%
@@ -3664,7 +3705,7 @@ method_call	: operation paren_args
 		| primary_value '[' opt_call_args rbracket
 		    {
 		    /*%%%*/
-			if ($1 && nd_type($1) == NODE_SELF)
+		      if ($1 && nd_type($1) == NODE_SELF)
 			    $$ = NEW_FCALL(tAREF, $3);
 			else
 			    $$ = NEW_CALL($1, tAREF, $3);
@@ -3716,6 +3757,22 @@ brace_block	: '{'
 		    %*/
 		    }
 		;
+k_patern_when    : keyword_when
+                    {
+                        patern_match_set=1;
+                    }
+
+patern_body      : k_patern_when patern_args then
+		     compstmt
+		     matches
+		    {
+		    /*%%%*/
+			$$ = NEW_WHEN($2, $4, $5);
+		    /*%
+			$$ = dispatch3(when, $2, $4, escape_Qundef($5));
+		    %*/
+		    }
+		;
 
 case_body	: keyword_when args then
 		  compstmt
@@ -3732,7 +3789,9 @@ case_body	: keyword_when args then
 cases		: opt_else
 		| case_body
 		;
-
+matches         : opt_else
+                | patern_body
+                ;
 opt_rescue	: keyword_rescue exc_list exc_var then
 		  compstmt
 		  opt_rescue
@@ -4182,6 +4241,7 @@ variable	: tIDENTIFIER
 var_ref		: variable
 		    {
 		    /*%%%*/
+		      
 			if (!($$ = gettable($1))) $$ = NEW_BEGIN(0);
 		    /*%
 			$$ = dispatch1(var_ref, $1);
@@ -8020,8 +8080,14 @@ gettable_gen(struct parser_params *parser, ID id)
     }
     else if (is_local_id(id)) {
 	if (dyna_in_block() && dvar_defined(id)) return NEW_DVAR(id);
-	if (local_id(id)) return NEW_LVAR(id);
+	if(patern_match_set == 1){
+	  assignable(id, 0);
+	  printf("id: %s\n", rb_id2name(id));
+	  return NEW_LIT(ID2SYM(id));
+	}
+	if (local_id(id))return NEW_LVAR(id);
 	/* method call without arguments */
+	//printf("id: %s\n", rb_id2name(id));
 	return NEW_VCALL(id);
     }
     else if (is_global_id(id)) {
@@ -10038,7 +10104,7 @@ static const struct kw_assoc {
     {keyword_elsif,	"elsif"},
     {keyword_else,	"else"},
     {keyword_case,	"case"},
-    {keyword_match,     "match"},
+    {keyword_patern,     "match"},
     {keyword_when,	"when"},
     {keyword_while,	"while"},
     {keyword_until,	"until"},
diff --git a/proc.o b/proc.o
index 54d52dc..85138f3 100644
Binary files a/proc.o and b/proc.o differ
diff --git a/process.o b/process.o
index d1eeaa6..5923b24 100644
Binary files a/process.o and b/process.o differ
diff --git a/ruby.o b/ruby.o
index eade7b2..c0a5f4e 100644
Binary files a/ruby.o and b/ruby.o differ
diff --git a/safe.o b/safe.o
index 623e14b..db30ef3 100644
Binary files a/safe.o and b/safe.o differ
diff --git a/signal.o b/signal.o
index 95d9d17..40c5ea7 100644
Binary files a/signal.o and b/signal.o differ
diff --git a/string.c b/string.c
index ffc3c14..30dfc4e 100644
--- a/string.c
+++ b/string.c
@@ -6885,6 +6885,17 @@ sym_equal(VALUE sym1, VALUE sym2)
     if (sym1 == sym2) return Qtrue;
     return Qfalse;
 }
+static VALUE
+patern_equal(VALUE sym1, VALUE sym2)
+{
+  VALUE str;
+  if(TYPE(sym1)==T_SYMBOL){
+    str=rb_id2str(SYM2ID(sym1));
+    rb_define_variable((char *)RSTRING_PTR(str), &sym2);
+  }
+  
+    return Qtrue;
+}
 
 
 static int
@@ -7253,6 +7264,7 @@ Init_String(void)
     rb_define_singleton_method(rb_cSymbol, "all_symbols", rb_sym_all_symbols, 0); /* in parse.y */
 
     rb_define_method(rb_cSymbol, "==", sym_equal, 1);
+    rb_define_method(rb_cSymbol, "p-match", patern_equal,1); 
     rb_define_method(rb_cSymbol, "inspect", sym_inspect, 0);
     rb_define_method(rb_cSymbol, "to_s", rb_sym_to_s, 0);
     rb_define_method(rb_cSymbol, "id2name", rb_sym_to_s, 0);
diff --git a/string.o b/string.o
index c84d4ec..ae39f10 100644
Binary files a/string.o and b/string.o differ
diff --git a/thread.o b/thread.o
index 056c9dc..4ba3b33 100644
Binary files a/thread.o and b/thread.o differ
diff --git a/variable.o b/variable.o
index 00b35f1..ce10a4e 100644
Binary files a/variable.o and b/variable.o differ
diff --git a/vm.o b/vm.o
index b5349c9..e8b830c 100644
Binary files a/vm.o and b/vm.o differ
diff --git a/vm_dump.o b/vm_dump.o
index 63f45bf..5cad2d3 100644
Binary files a/vm_dump.o and b/vm_dump.o differ
diff --git a/vm_insnhelper.c b/vm_insnhelper.c
index 7758c13..6c13c3c 100644
--- a/vm_insnhelper.c
+++ b/vm_insnhelper.c
@@ -566,6 +566,7 @@ vm_call_method(rb_thread_t * const th, rb_control_frame_t * const cfp,
 		int stat = NOEX_PRIVATE;
 
 		if (flag & VM_CALL_VCALL_BIT) {
+		  
 		    stat |= NOEX_VCALL;
 		}
 		val = vm_method_missing(th, id, recv, num, blockptr, stat);
@@ -598,6 +599,7 @@ vm_call_method(rb_thread_t * const th, rb_control_frame_t * const cfp,
 	/* method missing */
 	int stat = 0;
 	if (flag & VM_CALL_VCALL_BIT) {
+	  //printf("NOEX_VCALL\n");
 	    stat |= NOEX_VCALL;
 	}
 	if (flag & VM_CALL_SUPER_BIT) {
@@ -605,10 +607,12 @@ vm_call_method(rb_thread_t * const th, rb_control_frame_t * const cfp,
 	}
 	if (id == idMethodMissing) {
 	    VALUE *argv = ALLOCA_N(VALUE, num);
+	    
 	    vm_method_missing_args(th, argv, num - 1, 0, stat);
 	    rb_raise_method_missing(th, num, argv, recv, stat);
 	}
 	else {
+	  //printf("NOEX_VCALL\n");
 	    val = vm_method_missing(th, id, recv, num, blockptr, stat);
 	}
     }
