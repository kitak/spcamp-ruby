#node.h#:  node.h -
#node.h#:  Copyright (C) 1993-2007 Yukihiro Matsumoto
#node.h#:} /* satisfy cc-mode */
#node.h#:#define nd_type(n) ((int) (((RNODE(n))->flags & NODE_TYPEMASK)>>NODE_TYPESHIFT))
#node.h#:    RNODE(n)->flags=((RNODE(n)->flags&~NODE_TYPEMASK)|(((t)<<NODE_TYPESHIFT)&NODE_TYPEMASK))
#node.h#:#define NODE_LMASK  (((SIGNED_VALUE)1<<(sizeof(VALUE)*CHAR_BIT-NODE_LSHIFT))-1)
#node.h#:#define nd_line(n) ((VALUE)(((RNODE(n))->flags>>NODE_LSHIFT)&NODE_LMASK))
#node.h#:    RNODE(n)->flags=((RNODE(n)->flags&~(-1<<NODE_LSHIFT))|(((l)&NODE_LMASK)<<NODE_LSHIFT))
#node.h#:{ /* satisfy cc-mode */
COPYING.ja:$B$r:FG[I[$G$-$^$9!%(BGPL$B$K$D$$$F$O(BGPL$B%U%!%$%k$r;2>H$7$F2<$5$$!%(B
COPYING.ja:     $B<+M3$KJQ99$G$-$^$9!%(B
COPYING.ja:     $B%k$7$?%*%V%8%'%/%H%3!<%I$d<B9T7A<0$G$bG[I[$G$-$^$9!%(B
COPYING.ja:     (a) $B%P%$%J%j$r<u$1<h$C$??M$,%=!<%9$rF~<j$G$-$k$h$&$K!$(B
Makefile.in:XCFLAGS = -I. -I$(arch_hdrdir) -I$(hdrdir) -I$(srcdir) @XCFLAGS@
Makefile.in:RUNRUBY = @RUNRUBY@ $(RUNRUBYOPT) --
Makefile.in:RM            = rm -f
Makefile.in:		@-if test -f $@; then mv -f $@ $@.old; $(RM) $@.old; fi
Makefile.in:# MAB library on Apple/NeXT (see --enable-fat-binary in configure) is not
Makefile.in:		@-$(RANLIB) $@ 2> /dev/null || true
Makefile.in:		@-$(PRE_LIBRUBY_UPDATE)
Makefile.in:		-$(OBJCOPY) -w -L '@EXPORT_PREFIX@Init_*' $@
Makefile.in:		@-$(MINIRUBY) -e 'ARGV.each{|link| File.delete link if File.exist? link; \
Makefile.in:fake: $(arch)-fake.rb
Makefile.in:$(arch)-fake.rb: config.status
Makefile.in:		 @./config.status --file=$@:$(srcdir)/template/fake.rb.in
Makefile.in:		    echo "all:; -@rm -f conftest.mk"; \
Makefile.in:		$(MAKE) -f conftest.mk | grep '^AUTO_REMAKE$$' >/dev/null 2>&1 || \
Makefile.in:		MINIRUBY="$(MINIRUBY)" $(SHELL) ./config.status --recheck
Makefile.in:# * GNU make v.s. HP-UX make	# HP-UX make invokes the action if lex.c and keywords has same mtime.
Makefile.in:	if cmp -s $(srcdir)/defs/lex.c.src $?; then \
Makefile.in:	  set -x; \
Makefile.in:	  set -x; \
Makefile.in:	  gperf -C -p -j1 -i 1 -g -o -t -N rb_reserved_word -k1,3,$$ $? > $@.tmp && \
Makefile.in:	$(CC) $(CFLAGS) $(XCFLAGS) $(CPPFLAGS) $(COUTFLAG)$@ -c $<
Makefile.in:	$(AS) $(ASFLAGS) -o $@ $<
Makefile.in:	$(CC) $(CFLAGS) $(XCFLAGS) $(CPPFLAGS) $(COUTFLAG)$@ -S $<
Makefile.in:clean-local::
Makefile.in:distclean-local::
Makefile.in:	@-$(RM) run.gdb
Makefile.in:	@-$(RM) $(INSTALLED_LIST) $(arch_hdrdir)/ruby/config.h
Makefile.in:	@-$(RMDIRS) $(arch_hdrdir)/ruby
Makefile.in:distclean-rdoc:
Makefile.in:clean-ext distclean-ext realclean-ext::
Makefile.in:	    set dummy `find ext -name Makefile | sed 's:^ext/::;s:/Makefile$$::' | sort`; \
Makefile.in:	    [ -f "ext/$$dir/Makefile" ] || continue; \
Makefile.in:	    echo $(@:-ext=)ing "$$dir"; \
Makefile.in:	    (cd "ext/$$dir" && exec $(MAKE) $(MFLAGS) $(@:-ext=)) && \
Makefile.in:	    *distclean-ext*|*realclean-ext*) \
Makefile.in:distclean-ext realclean-ext::
Makefile.in:	@-rmdir ext 2> /dev/null || true
Makefile.in:	$(CC) $(CFLAGS) $(XCFLAGS) $(CPPFLAGS) $(COUTFLAG)$@ -c ext/extinit.c
Makefile.in:update-rubyspec: 
Makefile.in:	@if [ -d $(srcdir)/spec/mspec ]; then \
Makefile.in:	@if [ -d $(srcdir)/spec/rubyspec ]; then \
Makefile.in:test-rubyspec:
Makefile.in:	@if [ ! -d $(srcdir)/spec/rubyspec ]; then echo No rubyspec here.  make update-rubyspec first.; exit 1; fi
Makefile.in:	$(RUNRUBY) $(srcdir)/spec/mspec/bin/mspec -B $(srcdir)/spec/default.mspec $(MSPECOPT)
Makefile.in:	$(BASERUBY) -Ks $(srcdir)/tool/insns2vm.rb $(INSNS2VMOPT) $@
Makefile.in:	$(BASERUBY) -n $(srcdir)/tool/node_name.rb $? > $@
Makefile.in:	$(BASERUBY) $(srcdir)/tool/generic_erb.rb -c -o $@ $(srcdir)/template/known_errors.inc.tmpl $(srcdir)/defs/known_errors.def
Makefile.in:	$(BASERUBY) -I$(srcdir) $(srcdir)/tool/compile_prelude.rb $(srcdir)/prelude.rb $@
Makefile.in:	$(BASERUBY) "$(srcdir)/tool/transcode-tblgen.rb" -vo newline.c $(srcdir)/enc/trans/newline.trans
README.EXT:.\" README.EXT -  -*- Text -*- created at: Mon Aug  7 16:45:54 JST 1995
README.EXT:has its data-type.
README.EXT:1.1 Data-types
README.EXT:There is the data-type check function
README.EXT:    str according to a printf-like format.  These functions are
README.EXT:    Creates a new Ruby string with encoding US-ASCII.
README.EXT:    Creates an n-element array from the arguments.
README.EXT:    Creates an n-element array from a C array.
README.EXT:If argc is -1, the function will be called as:
README.EXT:If argc is -2, the arguments are passed in a Ruby array. The function
README.EXT:Oh, in addition, function-like methods, which are private methods defined
README.EXT:You can define read-only (from Ruby, of course) variables using the
README.EXT:function to free the pointer allocation.  If this is -1, the pointer
README.EXT:4. Example - Creating dbm extension
README.EXT:--
README.EXT:    rb_define_singleton_method(cDBM, "open", fdbm_s_open, -1);
README.EXT:--
README.EXT:--
README.EXT:--
README.EXT:--
README.EXT:    if (dbmp->di_dbm == 0) closed_dbm();\
README.EXT:--
README.EXT:--
README.EXT:--
README.EXT:--
README.EXT:--
README.EXT:--
README.EXT:--
README.EXT:  $CFLAGS: included in CFLAGS make variable (such as -O)
README.EXT:  $CPPFLAGS: included in CPPFLAGS make variable (such as -I, -D)
README.EXT:  $LDFLAGS: included in LDFLAGS make variable (such as -L)
README.EXT:  % gcc -MM *.c > depend
README.EXT:instead of site_ruby directory, use --vendor option as follows.
README.EXT:  ruby extconf.rb --vendor
README.EXT:    -> parse.c    : automatically generated
README.EXT:    -> lex.c      : automatically generated
README.EXT:    -> insn*.inc      : automatically generated
README.EXT:    -> opt*.inc       : automatically generated
README.EXT:    -> vm.inc         : automatically generated
README.EXT:    -> known_errors.inc  : automatically generated
README.EXT:    -> golf_prelude.c : automatically generated
README.EXT:Defines a read-only global variable.  Works just like
README.EXT:rb_define_variable(), except the defined variable is read-only.
README.EXT:is the number of arguments.  if argc is -1, the function will receive
README.EXT:3 arguments: argc, argv, and self.  if argc is -2, the function will
README.EXT:the arguments, such as "12" for 1 non-optional argument, 2 optional
README.EXT:When rb_iterate is used in 1.9, func1 has to call some Ruby-level method.
README.EXT:Prints a warning message according to a printf-like format.
README.EXT:Prints a warning message according to a printf-like format, if
README.EXT:Finds command in path, which is File::PATH_SEPARATOR-separated list of
README.EXT:--with-<withval>.
README.EXT:--enable-<config> is given, or false if --disable-<config> is given.
README.EXT:--with-<target>-dir, --with-<target>-include, and/or --with-<target>-lib
README.EXT:to $CFLAGS and/or $LDFLAGS.  --with-<target>-dir=/path is equivalent to
README.EXT:--with-<target>-include=/path/include --with-<target>-lib=/path/lib.
README.EXT:Obtains the information for pkg by pkg-config command.  The actual
README.EXT:command name can be overridden by --with-pkg-config command line
README.EXT: * fill-column: 70
README.EXT.ja:.\" README.EXT.ja -  -*- Text -*- created at: Mon Aug  7 16:45:54 JST 1995
README.EXT.ja:    ¥¨¥ó¥³¡¼¥Ç¥£¥ó¥°¤¬US-ASCII¤ÎRuby¤ÎÊ¸»úÎó¤òÀ¸À®¤¹¤ë.
README.EXT.ja:argc¤¬-1¤Î»þ¤Ï°ú¿ô¤òÇÛÎó¤ËÆþ¤ì¤ÆÅÏ¤µ¤ì¤Þ¤¹¡¥argc¤¬-2¤Î»þ¤Ï°ú
README.EXT.ja:´Ø¿ô¤¬¥¬¡¼¥Ù¡¼¥¸¥³¥ì¥¯¥¿¤«¤é¸Æ¤Ð¤ì¤Þ¤¹¡¥¤³¤ì¤¬-1¤Î¾ì¹ç¤Ï¡¤Ã±
README.EXT.ja:4¡¥ÎãÂê - dbm¥Ñ¥Ã¥±¡¼¥¸¤òºî¤ë
README.EXT.ja:--
README.EXT.ja:    rb_define_singleton_method(cDBM, "open", fdbm_s_open, -1);
README.EXT.ja:--
README.EXT.ja:--
README.EXT.ja:--
README.EXT.ja:--
README.EXT.ja:    if (dbmp->di_dbm == 0) closed_dbm();\
README.EXT.ja:--
README.EXT.ja:--
README.EXT.ja:--
README.EXT.ja:--
README.EXT.ja:--
README.EXT.ja:--
README.EXT.ja:--
README.EXT.ja:  $CFLAGS: ¥³¥ó¥Ñ¥¤¥ë»þ¤ËÄÉ²ÃÅª¤Ë»ØÄê¤¹¤ë¥Õ¥é¥°(-O¤Ê¤É)
README.EXT.ja:  $CPPFLAGS: ¥×¥ê¥×¥í¥»¥Ã¥µ¤ËÄÉ²ÃÅª¤Ë»ØÄê¤¹¤ë¥Õ¥é¥°(-I¤ä-D¤Ê¤É)
README.EXT.ja:  $LDFLAGS: ¥ê¥ó¥¯»þ¤ËÄÉ²ÃÅª¤Ë»ØÄê¤¹¤ë¥Õ¥é¥°(-L¤Ê¤É)
README.EXT.ja:  % gcc -MM *.c > depend
README.EXT.ja:  ruby -r mkmf extconf.rb
README.EXT.ja:°Ê²¼¤Î¤è¤¦¤Ë --vendor ¥ª¥×¥·¥ç¥ó¤ò²Ã¤¨¤Æ¤¯¤À¤µ¤¤¡¥
README.EXT.ja:  ruby extconf.rb --vendor
README.EXT.ja:    -> parse.c    : ¼«Æ°À¸À®
README.EXT.ja:    -> lex.c      : ¼«Æ°À¸À®
README.EXT.ja:    -> insn*.inc      : ¼«Æ°À¸À®
README.EXT.ja:    -> opt*.inc       : ¼«Æ°À¸À®
README.EXT.ja:    -> vm.inc         : ¼«Æ°À¸À®
README.EXT.ja:    -> known_errors.inc  : ¼«Æ°À¸À®
README.EXT.ja:    -> golf_prelude.c  : ¼«Æ°À¸À®
README.EXT.ja:  ¥á¥½¥Ã¥É¤òÄêµÁ¤¹¤ë¡¥argc¤Ïself¤ò½ü¤¯°ú¿ô¤Î¿ô¡¥argc¤¬-1¤Î»þ, 
README.EXT.ja:  °ú¿ô¤È¤¹¤ë·Á¼°¤ÇÍ¿¤¨¤é¤ì¤ë(Âè3°ú¿ô¤Ïself)¡¥argc¤¬-2¤Î»þ, 
README.EXT.ja:  ´Ø¿ôfunc¤òÄêµÁ¤·¤Æ¤¤¤ë¥é¥¤¥Ö¥é¥êlib¤ÎÂ¸ºß¤ò -Lpath ¤òÄÉ²Ã
README.EXT.ja:  ¥Ø¥Ã¥À¥Õ¥¡¥¤¥ëheader¤ÎÂ¸ºß¤ò -Ipath ¤òÄÉ²Ã¤·¤Ê¤¬¤é¥Á¥§¥Ã¥¯
README.EXT.ja:  ¥³¥Þ¥ó¥É¥é¥¤¥ó¾å¤Î--with-<withval>¤Ç»ØÄê¤µ¤ì¤¿¥ª¥×¥·¥ç¥óÃÍ
README.EXT.ja:  ¥³¥Þ¥ó¥É¥é¥¤¥ó¾å¤Î--enable-<config>¤Þ¤¿¤Ï
README.EXT.ja:  --disable-<config>¤Ç»ØÄê¤µ¤ì¤¿¿¿µ¶ÃÍ¤òÆÀ¤ë¡¥
README.EXT.ja:  --enable-<config>¤¬»ØÄê¤µ¤ì¤Æ¤¤¤¿¾ì¹ç¤Ïtrue¡¤
README.EXT.ja:  --disable-<config>¤¬»ØÄê¤µ¤ì¤Æ¤¤¤¿¾ì¹ç¤Ïfalse¤òÊÖ¤¹¡¥
README.EXT.ja:  ¥³¥Þ¥ó¥É¥é¥¤¥ó¾å¤Î--with-<target>-dir, --with-<target>-include,
README.EXT.ja:  --with-<target>-lib¤Î¤¤¤º¤ì¤«¤Ç»ØÄê¤µ¤ì¤ë¥Ç¥£¥ì¥¯¥È¥ê¤ò
README.EXT.ja:  $CFLAGS ¤ä $LDFLAGS ¤ËÄÉ²Ã¤¹¤ë¡¥--with-<target>-dir=/path¤Ï
README.EXT.ja:  --with-<target>-include=/path/include --with-<target>-lib=/path/lib
README.EXT.ja:  pkg-config¥³¥Þ¥ó¥É¤«¤é¥Ñ¥Ã¥±¡¼¥¸pkg¤Î¾ðÊó¤òÆÀ¤ë¡¥ 
README.EXT.ja:  pkg-config¤Î¼ÂºÝ¤Î¥³¥Þ¥ó¥ÉÌ¾¤Ï¡¤--with-pkg-config¥³¥Þ¥ó¥É
README.EXT.ja: * fill-column: 60
README.ja:  + °Ü¿¢À­¤¬¹â¤¤¡¥Â¿¤¯¤ÎUnix-like/POSIX¸ß´¹¥×¥é¥Ã¥È¥Õ¥©¡¼¥à¾å¤Ç
README.ja:    cf. http://redmine.ruby-lang.org/wiki/ruby-19/SupportedPlatformsJa
README.ja:  ftp://ftp.ruby-lang.org/pub/ruby/
README.ja:  $ svn co http://svn.ruby-lang.org/repos/ruby/trunk/ ruby
README.ja:  $ svn ls http://svn.ruby-lang.org/repos/ruby/branches/
README.ja:   http://www.ruby-lang.org/
README.ja:   ruby-list-ctl@ruby-lang.org
README.ja:   ruby-dev-ctl@ruby-lang.org
README.ja:¤Þ¤Çruby-list¤ÈÆ±ÍÍ¤ÎÊýË¡¤Ç¥á¡¼¥ë¤·¤Æ¤¯¤À¤µ¤¤¡£ 
README.ja:Ruby³ÈÄ¥¥â¥¸¥å¡¼¥ë¤Ë¤Ä¤¤¤ÆÏÃ¤·¹ç¤¦ruby-ext¥á¡¼¥ê¥ó¥°¥ê¥¹¥È¤È
README.ja:¿ô³Ø´Ø·¸¤ÎÏÃÂê¤Ë¤Ä¤¤¤ÆÏÃ¤·¹ç¤¦ruby-math¥á¡¼¥ê¥ó¥°¥ê¥¹¥È¤È
README.ja:±Ñ¸ì¤ÇÏÃ¤·¹ç¤¦ruby-talk¥á¡¼¥ê¥ó¥°¥ê¥¹¥È¤â¤¢¤ê¤Þ¤¹¡£»²²ÃÊýË¡
README.ja:-------------------------------------------------------
README.ja:mode: indented-text
array.c:  array.c -
array.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
array.c:  Copyright (C) 2000  Information-technology Promotion Agency, Japan
array.c:    while (size--) {
array.c:    while (size--) {
array.c:#define ARY_HEAP_PTR(a) (assert(!ARY_EMBED_P(a)), RARRAY(a)->as.heap.ptr)
array.c:#define ARY_HEAP_LEN(a) (assert(!ARY_EMBED_P(a)), RARRAY(a)->as.heap.len)
array.c:#define ARY_EMBED_PTR(a) (assert(ARY_EMBED_P(a)), RARRAY(a)->as.ary)
array.c:     (long)((RBASIC(a)->flags >> RARRAY_EMBED_LEN_SHIFT) & \
array.c:    RARRAY(ary)->as.heap.ptr = (p); \
array.c:    RBASIC(ary)->flags &= ~RARRAY_EMBED_LEN_MASK; \
array.c:    RBASIC(ary)->flags |= (tmp_n) << RARRAY_EMBED_LEN_SHIFT; \
array.c:    RARRAY(ary)->as.heap.len = n; \
array.c:    RARRAY(ary)->as.heap.ptr += n; \
array.c:        RARRAY(ary)->as.heap.len += n; \
array.c:		       ARY_SHARED_ROOT_P(ary) ? RARRAY_LEN(ary) : RARRAY(ary)->as.heap.aux.capa)
array.c:    RARRAY(ary)->as.heap.aux.capa = (n); \
array.c:#define ARY_SHARED(ary) (assert(ARY_SHARED_P(ary)), RARRAY(ary)->as.heap.aux.shared)
array.c:    RARRAY(ary)->as.heap.aux.shared = (value); \
array.c:    (assert(ARY_SHARED_ROOT_P(ary)), RARRAY(ary)->as.heap.aux.capa)
array.c:    RARRAY(ary)->as.heap.aux.capa = (value); \
array.c:            REALLOC_N(RARRAY(ary)->as.heap.ptr, VALUE, (capacity));
array.c:            MEMCPY(RARRAY(ary)->as.ary, ptr, VALUE, len); 
array.c:	int num = ARY_SHARED_NUM(shared) - 1;
array.c:    VALUE shared = RARRAY(ary)->as.heap.aux.shared;
array.c: *  call-seq:
array.c: *     array.frozen?  -> true or false
array.c: *  call-seq:
array.c: *     Array.try_convert(obj) -> array or nil
array.c: *  call-seq:
array.c:		     idx - RARRAY_LEN(ary));
array.c:	if (new_capa >= ARY_MAX_SIZE - idx) {
array.c:	    new_capa = (ARY_MAX_SIZE - idx) / 2;
array.c:		     idx-RARRAY_LEN(ary) + 1);
array.c:	offset = RARRAY_LEN(ary) - n;
array.c: *  call-seq:
array.c: *     array << obj            -> array
array.c: *  Append---Pushes the given object on to the end of this array. This
array.c: *  call-seq:
array.c: *     array.push(obj, ... )   -> array
array.c: *  Append---Pushes the given object(s) on to the end of this array. This
array.c:    while (argc--) {
array.c:    n = RARRAY_LEN(ary)-1;
array.c: *  call-seq:
array.c: *     array.pop    -> obj or nil
array.c: *     array.pop(n) -> array
array.c: *  (or less) just like <code>array.slice!(-n, n)</code> does.
array.c:    ARY_INCREASE_LEN(ary, -RARRAY_LEN(result));
array.c:	    MEMMOVE(RARRAY_PTR(ary), RARRAY_PTR(ary)+1, VALUE, RARRAY_LEN(ary)-1);
array.c:            ARY_INCREASE_LEN(ary, -1);
array.c:    ARY_INCREASE_LEN(ary, -1);
array.c: *  call-seq:
array.c: *     array.shift    -> obj or nil
array.c: *     array.shift(n) -> array
array.c: *     args = [ "-m", "-q", "filename" ]
array.c: *     args.shift     #=> "-m"
array.c: *     args           #=> ["-q", "filename"]
array.c: *     args = [ "-m", "-q", "filename" ]
array.c: *     args.shift(2)  #=> ["-m", "-q"]
array.c:	MEMMOVE(RARRAY_PTR(ary), RARRAY_PTR(ary)+n, VALUE, RARRAY_LEN(ary)-n);
array.c:    ARY_INCREASE_LEN(ary, -n);
array.c: *  call-seq:
array.c: *     array.unshift(obj, ...)  -> array
array.c:/* faster version - use this if you don't need to treat negative offset */
array.c:	len = RARRAY_LEN(ary) - beg;
array.c: *  call-seq:
array.c: *     array[index]                -> obj      or nil
array.c: *     array[start, length]        -> an_array or nil
array.c: *     array[range]                -> an_array or nil
array.c: *     array.slice(index)          -> obj      or nil
array.c: *     array.slice(start, length)  -> an_array or nil
array.c: *     array.slice(range)          -> an_array or nil
array.c: *  Element Reference---Returns the element at _index_,
array.c: *  array (-1 is the last element). Returns nil if the index
array.c: *     a[-3, 3]               #=> [ "c", "d", "e" ]
array.c:    /* special case - speeding up */
array.c: *  call-seq:
array.c: *     array.at(index)   ->   obj  or nil
array.c: *     a.at(-1)    #=> "e"
array.c: *  call-seq:
array.c: *     array.first     ->   obj or nil
array.c: *     array.first(n)  ->   an_array
array.c: *  call-seq:
array.c: *     array.last     ->  obj or nil
array.c: *     array.last(n)  ->  an_array
array.c:	return RARRAY_PTR(ary)[RARRAY_LEN(ary)-1];
array.c: *  call-seq:
array.c: *     array.fetch(index)                    -> obj
array.c: *     array.fetch(index, default )          -> obj
array.c: *     array.fetch(index) {|index| block }   -> obj
array.c: *     a.fetch(-1)              #=> 44
array.c: *  call-seq:
array.c: *     array.index(obj)           ->  int or nil
array.c: *     array.index {|item| block} ->  int or nil
array.c: *  call-seq:
array.c: *     array.rindex(obj)    ->  int or nil
array.c:	while (i--) {
array.c:    while (i--) {
array.c:	    beg -= RARRAY_LEN(ary);
array.c:	len = RARRAY_LEN(ary) - beg;
array.c:	if (beg > ARY_MAX_SIZE - rlen) {
array.c:	rb_mem_clear(RARRAY_PTR(ary) + RARRAY_LEN(ary), beg - RARRAY_LEN(ary));
array.c:	alen = RARRAY_LEN(ary) + rlen - len;
array.c:		    VALUE, RARRAY_LEN(ary) - (beg + len));
array.c: *  call-seq:
array.c: *     array[index]         = obj                     ->  obj
array.c: *     array[start, length] = obj or an_array or nil  ->  obj or an_array or nil
array.c: *     array[range]         = obj or an_array or nil  ->  obj or an_array or nil
array.c: *  Element Assignment---Sets the element at _index_,
array.c: *     a[-1]   = "Z"               #=> ["A", "Z"]
array.c: *     a[1..-1] = nil              #=> ["A", nil]
array.c: *     a[1..-1] = []               #=> ["A"]
array.c: *  call-seq:
array.c: *     array.insert(index, obj...)  -> array
array.c: *     a.insert(-2, 1, 2, 3)   #=> ["a", "b", 99, "c", 1, 2, 3, "d"]
array.c:    if (pos == -1) {
array.c:    rb_ary_splice(ary, pos, 0, rb_ary_new4(argc - 1, argv + 1));
array.c: *  call-seq:
array.c: *     array.each {|item| block }   ->   array
array.c: *     a.each {|x| print x, " -- " }
array.c: *     a -- b -- c --
array.c: *  call-seq:
array.c: *     array.each_index {|index| block }  ->  array
array.c: *     a.each_index {|x| print x, " -- " }
array.c: *     0 -- 1 -- 2 --
array.c: *  call-seq:
array.c:    while (len--) {
array.c: *  call-seq:
array.c: *     array.length -> int
array.c: *  call-seq:
array.c: *     array.empty?   -> true or false
array.c:	len += RSTRING_LEN(sep) * (RARRAY_LEN(ary) - 1);
array.c: *  call-seq:
array.c: *     array.join(sep=$,)    -> str
array.c: *     [ "a", "b", "c" ].join("-")   #=> "a-b-c"
array.c: *  call-seq:
array.c: *     array.to_s -> string
array.c: *     array.inspect  -> string
array.c: *  call-seq:
array.c: *     array.to_a     -> array
array.c: *  call-seq:
array.c: *     array.to_ary -> array
array.c:	p2 = p1 + RARRAY_LEN(ary) - 1;	/* points last item */
array.c:	    *p2-- = tmp;
array.c: *  call-seq:
array.c: *     array.reverse!   -> array 
array.c: *  call-seq:
array.c: *     array.reverse -> an_array
array.c:    ((data->opt_inited & SORT_OPTIMIZABLE_BIT(type)) ? \
array.c:     (data->opt_methods & SORT_OPTIMIZABLE_BIT(type)) : \
array.c:     ((data->opt_inited |= SORT_OPTIMIZABLE_BIT(type)), \
array.c:      (data->opt_methods |= SORT_OPTIMIZABLE_BIT(type))))
array.c:    if (RBASIC(ary)->klass) {
array.c:    VALUE retval = sort_reentered(data->ary);
array.c:    sort_reentered(data->ary);
array.c:    VALUE retval = sort_reentered(data->ary);
array.c:	if ((long)a < (long)b) return -1;
array.c:    sort_reentered(data->ary);
array.c: *  call-seq:
array.c: *     array.sort!                   -> array
array.c: *     array.sort! {| a,b | block }  -> array 
array.c: *  <i>a</i> and <i>b</i>, returning -1, 0, or +1. See also
array.c:	RBASIC(tmp)->klass = 0;
array.c:        RBASIC(tmp)->klass = rb_cArray;
array.c: *  call-seq:
array.c: *     array.sort                   -> an_array 
array.c: *     array.sort {| a,b | block }  -> an_array 
array.c: *  <i>a</i> and <i>b</i>, returning -1, 0, or +1. See also
array.c: *  call-seq:
array.c: *     array.collect {|item| block }  -> an_array
array.c: *     array.map     {|item| block }  -> an_array
array.c: *  call-seq:
array.c: *     array.collect! {|item| block }   ->   array
array.c: *     array.map!     {|item| block }   ->   array
array.c: *  call-seq:
array.c: *     array.values_at(selector,... )  -> an_array
array.c: *     a.values_at(-1, -3, -5, -7)
array.c: *  call-seq:
array.c: *     array.select {|item| block } -> an_array
array.c: *  call-seq:
array.c: *     array.delete(obj)            -> obj or nil 
array.c: *     array.delete(obj) { block }  -> obj or nil
array.c:	    RARRAY_LEN(ary)-pos-1);
array.c:    ARY_INCREASE_LEN(ary, -1);
array.c: *  call-seq:
array.c: *     array.delete_at(index)  -> obj or nil
array.c: *  call-seq:
array.c: *     array.slice!(index)         -> obj or nil
array.c: *     array.slice!(start, length) -> sub_array or nil
array.c: *     array.slice!(range)         -> sub_array or nil 
array.c: *     a.slice!(-1)    #=> "c"
array.c:	    len = orig_len - pos;
array.c:	RBASIC(arg2)->klass = rb_obj_class(ary);
array.c: *  call-seq:
array.c: *     array.reject! {|item| block }  -> array or nil
array.c: *  call-seq:
array.c: *     array.reject {|item| block }  -> an_array
array.c: *  call-seq:
array.c: *     array.delete_if {|item| block }  -> array
array.c:    if (args[1]-- == 0) rb_iter_break();
array.c: *  call-seq:
array.c: *     array.zip(arg, ...)                   -> an_array
array.c: *     array.zip(arg, ...) {| arr | block }  -> nil
array.c: *  generates a sequence of <code>self.size</code> <em>n</em>-element
array.c: *  call-seq:
array.c: *     array.transpose -> an_array
array.c:    long elen = -1, alen, i, j;
array.c: *  call-seq:
array.c: *     array.replace(other_array)  -> array
array.c: *  call-seq:
array.c: *     array.clear    ->  array
array.c: *  call-seq:
array.c: *     array.fill(obj)                                -> array
array.c: *     array.fill(obj, start [, length])              -> array
array.c: *     array.fill(obj, range )                        -> array
array.c: *     array.fill {|index| block }                    -> array
array.c: *     array.fill(start [, length] ) {|index| block } -> array
array.c: *     array.fill(range) {|index| block }             -> array
array.c: *     a.fill(-2) {|i| i*i*i}   #=> [0, 1, 8, 27]
array.c:	len = NIL_P(arg2) ? RARRAY_LEN(ary) - beg : NUM2LONG(arg2);
array.c:    if (beg >= ARY_MAX_SIZE || len > ARY_MAX_SIZE - beg) {
array.c:	rb_mem_clear(RARRAY_PTR(ary) + RARRAY_LEN(ary), end - RARRAY_LEN(ary));
array.c: *  call-seq:
array.c: *     array + other_array   -> an_array
array.c: *  Concatenation---Returns a new array built by concatenating the
array.c: *  call-seq:
array.c: *     array.concat(other_array)   ->  array
array.c: *  call-seq:
array.c: *     array * int     ->    an_array
array.c: *     array * str     ->    a_string
array.c: *  Repetition---With a String argument, equivalent to
array.c: *  call-seq:
array.c: *     array.assoc(obj)   ->  an_array  or  nil
array.c: *  call-seq:
array.c: *     array.rassoc(obj) -> an_array or nil
array.c:  result = rb_funcall(obj1, rb_intern("p-match"), 1, obj2);
array.c: *  call-seq:
array.c: *     array == other_array   ->   bool
array.c: *  Equality---Two arrays are equal if they contain the same number
array.c: *  call-seq:
array.c: *     array.eql?(other)  -> true or false
array.c: *  call-seq:
array.c: *     array.hash   -> fixnum
array.c: *  Compute a hash-code for this array. Two arrays with the same content
array.c: *  call-seq:
array.c: *     array.include?(obj)   -> true or false
array.c: *  call-seq:
array.c: *     array <=> other_array   ->  -1, 0, +1
array.c: *  Comparison---Returns an integer (-1, 0,
array.c: *     [ "a", "a", "c" ]    <=> [ "a", "b", "c" ]   #=> -1
array.c:    len = RARRAY_LEN(ary1) - RARRAY_LEN(ary2);
array.c:    return INT2FIX(-1);
array.c: *  call-seq:
array.c: *     array - other_array    -> an_array
array.c: *  Array Difference---Returns a new array that is a copy of
array.c: *  other_array. (If you need set-like behavior, see the
array.c: *     [ 1, 1, 2, 2, 3, 3, 4, 5 ] - [ 1, 2, 4 ]  #=>  [ 3, 3, 5 ]
array.c: *  call-seq:
array.c: *  Set Intersection---Returns a new array
array.c: *  call-seq:
array.c: *     array | other_array     ->  an_array
array.c: *  Set Union---Returns a new array by joining this array with
array.c: *  call-seq:
array.c: *     array.uniq! -> array or nil
array.c: *  call-seq:
array.c: *     array.uniq   -> an_array
array.c: *  call-seq:
array.c: *     array.compact!    ->   array  or  nil
array.c:    n = p - RARRAY_PTR(ary);
array.c: *  call-seq:
array.c: *     array.compact     ->  an_array
array.c: *  call-seq:
array.c: *     array.count      -> int
array.c: *     array.count(obj) -> int
array.c: *     array.count { |item| block }  -> int
array.c:	    if (RBASIC(result)->klass) {
array.c:    RBASIC(result)->klass = rb_class_of(ary);
array.c: *  call-seq:
array.c: *     array.flatten! -> array or nil
array.c: *     array.flatten!(level) -> array or nil
array.c:    int mod = 0, level = -1;
array.c: *  call-seq:
array.c: *     array.flatten -> an_array
array.c: *     array.flatten(level) -> an_array
array.c: *  Returns a new array that is a one-dimensional flattening of this
array.c:    int mod = 0, level = -1;
array.c: *  call-seq:
array.c: *     array.shuffle!        -> array
array.c:	VALUE tmp = RARRAY_PTR(ary)[--i];
array.c: *  call-seq:
array.c: *     array.shuffle -> an_array
array.c: *  call-seq:
array.c: *     array.sample        -> obj
array.c: *     array.sample(n)     -> an_array
array.c:	j = rb_genrand_real()*(len-1);
array.c:	j = rb_genrand_real()*(len-1);
array.c:	k = rb_genrand_real()*(len-2);
array.c:	    k = rb_genrand_real()*--len;
array.c:	    memmove(&sorted[j+1], &sorted[j], sizeof(sorted[0])*(i-j));
array.c:	    j = (long)(rb_genrand_real()*(len-i)) + i;
array.c: *  call-seq:
array.c: *  forever if none or nil is given.  If a non-positive number is
array.c:        n = -1;
array.c:    while (RARRAY_LEN(ary) > 0 && (n < 0 || 0 < n--)) {
array.c: * Recursively compute permutations of r elements of the set [0..n-1].
array.c:	    if (index < r-1) {             /* if not done yet */
array.c: *  call-seq:
array.c: *     ary.permutation { |p| block }          -> array
array.c: *     ary.permutation                        -> enumerator
array.c: *     ary.permutation(n) { |p| block }       -> array
array.c: *     ary.permutation(n)                     -> enumerator
array.c:    else if (r == 0) { /* exactly one permutation: the zero-length array */
array.c:	RBASIC(ary0)->klass = 0;
array.c:	RBASIC(ary0)->klass = rb_cArray;
array.c:    if (k*2 > n) k = n-k;
array.c:    for (i=1; i <= k; i++,n--) {
array.c: *  call-seq:
array.c: *     ary.combination(n) { |c| block }    -> ary
array.c: *     ary.combination(n)                  -> enumerator
array.c:	RBASIC(cc)->klass = 0;
array.c:	stack[0] = -1;
array.c:		stack[lev--]++;
array.c: *  call-seq:
array.c:    RBASIC(t0)->klass = 0;
array.c:    RBASIC(t1)->klass = 0;
array.c:    for (i = 1; i < n; i++) arrays[i] = to_ary(argv[i-1]);
array.c:	m = n-1;
array.c:	    m--;
array.c: *  call-seq:
array.c: *  call-seq:
array.c: *  call-seq:
array.c: *  call-seq:
array.c:/* Arrays are ordered, integer-indexed collections of any object. 
array.c: * assumed to be relative to the end of the array---that is, an index of -1 
array.c: * indicates the last element of the array, -2 is the next to last 
array.c:    rb_define_singleton_method(rb_cArray, "[]", rb_ary_s_create, -1);
array.c:    rb_define_method(rb_cArray, "initialize", rb_ary_initialize, -1);
array.c:    rb_define_method(rb_cArray, "patern-match",rb_patern_match,1);
array.c:    rb_define_method(rb_cArray, "[]", rb_ary_aref, -1);
array.c:    rb_define_method(rb_cArray, "[]=", rb_ary_aset, -1);
array.c:    rb_define_method(rb_cArray, "fetch", rb_ary_fetch, -1);
array.c:    rb_define_method(rb_cArray, "first", rb_ary_first, -1);
array.c:    rb_define_method(rb_cArray, "last", rb_ary_last, -1);
array.c:    rb_define_method(rb_cArray, "push", rb_ary_push_m, -1);
array.c:    rb_define_method(rb_cArray, "pop", rb_ary_pop_m, -1);
array.c:    rb_define_method(rb_cArray, "shift", rb_ary_shift_m, -1);
array.c:    rb_define_method(rb_cArray, "unshift", rb_ary_unshift_m, -1);
array.c:    rb_define_method(rb_cArray, "insert", rb_ary_insert, -1);
array.c:    rb_define_method(rb_cArray, "find_index", rb_ary_index, -1);
array.c:    rb_define_method(rb_cArray, "index", rb_ary_index, -1);
array.c:    rb_define_method(rb_cArray, "rindex", rb_ary_rindex, -1);
array.c:    rb_define_method(rb_cArray, "join", rb_ary_join_m, -1);
array.c:    rb_define_method(rb_cArray, "values_at", rb_ary_values_at, -1);
array.c:    rb_define_method(rb_cArray, "zip", rb_ary_zip, -1);
array.c:    rb_define_method(rb_cArray, "fill", rb_ary_fill, -1);
array.c:    rb_define_method(rb_cArray, "slice", rb_ary_aref, -1);
array.c:    rb_define_method(rb_cArray, "slice!", rb_ary_slice_bang, -1);
array.c:    rb_define_method(rb_cArray, "-", rb_ary_diff, 1);
array.c:    rb_define_method(rb_cArray, "flatten", rb_ary_flatten, -1);
array.c:    rb_define_method(rb_cArray, "flatten!", rb_ary_flatten_bang, -1);
array.c:    rb_define_method(rb_cArray, "count", rb_ary_count, -1);
array.c:    rb_define_method(rb_cArray, "sample", rb_ary_sample, -1);
array.c:    rb_define_method(rb_cArray, "cycle", rb_ary_cycle, -1);
array.c:    rb_define_method(rb_cArray, "permutation", rb_ary_permutation, -1);
array.c:    rb_define_method(rb_cArray, "product", rb_ary_product, -1);
array.c~:  array.c -
array.c~:  Copyright (C) 1993-2007 Yukihiro Matsumoto
array.c~:  Copyright (C) 2000  Information-technology Promotion Agency, Japan
array.c~:    while (size--) {
array.c~:    while (size--) {
array.c~:#define ARY_HEAP_PTR(a) (assert(!ARY_EMBED_P(a)), RARRAY(a)->as.heap.ptr)
array.c~:#define ARY_HEAP_LEN(a) (assert(!ARY_EMBED_P(a)), RARRAY(a)->as.heap.len)
array.c~:#define ARY_EMBED_PTR(a) (assert(ARY_EMBED_P(a)), RARRAY(a)->as.ary)
array.c~:     (long)((RBASIC(a)->flags >> RARRAY_EMBED_LEN_SHIFT) & \
array.c~:    RARRAY(ary)->as.heap.ptr = (p); \
array.c~:    RBASIC(ary)->flags &= ~RARRAY_EMBED_LEN_MASK; \
array.c~:    RBASIC(ary)->flags |= (tmp_n) << RARRAY_EMBED_LEN_SHIFT; \
array.c~:    RARRAY(ary)->as.heap.len = n; \
array.c~:    RARRAY(ary)->as.heap.ptr += n; \
array.c~:        RARRAY(ary)->as.heap.len += n; \
array.c~:		       ARY_SHARED_ROOT_P(ary) ? RARRAY_LEN(ary) : RARRAY(ary)->as.heap.aux.capa)
array.c~:    RARRAY(ary)->as.heap.aux.capa = (n); \
array.c~:#define ARY_SHARED(ary) (assert(ARY_SHARED_P(ary)), RARRAY(ary)->as.heap.aux.shared)
array.c~:    RARRAY(ary)->as.heap.aux.shared = (value); \
array.c~:    (assert(ARY_SHARED_ROOT_P(ary)), RARRAY(ary)->as.heap.aux.capa)
array.c~:    RARRAY(ary)->as.heap.aux.capa = (value); \
array.c~:            REALLOC_N(RARRAY(ary)->as.heap.ptr, VALUE, (capacity));
array.c~:            MEMCPY(RARRAY(ary)->as.ary, ptr, VALUE, len); 
array.c~:	int num = ARY_SHARED_NUM(shared) - 1;
array.c~:    VALUE shared = RARRAY(ary)->as.heap.aux.shared;
array.c~: *  call-seq:
array.c~: *     array.frozen?  -> true or false
array.c~: *  call-seq:
array.c~: *     Array.try_convert(obj) -> array or nil
array.c~: *  call-seq:
array.c~:		     idx - RARRAY_LEN(ary));
array.c~:	if (new_capa >= ARY_MAX_SIZE - idx) {
array.c~:	    new_capa = (ARY_MAX_SIZE - idx) / 2;
array.c~:		     idx-RARRAY_LEN(ary) + 1);
array.c~:	offset = RARRAY_LEN(ary) - n;
array.c~: *  call-seq:
array.c~: *     array << obj            -> array
array.c~: *  Append---Pushes the given object on to the end of this array. This
array.c~: *  call-seq:
array.c~: *     array.push(obj, ... )   -> array
array.c~: *  Append---Pushes the given object(s) on to the end of this array. This
array.c~:    while (argc--) {
array.c~:    n = RARRAY_LEN(ary)-1;
array.c~: *  call-seq:
array.c~: *     array.pop    -> obj or nil
array.c~: *     array.pop(n) -> array
array.c~: *  (or less) just like <code>array.slice!(-n, n)</code> does.
array.c~:    ARY_INCREASE_LEN(ary, -RARRAY_LEN(result));
array.c~:	    MEMMOVE(RARRAY_PTR(ary), RARRAY_PTR(ary)+1, VALUE, RARRAY_LEN(ary)-1);
array.c~:            ARY_INCREASE_LEN(ary, -1);
array.c~:    ARY_INCREASE_LEN(ary, -1);
array.c~: *  call-seq:
array.c~: *     array.shift    -> obj or nil
array.c~: *     array.shift(n) -> array
array.c~: *     args = [ "-m", "-q", "filename" ]
array.c~: *     args.shift     #=> "-m"
array.c~: *     args           #=> ["-q", "filename"]
array.c~: *     args = [ "-m", "-q", "filename" ]
array.c~: *     args.shift(2)  #=> ["-m", "-q"]
array.c~:	MEMMOVE(RARRAY_PTR(ary), RARRAY_PTR(ary)+n, VALUE, RARRAY_LEN(ary)-n);
array.c~:    ARY_INCREASE_LEN(ary, -n);
array.c~: *  call-seq:
array.c~: *     array.unshift(obj, ...)  -> array
array.c~:/* faster version - use this if you don't need to treat negative offset */
array.c~:	len = RARRAY_LEN(ary) - beg;
array.c~: *  call-seq:
array.c~: *     array[index]                -> obj      or nil
array.c~: *     array[start, length]        -> an_array or nil
array.c~: *     array[range]                -> an_array or nil
array.c~: *     array.slice(index)          -> obj      or nil
array.c~: *     array.slice(start, length)  -> an_array or nil
array.c~: *     array.slice(range)          -> an_array or nil
array.c~: *  Element Reference---Returns the element at _index_,
array.c~: *  array (-1 is the last element). Returns nil if the index
array.c~: *     a[-3, 3]               #=> [ "c", "d", "e" ]
array.c~:    /* special case - speeding up */
array.c~: *  call-seq:
array.c~: *     array.at(index)   ->   obj  or nil
array.c~: *     a.at(-1)    #=> "e"
array.c~: *  call-seq:
array.c~: *     array.first     ->   obj or nil
array.c~: *     array.first(n)  ->   an_array
array.c~: *  call-seq:
array.c~: *     array.last     ->  obj or nil
array.c~: *     array.last(n)  ->  an_array
array.c~:	return RARRAY_PTR(ary)[RARRAY_LEN(ary)-1];
array.c~: *  call-seq:
array.c~: *     array.fetch(index)                    -> obj
array.c~: *     array.fetch(index, default )          -> obj
array.c~: *     array.fetch(index) {|index| block }   -> obj
array.c~: *     a.fetch(-1)              #=> 44
array.c~: *  call-seq:
array.c~: *     array.index(obj)           ->  int or nil
array.c~: *     array.index {|item| block} ->  int or nil
array.c~: *  call-seq:
array.c~: *     array.rindex(obj)    ->  int or nil
array.c~:	while (i--) {
array.c~:    while (i--) {
array.c~:	    beg -= RARRAY_LEN(ary);
array.c~:	len = RARRAY_LEN(ary) - beg;
array.c~:	if (beg > ARY_MAX_SIZE - rlen) {
array.c~:	rb_mem_clear(RARRAY_PTR(ary) + RARRAY_LEN(ary), beg - RARRAY_LEN(ary));
array.c~:	alen = RARRAY_LEN(ary) + rlen - len;
array.c~:		    VALUE, RARRAY_LEN(ary) - (beg + len));
array.c~: *  call-seq:
array.c~: *     array[index]         = obj                     ->  obj
array.c~: *     array[start, length] = obj or an_array or nil  ->  obj or an_array or nil
array.c~: *     array[range]         = obj or an_array or nil  ->  obj or an_array or nil
array.c~: *  Element Assignment---Sets the element at _index_,
array.c~: *     a[-1]   = "Z"               #=> ["A", "Z"]
array.c~: *     a[1..-1] = nil              #=> ["A", nil]
array.c~: *     a[1..-1] = []               #=> ["A"]
array.c~: *  call-seq:
array.c~: *     array.insert(index, obj...)  -> array
array.c~: *     a.insert(-2, 1, 2, 3)   #=> ["a", "b", 99, "c", 1, 2, 3, "d"]
array.c~:    if (pos == -1) {
array.c~:    rb_ary_splice(ary, pos, 0, rb_ary_new4(argc - 1, argv + 1));
array.c~: *  call-seq:
array.c~: *     array.each {|item| block }   ->   array
array.c~: *     a.each {|x| print x, " -- " }
array.c~: *     a -- b -- c --
array.c~: *  call-seq:
array.c~: *     array.each_index {|index| block }  ->  array
array.c~: *     a.each_index {|x| print x, " -- " }
array.c~: *     0 -- 1 -- 2 --
array.c~: *  call-seq:
array.c~:    while (len--) {
array.c~: *  call-seq:
array.c~: *     array.length -> int
array.c~: *  call-seq:
array.c~: *     array.empty?   -> true or false
array.c~:	len += RSTRING_LEN(sep) * (RARRAY_LEN(ary) - 1);
array.c~: *  call-seq:
array.c~: *     array.join(sep=$,)    -> str
array.c~: *     [ "a", "b", "c" ].join("-")   #=> "a-b-c"
array.c~: *  call-seq:
array.c~: *     array.to_s -> string
array.c~: *     array.inspect  -> string
array.c~: *  call-seq:
array.c~: *     array.to_a     -> array
array.c~: *  call-seq:
array.c~: *     array.to_ary -> array
array.c~:	p2 = p1 + RARRAY_LEN(ary) - 1;	/* points last item */
array.c~:	    *p2-- = tmp;
array.c~: *  call-seq:
array.c~: *     array.reverse!   -> array 
array.c~: *  call-seq:
array.c~: *     array.reverse -> an_array
array.c~:    ((data->opt_inited & SORT_OPTIMIZABLE_BIT(type)) ? \
array.c~:     (data->opt_methods & SORT_OPTIMIZABLE_BIT(type)) : \
array.c~:     ((data->opt_inited |= SORT_OPTIMIZABLE_BIT(type)), \
array.c~:      (data->opt_methods |= SORT_OPTIMIZABLE_BIT(type))))
array.c~:    if (RBASIC(ary)->klass) {
array.c~:    VALUE retval = sort_reentered(data->ary);
array.c~:    sort_reentered(data->ary);
array.c~:    VALUE retval = sort_reentered(data->ary);
array.c~:	if ((long)a < (long)b) return -1;
array.c~:    sort_reentered(data->ary);
array.c~: *  call-seq:
array.c~: *     array.sort!                   -> array
array.c~: *     array.sort! {| a,b | block }  -> array 
array.c~: *  <i>a</i> and <i>b</i>, returning -1, 0, or +1. See also
array.c~:	RBASIC(tmp)->klass = 0;
array.c~:        RBASIC(tmp)->klass = rb_cArray;
array.c~: *  call-seq:
array.c~: *     array.sort                   -> an_array 
array.c~: *     array.sort {| a,b | block }  -> an_array 
array.c~: *  <i>a</i> and <i>b</i>, returning -1, 0, or +1. See also
array.c~: *  call-seq:
array.c~: *     array.collect {|item| block }  -> an_array
array.c~: *     array.map     {|item| block }  -> an_array
array.c~: *  call-seq:
array.c~: *     array.collect! {|item| block }   ->   array
array.c~: *     array.map!     {|item| block }   ->   array
array.c~: *  call-seq:
array.c~: *     array.values_at(selector,... )  -> an_array
array.c~: *     a.values_at(-1, -3, -5, -7)
array.c~: *  call-seq:
array.c~: *     array.select {|item| block } -> an_array
array.c~: *  call-seq:
array.c~: *     array.delete(obj)            -> obj or nil 
array.c~: *     array.delete(obj) { block }  -> obj or nil
array.c~:	    RARRAY_LEN(ary)-pos-1);
array.c~:    ARY_INCREASE_LEN(ary, -1);
array.c~: *  call-seq:
array.c~: *     array.delete_at(index)  -> obj or nil
array.c~: *  call-seq:
array.c~: *     array.slice!(index)         -> obj or nil
array.c~: *     array.slice!(start, length) -> sub_array or nil
array.c~: *     array.slice!(range)         -> sub_array or nil 
array.c~: *     a.slice!(-1)    #=> "c"
array.c~:	    len = orig_len - pos;
array.c~:	RBASIC(arg2)->klass = rb_obj_class(ary);
array.c~: *  call-seq:
array.c~: *     array.reject! {|item| block }  -> array or nil
array.c~: *  call-seq:
array.c~: *     array.reject {|item| block }  -> an_array
array.c~: *  call-seq:
array.c~: *     array.delete_if {|item| block }  -> array
array.c~:    if (args[1]-- == 0) rb_iter_break();
array.c~: *  call-seq:
array.c~: *     array.zip(arg, ...)                   -> an_array
array.c~: *     array.zip(arg, ...) {| arr | block }  -> nil
array.c~: *  generates a sequence of <code>self.size</code> <em>n</em>-element
array.c~: *  call-seq:
array.c~: *     array.transpose -> an_array
array.c~:    long elen = -1, alen, i, j;
array.c~: *  call-seq:
array.c~: *     array.replace(other_array)  -> array
array.c~: *  call-seq:
array.c~: *     array.clear    ->  array
array.c~: *  call-seq:
array.c~: *     array.fill(obj)                                -> array
array.c~: *     array.fill(obj, start [, length])              -> array
array.c~: *     array.fill(obj, range )                        -> array
array.c~: *     array.fill {|index| block }                    -> array
array.c~: *     array.fill(start [, length] ) {|index| block } -> array
array.c~: *     array.fill(range) {|index| block }             -> array
array.c~: *     a.fill(-2) {|i| i*i*i}   #=> [0, 1, 8, 27]
array.c~:	len = NIL_P(arg2) ? RARRAY_LEN(ary) - beg : NUM2LONG(arg2);
array.c~:    if (beg >= ARY_MAX_SIZE || len > ARY_MAX_SIZE - beg) {
array.c~:	rb_mem_clear(RARRAY_PTR(ary) + RARRAY_LEN(ary), end - RARRAY_LEN(ary));
array.c~: *  call-seq:
array.c~: *     array + other_array   -> an_array
array.c~: *  Concatenation---Returns a new array built by concatenating the
array.c~: *  call-seq:
array.c~: *     array.concat(other_array)   ->  array
array.c~: *  call-seq:
array.c~: *     array * int     ->    an_array
array.c~: *     array * str     ->    a_string
array.c~: *  Repetition---With a String argument, equivalent to
array.c~: *  call-seq:
array.c~: *     array.assoc(obj)   ->  an_array  or  nil
array.c~: *  call-seq:
array.c~: *     array.rassoc(obj) -> an_array or nil
array.c~: *  call-seq:
array.c~: *     array == other_array   ->   bool
array.c~: *  Equality---Two arrays are equal if they contain the same number
array.c~: *  call-seq:
array.c~: *     array.eql?(other)  -> true or false
array.c~: *  call-seq:
array.c~: *     array.hash   -> fixnum
array.c~: *  Compute a hash-code for this array. Two arrays with the same content
array.c~: *  call-seq:
array.c~: *     array.include?(obj)   -> true or false
array.c~: *  call-seq:
array.c~: *     array <=> other_array   ->  -1, 0, +1
array.c~: *  Comparison---Returns an integer (-1, 0,
array.c~: *     [ "a", "a", "c" ]    <=> [ "a", "b", "c" ]   #=> -1
array.c~:    len = RARRAY_LEN(ary1) - RARRAY_LEN(ary2);
array.c~:    return INT2FIX(-1);
array.c~: *  call-seq:
array.c~: *     array - other_array    -> an_array
array.c~: *  Array Difference---Returns a new array that is a copy of
array.c~: *  other_array. (If you need set-like behavior, see the
array.c~: *     [ 1, 1, 2, 2, 3, 3, 4, 5 ] - [ 1, 2, 4 ]  #=>  [ 3, 3, 5 ]
array.c~: *  call-seq:
array.c~: *  Set Intersection---Returns a new array
array.c~: *  call-seq:
array.c~: *     array | other_array     ->  an_array
array.c~: *  Set Union---Returns a new array by joining this array with
array.c~: *  call-seq:
array.c~: *     array.uniq! -> array or nil
array.c~: *  call-seq:
array.c~: *     array.uniq   -> an_array
array.c~: *  call-seq:
array.c~: *     array.compact!    ->   array  or  nil
array.c~:    n = p - RARRAY_PTR(ary);
array.c~: *  call-seq:
array.c~: *     array.compact     ->  an_array
array.c~: *  call-seq:
array.c~: *     array.count      -> int
array.c~: *     array.count(obj) -> int
array.c~: *     array.count { |item| block }  -> int
array.c~:	    if (RBASIC(result)->klass) {
array.c~:    RBASIC(result)->klass = rb_class_of(ary);
array.c~: *  call-seq:
array.c~: *     array.flatten! -> array or nil
array.c~: *     array.flatten!(level) -> array or nil
array.c~:    int mod = 0, level = -1;
array.c~: *  call-seq:
array.c~: *     array.flatten -> an_array
array.c~: *     array.flatten(level) -> an_array
array.c~: *  Returns a new array that is a one-dimensional flattening of this
array.c~:    int mod = 0, level = -1;
array.c~: *  call-seq:
array.c~: *     array.shuffle!        -> array
array.c~:	VALUE tmp = RARRAY_PTR(ary)[--i];
array.c~: *  call-seq:
array.c~: *     array.shuffle -> an_array
array.c~: *  call-seq:
array.c~: *     array.sample        -> obj
array.c~: *     array.sample(n)     -> an_array
array.c~:	j = rb_genrand_real()*(len-1);
array.c~:	j = rb_genrand_real()*(len-1);
array.c~:	k = rb_genrand_real()*(len-2);
array.c~:	    k = rb_genrand_real()*--len;
array.c~:	    memmove(&sorted[j+1], &sorted[j], sizeof(sorted[0])*(i-j));
array.c~:	    j = (long)(rb_genrand_real()*(len-i)) + i;
array.c~: *  call-seq:
array.c~: *  forever if none or nil is given.  If a non-positive number is
array.c~:        n = -1;
array.c~:    while (RARRAY_LEN(ary) > 0 && (n < 0 || 0 < n--)) {
array.c~: * Recursively compute permutations of r elements of the set [0..n-1].
array.c~:	    if (index < r-1) {             /* if not done yet */
array.c~: *  call-seq:
array.c~: *     ary.permutation { |p| block }          -> array
array.c~: *     ary.permutation                        -> enumerator
array.c~: *     ary.permutation(n) { |p| block }       -> array
array.c~: *     ary.permutation(n)                     -> enumerator
array.c~:    else if (r == 0) { /* exactly one permutation: the zero-length array */
array.c~:	RBASIC(ary0)->klass = 0;
array.c~:	RBASIC(ary0)->klass = rb_cArray;
array.c~:    if (k*2 > n) k = n-k;
array.c~:    for (i=1; i <= k; i++,n--) {
array.c~: *  call-seq:
array.c~: *     ary.combination(n) { |c| block }    -> ary
array.c~: *     ary.combination(n)                  -> enumerator
array.c~:	RBASIC(cc)->klass = 0;
array.c~:	stack[0] = -1;
array.c~:		stack[lev--]++;
array.c~: *  call-seq:
array.c~:    RBASIC(t0)->klass = 0;
array.c~:    RBASIC(t1)->klass = 0;
array.c~:    for (i = 1; i < n; i++) arrays[i] = to_ary(argv[i-1]);
array.c~:	m = n-1;
array.c~:	    m--;
array.c~: *  call-seq:
array.c~: *  call-seq:
array.c~: *  call-seq:
array.c~: *  call-seq:
array.c~:/* Arrays are ordered, integer-indexed collections of any object. 
array.c~: * assumed to be relative to the end of the array---that is, an index of -1 
array.c~: * indicates the last element of the array, -2 is the next to last 
array.c~:    rb_define_singleton_method(rb_cArray, "[]", rb_ary_s_create, -1);
array.c~:    rb_define_method(rb_cArray, "initialize", rb_ary_initialize, -1);
array.c~:    rb_define_method(rb_cArray, "[]", rb_ary_aref, -1);
array.c~:    rb_define_method(rb_cArray, "[]=", rb_ary_aset, -1);
array.c~:    rb_define_method(rb_cArray, "fetch", rb_ary_fetch, -1);
array.c~:    rb_define_method(rb_cArray, "first", rb_ary_first, -1);
array.c~:    rb_define_method(rb_cArray, "last", rb_ary_last, -1);
array.c~:    rb_define_method(rb_cArray, "push", rb_ary_push_m, -1);
array.c~:    rb_define_method(rb_cArray, "pop", rb_ary_pop_m, -1);
array.c~:    rb_define_method(rb_cArray, "shift", rb_ary_shift_m, -1);
array.c~:    rb_define_method(rb_cArray, "unshift", rb_ary_unshift_m, -1);
array.c~:    rb_define_method(rb_cArray, "insert", rb_ary_insert, -1);
array.c~:    rb_define_method(rb_cArray, "find_index", rb_ary_index, -1);
array.c~:    rb_define_method(rb_cArray, "index", rb_ary_index, -1);
array.c~:    rb_define_method(rb_cArray, "rindex", rb_ary_rindex, -1);
array.c~:    rb_define_method(rb_cArray, "join", rb_ary_join_m, -1);
array.c~:    rb_define_method(rb_cArray, "values_at", rb_ary_values_at, -1);
array.c~:    rb_define_method(rb_cArray, "zip", rb_ary_zip, -1);
array.c~:    rb_define_method(rb_cArray, "fill", rb_ary_fill, -1);
array.c~:    rb_define_method(rb_cArray, "slice", rb_ary_aref, -1);
array.c~:    rb_define_method(rb_cArray, "slice!", rb_ary_slice_bang, -1);
array.c~:    rb_define_method(rb_cArray, "-", rb_ary_diff, 1);
array.c~:    rb_define_method(rb_cArray, "flatten", rb_ary_flatten, -1);
array.c~:    rb_define_method(rb_cArray, "flatten!", rb_ary_flatten_bang, -1);
array.c~:    rb_define_method(rb_cArray, "count", rb_ary_count, -1);
array.c~:    rb_define_method(rb_cArray, "sample", rb_ary_sample, -1);
array.c~:    rb_define_method(rb_cArray, "cycle", rb_ary_cycle, -1);
array.c~:    rb_define_method(rb_cArray, "permutation", rb_ary_permutation, -1);
array.c~:    rb_define_method(rb_cArray, "product", rb_ary_product, -1);
ãã¤ããªã¼ã»ãã¡ã¤ã«array.oã¯ä¸è´ãã¾ãã
ãã¤ããªã¼ã»ãã¡ã¤ã«ascii.oã¯ä¸è´ãã¾ãã
bignum.c:  bignum.c -
bignum.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
bignum.c:#define BIGLO(x) ((BDIGIT)((x) & (BIGRAD-1)))
bignum.c:#define BDIGMAX ((BDIGIT)-1)
bignum.c:    for (i = RBIGNUM_LEN(x) - 1; 0 <= i; i--) {
bignum.c:        if (l < 0) return -1;
bignum.c:	return -1;
bignum.c:    if (RTEST(rb_funcall(val, '<', 1, INT2FIX(0)))) return -1;
bignum.c:  ((RBASIC(b)->flags & RBIGNUM_EMBED_FLAG) ? \
bignum.c:   (RBASIC(b)->flags = (RBASIC(b)->flags & ~RBIGNUM_EMBED_LEN_MASK) | \
bignum.c:   (RBIGNUM(b)->as.heap.len = (l)))
bignum.c:    if (RBASIC(big)->flags & RBIGNUM_EMBED_FLAG) {
bignum.c:	    MEMCPY(ds, RBIGNUM(big)->as.ary, BDIGIT, RBIGNUM_EMBED_LEN_MAX);
bignum.c:	    RBIGNUM(big)->as.heap.len = RBIGNUM_LEN(big);
bignum.c:	    RBIGNUM(big)->as.heap.digits = ds;
bignum.c:	    RBASIC(big)->flags &= ~RBIGNUM_EMBED_FLAG;
bignum.c:	    ds = RBIGNUM(big)->as.heap.digits;
bignum.c:	    RBASIC(big)->flags |= RBIGNUM_EMBED_FLAG;
bignum.c:		MEMCPY(RBIGNUM(big)->as.ary, ds, BDIGIT, len);
bignum.c:		RBIGNUM(big)->as.heap.digits = ALLOC_N(BDIGIT, len);
bignum.c:		REALLOC_N(RBIGNUM(big)->as.heap.digits, BDIGIT, len);
bignum.c:	RBASIC(big)->flags |= RBIGNUM_EMBED_FLAG;
bignum.c:    while (i--) ds[i] = ~ds[i];
bignum.c:	ds[RBIGNUM_LEN(x)-1] = 1;
bignum.c:    while (--len && !ds[len]);
bignum.c:	while (len--) {
bignum.c:		if (NEGFIXABLE(-(long)num)) return LONG2FIX(-(long)num);
bignum.c:    while (--i && !digits[i]) ;
bignum.c:	n = -n;
bignum.c:	while (len--) {
bignum.c:	if (!RBIGNUM_SIGN(val)) q = -q;
bignum.c:	    q = -(LONG_LONG)q;
bignum.c:    while (i-- && !digits[i]) ;
bignum.c:	while (len--) {
bignum.c:#define BNEG(b) (RSHIFT(((BDIGIT*)b)[QUAD_SIZE/SIZEOF_BDIGITS-1],BITSPERDIG-1) != 0)
bignum.c:	while (len--) {
bignum.c:    (!ISASCII(c) ? -1 : \
bignum.c:     ISDIGIT(c) ? ((c) - '0') : \
bignum.c:     ISLOWER(c) ? ((c) - 'a' + 10) : \
bignum.c:     ISUPPER(c) ? ((c) - 'A' + 10) : \
bignum.c:     -1)
bignum.c:    else if (str[0] == '-') {
bignum.c:    if (str[0] == '+' || str[0] == '-') {
bignum.c:	else if (base < -1) {
bignum.c:	    base = -base;
bignum.c:	if (!(c = *str) || ISSPACE(c)) --str;
bignum.c:		long result = -(long)val;
bignum.c:    for (i=len;i--;) zds[i]=0;
bignum.c:	str--;
bignum.c:	if (s+1 < str && str[-1] == '_') goto bad;
bignum.c:    while (i-- && !digits[i]) ;
bignum.c:	n = -n;
bignum.c:#define POW2_P(x) (((x)&((x)-1))==0)
bignum.c:    x -= (x >> 1) & MASK_55;
bignum.c:    return (int)ones(x) - 1;
bignum.c:    if (NIL_P(big2str_power_cache[base - 2][i])) {
bignum.c:	big2str_power_cache[base - 2][i] =
bignum.c:		   : bigsqr(power_cache_get_power0(base, i - 1));
bignum.c:	rb_gc_register_mark_object(big2str_power_cache[base - 2][i]);
bignum.c:    return big2str_power_cache[base - 2][i];
bignum.c:    i = m - LOG2_KARATSUBA_DIGITS;
bignum.c:	i = MAX_BIG2STR_TABLE_ENTRIES - 1;
bignum.c: * x = 2^0 * x_0 + 2^1 * x_1 + ... + 2^(B*n_0 - 1) * x_{B*n_0 - 1},
bignum.c:	bits = (SIZEOF_LONG*CHAR_BIT - 1)/2 + 1;
bignum.c:    return (long)ceil(bits/log_2[base - 2]);
bignum.c:	while (k--) {               /* x / hbase */
bignum.c:	if (trim && ds[i-1] == 0) i--;
bignum.c:	while (k--) {
bignum.c:	    ptr[--j] = ruby_digitmap[num % base];
bignum.c:	MEMMOVE(ptr, ptr + j, char, len - j);
bignum.c:	len -= j;
bignum.c:    lh = big2str_karatsuba(q, base, ptr, (len - m1)/2,
bignum.c:			   len - m1, hbase, trim);
bignum.c:    ptr[0] = RBIGNUM_SIGN(x) ? '+' : '-';
bignum.c: *  call-seq:
bignum.c:    while (len--) {
bignum.c:	return -num;
bignum.c:	return -num;
bignum.c:    if (!RBIGNUM_SIGN(x)) return -(SIGNED_VALUE)num;
bignum.c:    while (len--) {
bignum.c:    if (!RBIGNUM_SIGN(x)) return -num;
bignum.c:    if (!RBIGNUM_SIGN(x)) return -(LONG_LONG)num;
bignum.c:    double u = (d < 0)?-d:d;
bignum.c:	rb_raise(rb_eFloatDomainError, d < 0 ? "-Infinity" : "Infinity");
bignum.c:    while (i--) {
bignum.c:	u -= c;
bignum.c:    y = x >> 64; if (y) {n -= 64; x = y;}
bignum.c:    y = x >> 32; if (y) {n -= 32; x = y;}
bignum.c:    y = x >> 16; if (y) {n -= 16; x = y;}
bignum.c:    y = x >>  8; if (y) {n -=  8; x = y;}
bignum.c:    y = x >>  4; if (y) {n -=  4; x = y;}
bignum.c:    y = x >>  2; if (y) {n -=  2; x = y;}
bignum.c:    y = x >>  1; if (y) {return n - 2;}
bignum.c:    return n - x;
bignum.c:	bits = i * BITSPERDIG - nlz(ds[i-1]);
bignum.c:		lo = (bits -= DBL_MANT_DIG+1) / BITSPERDIG;
bignum.c:	    while (--i > lo) {
bignum.c:		    while (i-- > 0) {
bignum.c:    if (!RBIGNUM_SIGN(x)) d = -d;
bignum.c:	    d = -HUGE_VAL;
bignum.c: *  call-seq:
bignum.c: *     big.to_f -> float
bignum.c: *  call-seq:
bignum.c: *     big <=> numeric   => -1, 0, +1
bignum.c: *  Comparison---Returns -1, 0, or +1 depending on whether <i>big</i> is
bignum.c:		if (a > 0.0) return INT2FIX(-1);
bignum.c:    if (RBIGNUM_SIGN(x) < RBIGNUM_SIGN(y)) return INT2FIX(-1);
bignum.c:	return (RBIGNUM_SIGN(x)) ? INT2FIX(-1) : INT2FIX(1);
bignum.c:	return (RBIGNUM_SIGN(x)) ? INT2FIX(1) : INT2FIX(-1);
bignum.c:    while(xlen-- && (BDIGITS(x)[xlen]==BDIGITS(y)[xlen]));
bignum.c:    if (-1 == xlen) return INT2FIX(0);
bignum.c:	(RBIGNUM_SIGN(x) ? INT2FIX(1) : INT2FIX(-1)) :
bignum.c:	    (RBIGNUM_SIGN(x) ? INT2FIX(-1) : INT2FIX(1));
bignum.c: *  call-seq:
bignum.c: *  call-seq:
bignum.c: * call-seq:
bignum.c: *    -big   =>  other_big
bignum.c: * Unary minus (returns a new Bignum whose value is 0-big)
bignum.c: * call-seq:
bignum.c:    while (i--) {
bignum.c:	    i--;
bignum.c:	num += (BDIGIT_DBL_SIGNED)BDIGITS(x)[i] - BDIGITS(y)[i];
bignum.c: *  call-seq:
bignum.c: *  call-seq:
bignum.c: *     big - other  => Numeric
bignum.c:	return DBL2NUM(rb_big2dbl(x) - RFLOAT_VALUE(y));
bignum.c:	return rb_num_coerce_bin(x, y, '-');
bignum.c:    VALUE x = bms->x, y = bms->y, z = bms->z;
bignum.c:    while (j--) zds[j] = 0;
bignum.c:	if (bms->stop) return Qnil;
bignum.c: *  call-seq:
bignum.c:    long nx = bds->nx, ny = bds->ny;
bignum.c:    BDIGIT *yds = bds->yds, *zds = bds->zds;
bignum.c:	if (bds->stop) return Qnil;
bignum.c:	if (zds[j] ==  yds[ny-1]) q = BIGRAD-1;
bignum.c:	else q = (BDIGIT)((BIGUP(zds[j]) + zds[j-1])/yds[ny-1]);
bignum.c:		ee = num - BIGLO(t2);
bignum.c:		num = (BDIGIT_DBL)zds[j - ny + i] + ee;
bignum.c:		if (ee) zds[j - ny + i] = BIGLO(num);
bignum.c:	    num += zds[j - ny + i] - t2;/* borrow from high digit; don't update */
bignum.c:		i = 0; num = 0; q--;
bignum.c:		    num = (BDIGIT_DBL)zds[j - ny + i] + ee;
bignum.c:		    if (ee) zds[j - ny + i] = BIGLO(num);
bignum.c:		num--;
bignum.c:    } while (--j >= ny);
bignum.c:    if (nx < ny || (nx == ny && BDIGITS(x)[nx - 1] < BDIGITS(y)[ny - 1])) {
bignum.c:	while (i--) {
bignum.c:    while (!yds[ny-1]) ny--;
bignum.c:    q = yds[ny-1];
bignum.c:    while ((q & (1UL<<(BITSPERDIG-1))) == 0) {
bignum.c:	while (j--) zds[j] = xds[j];
bignum.c:	j = (nx==ny ? nx+2 : nx+1) - ny;
bignum.c:	if (!zds[i-1]) i--;
bignum.c:	while (--ny && !zds[ny]); ++ny;
bignum.c:	    while(i--) {
bignum.c:	if (!zds[ny-1]) ny--;
bignum.c: *  call-seq:
bignum.c: *  call-seq:
bignum.c: *  call-seq:
bignum.c: *     -1234567890987654321.remainder(13731)      #=> -6966
bignum.c: *     -1234567890987654321.remainder(13731.24)   #=> -9906.22531493148
bignum.c: *  call-seq:
bignum.c:	return big_lshift(x, (unsigned int)-n);
bignum.c: *  call-seq:
bignum.c: *     big.fdiv(numeric) -> float
bignum.c: *     -1234567890987654321.fdiv(13731)      #=> -89910996357705.5
bignum.c: *     -1234567890987654321.fdiv(13731.24)   #=> -89909424858035.7
bignum.c:	ex = (RBIGNUM_LEN(bigtrunc(x)) - 1) * BITSPERDIG;
bignum.c:	ex += bdigbitsize(BDIGITS(x)[RBIGNUM_LEN(x) - 1]);
bignum.c:	ex -= 2 * DBL_BIGDIG * BITSPERDIG;
bignum.c:	    ey = (RBIGNUM_LEN(bigtrunc(y)) - 1) * BITSPERDIG;
bignum.c:	    ey += bdigbitsize(BDIGITS(y)[RBIGNUM_LEN(y) - 1]);
bignum.c:	    ey -= DBL_BIGDIG * BITSPERDIG;
bignum.c:	    return DBL2NUM(ldexp(big2dbl(z), ex - ey));
bignum.c:	    ey -= DBL_MANT_DIG;
bignum.c:    a = bignew(len - k, 1);
bignum.c:    MEMCPY(BDIGITS(a), BDIGITS(x) + k, BDIGIT, len - k);
bignum.c: *  call-seq:
bignum.c: *    123456789 ** -2     #=> 6.5610001194102e-17
bignum.c: * call-seq:
bignum.c: * call-seq:
bignum.c:	zds[i] = sign?ds2[i]:(BIGRAD-1);
bignum.c: * call-seq:
bignum.c:	return RBIGNUM_SIGN(x) ? INT2FIX(0) : INT2FIX(-1);
bignum.c: * call-seq:
bignum.c:		shift = -shift;
bignum.c: * call-seq:
bignum.c:		shift = -shift;
bignum.c:	    return INT2FIX(-1);
bignum.c:    i = RBIGNUM_LEN(x); j = i - s1;
bignum.c:	else return INT2FIX(-1);
bignum.c:    while (i--, j--) {
bignum.c: *  call-seq:
bignum.c: *     big[n] -> 0, 1
bignum.c: *  Bit Reference---Returns the <em>n</em>th bit in the (assumed) binary
bignum.c: * call-seq:
bignum.c: *  call-seq:
bignum.c: *     big.abs -> aBignum
bignum.c: *     -1234567890987654321.abs   #=> 1234567890987654321
bignum.c: *  call-seq:
bignum.c: *     big.size -> integer
bignum.c: *     (256**10 - 1).size   #=> 12
bignum.c: *     (256**20 - 1).size   #=> 20
bignum.c: *     (256**40 - 1).size   #=> 40
bignum.c: *  call-seq:
bignum.c: *     big.odd? -> true or false
bignum.c: *  call-seq:
bignum.c: *     big.even? -> true or false
bignum.c: *  Bignum is treated as if it were an infinite-length
bignum.c: *  objects are not---assignment and parameter passing work with
bignum.c:    rb_define_method(rb_cBignum, "to_s", rb_big_to_s, -1);
bignum.c:    rb_define_method(rb_cBignum, "-@", rb_big_uminus, 0);
bignum.c:    rb_define_method(rb_cBignum, "-", rb_big_minus, 1);
ãã¤ããªã¼ã»ãã¡ã¤ã«bignum.oã¯ä¸è´ãã¾ãã
blockinlining.c:  blockinlining.c -
blockinlining.c:  Copyright (C) 2004-2007 Koichi Sasada
blockinlining.c:    if (iseq->argc > 1 || iseq->arg_simple == 0) {
blockinlining.c:    if (iseq->cached_special_block_builder) {
blockinlining.c:	if (iseq->cached_special_block_builder == builder) {
blockinlining.c:	    return iseq->cached_special_block;
blockinlining.c:	iseq->cached_special_block_builder = (void *)1;
blockinlining.c:    if (iseq->parent_iseq) {
blockinlining.c:	parent = iseq->parent_iseq->self;
blockinlining.c:    iseqval = rb_iseq_new_with_bopt(iseq->node, iseq->name, iseq->filename,
blockinlining.c:				      parent, iseq->type,
blockinlining.c:    iseq->cached_special_block = iseqval;
blockinlining.c:    iseq->cached_special_block_builder = builder;
blockinlining.c:    head->nd_next = tail;
blockinlining.c:    head->nd_next = tail;
blockinlining.c:	  return NEW_NODE(NODE_LASGN, lnode->nd_vid, rhs, lnode->nd_cnt);
blockinlining.c:	  /* NEW_LASGN(lnode->nd_vid, rhs); */
blockinlining.c:	  return NEW_GASGN(lnode->nd_vid, rhs);
blockinlining.c:	  return NEW_DASGN(lnode->nd_vid, rhs);
blockinlining.c:	  if (lnode->nd_args) {
blockinlining.c:	      args = NEW_ARRAY(lnode->nd_args->nd_head);
blockinlining.c:	      args->nd_next = NEW_ARRAY(rhs);
blockinlining.c:	      args->nd_alen = 2;
blockinlining.c:	  return NEW_ATTRASGN(lnode->nd_recv,
blockinlining.c:			      lnode->nd_mid,
blockinlining.c:    if (iseq->argc == 0) {
blockinlining.c:	iseq->argc += 2;
blockinlining.c:	iseq->argc++;
blockinlining.c:    rb_block_t *orig_block = GC_GUARDED_PTR_REF(th->cfp->lfp[0]);
blockinlining.c:    if (orig_block && BUILTIN_TYPE(orig_block->iseq) != T_NODE) {
blockinlining.c:	VALUE tsiseqval = iseq_special_block(orig_block->iseq,
blockinlining.c:	    th->cfp->lfp[0] = GC_GUARDED_PTR(&block);
blockinlining.c:    if (iseq->argc == 0) {
blockinlining.c:	iseq->argc += 2;
blockinlining.c:	iseq->argc++;
blockinlining.c:    rb_block_t *orig_block = GC_GUARDED_PTR_REF(th->cfp->lfp[0]);
blockinlining.c:    if (BUILTIN_TYPE(orig_block->iseq) != T_NODE) {
blockinlining.c:	VALUE tsiseqval = iseq_special_block(orig_block->iseq, builder);
blockinlining.c:	    th->cfp->lfp[0] = GC_GUARDED_PTR(&block);
blockinlining.c:    if (iseq->argc == 0) {
blockinlining.c:	iseq->argc += 2;
blockinlining.c:	iseq->argc++;
blockinlining.c:    rb_block_t *orig_block = GC_GUARDED_PTR_REF(th->cfp->lfp[0]);
blockinlining.c:    if (BUILTIN_TYPE(orig_block->iseq) != T_NODE) {
blockinlining.c:	VALUE tsiseqval = iseq_special_block(orig_block->iseq,
blockinlining.c:	    th->cfp->lfp[0] = GC_GUARDED_PTR(&block);
class.c:  class.c -
class.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
class.c:    obj->ptr = ext;
class.c:    if (RBASIC(super)->flags & FL_SINGLETON) {
class.c:	st_insert(data->tbl, mid, 0);
class.c:	NODE *fbody = body->nd_body->nd_body;
class.c:			     rb_iseq_clone((VALUE)fbody->nd_body, data->klass),
class.c:	st_insert(data->tbl, mid,
class.c:				 data->klass, /* TODO */
class.c:				 body->nd_body->nd_noex),
class.c:	RBASIC(clone)->klass = rb_singleton_class_clone(orig);
class.c:    VALUE klass = RBASIC(obj)->klass;
class.c:        VALUE clone = class_alloc(RBASIC(klass)->flags, 0);
class.c:	    RBASIC(clone)->klass = (VALUE)clone;
class.c:	    RBASIC(clone)->klass = rb_singleton_class_clone(klass);
class.c:	rb_singleton_class_attached(RBASIC(clone)->klass, (VALUE)clone);
class.c:    if (RBASIC(metaclass)->klass == metaclass) { /* for meta^(n)-class of Class */
class.c:        RBASIC(metametaclass)->klass = metametaclass;
class.c:        RBASIC(metametaclass)->klass = 
class.c:            (RBASIC(RBASIC(metaclass)->klass)->klass == RBASIC(metaclass)->klass)
class.c:            ? make_metametaclass(RBASIC(metaclass)->klass)
class.c:            : RBASIC(RBASIC(metaclass)->klass)->klass;
class.c:    RBASIC(metaclass)->klass = metametaclass;
class.c:        rb_iv_get(RBASIC(super_of_metaclass)->klass, "__attached__") == super_of_metaclass
class.c:        ? RBASIC(super_of_metaclass)->klass 
class.c:	RBASIC(obj)->klass = klass;
class.c:	metasuper = RBASIC(rb_class_real(super))->klass;
class.c:	    RBASIC(klass)->klass = metasuper;
class.c:    rb_make_metaclass(klass, RBASIC(super)->klass);
class.c:	module = RBASIC(module)->klass;
class.c:	RBASIC(klass)->klass = RBASIC(module)->klass;
class.c:	RBASIC(klass)->klass = module;
class.c: *  call-seq:
class.c: *     mod.included_modules -> array
class.c:	    rb_ary_push(ary, RBASIC(p)->klass);
class.c: *  call-seq:
class.c:	    if (RBASIC(p)->klass == mod2) return Qtrue;
class.c: *  call-seq:
class.c: *     mod.ancestors -> array
class.c:	    rb_ary_push(ary, RBASIC(p)->klass);
class.c:    if (type == -1) return ST_CONTINUE;
class.c:    return ins_methods_push(name, type, ary, -1); /* everything but private */
class.c:	if (body ==0 || !body->nd_body->nd_body) {
class.c:	    type = -1; /* none */
class.c:	    type = VISI(body->nd_body->nd_noex);
class.c: *  call-seq:
class.c: *  call-seq:
class.c: *  call-seq:
class.c: *  call-seq:
class.c: *  call-seq:
class.c:    if (FL_TEST(RBASIC(obj)->klass, FL_SINGLETON) &&
class.c:	rb_iv_get(RBASIC(obj)->klass, "__attached__") == obj) {
class.c:	klass = RBASIC(obj)->klass;
class.c:	klass = rb_make_metaclass(obj, RBASIC(obj)->klass);
class.c:	if (rb_iv_get(RBASIC(klass)->klass, "__attached__") != klass)
class.c:	n = *p - '0';
class.c:	n = i + *p - '0';
class.c:	    if (var) *var = rb_ary_new4(argc-i, argv+i);
ãã¤ããªã¼ã»ãã¡ã¤ã«class.oã¯ä¸è´ãã¾ãã
common.mk:RUBYLIB       = -
common.mk:RUBYOPT       = -
common.mk:STATIC_RUBY   = static-ruby
common.mk:LIBRUBY_EXTS  = ./.libruby-with-ext.time
common.mk:ID_H_TARGET   = -id.h-
common.mk:SCRIPT_ARGS   =	--dest-dir="$(DESTDIR)" \
common.mk:		--extout="$(EXTOUT)" \
common.mk:		--mflags="$(MFLAGS)" \
common.mk:		--make-flags="$(MAKEFLAGS)"
common.mk:EXTMK_ARGS    =	$(SCRIPT_ARGS) --extension $(EXTS) --extstatic $(EXTSTATIC) \
common.mk:		--make-flags="MINIRUBY='$(MINIRUBY)'" --
common.mk:		--data-mode=$(INSTALL_DATA_MODE) \
common.mk:		--prog-mode=$(INSTALL_PROG_MODE) \
common.mk:		--installed-list $(INSTALLED_LIST)
common.mk:PRE_LIBRUBY_UPDATE = $(MINIRUBY) -e 'ARGV[1] or File.unlink(ARGV[0]) rescue nil' -- \
common.mk:COMPILE_PRELUDE = $(MINIRUBY) -I$(srcdir) -rrbconfig $(srcdir)/tool/compile_prelude.rb
common.mk:	@$(MINIRUBY) $(srcdir)/ext/extmk.rb --make="$(MAKE)" --command-output=$@ $(EXTMK_ARGS)
common.mk:	$(MINIRUBY) -e 'p $$:'
common.mk:	@$(NM) -Pgp $(OBJS) | awk 'BEGIN{print "#!"}; $$2~/^[BD]$$/{print $$1}' | sort -u -o $@
common.mk:install: install-nodoc $(RDOCTARGET)
common.mk:install-all: install-nodoc install-doc
common.mk:install-nodoc: pre-install-nodoc do-install-nodoc post-install-nodoc
common.mk:pre-install-nodoc:: pre-install-local pre-install-ext
common.mk:do-install-nodoc: $(PREP)
common.mk:	$(INSTRUBY) --make="$(MAKE)" $(INSTRUBY_ARGS) --mantype="$(MANTYPE)"
common.mk:post-install-nodoc:: post-install-local post-install-ext
common.mk:install-local: pre-install-local do-install-local post-install-local
common.mk:pre-install-local:: pre-install-bin pre-install-lib pre-install-man
common.mk:do-install-local: $(PREP)
common.mk:	$(INSTRUBY) --make="$(MAKE)" $(INSTRUBY_ARGS) --install=local --mantype="$(MANTYPE)"
common.mk:post-install-local:: post-install-bin post-install-lib post-install-man
common.mk:install-ext: pre-install-ext do-install-ext post-install-ext
common.mk:pre-install-ext:: pre-install-ext-arch pre-install-ext-comm
common.mk:do-install-ext: $(PREP)
common.mk:	$(INSTRUBY) --make="$(MAKE)" $(INSTRUBY_ARGS) --install=ext
common.mk:post-install-ext:: post-install-ext-arch post-install-ext-comm
common.mk:install-arch: pre-install-arch do-install-arch post-install-arch
common.mk:pre-install-arch:: pre-install-bin pre-install-ext-arch
common.mk:do-install-arch: $(PREP)
common.mk:	$(INSTRUBY) --make="$(MAKE)" $(INSTRUBY_ARGS) --install=bin --install=ext-arch
common.mk:post-install-arch:: post-install-bin post-install-ext-arch
common.mk:install-comm: pre-install-comm do-install-comm post-install-comm
common.mk:pre-install-comm:: pre-install-lib pre-install-ext-comm pre-install-man
common.mk:do-install-comm: $(PREP)
common.mk:	$(INSTRUBY) --make="$(MAKE)" $(INSTRUBY_ARGS) --install=lib --install=ext-comm --install=man
common.mk:post-install-comm:: post-install-lib post-install-ext-comm post-install-man
common.mk:install-bin: pre-install-bin do-install-bin post-install-bin
common.mk:pre-install-bin:: install-prereq
common.mk:do-install-bin: $(PREP)
common.mk:	$(INSTRUBY) --make="$(MAKE)" $(INSTRUBY_ARGS) --install=bin
common.mk:post-install-bin::
common.mk:install-lib: pre-install-lib do-install-lib post-install-lib
common.mk:pre-install-lib:: install-prereq
common.mk:do-install-lib: $(PREP)
common.mk:	$(INSTRUBY) --make="$(MAKE)" $(INSTRUBY_ARGS) --install=lib
common.mk:post-install-lib::
common.mk:install-ext-comm: pre-install-ext-comm do-install-ext-comm post-install-ext-comm
common.mk:pre-install-ext-comm:: install-prereq
common.mk:do-install-ext-comm: $(PREP)
common.mk:	$(INSTRUBY) --make="$(MAKE)" $(INSTRUBY_ARGS) --install=ext-comm
common.mk:post-install-ext-comm::
common.mk:install-ext-arch: pre-install-ext-arch do-install-ext-arch post-install-ext-arch
common.mk:pre-install-ext-arch:: install-prereq
common.mk:do-install-ext-arch: $(PREP)
common.mk:	$(INSTRUBY) --make="$(MAKE)" $(INSTRUBY_ARGS) --install=ext-arch
common.mk:post-install-ext-arch::
common.mk:install-man: pre-install-man do-install-man post-install-man
common.mk:pre-install-man:: install-prereq
common.mk:do-install-man: $(PREP)
common.mk:	$(INSTRUBY) --make="$(MAKE)" $(INSTRUBY_ARGS) --install=man --mantype="$(MANTYPE)"
common.mk:post-install-man::
common.mk:what-where: no-install
common.mk:no-install: no-install-nodoc no-install-doc
common.mk:what-where-all: no-install-all
common.mk:no-install-all: no-install-nodoc
common.mk:what-where-nodoc: no-install-nodoc
common.mk:no-install-nodoc: pre-no-install-nodoc dont-install-nodoc post-no-install-nodoc
common.mk:pre-no-install-nodoc:: pre-no-install-local pre-no-install-ext
common.mk:dont-install-nodoc:  $(PREP)
common.mk:	$(INSTRUBY) -n --make="$(MAKE)" $(INSTRUBY_ARGS) --mantype="$(MANTYPE)"
common.mk:post-no-install-nodoc:: post-no-install-local post-no-install-ext
common.mk:what-where-local: no-install-local
common.mk:no-install-local: pre-no-install-local dont-install-local post-no-install-local
common.mk:pre-no-install-local:: pre-no-install-bin pre-no-install-lib pre-no-install-man
common.mk:dont-install-local: $(PREP)
common.mk:	$(INSTRUBY) -n --make="$(MAKE)" $(INSTRUBY_ARGS) --install=local --mantype="$(MANTYPE)"
common.mk:post-no-install-local:: post-no-install-bin post-no-install-lib post-no-install-man
common.mk:what-where-ext: no-install-ext
common.mk:no-install-ext: pre-no-install-ext dont-install-ext post-no-install-ext
common.mk:pre-no-install-ext:: pre-no-install-ext-arch pre-no-install-ext-comm
common.mk:dont-install-ext: $(PREP)
common.mk:	$(INSTRUBY) -n --make="$(MAKE)" $(INSTRUBY_ARGS) --install=ext
common.mk:post-no-install-ext:: post-no-install-ext-arch post-no-install-ext-comm
common.mk:what-where-arch: no-install-arch
common.mk:no-install-arch: pre-no-install-arch dont-install-arch post-no-install-arch
common.mk:pre-no-install-arch:: pre-no-install-bin pre-no-install-ext-arch
common.mk:dont-install-arch: $(PREP)
common.mk:	$(INSTRUBY) -n --make="$(MAKE)" $(INSTRUBY_ARGS) --install=bin --install=ext-arch
common.mk:post-no-install-arch:: post-no-install-lib post-no-install-man post-no-install-ext-arch
common.mk:what-where-comm: no-install-comm
common.mk:no-install-comm: pre-no-install-comm dont-install-comm post-no-install-comm
common.mk:pre-no-install-comm:: pre-no-install-lib pre-no-install-ext-comm pre-no-install-man
common.mk:dont-install-comm: $(PREP)
common.mk:	$(INSTRUBY) -n --make="$(MAKE)" $(INSTRUBY_ARGS) --install=lib --install=ext-comm --install=man
common.mk:post-no-install-comm:: post-no-install-lib post-no-install-ext-comm post-no-install-man
common.mk:what-where-bin: no-install-bin
common.mk:no-install-bin: pre-no-install-bin dont-install-bin post-no-install-bin
common.mk:pre-no-install-bin:: install-prereq
common.mk:dont-install-bin: $(PREP)
common.mk:	$(INSTRUBY) -n --make="$(MAKE)" $(INSTRUBY_ARGS) --install=bin
common.mk:post-no-install-bin::
common.mk:what-where-lib: no-install-lib
common.mk:no-install-lib: pre-no-install-lib dont-install-lib post-no-install-lib
common.mk:pre-no-install-lib:: install-prereq
common.mk:dont-install-lib: $(PREP)
common.mk:	$(INSTRUBY) -n --make="$(MAKE)" $(INSTRUBY_ARGS) --install=lib
common.mk:post-no-install-lib::
common.mk:what-where-ext-comm: no-install-ext-comm
common.mk:no-install-ext-comm: pre-no-install-ext-comm dont-install-ext-comm post-no-install-ext-comm
common.mk:pre-no-install-ext-comm:: install-prereq
common.mk:dont-install-ext-comm: $(PREP)
common.mk:	$(INSTRUBY) -n --make="$(MAKE)" $(INSTRUBY_ARGS) --install=ext-comm
common.mk:post-no-install-ext-comm::
common.mk:what-where-ext-arch: no-install-ext-arch
common.mk:no-install-ext-arch: pre-no-install-ext-arch dont-install-ext-arch post-no-install-ext-arch
common.mk:pre-no-install-ext-arch:: install-prereq
common.mk:dont-install-ext-arch: $(PREP)
common.mk:	$(INSTRUBY) -n --make="$(MAKE)" $(INSTRUBY_ARGS) --install=ext-arch
common.mk:post-no-install-ext-arch::
common.mk:what-where-man: no-install-man
common.mk:no-install-man: pre-no-install-man dont-install-man post-no-install-man
common.mk:pre-no-install-man:: install-prereq
common.mk:dont-install-man: $(PREP)
common.mk:	$(INSTRUBY) -n --make="$(MAKE)" $(INSTRUBY_ARGS) --install=man --mantype="$(MANTYPE)"
common.mk:post-no-install-man::
common.mk:install-doc: rdoc pre-install-doc do-install-doc post-install-doc
common.mk:pre-install-doc:: install-prereq
common.mk:do-install-doc: $(PROGRAM)
common.mk:	$(INSTRUBY) --make="$(MAKE)" $(INSTRUBY_ARGS) --install=rdoc --rdoc-output="$(RDOCOUT)"
common.mk:post-install-doc::
common.mk:	$(RUNRUBY) "$(srcdir)/bin/rdoc" --all --ri --op "$(RDOCOUT)" "$(srcdir)"
common.mk:what-where-doc: no-install-doc
common.mk:no-install-doc: pre-no-install-doc dont-install-doc post-no-install-doc
common.mk:pre-no-install-doc:: install-prereq
common.mk:dont-install-doc:: $(PREP)
common.mk:	$(INSTRUBY) -n --make="$(MAKE)" $(INSTRUBY_ARGS) --install=rdoc --rdoc-output="$(RDOCOUT)"
common.mk:post-no-install-doc::
common.mk:CLEAR_INSTALLED_LIST = clear-installed-list
common.mk:install-prereq: $(CLEAR_INSTALLED_LIST)
common.mk:clear-installed-list:
common.mk:clean: clean-ext clean-local clean-enc clean-golf clean-rdoc clean-extout
common.mk:clean-local::
common.mk:clean-ext::
common.mk:clean-enc:
common.mk:	@-$(MAKE) -f $(ENC_MK) $(MFLAGS) clean
common.mk:clean-golf:
common.mk:clean-rdoc:
common.mk:clean-extout:
common.mk:	@-$(RMDIRS) $(EXTOUT)/$(arch)
common.mk:distclean: distclean-ext distclean-local distclean-enc distclean-golf distclean-extout
common.mk:distclean-local:: clean-local
common.mk:distclean-ext::
common.mk:distclean-enc: clean-enc
common.mk:	@-$(MAKE) -f $(ENC_MK) $(MFLAGS) distclean
common.mk:distclean-golf: clean-golf
common.mk:distclean-rdoc:
common.mk:distclean-extout: clean-extout
common.mk:	@-$(RMDIRS) $(EXTOUT)
common.mk:realclean:: realclean-ext realclean-local realclean-enc realclean-golf realclean-extout
common.mk:realclean-local:: distclean-local
common.mk:realclean-ext::
common.mk:realclean-enc:: distclean-enc
common.mk:realclean-golf: distclean-golf
common.mk:realclean-extout: distclean-extout
common.mk:check: test test-all
common.mk:	$(BOOTSTRAPRUBY) "$(srcdir)/bootstraptest/runner.rb" --ruby="$(MINIRUBY)" $(OPTS)
common.mk:btest-ruby: miniruby$(EXEEXT) $(RBCONFIG) $(PROGRAM) PHONY
common.mk:	@$(RUNRUBY) "$(srcdir)/bootstraptest/runner.rb" --ruby="$(PROGRAM) -I$(srcdir)/lib" -q $(OPTS)
common.mk:test-sample: miniruby$(EXEEXT) $(RBCONFIG) $(PROGRAM) PHONY
common.mk:test-knownbug: miniruby$(EXEEXT) $(PROGRAM) $(RBCONFIG) PHONY
common.mk:	$(MINIRUBY) "$(srcdir)/bootstraptest/runner.rb" --ruby="$(PROGRAM)" $(OPTS) $(srcdir)/KNOWNBUGS.rb
common.mk:test: test-sample btest-ruby test-knownbug
common.mk:test-all:
common.mk:	$(RUNRUBY) -C "$(EXTCONFDIR)" $(EXTCONF) $(EXTCONFARGS)
common.mk:	@$(MINIRUBY) $(srcdir)/mkconfig.rb -timestamp=$@ \
common.mk:		-install_name=$(RUBY_INSTALL_NAME) \
common.mk:		-so_name=$(RUBY_SO_NAME) rbconfig.rb
common.mk:	$(MAKE) -f $(ENC_MK) RUBY="$(MINIRUBY)" MINIRUBY="$(MINIRUBY)" $(MFLAGS) $@
common.mk:	$(MINIRUBY) $(srcdir)/enc/make_encmake.rb --builtin-encs="$(BUILTIN_ENCOBJS)" --builtin-transes="$(BUILTIN_TRANSOBJS)" $@ $(ENCS)
common.mk:.PHONY: test install install-nodoc install-doc dist
common.mk:	$(YACC) -d $(YFLAGS) -o y.tab.c $(<:\=/)
common.mk:	sed -f $(srcdir)/tool/ytab.sed -e "/^#/s!y\.tab\.c!$@!" y.tab.c > $@.new
common.mk:	sed -e "/^#line.*y\.tab\.h/d;/^#line.*parse\.y/d" y.tab.h > $(@:.c=.h).new
common.mk:	$(CC) $(CFLAGS) -c $<
common.mk:# when I use -I., there is confliction at "OpenFile" 
common.mk:newline.c: $(srcdir)/enc/trans/newline.trans $(srcdir)/tool/transcode-tblgen.rb
common.mk:INSNS2VMOPT = --srcdir="$(srcdir)"
common.mk:srcs: {$(VPATH)}parse.c {$(VPATH)}lex.c {$(VPATH)}newline.c $(srcdir)/ext/ripper/ripper.c srcs-enc
common.mk:srcs-enc: $(ENC_MK)
common.mk:	$(MAKE) -f $(ENC_MK) RUBY="$(MINIRUBY)" MINIRUBY="$(MINIRUBY)" $(MFLAGS) srcs
common.mk:	$(MINIRUBY) $(srcdir)/tool/generic_erb.rb -c -o $@ $(srcdir)/template/encdb.h.tmpl $(srcdir)/enc enc
common.mk:transdb.h: $(PREP) srcs-enc $(srcdir)/tool/generic_erb.rb $(srcdir)/template/transdb.h.tmpl
common.mk:	$(MINIRUBY) $(srcdir)/tool/generic_erb.rb -c -o $@ $(srcdir)/template/transdb.h.tmpl $(srcdir)/enc/trans enc/trans
common.mk:# 	$(BASERUBY) $(srcdir)/tool/generic_erb.rb --if-change --output=$@ \
common.mk:# 		$(srcdir)/template/id.h.tmpl --vpath=$(VPATH) parse.h
common.mk:	@-$(BASERUBY) $(srcdir)/tool/file2lastrev.rb --revision.h "$(@D)" > "$@.tmp"
common.mk:	cd $(srcdir)/ext/ripper && $(exec) $(MAKE) -f depend $(MFLAGS) top_srcdir=../.. srcdir=.
common.mk:	$(BASERUBY) $(srcdir)/benchmark/driver.rb -v \
common.mk:	            --executables="$(COMPARE_RUBY); $(RUNRUBY)" \
common.mk:	            --pattern='bm_' --directory=$(srcdir)/benchmark $(OPTS)
common.mk:benchmark-each: $(PROGRAM) PHONY
common.mk:	$(BASERUBY) $(srcdir)/benchmark/driver.rb -v \
common.mk:	            --executables="$(COMPARE_RUBY); $(RUNRUBY)" \
common.mk:	            --pattern=$(ITEM) --directory=$(srcdir)/benchmark $(OPTS)
common.mk:	$(BASERUBY) $(srcdir)/benchmark/driver.rb -v \
common.mk:	            --executables="$(COMPARE_RUBY); $(RUNRUBY)" \
common.mk:	            --pattern='bmx_' --directory=$(srcdir)/benchmark $(OPTS)
common.mk:	gdb -x run.gdb --quiet --args $(MINIRUBY) $(TESTRUN_SCRIPT)
common.mk:gdb-ruby: $(PROGRAM) run.gdb PHONY
common.mk:	gdb -x run.gdb --quiet --args $(PROGRAM) $(TESTRUN_SCRIPT)
common.mk:	$(BASERUBY) $(srcdir)/tool/make-snapshot tmp $(RELNAME)
common.mk:	-@$(MAKE) $(MFLAGS) REVISION_FORCE=PHONY "$(srcdir)/revision.h"
common.mk:	@echo "  gdb-ruby:        runs test.rb by ruby under gdb"
common.mk:	@echo "  check:           equals make test test-all"
common.mk:	@echo "  test-all:        all ruby tests"
common.mk:	@echo "  test-rubyspec    run RubySpec test suite"
common.mk:	@echo "  update-rubyspec  update local copy of RubySpec"
common.mk:	@echo "  install-nodoc:   install without rdoc"
common.mk:	@echo "  http://redmine.ruby-lang.org/wiki/ruby/DeveloperHowto"
compar.c:  compar.c -
compar.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
compar.c: *  call-seq:
compar.c: *  call-seq:
compar.c: *  call-seq:
compar.c: *  call-seq:
compar.c: *  method, returning true if it returns -1.
compar.c: *  call-seq:
compar.c: *  method, returning true if it returns -1 or 0.
compar.c: *  call-seq:
compar.c: *  which compares the receiver against another object, returning -1, 0,
ãã¤ããªã¼ã»ãã¡ã¤ã«compar.oã¯ä¸è´ãã¾ãã
compile.c:  compile.c - ruby node tree -> VM instruction sequence
compile.c:  Copyright (C) 2004-2007 Koichi Sasada
compile.c:#define compile_debug iseq->compile_data->option->debug_level
compile.c:#define debug_node_end()  gl_node_level --;
compile.c:  (((rb_iseq_t*)DATA_PTR(iseq))->filename)
compile.c:  new_child_iseq(iseq, node, name, iseq->self, type)
compile.c:  new_child_iseq(iseq, iseq->node, iseq->name, iseq->parent_iseq, iseq->type, sym)
compile.c:      if ((event) == RUBY_EVENT_LINE && iseq->coverage && \
compile.c:	  RARRAY_PTR(iseq->coverage)[(line) - 1] == Qnil) { \
compile.c:	  RARRAY_PTR(iseq->coverage)[(line) - 1] = INT2FIX(0); \
compile.c:      if (iseq->compile_data->option->trace_instruction) { \
compile.c:  ADD_ELEM(seq, (LINK_ELEMENT *) new_adjust_body(iseq, label, -1))
compile.c:    (rb_ary_push(iseq->compile_data->catch_table_ary,		\
compile.c:  (((INSN*)(insn))->operands[idx])
compile.c:  (((INSN*)(insn))->insn_id)
compile.c:  VALUE tmp = GET_THREAD()->errinfo;               \
compile.c:  GET_THREAD()->errinfo = iseq->compile_data->err_info;  \
compile.c:  iseq->compile_data->err_info = GET_THREAD()->errinfo; \
compile.c:  GET_THREAD()->errinfo = tmp;                     \
compile.c:#define hide_obj(obj) do {OBJ_FREEZE(obj); RBASIC(obj)->klass = 0;} while (0)
compile.c:#define gl_node_level iseq->compile_data->node_level
compile.c:    list = anchor->anchor.next;
compile.c:    plist = &anchor->anchor;
compile.c:	if (plist != list->prev) {
compile.c:	list = list->next;
compile.c:    if (anchor->last != plist && anchor->last != 0) {
compile.c:    elem->prev = anchor->last;
compile.c:    anchor->last->next = elem;
compile.c:    anchor->last = elem;
compile.c:	rb_ary_push(iseq->mark_ary, v);
compile.c:#define ruby_sourcefile		RSTRING_PTR(iseq->filename)
compile.c:	rb_ary_push(iseq->compile_data->mark_ary, v);
compile.c:	iseq_set_local_table(iseq, node->nd_tbl);
compile.c:	iseq_set_arguments(iseq, ret, node->nd_args);
compile.c:	switch (iseq->type) {
compile.c:	    LABEL *start = iseq->compile_data->start_label = NEW_LABEL(0);
compile.c:	    LABEL *end = iseq->compile_data->end_label = NEW_LABEL(0);
compile.c:	    COMPILE(ret, "block body", node->nd_body);
compile.c:	    COMPILE(ret, "scoped node", node->nd_body);
compile.c:	    COMPILE(ret, "scoped node", node->nd_body);
compile.c:	    COMPILE(ret, "scoped node", node->nd_body);
compile.c:	switch (iseq->type) {
compile.c:    if (iseq->type == ISEQ_TYPE_RESCUE || iseq->type == ISEQ_TYPE_ENSURE) {
compile.c:	ADD_INSN(ret, iseq->compile_data->last_line, leave);
compile.c:    iseq->iseq_encoded = ALLOC_N(VALUE, iseq->iseq_size);
compile.c:    MEMCPY(iseq->iseq_encoded, iseq->iseq, VALUE, iseq->iseq_size);
compile.c:    for (i = 0; i < iseq->iseq_size; /* */ ) {
compile.c:	int insn = iseq->iseq_encoded[i];
compile.c:	iseq->iseq_encoded[i] = (VALUE)table[insn];
compile.c:    iseq->iseq_encoded = iseq->iseq;
compile.c:	iseq->compile_data->storage_current;
compile.c:    if (storage->pos + size > storage->size) {
compile.c:	unsigned long alloc_size = storage->size * 2;
compile.c:	storage->next = (void *)ALLOC_N(char, alloc_size +
compile.c:	storage = iseq->compile_data->storage_current = storage->next;
compile.c:	storage->next = 0;
compile.c:	storage->pos = 0;
compile.c:	storage->size = alloc_size;
compile.c:	storage->buff = (char *)(&storage->buff + 1);
compile.c:    ptr = (void *)&storage->buff[storage->pos];
compile.c:    storage->pos += size;
compile.c:    elem2->next = elem1->next;
compile.c:    elem2->prev = elem1;
compile.c:    elem1->next = elem2;
compile.c:    if (elem2->next) {
compile.c:	elem2->next->prev = elem2;
compile.c:    elem2->prev = elem1->prev;
compile.c:    elem2->next = elem1;
compile.c:    elem1->prev = elem2;
compile.c:    if (elem2->prev) {
compile.c:	elem2->prev->next = elem2;
compile.c:    elem2->prev = elem1->prev;
compile.c:    elem2->next = elem1->next;
compile.c:    if (elem1->prev) {
compile.c:	elem1->prev->next = elem2;
compile.c:    if (elem1->next) {
compile.c:	elem1->next->prev = elem2;
compile.c:    elem->prev->next = elem->next;
compile.c:    if (elem->next) {
compile.c:	elem->next->prev = elem->prev;
compile.c:    return anchor->anchor.next;
compile.c:  return anchor->last;
compile.c:    LINK_ELEMENT *elem = anchor->last;
compile.c:    anchor->last = anchor->last->prev;
compile.c:    anchor->last->next = 0;
compile.c:    LINK_ELEMENT *elem = anchor->anchor.next;
compile.c:	anchor->anchor.next = elem->next;
compile.c:    LINK_ELEMENT *elem = anchor->anchor.next;
compile.c:	elem = elem->next;
compile.c:    if (anchor->anchor.next == 0) {
compile.c:    if (anc2->anchor.next) {
compile.c:	anc1->last->next = anc2->anchor.next;
compile.c:	anc2->anchor.next->prev = anc1->last;
compile.c:	anc1->last = anc2->last;
compile.c:    if (anc2->anchor.next) {
compile.c:	LINK_ELEMENT *first = anc1->anchor.next;
compile.c:	anc1->anchor.next = anc2->anchor.next;
compile.c:	anc1->anchor.next->prev = &anc1->anchor;
compile.c:	anc2->last->next = first;
compile.c:	    first->prev = anc2->last;
compile.c:	    anc1->last = anc2->last;
compile.c:    first = &anc->anchor;
compile.c:    elem = first->next;
compile.c:    last = anc->last;
compile.c:	anc->anchor.next = last;
compile.c:	anc->last = elem;
compile.c:	e = elem->next;
compile.c:	elem->next = elem->prev;
compile.c:	elem->prev = e;
compile.c:    first->next = last;
compile.c:    last->prev = first;
compile.c:    anc->last->next = 0;
compile.c:    printf("----\n");
compile.c:    printf("anch: %p, frst: %p, last: %p\n", &anchor->anchor,
compile.c:	   anchor->anchor.next, anchor->last);
compile.c:	printf("curr: %p, next: %p, prev: %p, type: %d\n", list, list->next,
compile.c:	       list->prev, FIX2INT(list->type));
compile.c:	list = list->next;
compile.c:    printf("----\n");
compile.c:    dump_disasm_list(anchor->anchor.next);
compile.c:    labelobj->link.type = ISEQ_ELEMENT_LABEL;
compile.c:    labelobj->link.next = 0;
compile.c:    labelobj->label_no = iseq->compile_data->label_no++;
compile.c:    labelobj->sc_state = 0;
compile.c:    labelobj->sp = -1;
compile.c:    adjust->link.type = ISEQ_ELEMENT_ADJUST;
compile.c:    adjust->link.next = 0;
compile.c:    adjust->label = label;
compile.c:    adjust->line_no = line;
compile.c:    iobj->link.type = ISEQ_ELEMENT_INSN;
compile.c:    iobj->link.next = 0;
compile.c:    iobj->insn_id = insn_id;
compile.c:    iobj->line_no = line_no;
compile.c:    iobj->operands = argv;
compile.c:    iobj->operand_size = argc;
compile.c:    iobj->sc_state = 0;
compile.c:    debugs("[new_child_iseq]> ---------------------------------------\n");
compile.c:    ret = rb_iseq_new_with_opt(node, name, iseq_filename(iseq->self),
compile.c:			       parent, type, iseq->compile_data->option);
compile.c:    debugs("[new_child_iseq]< ---------------------------------------\n");
compile.c:    if (iseq->compile_data->option->instructions_unification) {
compile.c:    if (iseq->compile_data->option->stack_caching) {
compile.c:	VALUE str = rb_iseq_disasm(iseq->self);
compile.c:    iseq->local_table = (ID *)ALLOC_N(ID *, 1);
compile.c:    iseq->local_table_size = 1;
compile.c:    iseq->local_size = iseq->local_table_size + 1;
compile.c:    iseq->local_table[0] = id_dollar_bang;
compile.c:    for (i = 0; i < iseq->local_table_size; i++) {
compile.c:	if (iseq->local_table[i] == id) {
compile.c:    return -1;
compile.c:    int idx = get_dyna_var_idx_at_raw(iseq->local_iseq, id);
compile.c:    int lv = 0, idx = -1;
compile.c:	iseq = iseq->parent_iseq;
compile.c:	rb_bug("get_dyna_var_idx: -1");
compile.c:    *ls = iseq->local_size;
compile.c:	NODE *node_aux = node_args->nd_next;
compile.c:	NODE *node_opt = node_args->nd_opt;
compile.c:         *   NODE_ARGS     [m: int,  o: NODE_OPT_ARG, ->]
compile.c:         *   NODE_ARGS_AUX [r: ID,   b: ID,           ->]
compile.c:         *   NODE_OPT_ARGS [idx,     expr,            next ->]
compile.c:	iseq->argc = node_args->nd_frml;
compile.c:	debugs("  - argc: %d\n", iseq->argc);
compile.c:	    rest_id = node_aux->nd_rest;
compile.c:	    block_id = (ID)node_aux->nd_body;
compile.c:	    node_aux = node_aux->nd_next;
compile.c:		ID post_start_id = node_aux->nd_pid;
compile.c:		iseq->arg_post_start = get_dyna_var_idx_at_raw(iseq, post_start_id);
compile.c:		iseq->arg_post_len = node_aux->nd_plen;
compile.c:		node_init = node_aux->nd_next;
compile.c:		COMPILE_POPED(optargs, "optarg", node->nd_body);
compile.c:		node = node->nd_next;
compile.c:	    iseq->arg_opts = i;
compile.c:	    iseq->arg_opt_table = ALLOC_N(VALUE, i);
compile.c:	    MEMCPY(iseq->arg_opt_table, RARRAY_PTR(labels), VALUE, i);
compile.c:		iseq->arg_opt_table[j] &= ~1;
compile.c:	    iseq->arg_opts = 0;
compile.c:	    if (node_init->nd_1st) { /* m_init */
compile.c:		COMPILE_POPED(optargs, "init arguments (m)", node_init->nd_1st);
compile.c:	    if (node_init->nd_2nd) { /* p_init */
compile.c:		COMPILE_POPED(optargs, "init arguments (p)", node_init->nd_2nd);
compile.c:	    iseq->arg_rest = get_dyna_var_idx_at_raw(iseq, rest_id);
compile.c:	    if (iseq->arg_rest == -1) {
compile.c:		rb_bug("arg_rest: -1");
compile.c:	    if (iseq->arg_post_start == 0) {
compile.c:		iseq->arg_post_start = iseq->arg_rest + 1;
compile.c:	    iseq->arg_block = get_dyna_var_idx_at_raw(iseq, block_id);
compile.c:	if (iseq->arg_opts != 0 || iseq->arg_post_len != 0 ||
compile.c:	    iseq->arg_rest != -1 || iseq->arg_block != -1) {
compile.c:	    iseq->arg_simple = 0;
compile.c:	    if (iseq->arg_block != -1) {
compile.c:		iseq->arg_size = iseq->arg_block + 1;
compile.c:	    else if (iseq->arg_post_len) {
compile.c:		iseq->arg_size = iseq->arg_post_start + iseq->arg_post_len;
compile.c:	    else if (iseq->arg_rest != -1) {
compile.c:		iseq->arg_size = iseq->arg_rest + 1;
compile.c:	    else if (iseq->arg_opts) {
compile.c:		iseq->arg_size = iseq->argc + iseq->arg_opts - 1;
compile.c:		iseq->arg_size = iseq->argc;
compile.c:	    iseq->arg_simple = 1;
compile.c:	    iseq->arg_size = iseq->argc;
compile.c:	if (iseq->type == ISEQ_TYPE_BLOCK) {
compile.c:	    if (iseq->arg_opts == 0 && iseq->arg_post_len == 0 && iseq->arg_rest == -1) {
compile.c:		if (iseq->argc == 1 && last_comma == 0) {
compile.c:		    iseq->arg_simple |= 0x02;
compile.c:	iseq->arg_simple = 1;
compile.c:	iseq->local_table = (ID *)ALLOC_N(ID *, size);
compile.c:	MEMCPY(iseq->local_table, tbl, ID *, size);
compile.c:    iseq->local_size = iseq->local_table_size = size;
compile.c:    iseq->local_size += 1;
compile.c:	  dfp[-1]: svar
compile.c:          dfp[-1]: cref
compile.c:    debugs("iseq_set_local_table: %d, %d\n", iseq->local_size, iseq->local_table_size);
compile.c:	return -1;
compile.c:  ruby insn object array -> raw instruction sequence
compile.c:	switch (list->type) {
compile.c:		line = iobj->line_no;
compile.c:		lobj->position = pos;
compile.c:		lobj->set = Qtrue;
compile.c:		if (adjust->line_no != -1) {
compile.c:	    rb_compile_error(RSTRING_PTR(iseq->filename), line,
compile.c:	list = list->next;
compile.c:	switch (list->type) {
compile.c:		/* fprintf(stderr, "insn: %-16s, sp: %d\n", insn_name(iobj->insn_id), sp); */
compile.c:		operands = iobj->operands;
compile.c:		insn = iobj->insn_id;
compile.c:		if (iobj->operand_size != len - 1) {
compile.c:		    rb_compile_error(RSTRING_PTR(iseq->filename), iobj->line_no,
compile.c:				     iobj->operand_size, len - 1);
compile.c:		    /* printf("--> [%c - (%d-%d)]\n", type, k, j); */
compile.c:			    if (lobj->set != Qtrue) {
compile.c:				rb_compile_error(RSTRING_PTR(iseq->filename), iobj->line_no,
compile.c:			    if (lobj->sp == -1) {
compile.c:				lobj->sp = sp;
compile.c:				lobj->position - (pos + len);
compile.c:			    RHASH_TBL(map)->type = &cdhash_type;
compile.c:				if (lobj->set != Qtrue) {
compile.c:				    rb_compile_error(RSTRING_PTR(iseq->filename), iobj->line_no,
compile.c:				    rb_hash_aset(map, obj, INT2FIX(lobj->position - (pos+len)));
compile.c:				    rb_compile_warning(RSTRING_PTR(iseq->filename), iobj->line_no,
compile.c:			rb_compile_error(RSTRING_PTR(iseq->filename), iobj->line_no,
compile.c:		insn_info_table[k].line_no = iobj->line_no;
compile.c:		if (lobj->sp == -1) {
compile.c:		    lobj->sp = sp;
compile.c:		    sp = lobj->sp;
compile.c:		if (adjust->label) {
compile.c:		    sp = adjust->label->sp;
compile.c:		if (adjust->line_no != -1) {
compile.c:		    if (orig_sp - sp > 0) {
compile.c:			insn_info_table[k].line_no = adjust->line_no;
compile.c:			generated_iseq[pos++] = orig_sp - sp;
compile.c:		    else if (orig_sp - sp == 0) {
compile.c:			insn_info_table[k].line_no = adjust->line_no;
compile.c:	list = list->next;
compile.c:	rb_bug("SP is not 0 on %s (%d)\n", RSTRING_PTR(iseq->name), sp);
compile.c:    iseq->iseq = (void *)generated_iseq;
compile.c:    iseq->iseq_size = pos;
compile.c:    iseq->insn_info_table = insn_info_table;
compile.c:    iseq->insn_info_size = k;
compile.c:    iseq->stack_max = stack_max;
compile.c:    return lobj->position;
compile.c:    return lobj->sp;
compile.c:    tlen = RARRAY_LEN(iseq->compile_data->catch_table_ary);
compile.c:    tptr = RARRAY_PTR(iseq->compile_data->catch_table_ary);
compile.c:    iseq->catch_table = tlen ? ALLOC_N(struct iseq_catch_table_entry, tlen) : 0;
compile.c:    iseq->catch_table_size = tlen;
compile.c:	entry = &iseq->catch_table[i];
compile.c:	entry->type = ptr[0] & 0xffff;
compile.c:	entry->start = label_get_position((LABEL *)(ptr[1] & ~1));
compile.c:	entry->end = label_get_position((LABEL *)(ptr[2] & ~1));
compile.c:	entry->iseq = ptr[3];
compile.c:	if (entry->iseq != 0) {
compile.c:	    iseq_add_mark_object(iseq, entry->iseq);
compile.c:	    entry->cont = label_get_position(lobj);
compile.c:	    entry->sp = label_get_sp(lobj);
compile.c:	    if (entry->type == CATCH_TYPE_RESCUE ||
compile.c:		entry->type == CATCH_TYPE_BREAK ||
compile.c:		entry->type == CATCH_TYPE_NEXT) {
compile.c:		entry->sp--;
compile.c:	    entry->cont = 0;
compile.c:    iseq->compile_data->catch_table_ary = 0;	/* free */
compile.c:    if (iseq->arg_opts != 0) {
compile.c:	for (i = 0; i < iseq->arg_opts; i++) {
compile.c:	    iseq->arg_opt_table[i] =
compile.c:		label_get_position((LABEL *)iseq->arg_opt_table[i]);
compile.c:    list = lobj->link.next;
compile.c:	if (list->type == ISEQ_ELEMENT_INSN || list->type == ISEQ_ELEMENT_ADJUST) {
compile.c:	list = list->next;
compile.c:    LINK_ELEMENT *list = iobj->link.next;
compile.c:	if (list->type == ISEQ_ELEMENT_INSN || list->type == ISEQ_ELEMENT_ADJUST) {
compile.c:	list = list->next;
compile.c:    LINK_ELEMENT *list = iobj->link.prev;
compile.c:	if (list->type == ISEQ_ELEMENT_INSN || list->type == ISEQ_ELEMENT_ADJUST) {
compile.c:	list = list->prev;
compile.c:    if (iobj->insn_id == BIN(jump)) {
compile.c:	    REMOVE_ELEM(&iobj->link);
compile.c:	else if (iobj != diobj && diobj->insn_id == BIN(jump)) {
compile.c:	else if (diobj->insn_id == BIN(leave)) {
compile.c:	    INSN *eiobj = new_insn_core(iseq, iobj->line_no, BIN(leave),
compile.c:					diobj->operand_size, diobj->operands);
compile.c:	    INSN *popiobj = new_insn_core(iseq, iobj->line_no,
compile.c:		 (piobj->insn_id == BIN(branchif) ||
compile.c:		  piobj->insn_id == BIN(branchunless))) {
compile.c:		piobj->insn_id = (piobj->insn_id == BIN(branchif))
compile.c:		REMOVE_ELEM(&iobj->link);
compile.c:    if (iobj->insn_id == BIN(branchif) ||
compile.c:	iobj->insn_id == BIN(branchunless)) {
compile.c:	if (nobj->insn_id == BIN(jump)) {
compile.c:    if (do_tailcallopt && iobj->insn_id == BIN(leave)) {
compile.c:	if (piobj->insn_id == BIN(send) &&
compile.c:	    piobj->operands[2] == 0 /* block */
compile.c:	    piobj->operands[3] = INT2FIX(FIX2INT(piobj->operands[3]) | VM_CALL_TAILCALL_BIT);
compile.c:    iobj->insn_id = insn_id;
compile.c:    iobj->operand_size = 0;
compile.c:    iobj->insn_id = insn_id;
compile.c:    iobj->operand_size = n;
compile.c:	iobj->operands[i] = Qnil;
compile.c:    if (iobj->insn_id == BIN(send)) {
compile.c:    const int do_peepholeopt = iseq->compile_data->option->peephole_optimization;
compile.c:    const int do_tailcallopt = iseq->compile_data->option->tailcall_optimization;
compile.c:    const int do_si = iseq->compile_data->option->specialized_instruction;
compile.c:    const int do_ou = iseq->compile_data->option->operands_unification;
compile.c:	if (list->type == ISEQ_ELEMENT_INSN) {
compile.c:	list = list->next;
compile.c:	argc += iobj->operand_size;
compile.c:	list = list->next;
compile.c:	MEMCPY(ptr, iobj->operands, VALUE, iobj->operand_size);
compile.c:	ptr += iobj->operand_size;
compile.c:	list = list->next;
compile.c:    return new_insn_core(iseq, iobj->line_no, insn_id, argc, operands);
compile.c:	if (list->type == ISEQ_ELEMENT_INSN) {
compile.c:	    id = iobj->insn_id;
compile.c:		    LINK_ELEMENT *li = list->next;
compile.c:			if (li->type != ISEQ_ELEMENT_INSN ||
compile.c:			    ((INSN *)li)->insn_id != unified[k]) {
compile.c:			li = li->next;
compile.c:			new_unified_insn(iseq, unified[0], unified[1] - 1,
compile.c:		    niobj->link.prev = (LINK_ELEMENT *)iobj->link.prev;
compile.c:		    niobj->link.next = li;
compile.c:			li->prev = (LINK_ELEMENT *)niobj;
compile.c:		    list->prev->next = (LINK_ELEMENT *)niobj;
compile.c:	list = list->next;
compile.c:    insn_id = iobj->insn_id;
compile.c:    iobj->insn_id = SC_INSN(insn_id, state);
compile.c:    nstate = SC_NEXT(iobj->insn_id);
compile.c:	if (lobj->sc_state != 0) {
compile.c:	    if (lobj->sc_state != nstate) {
compile.c:		printf("\n-- %d, %d\n", lobj->sc_state, nstate);
compile.c:		rb_compile_error(RSTRING_PTR(iseq->filename), iobj->line_no,
compile.c:	    lobj->sc_state = nstate;
compile.c:    if (lobj->sc_state != 0) {
compile.c:	if (lobj->sc_state != state) {
compile.c:	    state = lobj->sc_state;
compile.c:	lobj->sc_state = state;
compile.c:	switch (list->type) {
compile.c:		insn_id = iobj->insn_id;
compile.c:			    list = list->next;
compile.c:			    rb_compile_error(RSTRING_PTR(iseq->filename), iobj->line_no,
compile.c:			list = list->next;
compile.c:	list = list->next;
compile.c:    NODE *list = node->nd_next;
compile.c:    VALUE lit = node->nd_lit;
compile.c:    ADD_INSN1(ret, nd_line(node), putobject, node->nd_lit);
compile.c:	COMPILE(ret, "each string", list->nd_head);
compile.c:	list = list->nd_next;
compile.c:    ADD_INSN2(ret, nd_line(node), toregexp, INT2FIX(node->nd_cflag), INT2FIX(cnt));
compile.c:	    compile_branch_condition(iseq, ret, cond->nd_1st, label,
compile.c:	    compile_branch_condition(iseq, ret, cond->nd_2nd, then_label,
compile.c:	    compile_branch_condition(iseq, ret, cond->nd_1st, then_label,
compile.c:	    compile_branch_condition(iseq, ret, cond->nd_2nd, then_label,
compile.c:  //unsigned long flag=n->flags;
compile.c:  switch(nd_type(n)-1){
compile.c:     n->u1.value = ID2SYM(n->nd_mid);
compile.c:    n->u1.value = ID2SYM(n->nd_vid);
compile.c:  n->flags = 0;
compile.c:  n->flags |= T_NODE;
compile.c:    n->u1.value = ID2SYM(n->nd_mid);
compile.c:    printf("id: %s\n", rb_id2name(n->nd_mid));
compile.c:    n->u1.value = ID2SYM(n->nd_vid);
compile.c:  n->u2.value = 0;
compile.c:  n->u3.value = 0;
compile.c:    int len = node->nd_alen, line = nd_line(node), i=0;
compile.c:	   switch(nd_type(node->nd_head)-1){
compile.c:	      var2sym(node->nd_head);
compile.c:	      COMPILE_(anchor, "array element", node->nd_head, poped);
compile.c:	    /*if(nd_type(node->nd_head)-1==NODE_LVAR){
compile.c:	      //printf("id: %s\n", rb_id2name(node->nd_head->nd_vid));
compile.c:	      var2sym(node->nd_head);
compile.c:	      //ADD_INSN1(anchor, nd_line(node->nd_head), putobject, ID2SYM(node->nd_head->nd_vid));
compile.c:	      COMPILE_(anchor, "array element", node->nd_head, poped);
compile.c:	      COMPILE_(anchor, "array element", node->nd_head, poped);
compile.c:	    if (opt_p && nd_type(node->nd_head) != NODE_LIT) {
compile.c:	    node = node->nd_next;
compile.c:	    rb_bug("node error: compile_array (%d: %d-%d)",
compile.c:		rb_ary_push(ary, node->nd_head->nd_lit);
compile.c:		node = node->nd_next;
compile.c:    int len = node->nd_alen, line = nd_line(node), i=0;
compile.c:	    if (opt_p && nd_type(node->nd_head) != NODE_LIT) {
compile.c:	    COMPILE_(anchor, "array element", node->nd_head, poped);
compile.c:	    node = node->nd_next;
compile.c:	    rb_bug("node error: compile_array (%d: %d-%d)",
compile.c:		rb_ary_push(ary, node->nd_head->nd_lit);
compile.c:		node = node->nd_next;
compile.c:	VALUE v = node->nd_lit;
compile.c:	return node->nd_lit;
compile.c:	val = vals->nd_head;
compile.c:	ADD_SEND(cond_seq, nd_line(val), ID2SYM(rb_intern("patern-match")), INT2FIX(1));
compile.c:	vals = vals->nd_next;
compile.c:	val = vals->nd_head;
compile.c:	vals = vals->nd_next;
compile.c:	dupidx = iobj->operands[1];
compile.c:	iobj->operands[1] = dupidx;
compile.c:	compile_massign_opt_lhs(iseq, ret, lhsn->nd_next);
compile.c:	compile_massign_lhs(iseq, ret, lhsn->nd_head);
compile.c:	NODE *ln = lhsn->nd_head;
compile.c:	    MEMORY(ln->nd_vid);
compile.c:	    MEMORY(ln->nd_vid);
compile.c:	lhsn = lhsn->nd_next;
compile.c:	    COMPILE_POPED(ret, "masgn val (poped)", rhsn->nd_head);
compile.c:	    COMPILE(ret, "masgn val", rhsn->nd_head);
compile.c:	rhsn = rhsn->nd_next;
compile.c:	for (i=0; i<llen-rlen; i++) {
compile.c:    NODE *rhsn = node->nd_value;
compile.c:    NODE *splatn = node->nd_args;
compile.c:    NODE *lhsn = node->nd_head;
compile.c:    int lhs_splat = (splatn && (VALUE)splatn != (VALUE)-1) ? 1 : 0;
compile.c:	    compile_massign_lhs(iseq, lhsseq, lhsn->nd_head);
compile.c:	    lhsn = lhsn->nd_next;
compile.c:		NODE *postn = splatn->nd_2nd;
compile.c:		NODE *restn = splatn->nd_1st;
compile.c:		int num = postn->nd_alen;
compile.c:		int flag = 0x02 | (((VALUE)restn == (VALUE)-1) ? 0x00 : 0x01);
compile.c:		if ((VALUE)restn != (VALUE)-1) {
compile.c:		    compile_massign_lhs(iseq, ret, postn->nd_head);
compile.c:		    postn = postn->nd_next;
compile.c:	debugi("compile_colon2 - colon", node->nd_vid);
compile.c:	ADD_INSN1(body, nd_line(node), getconstant, ID2SYM(node->nd_vid));
compile.c:	debugi("compile_colon2 - colon3", node->nd_mid);
compile.c:	ADD_INSN1(body, nd_line(node), getconstant, ID2SYM(node->nd_mid));
compile.c:	compile_colon2(iseq, node->nd_head, pref, body);
compile.c:	debugi("compile_colon2 - colon2", node->nd_mid);
compile.c:	ADD_INSN1(body, nd_line(node), getconstant, ID2SYM(node->nd_mid));
compile.c:    else if (cpath->nd_head) {
compile.c:	COMPILE(ret, "nd_else->nd_head", cpath->nd_head);
compile.c:	    defined_expr(iseq, ret, vals->nd_head, lfinish, Qfalse);
compile.c:	} while ((vals = vals->nd_next) != NULL);
compile.c:	estr = "local-variable";
compile.c:		  ID2SYM(node->nd_vid), needstr);
compile.c:		  ((VALUE)node->nd_entry) | 1, needstr);
compile.c:		  ID2SYM(node->nd_vid), needstr);
compile.c:		  ID2SYM(node->nd_vid), needstr);
compile.c:	defined_expr(iseq, ret, node->nd_head, lfinish, Qfalse);
compile.c:	if (rb_is_const_id(node->nd_mid)) {
compile.c:	    COMPILE(ret, "defined/colon2#nd_head", node->nd_head);
compile.c:		      ID2SYM(node->nd_mid), needstr);
compile.c:	    COMPILE(ret, "defined/colon2#nd_head", node->nd_head);
compile.c:		      ID2SYM(node->nd_mid), needstr);
compile.c:		  INT2FIX(DEFINED_CONST), ID2SYM(node->nd_mid), needstr);
compile.c:	    if (node->nd_recv == (NODE *)1) break;
compile.c:	if (node->nd_args) {
compile.c:	    defined_expr(iseq, ret, node->nd_args, lfinish, Qfalse);
compile.c:							   iseq->name),
compile.c:	    defined_expr(iseq, ret, node->nd_recv, lfinish, Qfalse);
compile.c:	    COMPILE(ret, "defined/recv", node->nd_recv);
compile.c:		      ID2SYM(node->nd_mid), needstr);
compile.c:		      ID2SYM(node->nd_mid), needstr);
compile.c:		  INT2FIX((node->nd_nth << 1) | (type == NODE_BACK_REF)),
compile.c:    if (iseq->parent_iseq != 0) {
compile.c:	while (ip->local_iseq != ip) {
compile.c:	    if (ip->type == ISEQ_TYPE_BLOCK) {
compile.c:	    ip = ip->parent_iseq;
compile.c:	return rb_sprintf("block in %s", RSTRING_PTR(ip->name));
compile.c:	return rb_sprintf("block (%d levels) in %s", level, RSTRING_PTR(ip->name));
compile.c:    enl->ensure_node = node;
compile.c:    enl->prev = iseq->compile_data->ensure_node_stack;	/* prev */
compile.c:    enl->erange = er;
compile.c:    iseq->compile_data->ensure_node_stack = enl;
compile.c:    while (erange->next != 0) {
compile.c:	erange = erange->next;
compile.c:    ne->next = 0;
compile.c:    ne->begin = lend;
compile.c:    ne->end = erange->end;
compile.c:    erange->end = lstart;
compile.c:    erange->next = ne;
compile.c:	iseq->compile_data->ensure_node_stack;
compile.c:	if (enlp->erange != 0) {
compile.c:	    add_ensure_range(iseq, enlp->erange, lstart, lend);
compile.c:	    iseq->compile_data->ensure_node_stack = enlp->prev;
compile.c:	    COMPILE_POPED(ensure_part, "ensure part", enlp->ensure_node);
compile.c:	enlp = enlp->prev;
compile.c:    iseq->compile_data->ensure_node_stack = prev_enlp;
compile.c:	COMPILE(arg_block, "block", argn->nd_body);
compile.c:	argn = argn->nd_head;
compile.c:	    COMPILE(args, "args (splat)", argn->nd_head);
compile.c:	    int next_is_array = (nd_type(argn->nd_head) == NODE_ARRAY);
compile.c:	    COMPILE(tmp, "args (cat: splat)", argn->nd_body);
compile.c:		argc = INT2FIX(compile_array(iseq, args, argn->nd_head, Qfalse) + 1);
compile.c:		argn = argn->nd_head;
compile.c:	    ADD_INSN(ret, iseq->compile_data->last_line, putnil);
compile.c:    iseq->compile_data->last_line = nd_line(node);
compile.c:    if (node->flags & NODE_FL_NEWLINE) {
compile.c:	    COMPILE_(ret, "BLOCK body", node->nd_head,
compile.c:		     (node->nd_next == 0 && poped == 0) ? 0 : 1);
compile.c:	    node = node->nd_next;
compile.c:	    COMPILE_(ret, "BLOCK next", node->nd_next, poped);
compile.c:	compile_branch_condition(iseq, cond_seq, node->nd_cond,
compile.c:	COMPILE_(then_seq, "then", node->nd_body, poped);
compile.c:	COMPILE_(else_seq, "else", node->nd_else, poped);
compile.c:	if (node->nd_head == 0) {
compile.c:	    COMPILE_(ret, "when", node->nd_body, poped);
compile.c:	COMPILE(head, "match base", node->nd_head);
compile.c:	node = node->nd_body;
compile.c:	    COMPILE_(body_seq, "when body", node->nd_body, poped);
compile.c:	    vals = node->nd_head;
compile.c:	    node = node->nd_next;
compile.c:	if (node->nd_head == 0) {
compile.c:	    COMPILE_(ret, "when", node->nd_body, poped);
compile.c:	COMPILE(head, "case base", node->nd_head);
compile.c:	node = node->nd_body;
compile.c:	    COMPILE_(body_seq, "when body", node->nd_body, poped);
compile.c:	    vals = node->nd_head;
compile.c:	    node = node->nd_next;
compile.c:	    COMPILE_(body_seq, "when", node->nd_body, poped);
compile.c:	    vals = node->nd_head;
compile.c:		    val = vals->nd_head;
compile.c:		    vals = vals->nd_next;
compile.c:		NODE *val = vals->nd_head;
compile.c:		    NODE *vs = vals->nd_head;
compile.c:		    val = vals->nd_body;
compile.c:			NODE* val = vs->nd_head;
compile.c:			vs = vs->nd_next;
compile.c:	    node = node->nd_next;
compile.c:	LABEL *prev_start_label = iseq->compile_data->start_label;
compile.c:	LABEL *prev_end_label = iseq->compile_data->end_label;
compile.c:	LABEL *prev_redo_label = iseq->compile_data->redo_label;
compile.c:	VALUE prev_loopval_popped = iseq->compile_data->loopval_popped;
compile.c:	LABEL *next_label = iseq->compile_data->start_label = NEW_LABEL(nd_line(node));	/* next  */
compile.c:	LABEL *redo_label = iseq->compile_data->redo_label = NEW_LABEL(nd_line(node));	/* redo  */
compile.c:	LABEL *break_label = iseq->compile_data->end_label = NEW_LABEL(nd_line(node));	/* break */
compile.c:	iseq->compile_data->loopval_popped = 0;
compile.c:	if (type == NODE_OPT_N || node->nd_state == 1) {
compile.c:	COMPILE_POPED(ret, "while body", node->nd_body);
compile.c:	    compile_branch_condition(iseq, ret, node->nd_cond,
compile.c:	    compile_branch_condition(iseq, ret, node->nd_cond,
compile.c:	if (node->nd_state == Qundef) {
compile.c:			iseq->compile_data->redo_label);
compile.c:	iseq->compile_data->start_label = prev_start_label;
compile.c:	iseq->compile_data->end_label = prev_end_label;
compile.c:	iseq->compile_data->redo_label = prev_redo_label;
compile.c:	iseq->compile_data->loopval_popped = prev_loopval_popped;
compile.c:	iseq->compile_data->ensure_node_stack = iseq->compile_data->ensure_node_stack->prev;
compile.c:	VALUE prevblock = iseq->compile_data->current_block;
compile.c:	    COMPILE(ret, "iter caller (for)", node->nd_iter);
compile.c:	    iseq->compile_data->current_block =
compile.c:		NEW_CHILD_ISEQVAL(node->nd_body, make_name_for_block(iseq),
compile.c:		       iseq->compile_data->current_block, INT2FIX(0));
compile.c:	    iseq->compile_data->current_block =
compile.c:		NEW_CHILD_ISEQVAL(node->nd_body, make_name_for_block(iseq),
compile.c:	    COMPILE(ret, "iter caller", node->nd_iter);
compile.c:	iseq->compile_data->current_block = prevblock;
compile.c:	if (iseq->compile_data->redo_label != 0) {
compile.c:	    ADD_ADJUST(ret, nd_line(node), iseq->compile_data->redo_label);
compile.c:	    COMPILE_(ret, "break val (while/until)", node->nd_stts, iseq->compile_data->loopval_popped);
compile.c:	    ADD_INSNL(ret, nd_line(node), jump, iseq->compile_data->end_label);
compile.c:	else if (iseq->type == ISEQ_TYPE_BLOCK) {
compile.c:	    COMPILE(ret, "break val (block)", node->nd_stts);
compile.c:	else if (iseq->type == ISEQ_TYPE_EVAL) {
compile.c:	    rb_iseq_t *ip = iseq->parent_iseq;
compile.c:		if (!ip->compile_data) {
compile.c:		if (ip->compile_data->redo_label != 0) {
compile.c:		    if (ip->compile_data->loopval_popped == 0) {
compile.c:		else if (ip->type == ISEQ_TYPE_BLOCK) {
compile.c:		else if (ip->type == ISEQ_TYPE_EVAL) {
compile.c:		ip = ip->parent_iseq;
compile.c:	if (iseq->compile_data->redo_label != 0) {
compile.c:	    COMPILE(ret, "next val/valid syntax?", node->nd_stts);
compile.c:	    ADD_ADJUST(ret, nd_line(node), iseq->compile_data->redo_label);
compile.c:	    ADD_INSNL(ret, nd_line(node), jump, iseq->compile_data->start_label);
compile.c:	else if (iseq->compile_data->end_label) {
compile.c:	    ADD_ADJUST(ret, nd_line(node), iseq->compile_data->start_label);
compile.c:	    COMPILE(ret, "next val", node->nd_stts);
compile.c:	    ADD_INSNL(ret, nd_line(node), jump, iseq->compile_data->end_label);
compile.c:	else if (iseq->type == ISEQ_TYPE_EVAL) {
compile.c:		if (!ip->compile_data) {
compile.c:		if (ip->compile_data->redo_label != 0) {
compile.c:		else if (ip->type == ISEQ_TYPE_BLOCK) {
compile.c:		else if (ip->type == ISEQ_TYPE_EVAL) {
compile.c:		ip = ip->parent_iseq;
compile.c:		COMPILE(ret, "next val", node->nd_stts);
compile.c:	if (iseq->compile_data->redo_label) {
compile.c:	    ADD_ADJUST(ret, nd_line(node), iseq->compile_data->redo_label);
compile.c:	    ADD_INSNL(ret, nd_line(node), jump, iseq->compile_data->redo_label);
compile.c:	else if (iseq->type == ISEQ_TYPE_EVAL) {
compile.c:	else if (iseq->compile_data->start_label) {
compile.c:	    ADD_ADJUST(ret, nd_line(node), iseq->compile_data->start_label);
compile.c:	    ADD_INSNL(ret, nd_line(node), jump, iseq->compile_data->start_label);
compile.c:		if (!ip->compile_data) {
compile.c:		if (ip->compile_data->redo_label != 0) {
compile.c:		else if (ip->type == ISEQ_TYPE_BLOCK) {
compile.c:		else if (ip->type == ISEQ_TYPE_EVAL) {
compile.c:		ip = ip->parent_iseq;
compile.c:	if (iseq->type == ISEQ_TYPE_RESCUE) {
compile.c:	COMPILE_(ret, "NODE_BEGIN", node->nd_body, poped);
compile.c:	    node->nd_resq,
compile.c:	    rb_str_concat(rb_str_new2("rescue in "), iseq->name),
compile.c:	COMPILE(ret, "rescue head", node->nd_head);
compile.c:	if (node->nd_else) {
compile.c:	    COMPILE(ret, "rescue else", node->nd_else);
compile.c:	    narg = resq->nd_args;
compile.c:			COMPILE(ret, "rescue arg", narg->nd_head);
compile.c:			narg = narg->nd_next;
compile.c:	    COMPILE(ret, "resbody body", resq->nd_body);
compile.c:	    if (iseq->compile_data->option->tailcall_optimization) {
compile.c:	    resq = resq->nd_head;
compile.c:	VALUE ensure = NEW_CHILD_ISEQVAL(node->nd_ensr,
compile.c:						       iseq->name),
compile.c:	COMPILE_POPED(ensr, "ensure ensr", node->nd_ensr);
compile.c:	push_ensure_entry(iseq, &enl, &er, node->nd_ensr);
compile.c:	COMPILE_(ret, "ensure head", node->nd_head, poped);
compile.c:	if (ensr->anchor.next == 0) {
compile.c:	erange = iseq->compile_data->ensure_node_stack->erange;
compile.c:	    ADD_CATCH_ENTRY(CATCH_TYPE_ENSURE, erange->begin, erange->end,
compile.c:	    erange = erange->next;
compile.c:	iseq->compile_data->ensure_node_stack = enl.prev;
compile.c:	COMPILE(ret, "nd_1st", node->nd_1st);
compile.c:	COMPILE_(ret, "nd_2nd", node->nd_2nd, poped);
compile.c:	ID id = node->nd_vid;
compile.c:	int idx = iseq->local_iseq->local_size - get_local_var_idx(iseq, id);
compile.c:	COMPILE(ret, "rvalue", node->nd_value);
compile.c:	COMPILE(ret, "dvalue", node->nd_value);
compile.c:	debugp_param("dassn id", rb_str_new2(rb_id2name(node->nd_vid) ? rb_id2name(node->nd_vid) : "*"));
compile.c:	idx = get_dyna_var_idx(iseq, node->nd_vid, &lv, &ls);
compile.c:	    rb_bug("NODE_DASGN(_CURR): unknown id (%s)", rb_id2name(node->nd_vid));
compile.c:		  INT2FIX(ls - idx), INT2FIX(lv));
compile.c:	COMPILE(ret, "lvalue", node->nd_value);
compile.c:		  (((long)node->nd_entry) | 1));
compile.c:	COMPILE(ret, "lvalue", node->nd_value);
compile.c:		  ID2SYM(node->nd_vid));
compile.c:	COMPILE(ret, "lvalue", node->nd_value);
compile.c:	if (node->nd_vid) {
compile.c:	    ADD_INSN1(ret, nd_line(node), setconstant, ID2SYM(node->nd_vid));
compile.c:	    compile_cpath(ret, iseq, node->nd_else);
compile.c:	    ADD_INSN1(ret, nd_line(node), setconstant, ID2SYM(node->nd_else->nd_mid));
compile.c:	COMPILE(ret, "cvasgn val", node->nd_value);
compile.c:		  ID2SYM(node->nd_vid));
compile.c:	ID id = node->nd_mid;
compile.c:	 * nd_recv[nd_args->nd_body] (nd_mid)= nd_args->nd_head;
compile.c:	 *              nd_args->nd_head
compile.c:	 *              nd_args->nd_body
compile.c:	COMPILE(ret, "NODE_OP_ASGN1 recv", node->nd_recv);
compile.c:	if (nd_type(node->nd_args->nd_body) != NODE_ZARRAY) {
compile.c:	    argc = setup_args(iseq, args, node->nd_args->nd_body, &flag);
compile.c:	    COMPILE(ret, "NODE_OP_ASGN1 args->head: ", node->nd_args->nd_head);
compile.c:	    COMPILE(ret, "NODE_OP_ASGN1 args->head: ", node->nd_args->nd_head);
compile.c:	ID atype = node->nd_next->nd_mid;
compile.c:	COMPILE(ret, "NODE_OP_ASGN2#recv", node->nd_recv);
compile.c:	ADD_SEND(ret, nd_line(node), ID2SYM(node->nd_next->nd_vid),
compile.c:	    COMPILE(ret, "NODE_OP_ASGN2 val", node->nd_value);
compile.c:	    ADD_SEND(ret, nd_line(node), ID2SYM(node->nd_next->nd_aid),
compile.c:	    COMPILE(ret, "NODE_OP_ASGN2 val", node->nd_value);
compile.c:	    ADD_SEND(ret, nd_line(node), ID2SYM(node->nd_next->nd_mid),
compile.c:	    ADD_SEND(ret, nd_line(node), ID2SYM(node->nd_next->nd_aid),
compile.c:	    defined_expr(iseq, ret, node->nd_head, lfinish, Qfalse);
compile.c:	COMPILE(ret, "NODE_OP_ASGN_AND/OR#nd_head", node->nd_head);
compile.c:	COMPILE(ret, "NODE_OP_ASGN_AND/OR#nd_value", node->nd_value);
compile.c:	ID mid = node->nd_mid;
compile.c:	VALUE parent_block = iseq->compile_data->current_block;
compile.c:	iseq->compile_data->current_block = Qfalse;
compile.c:		if (nd_type(node->nd_args->nd_head) == NODE_LIT &&
compile.c:		    SYMBOL_P(node->nd_args->nd_head->nd_lit)) {
compile.c:		    label_sym = label = node->nd_args->nd_head->nd_lit;
compile.c:			 rb_hash_aref(iseq->compile_data,
compile.c:			rb_hash_aset(iseq->compile_data, label_sym,
compile.c:	    COMPILE(recv, "recv", node->nd_recv);
compile.c:	    argc = setup_args(iseq, args, node->nd_args, &flag);
compile.c:	VALUE parent_block = iseq->compile_data->current_block;
compile.c:	iseq->compile_data->current_block = Qfalse;
compile.c:	    argc = setup_args(iseq, args, node->nd_args, &flag);
compile.c:	    rb_iseq_t *liseq = iseq->local_iseq;
compile.c:	    argc = INT2FIX(liseq->argc);
compile.c:	    for (i = 0; i < liseq->argc; i++) {
compile.c:		int idx = liseq->local_size - i;
compile.c:	    if (!liseq->arg_simple) {
compile.c:		if (liseq->arg_opts) {
compile.c:		    for (j = 0; j < liseq->arg_opts - 1; j++) {
compile.c:			int idx = liseq->local_size - (i + j);
compile.c:		if (liseq->arg_rest != -1) {
compile.c:		    int idx = liseq->local_size - liseq->arg_rest;
compile.c:		    argc = INT2FIX(liseq->arg_rest + 1);
compile.c:		if (liseq->arg_post_len) {
compile.c:		    int post_len = liseq->arg_post_len;
compile.c:		    int post_start = liseq->arg_post_start;
compile.c:		    if (liseq->arg_rest != -1) {
compile.c:			    int idx = liseq->local_size - (post_start + j);
compile.c:			    int idx = liseq->local_size - (post_start + j);
compile.c:	    COMPILE(ret, "values item", n->nd_head);
compile.c:	    n = n->nd_next;
compile.c:	ADD_INSN1(ret, nd_line(node), newarray, INT2FIX(node->nd_alen));
compile.c:	int type = node->nd_head ? nd_type(node->nd_head) : NODE_ZARRAY;
compile.c:	    compile_array(iseq, list, node->nd_head, Qfalse);
compile.c:	    if (is->type == ISEQ_TYPE_TOP || is->type == ISEQ_TYPE_CLASS) {
compile.c:		if (is->type == ISEQ_TYPE_METHOD) {
compile.c:		COMPILE(ret, "return nd_stts (return val)", node->nd_stts);
compile.c:		if (is->type == ISEQ_TYPE_METHOD) {
compile.c:	if (iseq->type == ISEQ_TYPE_TOP || iseq->type == ISEQ_TYPE_CLASS) {
compile.c:	if (node->nd_head) {
compile.c:	    argc = setup_args(iseq, args, node->nd_head, &flag);
compile.c:	    ID id = node->nd_vid;
compile.c:	    int idx = iseq->local_iseq->local_size - get_local_var_idx(iseq, id);
compile.c:	debugi("nd_vid", node->nd_vid);
compile.c:	    idx = get_dyna_var_idx(iseq, node->nd_vid, &lv, &ls);
compile.c:		rb_bug("unknown dvar (%s)", rb_id2name(node->nd_vid));
compile.c:	    ADD_INSN2(ret, nd_line(node), getdynamic, INT2FIX(ls - idx), INT2FIX(lv));
compile.c:		  (((long)node->nd_entry) | 1));
compile.c:	debugi("nd_vid", node->nd_vid);
compile.c:		      ID2SYM(node->nd_vid));
compile.c:	debugi("nd_vid", node->nd_vid);
compile.c:	if (iseq->compile_data->option->inline_const_cache) {
compile.c:	    ADD_INSN1(ret, nd_line(node), getconstant, ID2SYM(node->nd_vid));
compile.c:	    ADD_INSN1(ret, nd_line(node), getconstant, ID2SYM(node->nd_vid));
compile.c:		      ID2SYM(node->nd_vid));
compile.c:		      INT2FIX(node->nd_nth << 1));
compile.c:		      INT2FIX(0x01 | (node->nd_nth << 1)));
compile.c:	    ADD_INSN1(recv, nd_line(node), putobject, node->nd_lit);
compile.c:	    COMPILE(recv, "reciever", node->nd_recv);
compile.c:	    COMPILE(val, "value", node->nd_value);
compile.c:	    COMPILE(recv, "reciever", node->nd_value);
compile.c:	    COMPILE(val, "value", node->nd_recv);
compile.c:	if (iseq->compile_data->option->specialized_instruction) {
compile.c:	    if (recv->last == recv->anchor.next &&
compile.c:		INSN_OF(recv->last) == BIN(putobject) &&
compile.c:			  OPERAND_AT(recv->last, 0));
compile.c:	debugp_param("lit", node->nd_lit);
compile.c:	    ADD_INSN1(ret, nd_line(node), putobject, node->nd_lit);
compile.c:	debugp_param("nd_lit", node->nd_lit);
compile.c:	    hide_obj(node->nd_lit);
compile.c:	    ADD_INSN1(ret, nd_line(node), putstring, node->nd_lit);
compile.c:	ADD_INSN1(ret, nd_line(node), putobject, node->nd_lit);
compile.c:	COMPILE(ret, "nd_body", node->nd_body);
compile.c:	COMPILE(ret, "argscat head", node->nd_head);
compile.c:	COMPILE(ret, "argscat body", node->nd_body);
compile.c:	COMPILE(ret, "arsgpush head", node->nd_head);
compile.c:	COMPILE(ret, "argspush body", node->nd_body);
compile.c:	COMPILE(ret, "splat", node->nd_head);
compile.c:	VALUE iseqval = NEW_ISEQVAL(node->nd_defn,
compile.c:				    rb_str_dup(rb_id2str(node->nd_mid)),
compile.c:	ADD_INSN1(ret, nd_line(node), putobject, ID2SYM(node->nd_mid));
compile.c:	VALUE iseqval = NEW_ISEQVAL(node->nd_defn,
compile.c:				    rb_str_dup(rb_id2str(node->nd_mid)),
compile.c:	COMPILE(ret, "defs: recv", node->nd_recv);
compile.c:	ADD_INSN1(ret, nd_line(node), putobject, ID2SYM(node->nd_mid));
compile.c:	COMPILE(ret, "alias arg1", node->u1.node);
compile.c:	COMPILE(ret, "alias arg2", node->u2.node);
compile.c:	ADD_INSN1(ret, nd_line(node), putobject, ID2SYM(node->u1.id));
compile.c:	ADD_INSN1(ret, nd_line(node), putobject, ID2SYM(node->u2.id));
compile.c:	COMPILE(ret, "undef arg", node->u2.node);
compile.c:		node->nd_body,
compile.c:		rb_sprintf("<class:%s>", rb_id2name(node->nd_cpath->nd_mid)),
compile.c:	compile_cpath(ret, iseq, node->nd_cpath);
compile.c:	COMPILE(ret, "super", node->nd_super);
compile.c:		  ID2SYM(node->nd_cpath->nd_mid), iseqval, INT2FIX(0));
compile.c:	    node->nd_body,
compile.c:	    rb_sprintf("<module:%s>", rb_id2name(node->nd_cpath->nd_mid)),
compile.c:	compile_cpath(ret, iseq, node->nd_cpath);
compile.c:		  ID2SYM(node->nd_cpath->nd_mid), iseqval, INT2FIX(2));
compile.c:	    NEW_ISEQVAL(node->nd_body, rb_str_new2("singletonclass"),
compile.c:	COMPILE(ret, "sclass#recv", node->nd_recv);
compile.c:	if (rb_is_const_id(node->nd_mid)) {
compile.c:		if (iseq->compile_data->option->inline_const_cache) {
compile.c:		if (iseq->compile_data->option->inline_const_cache) {
compile.c:	    COMPILE(ret, "colon2#nd_head", node->nd_head);
compile.c:	    ADD_CALL(ret, nd_line(node), ID2SYM(node->nd_mid),
compile.c:	debugi("colon3#nd_mid", node->nd_mid);
compile.c:	if (iseq->compile_data->option->inline_const_cache) {
compile.c:	ADD_INSN1(ret, nd_line(node), getconstant, ID2SYM(node->nd_mid));
compile.c:	if (iseq->compile_data->option->inline_const_cache) {
compile.c:	COMPILE(ret, "min", (NODE *) node->nd_beg);
compile.c:	COMPILE(ret, "max", (NODE *) node->nd_end);
compile.c:	VALUE key = rb_sprintf("flipflag/%s-%p-%d",
compile.c:			       RSTRING_PTR(iseq->name), (void *)iseq,
compile.c:			       iseq->compile_data->flip_cnt++);
compile.c:	COMPILE(ret, "flip2 beg", node->nd_beg);
compile.c:	COMPILE(ret, "flip2 end", node->nd_end);
compile.c:	    if (iseq->type == ISEQ_TYPE_RESCUE) {
compile.c:		    if (ip->type == ISEQ_TYPE_RESCUE) {
compile.c:		    ip = ip->parent_iseq;
compile.c:	    defined_expr(iseq, ret, node->nd_head, lfinish, Qtrue);
compile.c:	VALUE block = NEW_CHILD_ISEQVAL(node->nd_body, make_name_for_block(iseq), ISEQ_TYPE_BLOCK);
compile.c:	argc = setup_args(iseq, args, node->nd_args, &flag);
compile.c:	if (node->nd_recv == (NODE *) 1) {
compile.c:	    COMPILE(recv, "recv", node->nd_recv);
compile.c:	debugp_param("nd_mid", ID2SYM(node->nd_mid));
compile.c:	ADD_SEND_R(ret, nd_line(node), ID2SYM(node->nd_mid), argc, 0, LONG2FIX(flag));
compile.c:	iseq->compile_data->start_label = next_label;
compile.c:	iseq->compile_data->redo_label = redo_label;
compile.c:	COMPILE_(ret, "optblock body", node->nd_head, 1 /* pop */ );
compile.c:	COMPILE_POPED(ret, "prelude", node->nd_head);
compile.c:	COMPILE_(ret, "body", node->nd_body, poped);
compile.c:	VALUE block = NEW_CHILD_ISEQVAL(node->nd_body, make_name_for_block(iseq), ISEQ_TYPE_BLOCK);
compile.c:    return insn_len(iobj->insn_id);
compile.c:    return insn_stack_increase(depth, insn->insn_id, insn->operands);
compile.c:    return insn_len(iobj->line_no);
compile.c:    str = rb_sprintf("%-16s", insn_name(iobj->insn_id));
compile.c:    if (iobj->operands) {
compile.c:	const char *types = insn_op_types(iobj->insn_id);
compile.c:		    rb_str_catf(str, "<L%03d>", lobj->label_no);
compile.c:			val = iseq->self;
compile.c:		    rb_str_cat2(str, rb_id2name(entry->id));
compile.c:    printf("-- raw disasm--------\n");
compile.c:	switch (link->type) {
compile.c:		printf("%04d %-65s(%4d)\n", pos, StringValueCStr(str),
compile.c:		printf("<L%03d>\n", lobj->label_no);
compile.c:		printf("adjust: [label: %d]\n", adjust->label->label_no);
compile.c:	    rb_raise(rb_eSyntaxError, "dump_disasm_list error: %ld\n", FIX2LONG(link->type));
compile.c:	link = link->next;
compile.c:    printf("---------------------\n");
compile.c:	    eiseqval = ruby_iseq_load(ptr[1], iseq->self, Qnil);
compile.c:     * index -> LABEL *label
compile.c:	    int argc = RARRAY_LEN(obj) - 1;
compile.c:		rb_compile_error(RSTRING_PTR(iseq->filename), line_no,
compile.c:	    if (argc != insn_len(insn_id)-1) {
compile.c:		rb_compile_error(RSTRING_PTR(iseq->filename), line_no,
compile.c:				    argv[j] = ruby_iseq_load(op, iseq->self, Qnil);
compile.c:    iseq->local_table_size = RARRAY_LEN(locals);
compile.c:    iseq->local_table = tbl = (ID *)ALLOC_N(ID *, iseq->local_table_size);
compile.c:    iseq->local_size = iseq->local_table_size + 1;
compile.c:	iseq->arg_size = iseq->argc = FIX2INT(args);
compile.c:	iseq->arg_simple = 1;
compile.c:	iseq->argc = FIX2INT(argc);
compile.c:	iseq->arg_rest = FIX2INT(arg_rest);
compile.c:	iseq->arg_post_len = FIX2INT(arg_post_len);
compile.c:	iseq->arg_post_start = FIX2INT(arg_post_start);
compile.c:	iseq->arg_block = FIX2INT(arg_block);
compile.c:	iseq->arg_opts = RARRAY_LEN(arg_opt_labels);
compile.c:	iseq->arg_opt_table = (VALUE *)ALLOC_N(VALUE, iseq->arg_opts);
compile.c:	if (iseq->arg_block != -1) {
compile.c:	    iseq->arg_size = iseq->arg_block + 1;
compile.c:	else if (iseq->arg_post_len) {
compile.c:	    iseq->arg_size = iseq->arg_post_start + iseq->arg_post_len;
compile.c:	else if (iseq->arg_rest != -1) {
compile.c:	    iseq->arg_size = iseq->arg_rest + 1;
compile.c:	    iseq->arg_size = iseq->argc + (iseq->arg_opts ? iseq->arg_opts - 1 : 0);
compile.c:	    iseq->arg_opt_table[i] =
compile.c:	iseq->arg_simple = NUM2INT(arg_simple);
compile.c:    return iseq->self;
compile.c:    if (th->base_block && (iseq = th->base_block->iseq)) {
compile.c:	while (iseq->type == ISEQ_TYPE_BLOCK ||
compile.c:	       iseq->type == ISEQ_TYPE_RESCUE ||
compile.c:	       iseq->type == ISEQ_TYPE_ENSURE ||
compile.c:	       iseq->type == ISEQ_TYPE_EVAL ||
compile.c:	       iseq->type == ISEQ_TYPE_MAIN
compile.c:	    for (i = 0; i < iseq->local_table_size; i++) {
compile.c:		if (iseq->local_table[i] == id) {
compile.c:	    iseq = iseq->parent_iseq;
compile.c:    if (th->base_block && th->base_block->iseq) {
compile.c:	iseq = th->base_block->iseq->local_iseq;
compile.c:	for (i=0; i<iseq->local_table_size; i++) {
compile.c:	    if (iseq->local_table[i] == id) {
compile.c:    return GET_THREAD()->parse_in_eval > 0;
compile.c:    return GET_THREAD()->parse_in_eval < 0;
compile.c~:  compile.c - ruby node tree -> VM instruction sequence
compile.c~:  Copyright (C) 2004-2007 Koichi Sasada
compile.c~:#define compile_debug iseq->compile_data->option->debug_level
compile.c~:#define debug_node_end()  gl_node_level --;
compile.c~:  (((rb_iseq_t*)DATA_PTR(iseq))->filename)
compile.c~:  new_child_iseq(iseq, node, name, iseq->self, type)
compile.c~:  new_child_iseq(iseq, iseq->node, iseq->name, iseq->parent_iseq, iseq->type, sym)
compile.c~:      if ((event) == RUBY_EVENT_LINE && iseq->coverage && \
compile.c~:	  RARRAY_PTR(iseq->coverage)[(line) - 1] == Qnil) { \
compile.c~:	  RARRAY_PTR(iseq->coverage)[(line) - 1] = INT2FIX(0); \
compile.c~:      if (iseq->compile_data->option->trace_instruction) { \
compile.c~:  ADD_ELEM(seq, (LINK_ELEMENT *) new_adjust_body(iseq, label, -1))
compile.c~:    (rb_ary_push(iseq->compile_data->catch_table_ary,		\
compile.c~:  (((INSN*)(insn))->operands[idx])
compile.c~:  (((INSN*)(insn))->insn_id)
compile.c~:  VALUE tmp = GET_THREAD()->errinfo;               \
compile.c~:  GET_THREAD()->errinfo = iseq->compile_data->err_info;  \
compile.c~:  iseq->compile_data->err_info = GET_THREAD()->errinfo; \
compile.c~:  GET_THREAD()->errinfo = tmp;                     \
compile.c~:#define hide_obj(obj) do {OBJ_FREEZE(obj); RBASIC(obj)->klass = 0;} while (0)
compile.c~:#define gl_node_level iseq->compile_data->node_level
compile.c~:    list = anchor->anchor.next;
compile.c~:    plist = &anchor->anchor;
compile.c~:	if (plist != list->prev) {
compile.c~:	list = list->next;
compile.c~:    if (anchor->last != plist && anchor->last != 0) {
compile.c~:    elem->prev = anchor->last;
compile.c~:    anchor->last->next = elem;
compile.c~:    anchor->last = elem;
compile.c~:	rb_ary_push(iseq->mark_ary, v);
compile.c~:#define ruby_sourcefile		RSTRING_PTR(iseq->filename)
compile.c~:	rb_ary_push(iseq->compile_data->mark_ary, v);
compile.c~:	iseq_set_local_table(iseq, node->nd_tbl);
compile.c~:	iseq_set_arguments(iseq, ret, node->nd_args);
compile.c~:	switch (iseq->type) {
compile.c~:	    LABEL *start = iseq->compile_data->start_label = NEW_LABEL(0);
compile.c~:	    LABEL *end = iseq->compile_data->end_label = NEW_LABEL(0);
compile.c~:	    COMPILE(ret, "block body", node->nd_body);
compile.c~:	    COMPILE(ret, "scoped node", node->nd_body);
compile.c~:	    COMPILE(ret, "scoped node", node->nd_body);
compile.c~:	    COMPILE(ret, "scoped node", node->nd_body);
compile.c~:	switch (iseq->type) {
compile.c~:    if (iseq->type == ISEQ_TYPE_RESCUE || iseq->type == ISEQ_TYPE_ENSURE) {
compile.c~:	ADD_INSN(ret, iseq->compile_data->last_line, leave);
compile.c~:    iseq->iseq_encoded = ALLOC_N(VALUE, iseq->iseq_size);
compile.c~:    MEMCPY(iseq->iseq_encoded, iseq->iseq, VALUE, iseq->iseq_size);
compile.c~:    for (i = 0; i < iseq->iseq_size; /* */ ) {
compile.c~:	int insn = iseq->iseq_encoded[i];
compile.c~:	iseq->iseq_encoded[i] = (VALUE)table[insn];
compile.c~:    iseq->iseq_encoded = iseq->iseq;
compile.c~:	iseq->compile_data->storage_current;
compile.c~:    if (storage->pos + size > storage->size) {
compile.c~:	unsigned long alloc_size = storage->size * 2;
compile.c~:	storage->next = (void *)ALLOC_N(char, alloc_size +
compile.c~:	storage = iseq->compile_data->storage_current = storage->next;
compile.c~:	storage->next = 0;
compile.c~:	storage->pos = 0;
compile.c~:	storage->size = alloc_size;
compile.c~:	storage->buff = (char *)(&storage->buff + 1);
compile.c~:    ptr = (void *)&storage->buff[storage->pos];
compile.c~:    storage->pos += size;
compile.c~:    elem2->next = elem1->next;
compile.c~:    elem2->prev = elem1;
compile.c~:    elem1->next = elem2;
compile.c~:    if (elem2->next) {
compile.c~:	elem2->next->prev = elem2;
compile.c~:    elem2->prev = elem1->prev;
compile.c~:    elem2->next = elem1;
compile.c~:    elem1->prev = elem2;
compile.c~:    if (elem2->prev) {
compile.c~:	elem2->prev->next = elem2;
compile.c~:    elem2->prev = elem1->prev;
compile.c~:    elem2->next = elem1->next;
compile.c~:    if (elem1->prev) {
compile.c~:	elem1->prev->next = elem2;
compile.c~:    if (elem1->next) {
compile.c~:	elem1->next->prev = elem2;
compile.c~:    elem->prev->next = elem->next;
compile.c~:    if (elem->next) {
compile.c~:	elem->next->prev = elem->prev;
compile.c~:    return anchor->anchor.next;
compile.c~:  return anchor->last;
compile.c~:    LINK_ELEMENT *elem = anchor->last;
compile.c~:    anchor->last = anchor->last->prev;
compile.c~:    anchor->last->next = 0;
compile.c~:    LINK_ELEMENT *elem = anchor->anchor.next;
compile.c~:	anchor->anchor.next = elem->next;
compile.c~:    LINK_ELEMENT *elem = anchor->anchor.next;
compile.c~:	elem = elem->next;
compile.c~:    if (anchor->anchor.next == 0) {
compile.c~:    if (anc2->anchor.next) {
compile.c~:	anc1->last->next = anc2->anchor.next;
compile.c~:	anc2->anchor.next->prev = anc1->last;
compile.c~:	anc1->last = anc2->last;
compile.c~:    if (anc2->anchor.next) {
compile.c~:	LINK_ELEMENT *first = anc1->anchor.next;
compile.c~:	anc1->anchor.next = anc2->anchor.next;
compile.c~:	anc1->anchor.next->prev = &anc1->anchor;
compile.c~:	anc2->last->next = first;
compile.c~:	    first->prev = anc2->last;
compile.c~:	    anc1->last = anc2->last;
compile.c~:    first = &anc->anchor;
compile.c~:    elem = first->next;
compile.c~:    last = anc->last;
compile.c~:	anc->anchor.next = last;
compile.c~:	anc->last = elem;
compile.c~:	e = elem->next;
compile.c~:	elem->next = elem->prev;
compile.c~:	elem->prev = e;
compile.c~:    first->next = last;
compile.c~:    last->prev = first;
compile.c~:    anc->last->next = 0;
compile.c~:    printf("----\n");
compile.c~:    printf("anch: %p, frst: %p, last: %p\n", &anchor->anchor,
compile.c~:	   anchor->anchor.next, anchor->last);
compile.c~:	printf("curr: %p, next: %p, prev: %p, type: %d\n", list, list->next,
compile.c~:	       list->prev, FIX2INT(list->type));
compile.c~:	list = list->next;
compile.c~:    printf("----\n");
compile.c~:    dump_disasm_list(anchor->anchor.next);
compile.c~:    labelobj->link.type = ISEQ_ELEMENT_LABEL;
compile.c~:    labelobj->link.next = 0;
compile.c~:    labelobj->label_no = iseq->compile_data->label_no++;
compile.c~:    labelobj->sc_state = 0;
compile.c~:    labelobj->sp = -1;
compile.c~:    adjust->link.type = ISEQ_ELEMENT_ADJUST;
compile.c~:    adjust->link.next = 0;
compile.c~:    adjust->label = label;
compile.c~:    adjust->line_no = line;
compile.c~:    iobj->link.type = ISEQ_ELEMENT_INSN;
compile.c~:    iobj->link.next = 0;
compile.c~:    iobj->insn_id = insn_id;
compile.c~:    iobj->line_no = line_no;
compile.c~:    iobj->operands = argv;
compile.c~:    iobj->operand_size = argc;
compile.c~:    iobj->sc_state = 0;
compile.c~:    debugs("[new_child_iseq]> ---------------------------------------\n");
compile.c~:    ret = rb_iseq_new_with_opt(node, name, iseq_filename(iseq->self),
compile.c~:			       parent, type, iseq->compile_data->option);
compile.c~:    debugs("[new_child_iseq]< ---------------------------------------\n");
compile.c~:    if (iseq->compile_data->option->instructions_unification) {
compile.c~:    if (iseq->compile_data->option->stack_caching) {
compile.c~:	VALUE str = rb_iseq_disasm(iseq->self);
compile.c~:    iseq->local_table = (ID *)ALLOC_N(ID *, 1);
compile.c~:    iseq->local_table_size = 1;
compile.c~:    iseq->local_size = iseq->local_table_size + 1;
compile.c~:    iseq->local_table[0] = id_dollar_bang;
compile.c~:    for (i = 0; i < iseq->local_table_size; i++) {
compile.c~:	if (iseq->local_table[i] == id) {
compile.c~:    return -1;
compile.c~:    int idx = get_dyna_var_idx_at_raw(iseq->local_iseq, id);
compile.c~:    int lv = 0, idx = -1;
compile.c~:	iseq = iseq->parent_iseq;
compile.c~:	rb_bug("get_dyna_var_idx: -1");
compile.c~:    *ls = iseq->local_size;
compile.c~:	NODE *node_aux = node_args->nd_next;
compile.c~:	NODE *node_opt = node_args->nd_opt;
compile.c~:         *   NODE_ARGS     [m: int,  o: NODE_OPT_ARG, ->]
compile.c~:         *   NODE_ARGS_AUX [r: ID,   b: ID,           ->]
compile.c~:         *   NODE_OPT_ARGS [idx,     expr,            next ->]
compile.c~:	iseq->argc = node_args->nd_frml;
compile.c~:	debugs("  - argc: %d\n", iseq->argc);
compile.c~:	    rest_id = node_aux->nd_rest;
compile.c~:	    block_id = (ID)node_aux->nd_body;
compile.c~:	    node_aux = node_aux->nd_next;
compile.c~:		ID post_start_id = node_aux->nd_pid;
compile.c~:		iseq->arg_post_start = get_dyna_var_idx_at_raw(iseq, post_start_id);
compile.c~:		iseq->arg_post_len = node_aux->nd_plen;
compile.c~:		node_init = node_aux->nd_next;
compile.c~:		COMPILE_POPED(optargs, "optarg", node->nd_body);
compile.c~:		node = node->nd_next;
compile.c~:	    iseq->arg_opts = i;
compile.c~:	    iseq->arg_opt_table = ALLOC_N(VALUE, i);
compile.c~:	    MEMCPY(iseq->arg_opt_table, RARRAY_PTR(labels), VALUE, i);
compile.c~:		iseq->arg_opt_table[j] &= ~1;
compile.c~:	    iseq->arg_opts = 0;
compile.c~:	    if (node_init->nd_1st) { /* m_init */
compile.c~:		COMPILE_POPED(optargs, "init arguments (m)", node_init->nd_1st);
compile.c~:	    if (node_init->nd_2nd) { /* p_init */
compile.c~:		COMPILE_POPED(optargs, "init arguments (p)", node_init->nd_2nd);
compile.c~:	    iseq->arg_rest = get_dyna_var_idx_at_raw(iseq, rest_id);
compile.c~:	    if (iseq->arg_rest == -1) {
compile.c~:		rb_bug("arg_rest: -1");
compile.c~:	    if (iseq->arg_post_start == 0) {
compile.c~:		iseq->arg_post_start = iseq->arg_rest + 1;
compile.c~:	    iseq->arg_block = get_dyna_var_idx_at_raw(iseq, block_id);
compile.c~:	if (iseq->arg_opts != 0 || iseq->arg_post_len != 0 ||
compile.c~:	    iseq->arg_rest != -1 || iseq->arg_block != -1) {
compile.c~:	    iseq->arg_simple = 0;
compile.c~:	    if (iseq->arg_block != -1) {
compile.c~:		iseq->arg_size = iseq->arg_block + 1;
compile.c~:	    else if (iseq->arg_post_len) {
compile.c~:		iseq->arg_size = iseq->arg_post_start + iseq->arg_post_len;
compile.c~:	    else if (iseq->arg_rest != -1) {
compile.c~:		iseq->arg_size = iseq->arg_rest + 1;
compile.c~:	    else if (iseq->arg_opts) {
compile.c~:		iseq->arg_size = iseq->argc + iseq->arg_opts - 1;
compile.c~:		iseq->arg_size = iseq->argc;
compile.c~:	    iseq->arg_simple = 1;
compile.c~:	    iseq->arg_size = iseq->argc;
compile.c~:	if (iseq->type == ISEQ_TYPE_BLOCK) {
compile.c~:	    if (iseq->arg_opts == 0 && iseq->arg_post_len == 0 && iseq->arg_rest == -1) {
compile.c~:		if (iseq->argc == 1 && last_comma == 0) {
compile.c~:		    iseq->arg_simple |= 0x02;
compile.c~:	iseq->arg_simple = 1;
compile.c~:	iseq->local_table = (ID *)ALLOC_N(ID *, size);
compile.c~:	MEMCPY(iseq->local_table, tbl, ID *, size);
compile.c~:    iseq->local_size = iseq->local_table_size = size;
compile.c~:    iseq->local_size += 1;
compile.c~:	  dfp[-1]: svar
compile.c~:          dfp[-1]: cref
compile.c~:    debugs("iseq_set_local_table: %d, %d\n", iseq->local_size, iseq->local_table_size);
compile.c~:	return -1;
compile.c~:  ruby insn object array -> raw instruction sequence
compile.c~:	switch (list->type) {
compile.c~:		line = iobj->line_no;
compile.c~:		lobj->position = pos;
compile.c~:		lobj->set = Qtrue;
compile.c~:		if (adjust->line_no != -1) {
compile.c~:	    rb_compile_error(RSTRING_PTR(iseq->filename), line,
compile.c~:	list = list->next;
compile.c~:	switch (list->type) {
compile.c~:		/* fprintf(stderr, "insn: %-16s, sp: %d\n", insn_name(iobj->insn_id), sp); */
compile.c~:		operands = iobj->operands;
compile.c~:		insn = iobj->insn_id;
compile.c~:		if (iobj->operand_size != len - 1) {
compile.c~:		    rb_compile_error(RSTRING_PTR(iseq->filename), iobj->line_no,
compile.c~:				     iobj->operand_size, len - 1);
compile.c~:		    /* printf("--> [%c - (%d-%d)]\n", type, k, j); */
compile.c~:			    if (lobj->set != Qtrue) {
compile.c~:				rb_compile_error(RSTRING_PTR(iseq->filename), iobj->line_no,
compile.c~:			    if (lobj->sp == -1) {
compile.c~:				lobj->sp = sp;
compile.c~:				lobj->position - (pos + len);
compile.c~:			    RHASH_TBL(map)->type = &cdhash_type;
compile.c~:				if (lobj->set != Qtrue) {
compile.c~:				    rb_compile_error(RSTRING_PTR(iseq->filename), iobj->line_no,
compile.c~:				    rb_hash_aset(map, obj, INT2FIX(lobj->position - (pos+len)));
compile.c~:				    rb_compile_warning(RSTRING_PTR(iseq->filename), iobj->line_no,
compile.c~:			rb_compile_error(RSTRING_PTR(iseq->filename), iobj->line_no,
compile.c~:		insn_info_table[k].line_no = iobj->line_no;
compile.c~:		if (lobj->sp == -1) {
compile.c~:		    lobj->sp = sp;
compile.c~:		    sp = lobj->sp;
compile.c~:		if (adjust->label) {
compile.c~:		    sp = adjust->label->sp;
compile.c~:		if (adjust->line_no != -1) {
compile.c~:		    if (orig_sp - sp > 0) {
compile.c~:			insn_info_table[k].line_no = adjust->line_no;
compile.c~:			generated_iseq[pos++] = orig_sp - sp;
compile.c~:		    else if (orig_sp - sp == 0) {
compile.c~:			insn_info_table[k].line_no = adjust->line_no;
compile.c~:	list = list->next;
compile.c~:	rb_bug("SP is not 0 on %s (%d)\n", RSTRING_PTR(iseq->name), sp);
compile.c~:    iseq->iseq = (void *)generated_iseq;
compile.c~:    iseq->iseq_size = pos;
compile.c~:    iseq->insn_info_table = insn_info_table;
compile.c~:    iseq->insn_info_size = k;
compile.c~:    iseq->stack_max = stack_max;
compile.c~:    return lobj->position;
compile.c~:    return lobj->sp;
compile.c~:    tlen = RARRAY_LEN(iseq->compile_data->catch_table_ary);
compile.c~:    tptr = RARRAY_PTR(iseq->compile_data->catch_table_ary);
compile.c~:    iseq->catch_table = tlen ? ALLOC_N(struct iseq_catch_table_entry, tlen) : 0;
compile.c~:    iseq->catch_table_size = tlen;
compile.c~:	entry = &iseq->catch_table[i];
compile.c~:	entry->type = ptr[0] & 0xffff;
compile.c~:	entry->start = label_get_position((LABEL *)(ptr[1] & ~1));
compile.c~:	entry->end = label_get_position((LABEL *)(ptr[2] & ~1));
compile.c~:	entry->iseq = ptr[3];
compile.c~:	if (entry->iseq != 0) {
compile.c~:	    iseq_add_mark_object(iseq, entry->iseq);
compile.c~:	    entry->cont = label_get_position(lobj);
compile.c~:	    entry->sp = label_get_sp(lobj);
compile.c~:	    if (entry->type == CATCH_TYPE_RESCUE ||
compile.c~:		entry->type == CATCH_TYPE_BREAK ||
compile.c~:		entry->type == CATCH_TYPE_NEXT) {
compile.c~:		entry->sp--;
compile.c~:	    entry->cont = 0;
compile.c~:    iseq->compile_data->catch_table_ary = 0;	/* free */
compile.c~:    if (iseq->arg_opts != 0) {
compile.c~:	for (i = 0; i < iseq->arg_opts; i++) {
compile.c~:	    iseq->arg_opt_table[i] =
compile.c~:		label_get_position((LABEL *)iseq->arg_opt_table[i]);
compile.c~:    list = lobj->link.next;
compile.c~:	if (list->type == ISEQ_ELEMENT_INSN || list->type == ISEQ_ELEMENT_ADJUST) {
compile.c~:	list = list->next;
compile.c~:    LINK_ELEMENT *list = iobj->link.next;
compile.c~:	if (list->type == ISEQ_ELEMENT_INSN || list->type == ISEQ_ELEMENT_ADJUST) {
compile.c~:	list = list->next;
compile.c~:    LINK_ELEMENT *list = iobj->link.prev;
compile.c~:	if (list->type == ISEQ_ELEMENT_INSN || list->type == ISEQ_ELEMENT_ADJUST) {
compile.c~:	list = list->prev;
compile.c~:    if (iobj->insn_id == BIN(jump)) {
compile.c~:	    REMOVE_ELEM(&iobj->link);
compile.c~:	else if (iobj != diobj && diobj->insn_id == BIN(jump)) {
compile.c~:	else if (diobj->insn_id == BIN(leave)) {
compile.c~:	    INSN *eiobj = new_insn_core(iseq, iobj->line_no, BIN(leave),
compile.c~:					diobj->operand_size, diobj->operands);
compile.c~:	    INSN *popiobj = new_insn_core(iseq, iobj->line_no,
compile.c~:		 (piobj->insn_id == BIN(branchif) ||
compile.c~:		  piobj->insn_id == BIN(branchunless))) {
compile.c~:		piobj->insn_id = (piobj->insn_id == BIN(branchif))
compile.c~:		REMOVE_ELEM(&iobj->link);
compile.c~:    if (iobj->insn_id == BIN(branchif) ||
compile.c~:	iobj->insn_id == BIN(branchunless)) {
compile.c~:	if (nobj->insn_id == BIN(jump)) {
compile.c~:    if (do_tailcallopt && iobj->insn_id == BIN(leave)) {
compile.c~:	if (piobj->insn_id == BIN(send) &&
compile.c~:	    piobj->operands[2] == 0 /* block */
compile.c~:	    piobj->operands[3] = INT2FIX(FIX2INT(piobj->operands[3]) | VM_CALL_TAILCALL_BIT);
compile.c~:    iobj->insn_id = insn_id;
compile.c~:    iobj->operand_size = 0;
compile.c~:    iobj->insn_id = insn_id;
compile.c~:    iobj->operand_size = n;
compile.c~:	iobj->operands[i] = Qnil;
compile.c~:    if (iobj->insn_id == BIN(send)) {
compile.c~:    const int do_peepholeopt = iseq->compile_data->option->peephole_optimization;
compile.c~:    const int do_tailcallopt = iseq->compile_data->option->tailcall_optimization;
compile.c~:    const int do_si = iseq->compile_data->option->specialized_instruction;
compile.c~:    const int do_ou = iseq->compile_data->option->operands_unification;
compile.c~:	if (list->type == ISEQ_ELEMENT_INSN) {
compile.c~:	list = list->next;
compile.c~:	argc += iobj->operand_size;
compile.c~:	list = list->next;
compile.c~:	MEMCPY(ptr, iobj->operands, VALUE, iobj->operand_size);
compile.c~:	ptr += iobj->operand_size;
compile.c~:	list = list->next;
compile.c~:    return new_insn_core(iseq, iobj->line_no, insn_id, argc, operands);
compile.c~:	if (list->type == ISEQ_ELEMENT_INSN) {
compile.c~:	    id = iobj->insn_id;
compile.c~:		    LINK_ELEMENT *li = list->next;
compile.c~:			if (li->type != ISEQ_ELEMENT_INSN ||
compile.c~:			    ((INSN *)li)->insn_id != unified[k]) {
compile.c~:			li = li->next;
compile.c~:			new_unified_insn(iseq, unified[0], unified[1] - 1,
compile.c~:		    niobj->link.prev = (LINK_ELEMENT *)iobj->link.prev;
compile.c~:		    niobj->link.next = li;
compile.c~:			li->prev = (LINK_ELEMENT *)niobj;
compile.c~:		    list->prev->next = (LINK_ELEMENT *)niobj;
compile.c~:	list = list->next;
compile.c~:    insn_id = iobj->insn_id;
compile.c~:    iobj->insn_id = SC_INSN(insn_id, state);
compile.c~:    nstate = SC_NEXT(iobj->insn_id);
compile.c~:	if (lobj->sc_state != 0) {
compile.c~:	    if (lobj->sc_state != nstate) {
compile.c~:		printf("\n-- %d, %d\n", lobj->sc_state, nstate);
compile.c~:		rb_compile_error(RSTRING_PTR(iseq->filename), iobj->line_no,
compile.c~:	    lobj->sc_state = nstate;
compile.c~:    if (lobj->sc_state != 0) {
compile.c~:	if (lobj->sc_state != state) {
compile.c~:	    state = lobj->sc_state;
compile.c~:	lobj->sc_state = state;
compile.c~:	switch (list->type) {
compile.c~:		insn_id = iobj->insn_id;
compile.c~:			    list = list->next;
compile.c~:			    rb_compile_error(RSTRING_PTR(iseq->filename), iobj->line_no,
compile.c~:			list = list->next;
compile.c~:	list = list->next;
compile.c~:    NODE *list = node->nd_next;
compile.c~:    VALUE lit = node->nd_lit;
compile.c~:    ADD_INSN1(ret, nd_line(node), putobject, node->nd_lit);
compile.c~:	COMPILE(ret, "each string", list->nd_head);
compile.c~:	list = list->nd_next;
compile.c~:    ADD_INSN2(ret, nd_line(node), toregexp, INT2FIX(node->nd_cflag), INT2FIX(cnt));
compile.c~:	    compile_branch_condition(iseq, ret, cond->nd_1st, label,
compile.c~:	    compile_branch_condition(iseq, ret, cond->nd_2nd, then_label,
compile.c~:	    compile_branch_condition(iseq, ret, cond->nd_1st, then_label,
compile.c~:	    compile_branch_condition(iseq, ret, cond->nd_2nd, then_label,
compile.c~:  //unsigned long flag=n->flags;
compile.c~:  switch(nd_type(n)-1){
compile.c~:     n->u1.value = ID2SYM(n->nd_mid);
compile.c~:    n->u1.value = ID2SYM(n->nd_vid);
compile.c~:  n->flags = 0;
compile.c~:  n->flags |= T_NODE;
compile.c~:    n->u1.value = ID2SYM(n->nd_mid);
compile.c~:    printf("id: %s\n", rb_id2name(n->nd_mid));
compile.c~:    n->u1.value = ID2SYM(n->nd_vid);
compile.c~:  n->u2.value = 0;
compile.c~:  n->u3.value = 0;
compile.c~:    int len = node->nd_alen, line = nd_line(node), i=0;
compile.c~:	   switch(nd_type(node->nd_head)-1){
compile.c~:	      var2sym(node->nd_head);
compile.c~:	      COMPILE_(anchor, "array element", node->nd_head, poped);
compile.c~:	    /*if(nd_type(node->nd_head)-1==NODE_LVAR){
compile.c~:	      //printf("id: %s\n", rb_id2name(node->nd_head->nd_vid));
compile.c~:	      var2sym(node->nd_head);
compile.c~:	      //ADD_INSN1(anchor, nd_line(node->nd_head), putobject, ID2SYM(node->nd_head->nd_vid));
compile.c~:	      COMPILE_(anchor, "array element", node->nd_head, poped);
compile.c~:	      COMPILE_(anchor, "array element", node->nd_head, poped);
compile.c~:	    if (opt_p && nd_type(node->nd_head) != NODE_LIT) {
compile.c~:	    node = node->nd_next;
compile.c~:	    rb_bug("node error: compile_array (%d: %d-%d)",
compile.c~:		rb_ary_push(ary, node->nd_head->nd_lit);
compile.c~:		node = node->nd_next;
compile.c~:    int len = node->nd_alen, line = nd_line(node), i=0;
compile.c~:	    if (opt_p && nd_type(node->nd_head) != NODE_LIT) {
compile.c~:	    COMPILE_(anchor, "array element", node->nd_head, poped);
compile.c~:	    node = node->nd_next;
compile.c~:	    rb_bug("node error: compile_array (%d: %d-%d)",
compile.c~:		rb_ary_push(ary, node->nd_head->nd_lit);
compile.c~:		node = node->nd_next;
compile.c~:	VALUE v = node->nd_lit;
compile.c~:	return node->nd_lit;
compile.c~:	val = vals->nd_head;
compile.c~:	ADD_SEND(cond_seq, nd_line(val), ID2SYM(rb_intern("patern-match")), INT2FIX(1));
compile.c~:	vals = vals->nd_next;
compile.c~:	val = vals->nd_head;
compile.c~:	vals = vals->nd_next;
compile.c~:	dupidx = iobj->operands[1];
compile.c~:	iobj->operands[1] = dupidx;
compile.c~:	compile_massign_opt_lhs(iseq, ret, lhsn->nd_next);
compile.c~:	compile_massign_lhs(iseq, ret, lhsn->nd_head);
compile.c~:	NODE *ln = lhsn->nd_head;
compile.c~:	    MEMORY(ln->nd_vid);
compile.c~:	    MEMORY(ln->nd_vid);
compile.c~:	lhsn = lhsn->nd_next;
compile.c~:	    COMPILE_POPED(ret, "masgn val (poped)", rhsn->nd_head);
compile.c~:	    COMPILE(ret, "masgn val", rhsn->nd_head);
compile.c~:	rhsn = rhsn->nd_next;
compile.c~:	for (i=0; i<llen-rlen; i++) {
compile.c~:    NODE *rhsn = node->nd_value;
compile.c~:    NODE *splatn = node->nd_args;
compile.c~:    NODE *lhsn = node->nd_head;
compile.c~:    int lhs_splat = (splatn && (VALUE)splatn != (VALUE)-1) ? 1 : 0;
compile.c~:	    compile_massign_lhs(iseq, lhsseq, lhsn->nd_head);
compile.c~:	    lhsn = lhsn->nd_next;
compile.c~:		NODE *postn = splatn->nd_2nd;
compile.c~:		NODE *restn = splatn->nd_1st;
compile.c~:		int num = postn->nd_alen;
compile.c~:		int flag = 0x02 | (((VALUE)restn == (VALUE)-1) ? 0x00 : 0x01);
compile.c~:		if ((VALUE)restn != (VALUE)-1) {
compile.c~:		    compile_massign_lhs(iseq, ret, postn->nd_head);
compile.c~:		    postn = postn->nd_next;
compile.c~:	debugi("compile_colon2 - colon", node->nd_vid);
compile.c~:	ADD_INSN1(body, nd_line(node), getconstant, ID2SYM(node->nd_vid));
compile.c~:	debugi("compile_colon2 - colon3", node->nd_mid);
compile.c~:	ADD_INSN1(body, nd_line(node), getconstant, ID2SYM(node->nd_mid));
compile.c~:	compile_colon2(iseq, node->nd_head, pref, body);
compile.c~:	debugi("compile_colon2 - colon2", node->nd_mid);
compile.c~:	ADD_INSN1(body, nd_line(node), getconstant, ID2SYM(node->nd_mid));
compile.c~:    else if (cpath->nd_head) {
compile.c~:	COMPILE(ret, "nd_else->nd_head", cpath->nd_head);
compile.c~:	    defined_expr(iseq, ret, vals->nd_head, lfinish, Qfalse);
compile.c~:	} while ((vals = vals->nd_next) != NULL);
compile.c~:	estr = "local-variable";
compile.c~:		  ID2SYM(node->nd_vid), needstr);
compile.c~:		  ((VALUE)node->nd_entry) | 1, needstr);
compile.c~:		  ID2SYM(node->nd_vid), needstr);
compile.c~:		  ID2SYM(node->nd_vid), needstr);
compile.c~:	defined_expr(iseq, ret, node->nd_head, lfinish, Qfalse);
compile.c~:	if (rb_is_const_id(node->nd_mid)) {
compile.c~:	    COMPILE(ret, "defined/colon2#nd_head", node->nd_head);
compile.c~:		      ID2SYM(node->nd_mid), needstr);
compile.c~:	    COMPILE(ret, "defined/colon2#nd_head", node->nd_head);
compile.c~:		      ID2SYM(node->nd_mid), needstr);
compile.c~:		  INT2FIX(DEFINED_CONST), ID2SYM(node->nd_mid), needstr);
compile.c~:	    if (node->nd_recv == (NODE *)1) break;
compile.c~:	if (node->nd_args) {
compile.c~:	    defined_expr(iseq, ret, node->nd_args, lfinish, Qfalse);
compile.c~:							   iseq->name),
compile.c~:	    defined_expr(iseq, ret, node->nd_recv, lfinish, Qfalse);
compile.c~:	    COMPILE(ret, "defined/recv", node->nd_recv);
compile.c~:		      ID2SYM(node->nd_mid), needstr);
compile.c~:		      ID2SYM(node->nd_mid), needstr);
compile.c~:		  INT2FIX((node->nd_nth << 1) | (type == NODE_BACK_REF)),
compile.c~:    if (iseq->parent_iseq != 0) {
compile.c~:	while (ip->local_iseq != ip) {
compile.c~:	    if (ip->type == ISEQ_TYPE_BLOCK) {
compile.c~:	    ip = ip->parent_iseq;
compile.c~:	return rb_sprintf("block in %s", RSTRING_PTR(ip->name));
compile.c~:	return rb_sprintf("block (%d levels) in %s", level, RSTRING_PTR(ip->name));
compile.c~:    enl->ensure_node = node;
compile.c~:    enl->prev = iseq->compile_data->ensure_node_stack;	/* prev */
compile.c~:    enl->erange = er;
compile.c~:    iseq->compile_data->ensure_node_stack = enl;
compile.c~:    while (erange->next != 0) {
compile.c~:	erange = erange->next;
compile.c~:    ne->next = 0;
compile.c~:    ne->begin = lend;
compile.c~:    ne->end = erange->end;
compile.c~:    erange->end = lstart;
compile.c~:    erange->next = ne;
compile.c~:	iseq->compile_data->ensure_node_stack;
compile.c~:	if (enlp->erange != 0) {
compile.c~:	    add_ensure_range(iseq, enlp->erange, lstart, lend);
compile.c~:	    iseq->compile_data->ensure_node_stack = enlp->prev;
compile.c~:	    COMPILE_POPED(ensure_part, "ensure part", enlp->ensure_node);
compile.c~:	enlp = enlp->prev;
compile.c~:    iseq->compile_data->ensure_node_stack = prev_enlp;
compile.c~:	COMPILE(arg_block, "block", argn->nd_body);
compile.c~:	argn = argn->nd_head;
compile.c~:	    COMPILE(args, "args (splat)", argn->nd_head);
compile.c~:	    int next_is_array = (nd_type(argn->nd_head) == NODE_ARRAY);
compile.c~:	    COMPILE(tmp, "args (cat: splat)", argn->nd_body);
compile.c~:		argc = INT2FIX(compile_array(iseq, args, argn->nd_head, Qfalse) + 1);
compile.c~:		argn = argn->nd_head;
compile.c~:	    ADD_INSN(ret, iseq->compile_data->last_line, putnil);
compile.c~:    iseq->compile_data->last_line = nd_line(node);
compile.c~:    if (node->flags & NODE_FL_NEWLINE) {
compile.c~:	    COMPILE_(ret, "BLOCK body", node->nd_head,
compile.c~:		     (node->nd_next == 0 && poped == 0) ? 0 : 1);
compile.c~:	    node = node->nd_next;
compile.c~:	    COMPILE_(ret, "BLOCK next", node->nd_next, poped);
compile.c~:	compile_branch_condition(iseq, cond_seq, node->nd_cond,
compile.c~:	COMPILE_(then_seq, "then", node->nd_body, poped);
compile.c~:	COMPILE_(else_seq, "else", node->nd_else, poped);
compile.c~:	if (node->nd_head == 0) {
compile.c~:	    COMPILE_(ret, "when", node->nd_body, poped);
compile.c~:	COMPILE(head, "match base", node->nd_head);
compile.c~:	node = node->nd_body;
compile.c~:	    COMPILE_(body_seq, "when body", node->nd_body, poped);
compile.c~:	    vals = node->nd_head;
compile.c~:	    node = node->nd_next;
compile.c~:	if (node->nd_head == 0) {
compile.c~:	    COMPILE_(ret, "when", node->nd_body, poped);
compile.c~:	COMPILE(head, "case base", node->nd_head);
compile.c~:	node = node->nd_body;
compile.c~:	    COMPILE_(body_seq, "when body", node->nd_body, poped);
compile.c~:	    vals = node->nd_head;
compile.c~:	    node = node->nd_next;
compile.c~:	    COMPILE_(body_seq, "when", node->nd_body, poped);
compile.c~:	    vals = node->nd_head;
compile.c~:		    val = vals->nd_head;
compile.c~:		    vals = vals->nd_next;
compile.c~:		NODE *val = vals->nd_head;
compile.c~:		    NODE *vs = vals->nd_head;
compile.c~:		    val = vals->nd_body;
compile.c~:			NODE* val = vs->nd_head;
compile.c~:			vs = vs->nd_next;
compile.c~:	    node = node->nd_next;
compile.c~:	LABEL *prev_start_label = iseq->compile_data->start_label;
compile.c~:	LABEL *prev_end_label = iseq->compile_data->end_label;
compile.c~:	LABEL *prev_redo_label = iseq->compile_data->redo_label;
compile.c~:	VALUE prev_loopval_popped = iseq->compile_data->loopval_popped;
compile.c~:	LABEL *next_label = iseq->compile_data->start_label = NEW_LABEL(nd_line(node));	/* next  */
compile.c~:	LABEL *redo_label = iseq->compile_data->redo_label = NEW_LABEL(nd_line(node));	/* redo  */
compile.c~:	LABEL *break_label = iseq->compile_data->end_label = NEW_LABEL(nd_line(node));	/* break */
compile.c~:	iseq->compile_data->loopval_popped = 0;
compile.c~:	if (type == NODE_OPT_N || node->nd_state == 1) {
compile.c~:	COMPILE_POPED(ret, "while body", node->nd_body);
compile.c~:	    compile_branch_condition(iseq, ret, node->nd_cond,
compile.c~:	    compile_branch_condition(iseq, ret, node->nd_cond,
compile.c~:	if (node->nd_state == Qundef) {
compile.c~:			iseq->compile_data->redo_label);
compile.c~:	iseq->compile_data->start_label = prev_start_label;
compile.c~:	iseq->compile_data->end_label = prev_end_label;
compile.c~:	iseq->compile_data->redo_label = prev_redo_label;
compile.c~:	iseq->compile_data->loopval_popped = prev_loopval_popped;
compile.c~:	iseq->compile_data->ensure_node_stack = iseq->compile_data->ensure_node_stack->prev;
compile.c~:	VALUE prevblock = iseq->compile_data->current_block;
compile.c~:	    COMPILE(ret, "iter caller (for)", node->nd_iter);
compile.c~:	    iseq->compile_data->current_block =
compile.c~:		NEW_CHILD_ISEQVAL(node->nd_body, make_name_for_block(iseq),
compile.c~:		       iseq->compile_data->current_block, INT2FIX(0));
compile.c~:	    iseq->compile_data->current_block =
compile.c~:		NEW_CHILD_ISEQVAL(node->nd_body, make_name_for_block(iseq),
compile.c~:	    COMPILE(ret, "iter caller", node->nd_iter);
compile.c~:	iseq->compile_data->current_block = prevblock;
compile.c~:	if (iseq->compile_data->redo_label != 0) {
compile.c~:	    ADD_ADJUST(ret, nd_line(node), iseq->compile_data->redo_label);
compile.c~:	    COMPILE_(ret, "break val (while/until)", node->nd_stts, iseq->compile_data->loopval_popped);
compile.c~:	    ADD_INSNL(ret, nd_line(node), jump, iseq->compile_data->end_label);
compile.c~:	else if (iseq->type == ISEQ_TYPE_BLOCK) {
compile.c~:	    COMPILE(ret, "break val (block)", node->nd_stts);
compile.c~:	else if (iseq->type == ISEQ_TYPE_EVAL) {
compile.c~:	    rb_iseq_t *ip = iseq->parent_iseq;
compile.c~:		if (!ip->compile_data) {
compile.c~:		if (ip->compile_data->redo_label != 0) {
compile.c~:		    if (ip->compile_data->loopval_popped == 0) {
compile.c~:		else if (ip->type == ISEQ_TYPE_BLOCK) {
compile.c~:		else if (ip->type == ISEQ_TYPE_EVAL) {
compile.c~:		ip = ip->parent_iseq;
compile.c~:	if (iseq->compile_data->redo_label != 0) {
compile.c~:	    COMPILE(ret, "next val/valid syntax?", node->nd_stts);
compile.c~:	    ADD_ADJUST(ret, nd_line(node), iseq->compile_data->redo_label);
compile.c~:	    ADD_INSNL(ret, nd_line(node), jump, iseq->compile_data->start_label);
compile.c~:	else if (iseq->compile_data->end_label) {
compile.c~:	    ADD_ADJUST(ret, nd_line(node), iseq->compile_data->start_label);
compile.c~:	    COMPILE(ret, "next val", node->nd_stts);
compile.c~:	    ADD_INSNL(ret, nd_line(node), jump, iseq->compile_data->end_label);
compile.c~:	else if (iseq->type == ISEQ_TYPE_EVAL) {
compile.c~:		if (!ip->compile_data) {
compile.c~:		if (ip->compile_data->redo_label != 0) {
compile.c~:		else if (ip->type == ISEQ_TYPE_BLOCK) {
compile.c~:		else if (ip->type == ISEQ_TYPE_EVAL) {
compile.c~:		ip = ip->parent_iseq;
compile.c~:		COMPILE(ret, "next val", node->nd_stts);
compile.c~:	if (iseq->compile_data->redo_label) {
compile.c~:	    ADD_ADJUST(ret, nd_line(node), iseq->compile_data->redo_label);
compile.c~:	    ADD_INSNL(ret, nd_line(node), jump, iseq->compile_data->redo_label);
compile.c~:	else if (iseq->type == ISEQ_TYPE_EVAL) {
compile.c~:	else if (iseq->compile_data->start_label) {
compile.c~:	    ADD_ADJUST(ret, nd_line(node), iseq->compile_data->start_label);
compile.c~:	    ADD_INSNL(ret, nd_line(node), jump, iseq->compile_data->start_label);
compile.c~:		if (!ip->compile_data) {
compile.c~:		if (ip->compile_data->redo_label != 0) {
compile.c~:		else if (ip->type == ISEQ_TYPE_BLOCK) {
compile.c~:		else if (ip->type == ISEQ_TYPE_EVAL) {
compile.c~:		ip = ip->parent_iseq;
compile.c~:	if (iseq->type == ISEQ_TYPE_RESCUE) {
compile.c~:	COMPILE_(ret, "NODE_BEGIN", node->nd_body, poped);
compile.c~:	    node->nd_resq,
compile.c~:	    rb_str_concat(rb_str_new2("rescue in "), iseq->name),
compile.c~:	COMPILE(ret, "rescue head", node->nd_head);
compile.c~:	if (node->nd_else) {
compile.c~:	    COMPILE(ret, "rescue else", node->nd_else);
compile.c~:	    narg = resq->nd_args;
compile.c~:			COMPILE(ret, "rescue arg", narg->nd_head);
compile.c~:			narg = narg->nd_next;
compile.c~:	    COMPILE(ret, "resbody body", resq->nd_body);
compile.c~:	    if (iseq->compile_data->option->tailcall_optimization) {
compile.c~:	    resq = resq->nd_head;
compile.c~:	VALUE ensure = NEW_CHILD_ISEQVAL(node->nd_ensr,
compile.c~:						       iseq->name),
compile.c~:	COMPILE_POPED(ensr, "ensure ensr", node->nd_ensr);
compile.c~:	push_ensure_entry(iseq, &enl, &er, node->nd_ensr);
compile.c~:	COMPILE_(ret, "ensure head", node->nd_head, poped);
compile.c~:	if (ensr->anchor.next == 0) {
compile.c~:	erange = iseq->compile_data->ensure_node_stack->erange;
compile.c~:	    ADD_CATCH_ENTRY(CATCH_TYPE_ENSURE, erange->begin, erange->end,
compile.c~:	    erange = erange->next;
compile.c~:	iseq->compile_data->ensure_node_stack = enl.prev;
compile.c~:	COMPILE(ret, "nd_1st", node->nd_1st);
compile.c~:	COMPILE_(ret, "nd_2nd", node->nd_2nd, poped);
compile.c~:	ID id = node->nd_vid;
compile.c~:	int idx = iseq->local_iseq->local_size - get_local_var_idx(iseq, id);
compile.c~:	COMPILE(ret, "rvalue", node->nd_value);
compile.c~:	COMPILE(ret, "dvalue", node->nd_value);
compile.c~:	debugp_param("dassn id", rb_str_new2(rb_id2name(node->nd_vid) ? rb_id2name(node->nd_vid) : "*"));
compile.c~:	idx = get_dyna_var_idx(iseq, node->nd_vid, &lv, &ls);
compile.c~:	    rb_bug("NODE_DASGN(_CURR): unknown id (%s)", rb_id2name(node->nd_vid));
compile.c~:		  INT2FIX(ls - idx), INT2FIX(lv));
compile.c~:	COMPILE(ret, "lvalue", node->nd_value);
compile.c~:		  (((long)node->nd_entry) | 1));
compile.c~:	COMPILE(ret, "lvalue", node->nd_value);
compile.c~:		  ID2SYM(node->nd_vid));
compile.c~:	COMPILE(ret, "lvalue", node->nd_value);
compile.c~:	if (node->nd_vid) {
compile.c~:	    ADD_INSN1(ret, nd_line(node), setconstant, ID2SYM(node->nd_vid));
compile.c~:	    compile_cpath(ret, iseq, node->nd_else);
compile.c~:	    ADD_INSN1(ret, nd_line(node), setconstant, ID2SYM(node->nd_else->nd_mid));
compile.c~:	COMPILE(ret, "cvasgn val", node->nd_value);
compile.c~:		  ID2SYM(node->nd_vid));
compile.c~:	ID id = node->nd_mid;
compile.c~:	 * nd_recv[nd_args->nd_body] (nd_mid)= nd_args->nd_head;
compile.c~:	 *              nd_args->nd_head
compile.c~:	 *              nd_args->nd_body
compile.c~:	COMPILE(ret, "NODE_OP_ASGN1 recv", node->nd_recv);
compile.c~:	if (nd_type(node->nd_args->nd_body) != NODE_ZARRAY) {
compile.c~:	    argc = setup_args(iseq, args, node->nd_args->nd_body, &flag);
compile.c~:	    COMPILE(ret, "NODE_OP_ASGN1 args->head: ", node->nd_args->nd_head);
compile.c~:	    COMPILE(ret, "NODE_OP_ASGN1 args->head: ", node->nd_args->nd_head);
compile.c~:	ID atype = node->nd_next->nd_mid;
compile.c~:	COMPILE(ret, "NODE_OP_ASGN2#recv", node->nd_recv);
compile.c~:	ADD_SEND(ret, nd_line(node), ID2SYM(node->nd_next->nd_vid),
compile.c~:	    COMPILE(ret, "NODE_OP_ASGN2 val", node->nd_value);
compile.c~:	    ADD_SEND(ret, nd_line(node), ID2SYM(node->nd_next->nd_aid),
compile.c~:	    COMPILE(ret, "NODE_OP_ASGN2 val", node->nd_value);
compile.c~:	    ADD_SEND(ret, nd_line(node), ID2SYM(node->nd_next->nd_mid),
compile.c~:	    ADD_SEND(ret, nd_line(node), ID2SYM(node->nd_next->nd_aid),
compile.c~:	    defined_expr(iseq, ret, node->nd_head, lfinish, Qfalse);
compile.c~:	COMPILE(ret, "NODE_OP_ASGN_AND/OR#nd_head", node->nd_head);
compile.c~:	COMPILE(ret, "NODE_OP_ASGN_AND/OR#nd_value", node->nd_value);
compile.c~:	ID mid = node->nd_mid;
compile.c~:	VALUE parent_block = iseq->compile_data->current_block;
compile.c~:	iseq->compile_data->current_block = Qfalse;
compile.c~:		if (nd_type(node->nd_args->nd_head) == NODE_LIT &&
compile.c~:		    SYMBOL_P(node->nd_args->nd_head->nd_lit)) {
compile.c~:		    label_sym = label = node->nd_args->nd_head->nd_lit;
compile.c~:			 rb_hash_aref(iseq->compile_data,
compile.c~:			rb_hash_aset(iseq->compile_data, label_sym,
compile.c~:	    COMPILE(recv, "recv", node->nd_recv);
compile.c~:	    argc = setup_args(iseq, args, node->nd_args, &flag);
compile.c~:	VALUE parent_block = iseq->compile_data->current_block;
compile.c~:	iseq->compile_data->current_block = Qfalse;
compile.c~:	    argc = setup_args(iseq, args, node->nd_args, &flag);
compile.c~:	    rb_iseq_t *liseq = iseq->local_iseq;
compile.c~:	    argc = INT2FIX(liseq->argc);
compile.c~:	    for (i = 0; i < liseq->argc; i++) {
compile.c~:		int idx = liseq->local_size - i;
compile.c~:	    if (!liseq->arg_simple) {
compile.c~:		if (liseq->arg_opts) {
compile.c~:		    for (j = 0; j < liseq->arg_opts - 1; j++) {
compile.c~:			int idx = liseq->local_size - (i + j);
compile.c~:		if (liseq->arg_rest != -1) {
compile.c~:		    int idx = liseq->local_size - liseq->arg_rest;
compile.c~:		    argc = INT2FIX(liseq->arg_rest + 1);
compile.c~:		if (liseq->arg_post_len) {
compile.c~:		    int post_len = liseq->arg_post_len;
compile.c~:		    int post_start = liseq->arg_post_start;
compile.c~:		    if (liseq->arg_rest != -1) {
compile.c~:			    int idx = liseq->local_size - (post_start + j);
compile.c~:			    int idx = liseq->local_size - (post_start + j);
compile.c~:	    COMPILE(ret, "values item", n->nd_head);
compile.c~:	    n = n->nd_next;
compile.c~:	ADD_INSN1(ret, nd_line(node), newarray, INT2FIX(node->nd_alen));
compile.c~:	int type = node->nd_head ? nd_type(node->nd_head) : NODE_ZARRAY;
compile.c~:	    compile_array(iseq, list, node->nd_head, Qfalse);
compile.c~:	    if (is->type == ISEQ_TYPE_TOP || is->type == ISEQ_TYPE_CLASS) {
compile.c~:		if (is->type == ISEQ_TYPE_METHOD) {
compile.c~:		COMPILE(ret, "return nd_stts (return val)", node->nd_stts);
compile.c~:		if (is->type == ISEQ_TYPE_METHOD) {
compile.c~:	if (iseq->type == ISEQ_TYPE_TOP || iseq->type == ISEQ_TYPE_CLASS) {
compile.c~:	if (node->nd_head) {
compile.c~:	    argc = setup_args(iseq, args, node->nd_head, &flag);
compile.c~:	    ID id = node->nd_vid;
compile.c~:	    int idx = iseq->local_iseq->local_size - get_local_var_idx(iseq, id);
compile.c~:	debugi("nd_vid", node->nd_vid);
compile.c~:	    idx = get_dyna_var_idx(iseq, node->nd_vid, &lv, &ls);
compile.c~:		rb_bug("unknown dvar (%s)", rb_id2name(node->nd_vid));
compile.c~:	    ADD_INSN2(ret, nd_line(node), getdynamic, INT2FIX(ls - idx), INT2FIX(lv));
compile.c~:		  (((long)node->nd_entry) | 1));
compile.c~:	debugi("nd_vid", node->nd_vid);
compile.c~:		      ID2SYM(node->nd_vid));
compile.c~:	debugi("nd_vid", node->nd_vid);
compile.c~:	if (iseq->compile_data->option->inline_const_cache) {
compile.c~:	    ADD_INSN1(ret, nd_line(node), getconstant, ID2SYM(node->nd_vid));
compile.c~:	    ADD_INSN1(ret, nd_line(node), getconstant, ID2SYM(node->nd_vid));
compile.c~:		      ID2SYM(node->nd_vid));
compile.c~:		      INT2FIX(node->nd_nth << 1));
compile.c~:		      INT2FIX(0x01 | (node->nd_nth << 1)));
compile.c~:	    ADD_INSN1(recv, nd_line(node), putobject, node->nd_lit);
compile.c~:	    COMPILE(recv, "reciever", node->nd_recv);
compile.c~:	    COMPILE(val, "value", node->nd_value);
compile.c~:	    COMPILE(recv, "reciever", node->nd_value);
compile.c~:	    COMPILE(val, "value", node->nd_recv);
compile.c~:	if (iseq->compile_data->option->specialized_instruction) {
compile.c~:	    if (recv->last == recv->anchor.next &&
compile.c~:		INSN_OF(recv->last) == BIN(putobject) &&
compile.c~:			  OPERAND_AT(recv->last, 0));
compile.c~:	debugp_param("lit", node->nd_lit);
compile.c~:	    ADD_INSN1(ret, nd_line(node), putobject, node->nd_lit);
compile.c~:	debugp_param("nd_lit", node->nd_lit);
compile.c~:	    hide_obj(node->nd_lit);
compile.c~:	    ADD_INSN1(ret, nd_line(node), putstring, node->nd_lit);
compile.c~:	ADD_INSN1(ret, nd_line(node), putobject, node->nd_lit);
compile.c~:	COMPILE(ret, "nd_body", node->nd_body);
compile.c~:	COMPILE(ret, "argscat head", node->nd_head);
compile.c~:	COMPILE(ret, "argscat body", node->nd_body);
compile.c~:	COMPILE(ret, "arsgpush head", node->nd_head);
compile.c~:	COMPILE(ret, "argspush body", node->nd_body);
compile.c~:	COMPILE(ret, "splat", node->nd_head);
compile.c~:	VALUE iseqval = NEW_ISEQVAL(node->nd_defn,
compile.c~:				    rb_str_dup(rb_id2str(node->nd_mid)),
compile.c~:	ADD_INSN1(ret, nd_line(node), putobject, ID2SYM(node->nd_mid));
compile.c~:	VALUE iseqval = NEW_ISEQVAL(node->nd_defn,
compile.c~:				    rb_str_dup(rb_id2str(node->nd_mid)),
compile.c~:	COMPILE(ret, "defs: recv", node->nd_recv);
compile.c~:	ADD_INSN1(ret, nd_line(node), putobject, ID2SYM(node->nd_mid));
compile.c~:	COMPILE(ret, "alias arg1", node->u1.node);
compile.c~:	COMPILE(ret, "alias arg2", node->u2.node);
compile.c~:	ADD_INSN1(ret, nd_line(node), putobject, ID2SYM(node->u1.id));
compile.c~:	ADD_INSN1(ret, nd_line(node), putobject, ID2SYM(node->u2.id));
compile.c~:	COMPILE(ret, "undef arg", node->u2.node);
compile.c~:		node->nd_body,
compile.c~:		rb_sprintf("<class:%s>", rb_id2name(node->nd_cpath->nd_mid)),
compile.c~:	compile_cpath(ret, iseq, node->nd_cpath);
compile.c~:	COMPILE(ret, "super", node->nd_super);
compile.c~:		  ID2SYM(node->nd_cpath->nd_mid), iseqval, INT2FIX(0));
compile.c~:	    node->nd_body,
compile.c~:	    rb_sprintf("<module:%s>", rb_id2name(node->nd_cpath->nd_mid)),
compile.c~:	compile_cpath(ret, iseq, node->nd_cpath);
compile.c~:		  ID2SYM(node->nd_cpath->nd_mid), iseqval, INT2FIX(2));
compile.c~:	    NEW_ISEQVAL(node->nd_body, rb_str_new2("singletonclass"),
compile.c~:	COMPILE(ret, "sclass#recv", node->nd_recv);
compile.c~:	if (rb_is_const_id(node->nd_mid)) {
compile.c~:		if (iseq->compile_data->option->inline_const_cache) {
compile.c~:		if (iseq->compile_data->option->inline_const_cache) {
compile.c~:	    COMPILE(ret, "colon2#nd_head", node->nd_head);
compile.c~:	    ADD_CALL(ret, nd_line(node), ID2SYM(node->nd_mid),
compile.c~:	debugi("colon3#nd_mid", node->nd_mid);
compile.c~:	if (iseq->compile_data->option->inline_const_cache) {
compile.c~:	ADD_INSN1(ret, nd_line(node), getconstant, ID2SYM(node->nd_mid));
compile.c~:	if (iseq->compile_data->option->inline_const_cache) {
compile.c~:	COMPILE(ret, "min", (NODE *) node->nd_beg);
compile.c~:	COMPILE(ret, "max", (NODE *) node->nd_end);
compile.c~:	VALUE key = rb_sprintf("flipflag/%s-%p-%d",
compile.c~:			       RSTRING_PTR(iseq->name), (void *)iseq,
compile.c~:			       iseq->compile_data->flip_cnt++);
compile.c~:	COMPILE(ret, "flip2 beg", node->nd_beg);
compile.c~:	COMPILE(ret, "flip2 end", node->nd_end);
compile.c~:	    if (iseq->type == ISEQ_TYPE_RESCUE) {
compile.c~:		    if (ip->type == ISEQ_TYPE_RESCUE) {
compile.c~:		    ip = ip->parent_iseq;
compile.c~:	    defined_expr(iseq, ret, node->nd_head, lfinish, Qtrue);
compile.c~:	VALUE block = NEW_CHILD_ISEQVAL(node->nd_body, make_name_for_block(iseq), ISEQ_TYPE_BLOCK);
compile.c~:	argc = setup_args(iseq, args, node->nd_args, &flag);
compile.c~:	if (node->nd_recv == (NODE *) 1) {
compile.c~:	    COMPILE(recv, "recv", node->nd_recv);
compile.c~:	debugp_param("nd_mid", ID2SYM(node->nd_mid));
compile.c~:	ADD_SEND_R(ret, nd_line(node), ID2SYM(node->nd_mid), argc, 0, LONG2FIX(flag));
compile.c~:	iseq->compile_data->start_label = next_label;
compile.c~:	iseq->compile_data->redo_label = redo_label;
compile.c~:	COMPILE_(ret, "optblock body", node->nd_head, 1 /* pop */ );
compile.c~:	COMPILE_POPED(ret, "prelude", node->nd_head);
compile.c~:	COMPILE_(ret, "body", node->nd_body, poped);
compile.c~:	VALUE block = NEW_CHILD_ISEQVAL(node->nd_body, make_name_for_block(iseq), ISEQ_TYPE_BLOCK);
compile.c~:    return insn_len(iobj->insn_id);
compile.c~:    return insn_stack_increase(depth, insn->insn_id, insn->operands);
compile.c~:    return insn_len(iobj->line_no);
compile.c~:    str = rb_sprintf("%-16s", insn_name(iobj->insn_id));
compile.c~:    if (iobj->operands) {
compile.c~:	const char *types = insn_op_types(iobj->insn_id);
compile.c~:		    rb_str_catf(str, "<L%03d>", lobj->label_no);
compile.c~:			val = iseq->self;
compile.c~:		    rb_str_cat2(str, rb_id2name(entry->id));
compile.c~:    printf("-- raw disasm--------\n");
compile.c~:	switch (link->type) {
compile.c~:		printf("%04d %-65s(%4d)\n", pos, StringValueCStr(str),
compile.c~:		printf("<L%03d>\n", lobj->label_no);
compile.c~:		printf("adjust: [label: %d]\n", adjust->label->label_no);
compile.c~:	    rb_raise(rb_eSyntaxError, "dump_disasm_list error: %ld\n", FIX2LONG(link->type));
compile.c~:	link = link->next;
compile.c~:    printf("---------------------\n");
compile.c~:	    eiseqval = ruby_iseq_load(ptr[1], iseq->self, Qnil);
compile.c~:     * index -> LABEL *label
compile.c~:	    int argc = RARRAY_LEN(obj) - 1;
compile.c~:		rb_compile_error(RSTRING_PTR(iseq->filename), line_no,
compile.c~:	    if (argc != insn_len(insn_id)-1) {
compile.c~:		rb_compile_error(RSTRING_PTR(iseq->filename), line_no,
compile.c~:				    argv[j] = ruby_iseq_load(op, iseq->self, Qnil);
compile.c~:    iseq->local_table_size = RARRAY_LEN(locals);
compile.c~:    iseq->local_table = tbl = (ID *)ALLOC_N(ID *, iseq->local_table_size);
compile.c~:    iseq->local_size = iseq->local_table_size + 1;
compile.c~:	iseq->arg_size = iseq->argc = FIX2INT(args);
compile.c~:	iseq->arg_simple = 1;
compile.c~:	iseq->argc = FIX2INT(argc);
compile.c~:	iseq->arg_rest = FIX2INT(arg_rest);
compile.c~:	iseq->arg_post_len = FIX2INT(arg_post_len);
compile.c~:	iseq->arg_post_start = FIX2INT(arg_post_start);
compile.c~:	iseq->arg_block = FIX2INT(arg_block);
compile.c~:	iseq->arg_opts = RARRAY_LEN(arg_opt_labels);
compile.c~:	iseq->arg_opt_table = (VALUE *)ALLOC_N(VALUE, iseq->arg_opts);
compile.c~:	if (iseq->arg_block != -1) {
compile.c~:	    iseq->arg_size = iseq->arg_block + 1;
compile.c~:	else if (iseq->arg_post_len) {
compile.c~:	    iseq->arg_size = iseq->arg_post_start + iseq->arg_post_len;
compile.c~:	else if (iseq->arg_rest != -1) {
compile.c~:	    iseq->arg_size = iseq->arg_rest + 1;
compile.c~:	    iseq->arg_size = iseq->argc + (iseq->arg_opts ? iseq->arg_opts - 1 : 0);
compile.c~:	    iseq->arg_opt_table[i] =
compile.c~:	iseq->arg_simple = NUM2INT(arg_simple);
compile.c~:    return iseq->self;
compile.c~:    if (th->base_block && (iseq = th->base_block->iseq)) {
compile.c~:	while (iseq->type == ISEQ_TYPE_BLOCK ||
compile.c~:	       iseq->type == ISEQ_TYPE_RESCUE ||
compile.c~:	       iseq->type == ISEQ_TYPE_ENSURE ||
compile.c~:	       iseq->type == ISEQ_TYPE_EVAL ||
compile.c~:	       iseq->type == ISEQ_TYPE_MAIN
compile.c~:	    for (i = 0; i < iseq->local_table_size; i++) {
compile.c~:		if (iseq->local_table[i] == id) {
compile.c~:	    iseq = iseq->parent_iseq;
compile.c~:    if (th->base_block && th->base_block->iseq) {
compile.c~:	iseq = th->base_block->iseq->local_iseq;
compile.c~:	for (i=0; i<iseq->local_table_size; i++) {
compile.c~:	    if (iseq->local_table[i] == id) {
compile.c~:    return GET_THREAD()->parse_in_eval > 0;
compile.c~:    return GET_THREAD()->parse_in_eval < 0;
ãã¤ããªã¼ã»ãã¡ã¤ã«compile.oã¯ä¸è´ãã¾ãã
complex.c:	long c = FIX2LONG(x) - FIX2LONG(y);
complex.c:	    c = -1;
complex.c:    return rb_funcall(x, '-', 1, y);
complex.c:    obj->real = real;
complex.c:    obj->imag = imag;
complex.c:				     f_sub(real, dat->imag),
complex.c:				     f_add(ZERO, dat->real));
complex.c:				     dat->real,
complex.c:				     f_add(dat->imag, imag));
complex.c:				     f_sub(adat->real, bdat->imag),
complex.c:				     f_add(adat->imag, bdat->real));
complex.c:			      f_mul(m_cos_bang(dat->real),
complex.c:				    m_cosh_bang(dat->imag)),
complex.c:			      f_mul(f_negate(m_sin_bang(dat->real)),
complex.c:				    m_sinh_bang(dat->imag)));
complex.c:			      f_mul(m_sin_bang(dat->real),
complex.c:				    m_cosh_bang(dat->imag)),
complex.c:			      f_mul(m_cos_bang(dat->real),
complex.c:				    m_sinh_bang(dat->imag)));
complex.c:	if (f_negative_p(dat->imag))
complex.c:				  m_sqrt_bang(f_div(f_add(a, dat->real), TWO)),
complex.c:				  m_sqrt_bang(f_div(f_sub(a, dat->real), TWO)));
complex.c:    return dat->real;
complex.c:    return dat->imag;
complex.c:			f_negate(dat->real), f_negate(dat->imag));
complex.c:	real = f_add(adat->real, bdat->real);
complex.c:	imag = f_add(adat->imag, bdat->imag);
complex.c:			      f_add(dat->real, other), dat->imag);
complex.c:	real = f_sub(adat->real, bdat->real);
complex.c:	imag = f_sub(adat->imag, bdat->imag);
complex.c:			      f_sub(dat->real, other), dat->imag);
complex.c:    return rb_num_coerce_bin(self, other, '-');
complex.c:	real = f_sub(f_mul(adat->real, bdat->real),
complex.c:		     f_mul(adat->imag, bdat->imag));
complex.c:	imag = f_add(f_mul(adat->real, bdat->imag),
complex.c:		      f_mul(adat->imag, bdat->real));
complex.c:			      f_mul(dat->real, other),
complex.c:			      f_mul(dat->imag, other));
complex.c:	if (TYPE(adat->real)  == T_FLOAT ||
complex.c:	    TYPE(adat->imag) == T_FLOAT ||
complex.c:	    TYPE(bdat->real)  == T_FLOAT ||
complex.c:	    TYPE(bdat->imag) == T_FLOAT) {
complex.c:	    VALUE magn = m_hypot(bdat->real, bdat->imag);
complex.c:					    f_div(bdat->real, magn),
complex.c:					    f_div(bdat->imag, magn));
complex.c:			      f_div(dat->real, other),
complex.c:			      f_div(dat->imag, other));
complex.c:				f_to_f(dat->real),
complex.c:				f_to_f(dat->imag)), other);
complex.c:	ore = dat->real;
complex.c:	oim = dat->imag;
complex.c:				       f_sub(f_mul(dat->real, dat->real),
complex.c:					     f_mul(dat->imag, dat->imag)),
complex.c:				       f_mul(f_mul(TWO, dat->real), dat->imag));
complex.c:	return f_boolcast(f_equal_p(adat->real, bdat->real) &&
complex.c:			  f_equal_p(adat->imag, bdat->imag));
complex.c:	return f_boolcast(f_equal_p(dat->real, other) && f_zero_p(dat->imag));
complex.c:    return m_hypot(dat->real, dat->imag);
complex.c:    return f_add(f_mul(dat->real, dat->real),
complex.c:		 f_mul(dat->imag, dat->imag));
complex.c:    return m_atan2_bang(dat->imag, dat->real);
complex.c:    return rb_assoc_new(dat->real, dat->imag);
complex.c:    return f_complex_new2(CLASS_OF(self), dat->real, f_negate(dat->imag));
complex.c:    return f_boolcast(f_exact_p(dat->real) && f_exact_p(dat->imag));
complex.c:    return rb_lcm(f_denominator(dat->real), f_denominator(dat->imag));
complex.c:			  f_mul(f_numerator(dat->real),
complex.c:				f_div(cd, f_denominator(dat->real))),
complex.c:			  f_mul(f_numerator(dat->imag),
complex.c:				f_div(cd, f_denominator(dat->imag))));
complex.c:    return f_xor(f_hash(dat->real), f_hash(dat->imag));
complex.c:	return f_boolcast((CLASS_OF(adat->real) == CLASS_OF(bdat->real)) &&
complex.c:			  (CLASS_OF(adat->imag) == CLASS_OF(bdat->imag)) &&
complex.c:	  return f_boolcast(s[0] == '-');
complex.c:    impos = f_tpositive_p(dat->imag);
complex.c:    s = (*func)(dat->real);
complex.c:    rb_str_cat2(s, !impos ? "-" : "+");
complex.c:    rb_str_concat(s, (*func)(f_abs(dat->imag)));
complex.c:    if (!rb_isdigit(RSTRING_PTR(s)[RSTRING_LEN(s) - 1]))
complex.c:    a = rb_assoc_new(dat->real, dat->imag);
complex.c:    dat->real = RARRAY_PTR(a)[0];
complex.c:    dat->imag = RARRAY_PTR(a)[1];
complex.c:/* --- */
complex.c:    if (k_inexact_p(dat->imag) || f_nonzero_p(dat->imag)) {
complex.c:    return f_to_i(dat->real);
complex.c:    if (k_inexact_p(dat->imag) || f_nonzero_p(dat->imag)) {
complex.c:    return f_to_f(dat->real);
complex.c:    if (k_inexact_p(dat->imag) || f_nonzero_p(dat->imag)) {
complex.c:    return f_to_r(dat->real);
complex.c:#define NUMERATOR "(?:" DIGITS "?\\.)?" DIGITS "(?:[eE][-+]?" DIGITS ")?"
complex.c:#define NUMBER "[-+]?" NUMERATOR "(?:\\/" DENOMINATOR ")?"
complex.c:#define PATTERN1 "\\A" WS "([-+])?(" NUMBER ")?[iIjJ]" WS
complex.c:#define PATTERN2 "\\A" WS "(" NUMBER ")(([-+])(" NUMBERNOS ")?[iIjJ])?" WS
complex.c:    comp_pat0 = rb_reg_new(comp_pat0_source, sizeof comp_pat0_source - 1, 0);
complex.c:    comp_pat1 = rb_reg_new(comp_pat1_source, sizeof comp_pat1_source - 1, 0);
complex.c:    comp_pat2 = rb_reg_new(comp_pat2_source, sizeof comp_pat2_source - 1, 0);
complex.c:				 sizeof underscores_pat_source - 1, 0);
complex.c:	    if (k_exact_p(dat->imag) && f_zero_p(dat->imag))
complex.c:		a1 = dat->real;
complex.c:	    if (k_exact_p(dat->imag) && f_zero_p(dat->imag))
complex.c:		a2 = dat->real;
complex.c:/* --- */
complex.c: * call-seq:
complex.c: *    num.arg    ->  0 or float
complex.c: *    num.angle  ->  0 or float
complex.c: *    num.phase  ->  0 or float
complex.c: * call-seq:
complex.c: *    flo.arg    ->  0 or float
complex.c: *    flo.angle  ->  0 or float
complex.c: *    flo.phase  ->  0 or float
complex.c: *    Complex.polar(2, 3)  #=> (-1.9799849932008908+0.2822400161197344i)
complex.c: * You can also create complex object from floating-point numbers or
complex.c: *    Complex('0.3-0.5i')  #=> (0.3-0.5i)
complex.c: *    Complex('1@2')       #=> (-0.4161468365471424+0.9092974268256817i)
complex.c: *    '0.3-0.5i'.to_c      #=> (0.3-0.5i)
complex.c: *    '1@2'.to_c           #=> (-0.4161468365471424+0.9092974268256817i)
complex.c:    id_negate = rb_intern("-@");
complex.c:    rb_define_private_method(CLASS_OF(rb_cComplex), "new!", nucomp_s_new_bang, -1);
complex.c:    rb_define_private_method(CLASS_OF(rb_cComplex), "new", nucomp_s_new, -1);
complex.c:    rb_define_singleton_method(rb_cComplex, "rectangular", nucomp_s_new, -1);
complex.c:    rb_define_singleton_method(rb_cComplex, "rect", nucomp_s_new, -1);
complex.c:    rb_define_global_function("Complex", nucomp_f_complex, -1);
complex.c:    rb_define_method(rb_cComplex, "-@", nucomp_negate, 0);
complex.c:    rb_define_method(rb_cComplex, "-", nucomp_sub, 1);
complex.c:    /* --- */
complex.c:    rb_define_private_method(CLASS_OF(rb_cComplex), "convert", nucomp_s_convert, -1);
complex.c:    /* --- */
complex.c:c-file-style: "ruby"
ãã¤ããªã¼ã»ãã¡ã¤ã«complex.oã¯ä¸è´ãã¾ãã
config.guess:timestamp='2008-08-10'
config.guess:# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
config.guess:# 02110-1301, USA.
config.guess:# Please send patches to <config-patches@gnu.org>.  Submit a context
config.guess:me=`echo "$0" | sed -e 's,.*/,,'`
config.guess:  -h, --help         print this help, then exit
config.guess:  -t, --time-stamp   print date of last modification, then exit
config.guess:  -v, --version      print version number, then exit
config.guess:Report bugs and patches to <config-patches@gnu.org>."
config.guess:Try \`$me --help' for more information."
config.guess:while test $# -gt 0 ; do
config.guess:    --time-stamp | --time* | -t )
config.guess:    --version | -v )
config.guess:    --help | --h* | -h )
config.guess:    -- )     # Stop option processing
config.guess:    - )	# Use stdin as input.
config.guess:    -* )
config.guess:# CC_FOR_BUILD -- compiler used by this script. Note that the use of a
config.guess:trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
config.guess:trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
config.guess: { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
config.guess: { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
config.guess: { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo "Warning: creating insecure temp directory" >&2 ; } ||
config.guess:	  if ($c -c -o $dummy.o $dummy.c) >/dev/null 2>&1 ; then
config.guess:# (ghazi@noc.rutgers.edu 1994-08-24)
config.guess:if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
config.guess:UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
config.guess:UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
config.guess:UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
config.guess:UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
config.guess:# Note: order is significant - the case branches are not exclusive.
config.guess:	# more of the tupples: *-*-netbsdelf*, *-*-netbsdaout*,
config.guess:	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
config.guess:	# switched to ELF, *-*-netbsd* would select the old
config.guess:	sysctl="sysctl -n hw.machine_arch"
config.guess:	    armeb) machine=armeb-unknown ;;
config.guess:	    arm*) machine=arm-unknown ;;
config.guess:	    sh3el) machine=shl-unknown ;;
config.guess:	    sh3eb) machine=sh-unknown ;;
config.guess:	    sh5el) machine=sh5le-unknown ;;
config.guess:	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
config.guess:		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
config.guess:	# suitable tag, in the style of linux-gnu.
config.guess:		release='-gnu'
config.guess:		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
config.guess:	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
config.guess:	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
config.guess:	echo "${machine}-${os}${release}"
config.guess:	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
config.guess:	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
config.guess:	echo ${UNAME_MACHINE}-unknown-solidbsd${UNAME_RELEASE}
config.guess:	echo powerpc-unknown-mirbsd${UNAME_RELEASE}
config.guess:	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
config.guess:		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
config.guess:	        UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
config.guess:	# types through head -n 1, so we only detect the type of CPU 0.
config.guess:	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
config.guess:	# 1.2 uses "1.2" for uname -r.
config.guess:	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
config.guess:	echo alpha-pc-interix
config.guess:	echo alpha-dec-winnt3.5
config.guess:	echo m68k-unknown-sysv4
config.guess:	echo ${UNAME_MACHINE}-unknown-amigaos
config.guess:	echo ${UNAME_MACHINE}-unknown-morphos
config.guess:	echo i370-ibm-openedition
config.guess:	echo s390-ibm-zvmoe
config.guess:        echo powerpc-ibm-os400
config.guess:	echo arm-acorn-riscix${UNAME_RELEASE}
config.guess:	echo arm-unknown-riscos
config.guess:    SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
config.guess:	echo hppa1.1-hitachi-hiuxmpp
config.guess:    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
config.guess:		echo pyramid-pyramid-sysv3
config.guess:		echo pyramid-pyramid-bsd
config.guess:	echo pyramid-pyramid-svr4
config.guess:	echo sparc-icl-nx6
config.guess:	case `/usr/bin/uname -p` in
config.guess:	    sparc) echo sparc-icl-nx7; exit ;;
config.guess:	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
config.guess:	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
config.guess:	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
config.guess:	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
config.guess:	case "`/usr/bin/arch -k`" in
config.guess:		UNAME_RELEASE=`uname -v`
config.guess:	# Japanese Language versions have a version number like `4.1.3-JL'.
config.guess:	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
config.guess:	echo m68k-sun-sunos${UNAME_RELEASE}
config.guess:		echo m68k-sun-sunos${UNAME_RELEASE}
config.guess:		echo sparc-sun-sunos${UNAME_RELEASE}
config.guess:	echo sparc-auspex-sunos${UNAME_RELEASE}
config.guess:        echo m68k-atari-mint${UNAME_RELEASE}
config.guess:	echo m68k-atari-mint${UNAME_RELEASE}
config.guess:        echo m68k-atari-mint${UNAME_RELEASE}
config.guess:        echo m68k-milan-mint${UNAME_RELEASE}
config.guess:        echo m68k-hades-mint${UNAME_RELEASE}
config.guess:        echo m68k-unknown-mint${UNAME_RELEASE}
config.guess:	echo m68k-apple-machten${UNAME_RELEASE}
config.guess:	echo powerpc-apple-machten${UNAME_RELEASE}
config.guess:	echo mips-dec-mach_bsd4.3
config.guess:	echo mips-dec-ultrix${UNAME_RELEASE}
config.guess:	echo vax-dec-ultrix${UNAME_RELEASE}
config.guess:	echo clipper-intergraph-clix${UNAME_RELEASE}
config.guess:	  printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
config.guess:	  printf ("mips-mips-riscos%ssvr4\n", argv[1]); exit (0);
config.guess:	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
config.guess:	  exit (-1);
config.guess:	$CC_FOR_BUILD -o $dummy $dummy.c &&
config.guess:	  dummyarg=`echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` &&
config.guess:	echo mips-mips-riscos${UNAME_RELEASE}
config.guess:	echo powerpc-motorola-powermax
config.guess:    Motorola:*:4.3:PL8-*)
config.guess:	echo powerpc-harris-powermax
config.guess:	echo powerpc-harris-powermax
config.guess:	echo powerpc-harris-powerunix
config.guess:	echo m88k-harris-cxux7
config.guess:	echo m88k-motorola-sysv4
config.guess:	echo m88k-motorola-sysv3
config.guess:        UNAME_PROCESSOR=`/usr/bin/uname -p`
config.guess:		echo m88k-dg-dgux${UNAME_RELEASE}
config.guess:		echo m88k-dg-dguxbcs${UNAME_RELEASE}
config.guess:	    echo i586-dg-dgux${UNAME_RELEASE}
config.guess:	echo m88k-dolphin-sysv3
config.guess:	echo m88k-motorola-sysv3
config.guess:	echo m88k-tektronix-sysv3
config.guess:    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
config.guess:	echo m68k-tektronix-bsd
config.guess:	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
config.guess:	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
config.guess:	exit ;;               # Note that: echo "'`uname -s`'" gives 'AIX '
config.guess:	echo i386-ibm-aix
config.guess:	if [ -x /usr/bin/oslevel ] ; then
config.guess:	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
config.guess:			puts("powerpc-ibm-aix3.2.5");
config.guess:		if $CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy`
config.guess:			echo rs6000-ibm-aix3.2.5
config.guess:		echo rs6000-ibm-aix3.2.4
config.guess:		echo rs6000-ibm-aix3.2
config.guess:	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
config.guess:	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
config.guess:	if [ -x /usr/bin/oslevel ] ; then
config.guess:	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
config.guess:	echo rs6000-ibm-aix
config.guess:    ibmrt:4.4BSD:*|romp-ibm:BSD:*)
config.guess:	echo romp-ibm-bsd4.4
config.guess:    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
config.guess:	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
config.guess:	exit ;;                             # report: romp-ibm BSD 4.3
config.guess:	echo rs6000-bull-bosx
config.guess:	echo m68k-bull-sysv3
config.guess:	echo m68k-hp-bsd
config.guess:	echo m68k-hp-bsd4.4
config.guess:    9000/[34678]??:HP-UX:*:*)
config.guess:	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
config.guess:	    9000/[678][0-9][0-9])
config.guess:		if [ -x /usr/bin/getconf ]; then
config.guess:			  '') HP_ARCH="hppa2.0" ;;   # HP-UX 10.20
config.guess:		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
config.guess:		    test -z "$HP_ARCH" && HP_ARCH=hppa
config.guess:	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
config.guess:	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
config.guess:	    # generating 64-bit code.  GNU and HP use different nomenclature:
config.guess:	    # => hppa2.0w-hp-hpux11.23
config.guess:	    # => hppa64-hp-hpux11.23
config.guess:	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
config.guess:	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
config.guess:    ia64:HP-UX:*:*)
config.guess:	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
config.guess:	echo ia64-hp-hpux${HPUX_REV}
config.guess:    3050*:HI-UX:*:*)
config.guess:		  case CPU_PA_RISC1_0: puts ("hppa1.0-hitachi-hiuxwe2"); break;
config.guess:		  case CPU_PA_RISC1_1: puts ("hppa1.1-hitachi-hiuxwe2"); break;
config.guess:		  case CPU_PA_RISC2_0: puts ("hppa2.0-hitachi-hiuxwe2"); break;
config.guess:		  default: puts ("hppa-hitachi-hiuxwe2"); break;
config.guess:	    puts ("m68k-hitachi-hiuxwe2");
config.guess:	  else puts ("unknown-hitachi-hiuxwe2");
config.guess:	$CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy` &&
config.guess:	echo unknown-hitachi-hiuxwe2
config.guess:	echo hppa1.1-hp-bsd
config.guess:	echo hppa1.0-hp-bsd
config.guess:	echo hppa1.0-hp-mpeix
config.guess:	echo hppa1.1-hp-osf
config.guess:	echo hppa1.0-hp-osf
config.guess:	if [ -x /usr/sbin/sysversion ] ; then
config.guess:	    echo ${UNAME_MACHINE}-unknown-osf1mk
config.guess:	    echo ${UNAME_MACHINE}-unknown-osf1
config.guess:	echo hppa1.1-hp-lites
config.guess:	echo c1-convex-bsd
config.guess:	if getsysinfo -f scalar_acc
config.guess:	then echo c32-convex-bsd
config.guess:	else echo c2-convex-bsd
config.guess:	echo c34-convex-bsd
config.guess:	echo c38-convex-bsd
config.guess:	echo c4-convex-bsd
config.guess:    CRAY*Y-MP:*:*:*)
config.guess:	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
config.guess:    CRAY*[A-Z]90:*:*:*)
config.guess:	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
config.guess:	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
config.guess:	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
config.guess:	      -e 's/\.[^.]*$/.X/'
config.guess:	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
config.guess:	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
config.guess:	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
config.guess:	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
config.guess:	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
config.guess:        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
config.guess:        FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
config.guess:        echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
config.guess:        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
config.guess:        FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
config.guess:        echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
config.guess:	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
config.guess:	echo sparc-unknown-bsdi${UNAME_RELEASE}
config.guess:	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
config.guess:		echo i386-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
config.guess:		echo x86_64-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
config.guess:		echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
config.guess:	echo ${UNAME_MACHINE}-pc-cygwin
config.guess:	echo ${UNAME_MACHINE}-pc-mingw32
config.guess:    	# uname -m includes "-pc" on this system.
config.guess:    	echo ${UNAME_MACHINE}-mingw32
config.guess:	echo ${UNAME_MACHINE}-pc-pw32
config.guess:		echo i586-pc-interix${UNAME_RELEASE}
config.guess:		echo x86_64-unknown-interix${UNAME_RELEASE}
config.guess:		echo ia64-unknown-interix${UNAME_RELEASE}
config.guess:	echo i${UNAME_MACHINE}-pc-mks
config.guess:	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
config.guess:	echo i586-pc-interix
config.guess:	echo ${UNAME_MACHINE}-pc-uwin
config.guess:	echo x86_64-unknown-cygwin
config.guess:	echo powerpcle-unknown-cygwin
config.guess:	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
config.guess:	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
config.guess:	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
config.guess:	echo ${UNAME_MACHINE}-pc-minix
config.guess:	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
config.guess:	    | grep -q __ARM_EABI__
config.guess:	    echo ${UNAME_MACHINE}-unknown-linux-gnu
config.guess:	    echo ${UNAME_MACHINE}-unknown-linux-gnueabi
config.guess:	echo ${UNAME_MACHINE}-unknown-linux-gnu
config.guess:	echo cris-axis-linux-gnu
config.guess:	echo crisv32-axis-linux-gnu
config.guess:    	echo frv-unknown-linux-gnu
config.guess:	echo ${UNAME_MACHINE}-unknown-linux-gnu
config.guess:	echo ${UNAME_MACHINE}-unknown-linux-gnu
config.guess:	echo ${UNAME_MACHINE}-unknown-linux-gnu
config.guess:	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
config.guess:	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
config.guess:	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
config.guess:	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
config.guess:	echo or32-unknown-linux-gnu
config.guess:	echo powerpc-unknown-linux-gnu
config.guess:	echo powerpc64-unknown-linux-gnu
config.guess:	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
config.guess:	objdump --private-headers /bin/sh | grep ld.so.1 >/dev/null
config.guess:	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
config.guess:	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
config.guess:	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
config.guess:	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
config.guess:	  *)    echo hppa-unknown-linux-gnu ;;
config.guess:	echo hppa64-unknown-linux-gnu
config.guess:	echo ${UNAME_MACHINE}-ibm-linux
config.guess:    	echo ${UNAME_MACHINE}-unknown-linux-gnu
config.guess:	echo ${UNAME_MACHINE}-unknown-linux-gnu
config.guess:	echo ${UNAME_MACHINE}-unknown-linux-gnu
config.guess:	echo ${UNAME_MACHINE}-dec-linux-gnu
config.guess:	echo x86_64-unknown-linux-gnu
config.guess:    	echo ${UNAME_MACHINE}-unknown-linux-gnu
config.guess:	ld_supported_targets=`cd /; LC_ALL=C ld --help 2>&1 \
config.guess:			 | sed -ne '/supported targets:/!d
config.guess:	  elf32-i386)
config.guess:		TENTATIVE="${UNAME_MACHINE}-pc-linux-gnu"
config.guess:	  a.out-i386-linux)
config.guess:		echo "${UNAME_MACHINE}-pc-linux-gnuaout"
config.guess:	  coff-i386)
config.guess:		echo "${UNAME_MACHINE}-pc-linux-gnucoff"
config.guess:		# Either a pre-BFD a.out linker (linux-gnuoldld) or
config.guess:		# one that does not give us useful --help.
config.guess:		echo "${UNAME_MACHINE}-pc-linux-gnuoldld"
config.guess:	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
config.guess:		echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
config.guess:	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
config.guess:	echo i386-sequent-sysv4
config.guess:	# I just have to hope.  -- rms.
config.guess:	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
config.guess:	echo ${UNAME_MACHINE}-pc-os2-emx
config.guess:    i*86:XTS-300:*:STOP)
config.guess:	echo ${UNAME_MACHINE}-unknown-stop
config.guess:	echo ${UNAME_MACHINE}-unknown-atheos
config.guess:	echo ${UNAME_MACHINE}-pc-syllable
config.guess:	echo i386-unknown-lynxos${UNAME_RELEASE}
config.guess:	echo ${UNAME_MACHINE}-pc-msdosdjgpp
config.guess:		echo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}
config.guess:		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
config.guess:	case `/bin/uname -X | grep "^Machine"` in
config.guess:	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
config.guess:	if test -f /usr/options/cb.name; then
config.guess:		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
config.guess:		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
config.guess:	elif /bin/uname -X 2>/dev/null >/dev/null ; then
config.guess:		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
config.guess:		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
config.guess:		(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \
config.guess:		(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \
config.guess:		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
config.guess:		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
config.guess:		echo ${UNAME_MACHINE}-pc-sysv32
config.guess:        # uname -m prints for DJGPP always 'pc', but it prints nothing about
config.guess:	echo i386-pc-msdosdjgpp
config.guess:	echo i386-pc-mach3
config.guess:	echo i860-intel-osf1
config.guess:    i860:*:4.*:*) # i860-SVR4
config.guess:	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
config.guess:	else # Add other i860-SVR4 vendors below as they are discovered.
config.guess:	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
config.guess:	echo m68010-convergent-sysv
config.guess:	echo m68k-convergent-sysv
config.guess:    M680?0:D-NIX:5.3:*)
config.guess:	echo m68k-diab-dnix
config.guess:	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
config.guess:	test -r /etc/.relid \
config.guess:	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
config.guess:	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
config.guess:	  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
config.guess:	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
config.guess:	  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
config.guess:        /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
config.guess:          && { echo i486-ncr-sysv4; exit; } ;;
config.guess:	echo m68k-unknown-lynxos${UNAME_RELEASE}
config.guess:	echo m68k-atari-sysv4
config.guess:	echo sparc-unknown-lynxos${UNAME_RELEASE}
config.guess:	echo rs6000-unknown-lynxos${UNAME_RELEASE}
config.guess:	echo powerpc-unknown-lynxos${UNAME_RELEASE}
config.guess:	echo mips-dde-sysv${UNAME_RELEASE}
config.guess:    RM*:ReliantUNIX-*:*:*)
config.guess:	echo mips-sni-sysv4
config.guess:    RM*:SINIX-*:*:*)
config.guess:	echo mips-sni-sysv4
config.guess:    *:SINIX-*:*:*)
config.guess:	if uname -p 2>/dev/null >/dev/null ; then
config.guess:		UNAME_MACHINE=`(uname -p) 2>/dev/null`
config.guess:		echo ${UNAME_MACHINE}-sni-sysv4
config.guess:		echo ns32k-sni-sysv
config.guess:        echo i586-unisys-sysv4
config.guess:	# How about differentiating between stratus architectures? -djm
config.guess:	echo hppa1.1-stratus-sysv4
config.guess:	echo i860-stratus-sysv4
config.guess:	echo ${UNAME_MACHINE}-stratus-vos
config.guess:	echo hppa1.1-stratus-vos
config.guess:	echo m68k-apple-aux${UNAME_RELEASE}
config.guess:    news*:NEWS-OS:6*:*)
config.guess:	echo mips-sony-newsos6
config.guess:	if [ -d /usr/nec ]; then
config.guess:	        echo mips-nec-sysv${UNAME_RELEASE}
config.guess:	        echo mips-unknown-sysv${UNAME_RELEASE}
config.guess:	echo powerpc-be-beos
config.guess:	echo powerpc-apple-beos
config.guess:	echo i586-pc-beos
config.guess:	echo powerpc-apple-haiku
config.guess:	echo i586-pc-haiku
config.guess:    SX-4:SUPER-UX:*:*)
config.guess:	echo sx4-nec-superux${UNAME_RELEASE}
config.guess:    SX-5:SUPER-UX:*:*)
config.guess:	echo sx5-nec-superux${UNAME_RELEASE}
config.guess:    SX-6:SUPER-UX:*:*)
config.guess:	echo sx6-nec-superux${UNAME_RELEASE}
config.guess:    SX-7:SUPER-UX:*:*)
config.guess:	echo sx7-nec-superux${UNAME_RELEASE}
config.guess:    SX-8:SUPER-UX:*:*)
config.guess:	echo sx8-nec-superux${UNAME_RELEASE}
config.guess:    SX-8R:SUPER-UX:*:*)
config.guess:	echo sx8r-nec-superux${UNAME_RELEASE}
config.guess:	echo powerpc-apple-rhapsody${UNAME_RELEASE}
config.guess:	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
config.guess:	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
config.guess:	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
config.guess:	UNAME_PROCESSOR=`uname -p`
config.guess:	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
config.guess:	echo i386-pc-qnx
config.guess:    NSE-?:NONSTOP_KERNEL:*:*)
config.guess:	echo nse-tandem-nsk${UNAME_RELEASE}
config.guess:    NSR-?:NONSTOP_KERNEL:*:*)
config.guess:	echo nsr-tandem-nsk${UNAME_RELEASE}
config.guess:    *:NonStop-UX:*:*)
config.guess:	echo mips-compaq-nonstopux
config.guess:	echo bs2000-siemens-sysv
config.guess:	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
config.guess:	# "uname -m" is not consistent, so use $cputype instead. 386
config.guess:	echo ${UNAME_MACHINE}-unknown-plan9
config.guess:    *:TOPS-10:*:*)
config.guess:	echo pdp10-unknown-tops10
config.guess:	echo pdp10-unknown-tenex
config.guess:    KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
config.guess:	echo pdp10-dec-tops20
config.guess:    XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
config.guess:	echo pdp10-xkl-tops20
config.guess:    *:TOPS-20:*:*)
config.guess:	echo pdp10-unknown-tops20
config.guess:	echo pdp10-unknown-its
config.guess:        echo mips-sei-seiux${UNAME_RELEASE}
config.guess:	echo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
config.guess:    	UNAME_MACHINE=`(uname -p) 2>/dev/null`
config.guess:	    A*) echo alpha-dec-vms ; exit ;;
config.guess:	    I*) echo ia64-dec-vms ; exit ;;
config.guess:	    V*) echo vax-dec-vms ; exit ;;
config.guess:	echo i386-pc-xenix
config.guess:	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
config.guess:	echo ${UNAME_MACHINE}-pc-rdos
config.guess:  printf ("mips-sony-bsd\n"); exit (0);
config.guess:  printf ("m68k-sony-newsos%s\n",
config.guess:  printf ("arm-acorn-riscix\n"); exit (0);
config.guess:  printf ("m68k-hp-bsd\n"); exit (0);
config.guess:  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
config.guess:    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
config.guess:    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
config.guess:  printf ("ns32k-encore-sysv\n"); exit (0);
config.guess:  printf ("ns32k-encore-mach\n"); exit (0);
config.guess:  printf ("ns32k-encore-bsd\n"); exit (0);
config.guess:  printf ("i386-pc-bsd\n"); exit (0);
config.guess:  printf ("i386-sequent-dynix\n"); exit (0);
config.guess:  printf ("ns32k-sequent-dynix\n"); exit (0);
config.guess:	printf ("i386-sequent-ptx2\n"); exit (0);
config.guess:	printf ("i386-sequent-ptx1\n"); exit (0);
config.guess:    printf ("i386-sequent-ptx\n"); exit (0);
config.guess:      printf ("vax-dec-bsd4.3\n"); exit (0);
config.guess:      printf ("vax-dec-bsd4.3reno\n"); exit (0);
config.guess:      printf ("vax-dec-bsd\n"); exit (0);
config.guess:    printf ("vax-dec-bsd\n"); exit (0);
config.guess:    printf ("vax-dec-ultrix\n"); exit (0);
config.guess:  printf ("i860-alliant-bsd\n"); exit (0);
config.guess:$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&
config.guess:test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }
config.guess:if [ -x /usr/convex/getsysinfo ]
config.guess:    case `getsysinfo -f cpu_type` in
config.guess:	echo c1-convex-bsd
config.guess:	if getsysinfo -f scalar_acc
config.guess:	then echo c32-convex-bsd
config.guess:	else echo c2-convex-bsd
config.guess:	echo c34-convex-bsd
config.guess:	echo c38-convex-bsd
config.guess:	echo c4-convex-bsd
config.guess:  http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.guess
config.guess:  http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.sub
config.guess:pertinent to <config-patches@gnu.org> in order to provide the needed
config.guess:uname -m = `(uname -m) 2>/dev/null || echo unknown`
config.guess:uname -r = `(uname -r) 2>/dev/null || echo unknown`
config.guess:uname -s = `(uname -s) 2>/dev/null || echo unknown`
config.guess:uname -v = `(uname -v) 2>/dev/null || echo unknown`
config.guess:/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`
config.guess:/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`
config.guess:/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`
config.guess:# eval: (add-hook 'write-file-hooks 'time-stamp)
config.guess:# time-stamp-start: "timestamp='"
config.guess:# time-stamp-format: "%:y-%02m-%02d"
config.guess:# time-stamp-end: "'"
config.log:## --------- ##
config.log:## --------- ##
config.log:uname -m = i686
config.log:uname -r = 2.6.24-24-generic
config.log:uname -s = Linux
config.log:uname -v = #1 SMP Tue Aug 18 17:04:53 UTC 2009
config.log:/usr/bin/uname -p = unknown
config.log:/bin/uname -X     = unknown
config.log:/usr/bin/arch -k       = unknown
config.log:## ----------- ##
config.log:## ----------- ##
config.log:configure:2087: result: i686-pc-linux-gnu
config.log:configure:2124: result: i686-pc-linux-gnu
config.log:configure:2161: result: i686-pc-linux-gnu
config.log:configure:2633: gcc --version >&5
config.log:gcc (GCC) 4.2.4 (Ubuntu 4.2.4-1ubuntu4)
config.log:configure:2644: gcc -v >&5
config.log:Using built-in specs.
config.log:Target: i486-linux-gnu
config.log:Configured with: ../src/configure -v --enable-languages=c,c++,fortran,objc,obj-c++,treelang --prefix=/usr --enable-shared --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --enable-nls --with-gxx-include-dir=/usr/include/c++/4.2 --program-suffix=-4.2 --enable-clocale=gnu --enable-libstdcxx-debug --enable-objc-gc --enable-mpfr --enable-targets=all --enable-checking=release --build=i486-linux-gnu --host=i486-linux-gnu --target=i486-linux-gnu
config.log:gcc version 4.2.4 (Ubuntu 4.2.4-1ubuntu4)
config.log:configure:2655: gcc -V >&5
config.log:gcc: '-V' option must have argument
config.log:configure:2817: gcc -o conftest    conftest.c  >&5
config.log:configure:2879: gcc -c   conftest.c >&5
config.log:configure:2941: gcc -c   conftest.c >&5
config.log:configure:2974: checking whether gcc accepts -g
config.log:configure:3004: gcc -c -g  conftest.c >&5
config.log:configure:3203: gcc  -c   conftest.c >&5
config.log:configure:3371: g++ --version >&5
config.log:configure:3382: g++ -v >&5
config.log:configure:3393: g++ -V >&5
config.log:configure:3429: g++ -c   conftest.cpp >&5
config.log:configure:3462: checking whether g++ accepts -g
config.log:configure:3492: g++ -c -g  conftest.cpp >&5
config.log:configure:3531: g++ -c   conftest.cpp >&5
config.log:configure:3571: g++ -c -g  conftest.cpp >&5
config.log:configure:3669: gcc -E  conftest.c
config.log:configure:3707: gcc -E  conftest.c
config.log:configure:3747: result: gcc -E
config.log:configure:3776: gcc -E  conftest.c
config.log:configure:3814: gcc -E  conftest.c
config.log:configure:3861: checking for grep that handles long lines and -e
config.log:configure:3990: result: /bin/grep -E
config.log:configure:3996: checking whether gcc needs -traditional
config.log:configure:4071: checking whether gcc -E accepts -o
config.log:configure:4091: gcc -E -o conftest.i conftest.c
config.log:configure:5165: checking whether ln -s works
config.log:configure:5221: checking for a BSD-compatible install
config.log:configure:5289: result: /usr/bin/install -c
config.log:configure:5332: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:5438: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c  >&5
config.log:configure:5515: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:5515: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:5515: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:5515: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:5515: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:5515: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:5515: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:5515: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:5515: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:5581: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:5621: gcc -E  conftest.c
config.log:configure:5736: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:5943: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:|  /* Check that off_t can represent 2**63 - 1 correctly.
config.log:| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
config.log:| 		      ? 1 : -1];
config.log:configure:5994: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:6195: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:6229: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:6297: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:6331: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:6682: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c  >&5
config.log:configure:7041: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c  >&5
config.log:configure:7400: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c  >&5
config.log:configure:7759: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c  >&5
config.log:configure:8118: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c  >&5
config.log:configure:8477: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c  >&5
config.log:configure:8836: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c  >&5
config.log:configure:9195: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c  >&5
config.log:configure:9554: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c  >&5
config.log:configure:9913: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c  >&5
config.log:configure:9993: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:10027: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:10102: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:| static int test_array [1 - 2 * !((rb_pid_t)-1 > 0)];
config.log:configure:10148: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:| static int test_array [1 - 2 * !(sizeof(rb_pid_t) > sizeof(long))];
config.log:configure:10195: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:10261: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:10295: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:10370: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:10416: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:| static int test_array [1 - 2 * !(sizeof(rb_uid_t) > sizeof(long))];
config.log:configure:10463: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:10529: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:10563: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:10638: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:10684: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:| static int test_array [1 - 2 * !(sizeof(rb_gid_t) > sizeof(long))];
config.log:configure:10731: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:10796: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:10853: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:10927: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:11001: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:11069: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:11126: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:11194: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:11267: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:11340: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:11413: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:11486: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:11559: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:11628: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c  >&5
config.log:configure:11699: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:11699: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:11762: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12099: checking for crypt in -lcrypt
config.log:configure:12134: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lcrypt  -lm  >&5
config.log:configure:12174: checking for dlopen in -ldl
config.log:configure:12209: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -ldl  -lcrypt -lm  >&5
config.log:configure:12249: checking for shl_load in -ldld
config.log:configure:12284: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -ldld  -ldl -lcrypt -lm  >&5
config.log:/usr/bin/ld: cannot find -ldld
config.log:configure:12324: checking for socketpair in -lsocket
config.log:configure:12359: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lsocket  -ldl -lcrypt -lm  >&5
config.log:/usr/bin/ld: cannot find -lsocket
config.log:configure:12399: checking for clock_gettime in -lrt
config.log:configure:12434: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt  -ldl -lcrypt -lm  >&5
config.log:configure:12525: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12605: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:12777: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:12878: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:12918: gcc -E  conftest.c
config.log:configure:13391: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:13470: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:13504: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:13855: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:14214: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:14292: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:14401: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:14517: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:14626: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:14666: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:14730: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:14770: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:14834: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:14874: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:14938: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:14978: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:15042: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:15082: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:15146: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:15186: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:15250: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:15290: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:15354: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:15394: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:15458: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:15498: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:15566: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:15603: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:15673: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:15707: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:15776: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:15846: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:15916: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:15986: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:16056: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:16126: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:16196: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:16266: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:16336: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:16406: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:16476: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:16546: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:16616: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:16687: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:16806: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:16892: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:16966: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17050: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17369: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17413: checking for broken erfc of glibc-2.3.6 on IA64
config.log:configure:17443: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17561: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17561: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:conftest.c:144: warning: conflicting types for built-in function 'memmove'
config.log:configure:17561: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17561: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:conftest.c:146: warning: conflicting types for built-in function 'strchr'
config.log:configure:17561: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:conftest.c:147: warning: conflicting types for built-in function 'strstr'
config.log:configure:17561: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17561: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17561: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:conftest.c:150: warning: conflicting types for built-in function 'vsnprintf'
config.log:configure:17561: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:conftest.c:151: warning: conflicting types for built-in function 'isnan'
config.log:configure:17561: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:conftest.c:152: warning: conflicting types for built-in function 'finite'
config.log:configure:17561: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:conftest.c:153: warning: conflicting types for built-in function 'isinf'
config.log:configure:17561: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:conftest.c:154: warning: conflicting types for built-in function 'hypot'
config.log:configure:17561: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:conftest.c:155: warning: conflicting types for built-in function 'acosh'
config.log:configure:17561: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:conftest.c:156: warning: conflicting types for built-in function 'erf'
config.log:configure:17561: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:conftest.c:157: warning: conflicting types for built-in function 'tgamma'
config.log:configure:17561: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17561: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:conftest.c:159: warning: conflicting types for built-in function 'cbrt'
config.log:configure:17561: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
config.log:configure:17561: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:conftest.c:160: warning: conflicting types for built-in function 'fmod'
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:conftest.c:164: warning: conflicting types for built-in function 'fork'
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:conftest.c:208: warning: conflicting types for built-in function 'snprintf'
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:conftest.c:213: warning: conflicting types for built-in function 'cosh'
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:conftest.c:214: warning: conflicting types for built-in function 'sinh'
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:conftest.c:215: warning: conflicting types for built-in function 'tanh'
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:conftest.c:216: warning: conflicting types for built-in function 'log2'
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:conftest.c:217: warning: conflicting types for built-in function 'round'
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:conftest.c:218: warning: conflicting types for built-in function 'signbit'
config.log:|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17762: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17831: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:17969: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:18032: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:18282: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:18339: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:18408: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:18449: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:18525: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:18669: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:configure:18737: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:18821: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:conftest.c:233: warning: incompatible implicit declaration of built-in function 'exit'
config.log:configure:19076: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:19143: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lrt -ldl -lcrypt -lm  >&5
config.log:| /* If this system has a BSD-style setpgrp which takes arguments,
config.log:|   setpgrp(1, 1) will fail with ESRCH and return -1, in that case
config.log:|   return setpgrp (1,1) != -1;
config.log:configure:19211: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:19268: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:19307: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:19591: checking for an ANSI C-conforming const
config.log:configure:19666: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:19727: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:19784: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:19857: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:19990: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:20054: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:| FILE *f = stdin; f->_cnt = 0;
config.log:configure:20054: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:| FILE *f = stdin; f->__cnt = 0;
config.log:configure:20054: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:| FILE *f = stdin; f->_r = 0;
config.log:configure:20054: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:| FILE *f = stdin; f->readCount = 0;
config.log:configure:20054: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:| FILE *f = stdin; f->_rcount = 0;
config.log:configure:20118: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:20182: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:20251: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:20312: gcc -c  -O2 -g -Wall -Wno-parentheses  conftest.c >&5
config.log:configure:20420: result: -1
config.log:configure:20430: checking for pthread_kill in -lthr
config.log:configure:20465: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lthr  -lrt -ldl -lcrypt -lm  >&5
config.log:/usr/bin/ld: cannot find -lthr
config.log:| #define STACK_GROW_DIRECTION -1
config.log:configure:20430: checking for pthread_kill in -lpthread
config.log:configure:20465: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lpthread  -lrt -ldl -lcrypt -lm  >&5
config.log:configure:20598: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lpthread -lrt -ldl -lcrypt -lm  >&5
config.log:configure:20598: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lpthread -lrt -ldl -lcrypt -lm  >&5
config.log:configure:20598: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lpthread -lrt -ldl -lcrypt -lm  >&5
config.log:configure:20786: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lpthread -lrt -ldl -lcrypt -lm  >&5
config.log:configure:20786: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lpthread -lrt -ldl -lcrypt -lm  >&5
config.log:configure:20909: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lpthread -lrt -ldl -lcrypt -lm  >&5
config.log:configure:21008: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lpthread -lrt -ldl -lcrypt -lm  >&5
config.log:configure:21247: gcc -o conftest  -O2 -g -Wall -Wno-parentheses   conftest.c -lpthread -lrt -ldl -lcrypt -lm  >&5
config.log:## ---------------------- ##
config.log:## ---------------------- ##
config.log:## ---------------- ##
config.log:## ---------------- ##
config.log:ac_cv_build=i686-pc-linux-gnu
config.log:ac_cv_host=i686-pc-linux-gnu
config.log:ac_cv_path_EGREP='/bin/grep -E'
config.log:ac_cv_path_install='/usr/bin/install -c'
config.log:ac_cv_prog_CPP='gcc -E'
config.log:ac_cv_target=i686-pc-linux-gnu
config.log:rb_cv_stack_grow_dir=-1
config.log:## ----------------- ##
config.log:## ----------------- ##
config.log:CCDLFLAGS=' -fPIC'
config.log:COUTFLAG='-o '
config.log:CPP='gcc -E'
config.log:CPPOUTFILE='-o conftest.i'
config.log:DEFS='-D_FILE_OFFSET_BITS=64'
config.log:DLDLIBS=' -lc'
config.log:ECHO_N='-n'
config.log:EGREP='/bin/grep -E'
config.log:INSTALL_DATA='${INSTALL} -m 644'
config.log:LDFLAGS='-L.  -rdynamic -Wl,-export-dynamic'
config.log:LDSHARED='${CC} -shared'
config.log:LDSHAREDXX='${CXX} -shared'
config.log:LIBPATHFLAG=' -L%1$-s'
config.log:LIBRUBYARG_SHARED='-Wl,-R -Wl,$(libdir) -L$(libdir) -l$(RUBY_SO_NAME)'
config.log:LIBRUBYARG_STATIC='-Wl,-R -Wl,$(libdir) -L$(libdir) -l$(RUBY_SO_NAME)-static'
config.log:LIBRUBY_A='lib$(RUBY_SO_NAME)-static.a'
config.log:LIBRUBY_LDSHARED='${CC} -shared'
config.log:LIBS='-lpthread -lrt -ldl -lcrypt -lm '
config.log:LN_S='ln -s'
config.log:MAKEDIRS='mkdir -p'
config.log:MINIRUBY='./miniruby$(EXEEXT) -I$(srcdir)/lib -I$(EXTOUT)/common -I./- -r$(srcdir)/ext/purelib.rb'
config.log:OUTFLAG='-o '
config.log:RDOCTARGET='install-doc'
config.log:RM='rm -f'
config.log:RMALL='rm -fr'
config.log:RPATHFLAG=' -Wl,-R%1$-s'
config.log:RUNRUBY='$(MINIRUBY) $(srcdir)/runruby.rb --extout=$(EXTOUT)'
config.log:STRIP='strip -S -x'
config.log:XCFLAGS=' -DRUBY_EXPORT'
config.log:arch='i686-linux'
config.log:build='i686-pc-linux-gnu'
config.log:build_os='linux-gnu'
config.log:debugflags='-g'
config.log:host='i686-pc-linux-gnu'
config.log:host_os='linux-gnu'
config.log:optflags='-O2'
config.log:rubyhdrdir='${includedir}/${RUBY_INSTALL_NAME}-${ruby_version}'
config.log:sitearch='i686-linux'
config.log:target='i686-pc-linux-gnu'
config.log:warnflags='-Wall -Wno-parentheses'
config.log:## ----------- ##
config.log:## ----------- ##
config.status:SHELL=${CONFIG_SHELL-/bin/bash}
config.status:## --------------------- ##
config.status:## --------------------- ##
config.status:if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
config.status:  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
config.status:  alias -g '${1+"$@"}'='"$@"'
config.status:  case `(set -o) 2>/dev/null` in
config.status:  *posix*) set -o posix ;;
config.status:  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
config.status:    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
config.status:    as_echo_n='/usr/ucb/echo -n'
config.status:      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
config.status:    as_echo_n='sh -c $as_echo_n_body as_echo'
config.status:  as_echo='sh -c $as_echo_body as_echo'
config.status:  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
config.status:    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
config.status:# there to prevent editors from complaining about space-tab.
config.status:  test -z "$as_dir" && as_dir=.
config.status:  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
config.status:if test ! -f "$as_myself"; then
config.status:# Work around bugs in pre-3.0 UWIN ksh.
config.status:if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
config.status:as_me=`$as_basename -- "$0" ||
config.status:  # line-number line after each line using $LINENO; the second 'sed'
config.status:  # line-number line with the line containing $LINENO, and appends
config.status:  # trailing '-' during substitution so that $LINENO is not a special
config.status:  # E. McMahon (1931-1989) for sed's syntax.  :-)
config.status:  sed -n '
config.status:      s/[$]LINENO.*/&-/
config.status:      s/-\n.*//
config.status:if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
config.status:case `echo -n x` in
config.status:-n*)
config.status:  ECHO_N='-n';;
config.status:rm -f conf$$ conf$$.exe conf$$.file
config.status:if test -d conf$$.dir; then
config.status:  rm -f conf$$.dir/conf$$.file
config.status:  rm -f conf$$.dir
config.status:  if ln -s conf$$.file conf$$ 2>/dev/null; then
config.status:    as_ln_s='ln -s'
config.status:    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
config.status:    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
config.status:    # In both cases, we have to default to `cp -p'.
config.status:    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
config.status:      as_ln_s='cp -p'
config.status:    as_ln_s='cp -p'
config.status:  as_ln_s='cp -p'
config.status:rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
config.status:if mkdir -p . 2>/dev/null; then
config.status:  test -d ./-p && rmdir ./-p
config.status:if test -x / >/dev/null 2>&1; then
config.status:  as_test_x='test -x'
config.status:  if ls -dL / >/dev/null 2>&1; then
config.status:    eval sh -c '\''
config.status:      if test -d "$1"; then
config.status:	test -d "$1/.";
config.status:	-*)set "./$1";;
config.status:	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in
config.status:on `(hostname || uname -n) 2>/dev/null | sed 1q`
config.status:  -h, --help       print this help, then exit
config.status:  -V, --version    print version number and configuration settings, then exit
config.status:  -q, --quiet, --silent
config.status:  -d, --debug      don't remove temporary files
config.status:      --recheck    update $as_me by reconfiguring in the same conditions
config.status:      --file=FILE[:TEMPLATE]
config.status:Report bugs to <bug-autoconf@gnu.org>."
config.status:INSTALL='/usr/bin/install -c'
config.status:test -n "$AWK" || AWK=awk
config.status:  --*=*)
config.status:  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
config.status:  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
config.status:  --debug | --debu | --deb | --de | --d | -d )
config.status:  --file | --fil | --fi | --f )
config.status:  --he | --h |  --help | --hel | -h )
config.status:  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
config.status:  | -silent | --silent | --silen | --sile | --sil | --si | --s)
config.status:  -*) { $as_echo "$as_me: error: unrecognized option: $1
config.status:Try \`$0 --help' for more information." >&2
config.status:  ac_configure_extra_args="$ac_configure_extra_args --silent"
config.status:  set X '/bin/bash' './configure'  $ac_configure_extra_args --no-create --no-recursion
config.status:  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
config.status:# INIT-COMMANDS
config.status:  { test -z "$tmp" || test ! -d "$tmp" || rm -fr "$tmp"; } && exit $exit_status
config.status:  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
config.status:  test -n "$tmp" && test -d "$tmp"
config.status:  tmp=./conf$$-$RANDOM
config.status:if test -n "$CONFIG_FILES"; then
config.status:S["rubyhdrdir"]="${includedir}/${RUBY_INSTALL_NAME}-${ruby_version}"
config.status:S["sitearch"]="i686-linux"
config.status:S["arch"]="i686-linux"
config.status:S["DLDLIBS"]=" -lc"
config.status:S["LIBRUBYARG_SHARED"]="-Wl,-R -Wl,$(libdir) -L$(libdir) -l$(RUBY_SO_NAME)"
config.status:S["LIBRUBYARG_STATIC"]="-Wl,-R -Wl,$(libdir) -L$(libdir) -l$(RUBY_SO_NAME)-static"
config.status:S["LIBRUBY_A"]="lib$(RUBY_SO_NAME)-static.a"
config.status:S["LIBRUBY_LDSHARED"]="${CC} -shared"
config.status:S["XCFLAGS"]=" -DRUBY_EXPORT"
config.status:S["warnflags"]="-Wall -Wno-parentheses"
config.status:S["debugflags"]="-g"
config.status:S["optflags"]="-O2"
config.status:S["RDOCTARGET"]="install-doc"
config.status:S["RUNRUBY"]="$(MINIRUBY) $(srcdir)/runruby.rb --extout=$(EXTOUT)"
config.status:S["MINIRUBY"]="./miniruby$(EXEEXT) -I$(srcdir)/lib -I$(EXTOUT)/common -I./- -r$(srcdir)/ext/purelib.rb"
config.status:S["STRIP"]="strip -S -x"
config.status:S["RPATHFLAG"]=" -Wl,-R%1$-s"
config.status:S["LIBPATHFLAG"]=" -L%1$-s"
config.status:S["LDSHAREDXX"]="${CXX} -shared"
config.status:S["LDSHARED"]="${CC} -shared"
config.status:S["CCDLFLAGS"]=" -fPIC"
config.status:S["RMALL"]="rm -fr"
config.status:S["MAKEDIRS"]="mkdir -p"
config.status:S["RM"]="rm -f"
config.status:S["INSTALL_DATA"]="${INSTALL} -m 644"
config.status:S["LN_S"]="ln -s"
config.status:S["COUTFLAG"]="-o "
config.status:S["OUTFLAG"]="-o "
config.status:S["CPPOUTFILE"]="-o conftest.i"
config.status:S["EGREP"]="/bin/grep -E"
config.status:S["CPP"]="gcc -E"
config.status:S["LDFLAGS"]="-L.  -rdynamic -Wl,-export-dynamic"
config.status:S["target"]="i686-pc-linux-gnu"
config.status:S["host_os"]="linux-gnu"
config.status:S["host"]="i686-pc-linux-gnu"
config.status:S["build_os"]="linux-gnu"
config.status:S["build"]="i686-pc-linux-gnu"
config.status:S["LIBS"]="-lpthread -lrt -ldl -lcrypt -lm "
config.status:S["ECHO_N"]="-n"
config.status:S["DEFS"]="-D_FILE_OFFSET_BITS=64"
config.status:fi # test -n "$CONFIG_FILES"
config.status:  :[FH]-) ac_tag=-:-;;
config.status:      -) ac_f="$tmp/stdin";;
config.status:	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
config.status:	 test -f "$ac_f" ||
config.status:	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
config.status:    if test x"$ac_file" != x-; then
config.status:    *:-:* | *:-) cat >"$tmp/stdin" \
config.status:  ac_dir=`$as_dirname -- "$ac_file" ||
config.status:  -*) as_dir=./$as_dir;;
config.status:  test -d "$as_dir" || { $as_mkdir_p && mkdir -p "$as_dir"; } || {
config.status:      as_dir=`$as_dirname -- "$as_dir" ||
config.status:      test -d "$as_dir" && break
config.status:    test -z "$as_dirs" || eval "mkdir $as_dirs"
config.status:  } || test -d "$as_dir" || { { $as_echo "$as_me:$LINENO: error: cannot create directory $as_dir" >&5
config.status:case `eval "sed -n \"\$ac_sed_dataroot\" $ac_file_inputs"` in
config.status:  { $as_echo "$as_me:$LINENO: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
config.status:$as_echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
config.status:/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
config.status:eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$tmp/subs.awk" >$tmp/out \
config.status:test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
config.status:  { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
config.status:  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
config.status:  rm -f "$tmp/stdin"
config.status:  -) cat "$tmp/out" && rm -f "$tmp/out";;
config.status:  *) rm -f "$ac_file" && mv "$tmp/out" "$ac_file";;
config.status:	if test -d "$srcdir/.svn"; then
config.status:	elif test -d "$srcdir/.git/svn"; then
config.status:	elif test -d "$srcdir/.git"; then
config.status:	    echo 'distclean-local::; @$(RM) GNUmakefile uncommon.mk'
config.status:      } >> confmk$$.tmp && mv -f confmk$$.tmp Makefile ;;
config.sub:timestamp='2008-01-16'
config.sub:# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
config.sub:# 02110-1301, USA.
config.sub:# Please send patches to <config-patches@gnu.org>.  Submit a context
config.sub:#	CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
config.sub:# or in some cases, the newer four-part form:
config.sub:#	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
config.sub:me=`echo "$0" | sed -e 's,.*/,,'`
config.sub:Usage: $0 [OPTION] CPU-MFR-OPSYS
config.sub:  -h, --help         print this help, then exit
config.sub:  -t, --time-stamp   print date of last modification, then exit
config.sub:  -v, --version      print version number, then exit
config.sub:Report bugs and patches to <config-patches@gnu.org>."
config.sub:Try \`$me --help' for more information."
config.sub:while test $# -gt 0 ; do
config.sub:    --time-stamp | --time* | -t )
config.sub:    --version | -v )
config.sub:    --help | --h* | -h )
config.sub:    -- )     # Stop option processing
config.sub:    - )	# Use stdin as input.
config.sub:    -* )
config.sub:# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
config.sub:# Here we must recognize all the valid KERNEL-OS combinations.
config.sub:maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
config.sub:  nto-qnx* | linux-gnu* | linux-dietlibc | linux-newlib* | linux-uclibc* | \
config.sub:  uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* | \
config.sub:  storm-chaos* | os2-emx* | rtmk-nova*)
config.sub:    os=-$maybe_os
config.sub:    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
config.sub:    basic_machine=`echo $1 | sed 's/-[^-]*$//'`
config.sub:    then os=`echo $1 | sed 's/.*-/-/'`
config.sub:### that things like config.sub decstation-3100 work.  We also
config.sub:	-sun*os*)
config.sub:	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
config.sub:	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
config.sub:	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
config.sub:	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
config.sub:	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
config.sub:	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
config.sub:	-apple | -axis | -knuth | -cray)
config.sub:	-sim | -cisco | -oki | -wec | -winbond)
config.sub:	-scout)
config.sub:	-wrs)
config.sub:		os=-vxworks
config.sub:	-chorusos*)
config.sub:		os=-chorusos
config.sub: 	-chorusrdb)
config.sub: 		os=-chorusrdb
config.sub:	-hiux*)
config.sub:		os=-hiuxwe2
config.sub:	-sco6)
config.sub:		os=-sco5v6
config.sub:		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
config.sub:	-sco5)
config.sub:		os=-sco3.2v5
config.sub:		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
config.sub:	-sco4)
config.sub:		os=-sco3.2v4
config.sub:		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
config.sub:	-sco3.2.[4-9]*)
config.sub:		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
config.sub:		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
config.sub:	-sco3.2v[4-9]*)
config.sub:		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
config.sub:	-sco5v6*)
config.sub:		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
config.sub:	-sco*)
config.sub:		os=-sco3.2v2
config.sub:		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
config.sub:	-udk*)
config.sub:		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
config.sub:	-isc)
config.sub:		os=-isc2.2
config.sub:		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
config.sub:	-clix*)
config.sub:		basic_machine=clipper-intergraph
config.sub:	-isc*)
config.sub:		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
config.sub:	-lynx*)
config.sub:		os=-lynxos
config.sub:	-ptx*)
config.sub:		basic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`
config.sub:	-windowsnt*)
config.sub:		os=`echo $os | sed -e 's/windowsnt/winnt/'`
config.sub:	-psos*)
config.sub:		os=-psos
config.sub:	-mint | -mint[0-9]*)
config.sub:		basic_machine=m68k-atari
config.sub:		os=-mint
config.sub:# Decode aliases for certain CPU-COMPANY combinations.
config.sub:	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
config.sub:	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
config.sub:		basic_machine=$basic_machine-unknown
config.sub:		basic_machine=$basic_machine-unknown
config.sub:		os=-none
config.sub:		basic_machine=mt-unknown
config.sub:	  basic_machine=$basic_machine-pc
config.sub:	*-*-*)
config.sub:	580-* \
config.sub:	| a29k-* \
config.sub:	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
config.sub:	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
config.sub:	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
config.sub:	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
config.sub:	| avr-* | avr32-* \
config.sub:	| bfin-* | bs2000-* \
config.sub:	| c[123]* | c30-* | [cjt]90-* | c4x-* | c54x-* | c55x-* | c6x-* \
config.sub:	| clipper-* | craynv-* | cydra-* \
config.sub:	| d10v-* | d30v-* | dlx-* \
config.sub:	| elxsi-* \
config.sub:	| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \
config.sub:	| h8300-* | h8500-* \
config.sub:	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
config.sub:	| i*86-* | i860-* | i960-* | ia64-* \
config.sub:	| ip2k-* | iq2000-* \
config.sub:	| m32c-* | m32r-* | m32rle-* \
config.sub:	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
config.sub:	| m88110-* | m88k-* | maxq-* | mcore-* \
config.sub:	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
config.sub:	| mips16-* \
config.sub:	| mips64-* | mips64el-* \
config.sub:	| mips64vr-* | mips64vrel-* \
config.sub:	| mips64orion-* | mips64orionel-* \
config.sub:	| mips64vr4100-* | mips64vr4100el-* \
config.sub:	| mips64vr4300-* | mips64vr4300el-* \
config.sub:	| mips64vr5000-* | mips64vr5000el-* \
config.sub:	| mips64vr5900-* | mips64vr5900el-* \
config.sub:	| mipsisa32-* | mipsisa32el-* \
config.sub:	| mipsisa32r2-* | mipsisa32r2el-* \
config.sub:	| mipsisa64-* | mipsisa64el-* \
config.sub:	| mipsisa64r2-* | mipsisa64r2el-* \
config.sub:	| mipsisa64sb1-* | mipsisa64sb1el-* \
config.sub:	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
config.sub:	| mipstx39-* | mipstx39el-* \
config.sub:	| mmix-* \
config.sub:	| mt-* \
config.sub:	| msp430-* \
config.sub:	| nios-* | nios2-* \
config.sub:	| none-* | np1-* | ns16k-* | ns32k-* \
config.sub:	| orion-* \
config.sub:	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
config.sub:	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \
config.sub:	| pyramid-* \
config.sub:	| romp-* | rs6000-* \
config.sub:	| sh-* | sh[1234]-* | sh[24]a-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
config.sub:	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
config.sub:	| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \
config.sub:	| sparclite-* \
config.sub:	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | strongarm-* | sv1-* | sx?-* \
config.sub:	| tahoe-* | thumb-* \
config.sub:	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
config.sub:	| tron-* \
config.sub:	| v850-* | v850e-* | vax-* \
config.sub:	| we32k-* \
config.sub:	| x86-* | x86_64-* | xc16x-* | xps100-* | xscale-* | xscalee[bl]-* \
config.sub:	| xstormy16-* | xtensa*-* \
config.sub:	| ymp-* \
config.sub:	| z8k-*)
config.sub:		basic_machine=$basic_machine-unknown
config.sub:		basic_machine=i386-unknown
config.sub:		os=-bsd
config.sub:	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
config.sub:		basic_machine=m68000-att
config.sub:		basic_machine=we32k-att
config.sub:		basic_machine=a29k-amd
config.sub:		os=-udi
config.sub:		basic_machine=abacus-unknown
config.sub:		basic_machine=m68010-adobe
config.sub:		os=-scout
config.sub:		basic_machine=fx80-alliant
config.sub:		basic_machine=m68k-altos
config.sub:		basic_machine=a29k-none
config.sub:		os=-bsd
config.sub:		basic_machine=x86_64-pc
config.sub:	amd64-*)
config.sub:		basic_machine=x86_64-`echo $basic_machine | sed 's/^[^-]*-//'`
config.sub:		basic_machine=580-amdahl
config.sub:		os=-sysv
config.sub:	amiga | amiga-*)
config.sub:		basic_machine=m68k-unknown
config.sub:		basic_machine=m68k-unknown
config.sub:		os=-amigaos
config.sub:		basic_machine=m68k-unknown
config.sub:		os=-sysv4
config.sub:		basic_machine=m68k-apollo
config.sub:		os=-sysv
config.sub:		basic_machine=m68k-apollo
config.sub:		os=-bsd
config.sub:		basic_machine=m68k-apple
config.sub:		os=-aux
config.sub:		basic_machine=ns32k-sequent
config.sub:		os=-dynix
config.sub:		basic_machine=bfin-unknown
config.sub:		os=-linux
config.sub:	blackfin-*)
config.sub:		basic_machine=bfin-`echo $basic_machine | sed 's/^[^-]*-//'`
config.sub:		os=-linux
config.sub:		basic_machine=c90-cray
config.sub:		os=-unicos
config.sub:	convex-c1)
config.sub:		basic_machine=c1-convex
config.sub:		os=-bsd
config.sub:	convex-c2)
config.sub:		basic_machine=c2-convex
config.sub:		os=-bsd
config.sub:	convex-c32)
config.sub:		basic_machine=c32-convex
config.sub:		os=-bsd
config.sub:	convex-c34)
config.sub:		basic_machine=c34-convex
config.sub:		os=-bsd
config.sub:	convex-c38)
config.sub:		basic_machine=c38-convex
config.sub:		os=-bsd
config.sub:		basic_machine=j90-cray
config.sub:		os=-unicos
config.sub:		basic_machine=craynv-cray
config.sub:		os=-unicosmp
config.sub:		basic_machine=cr16-unknown
config.sub:		os=-elf
config.sub:		basic_machine=m68k-crds
config.sub:	crisv32 | crisv32-* | etraxfs*)
config.sub:		basic_machine=crisv32-axis
config.sub:	cris | cris-* | etrax*)
config.sub:		basic_machine=cris-axis
config.sub:		basic_machine=crx-unknown
config.sub:		os=-elf
config.sub:	da30 | da30-*)
config.sub:		basic_machine=m68k-da30
config.sub:	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
config.sub:		basic_machine=mips-dec
config.sub:		basic_machine=pdp10-dec
config.sub:		os=-tops10
config.sub:		basic_machine=pdp10-dec
config.sub:		os=-tops20
config.sub:	delta | 3300 | motorola-3300 | motorola-delta \
config.sub:	      | 3300-motorola | delta-motorola)
config.sub:		basic_machine=m68k-motorola
config.sub:		basic_machine=m88k-motorola
config.sub:		os=-sysv3
config.sub:		basic_machine=i586-pc
config.sub:		os=-msdosdjgpp
config.sub:	dpx20 | dpx20-*)
config.sub:		basic_machine=rs6000-bull
config.sub:		os=-bosx
config.sub:	dpx2* | dpx2*-bull)
config.sub:		basic_machine=m68k-bull
config.sub:		os=-sysv3
config.sub:		basic_machine=a29k-amd
config.sub:		os=-ebmon
config.sub:		basic_machine=elxsi-elxsi
config.sub:		os=-bsd
config.sub:		basic_machine=ns32k-encore
config.sub:		basic_machine=m68k-ericsson
config.sub:		os=-ose
config.sub:		basic_machine=i860-alliant
config.sub:		basic_machine=ns32k-ns
config.sub:		basic_machine=tron-gmicro
config.sub:		os=-sysv
config.sub:		basic_machine=i386-pc
config.sub:		os=-go32
config.sub:		basic_machine=hppa1.1-hitachi
config.sub:		os=-hiuxwe2
config.sub:		basic_machine=h8300-hitachi
config.sub:		os=-hms
config.sub:		basic_machine=h8300-hitachi
config.sub:		os=-xray
config.sub:		basic_machine=h8500-hitachi
config.sub:		os=-hms
config.sub:		basic_machine=m88k-harris
config.sub:		os=-sysv3
config.sub:	hp300-*)
config.sub:		basic_machine=m68k-hp
config.sub:		basic_machine=m68k-hp
config.sub:		os=-bsd
config.sub:		basic_machine=m68k-hp
config.sub:		os=-hpux
config.sub:	hp3k9[0-9][0-9] | hp9[0-9][0-9])
config.sub:		basic_machine=hppa1.0-hp
config.sub:	hp9k2[0-9][0-9] | hp9k31[0-9])
config.sub:		basic_machine=m68000-hp
config.sub:	hp9k3[2-9][0-9])
config.sub:		basic_machine=m68k-hp
config.sub:	hp9k6[0-9][0-9] | hp6[0-9][0-9])
config.sub:		basic_machine=hppa1.0-hp
config.sub:	hp9k7[0-79][0-9] | hp7[0-79][0-9])
config.sub:		basic_machine=hppa1.1-hp
config.sub:	hp9k78[0-9] | hp78[0-9])
config.sub:		# FIXME: really hppa2.0-hp
config.sub:		basic_machine=hppa1.1-hp
config.sub:		# FIXME: really hppa2.0-hp
config.sub:		basic_machine=hppa1.1-hp
config.sub:	hp9k8[0-9][13679] | hp8[0-9][13679])
config.sub:		basic_machine=hppa1.1-hp
config.sub:	hp9k8[0-9][0-9] | hp8[0-9][0-9])
config.sub:		basic_machine=hppa1.0-hp
config.sub:	hppa-next)
config.sub:		os=-nextstep3
config.sub:		basic_machine=hppa1.1-hp
config.sub:		os=-osf
config.sub:		basic_machine=hppa1.1-hp
config.sub:		os=-proelf
config.sub:	i370-ibm* | ibm*)
config.sub:		basic_machine=i370-ibm
config.sub:		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
config.sub:		os=-sysv32
config.sub:		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
config.sub:		os=-sysv4
config.sub:		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
config.sub:		os=-sysv
config.sub:		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
config.sub:		os=-solaris2
config.sub:		basic_machine=i386-mach
config.sub:		os=-mach
config.sub:	i386-vsta | vsta)
config.sub:		basic_machine=i386-unknown
config.sub:		os=-vsta
config.sub:		basic_machine=mips-sgi
config.sub:		    -irix*)
config.sub:			os=-irix4
config.sub:		basic_machine=m68k-isi
config.sub:		os=-sysv
config.sub:		basic_machine=m68k-unknown
config.sub:		os=-linux
config.sub:	m68knommu-*)
config.sub:		basic_machine=m68k-`echo $basic_machine | sed 's/^[^-]*-//'`
config.sub:		os=-linux
config.sub:	m88k-omron*)
config.sub:		basic_machine=m88k-omron
config.sub:		basic_machine=mips-mips
config.sub:		os=-sysv
config.sub:		basic_machine=ns32k-utek
config.sub:		os=-sysv
config.sub:		basic_machine=i386-pc
config.sub:		os=-mingw32
config.sub:		basic_machine=arm-unknown
config.sub:		os=-mingw32ce
config.sub:		basic_machine=m68000-convergent
config.sub:	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
config.sub:		basic_machine=m68k-atari
config.sub:		os=-mint
config.sub:	mips3*-*)
config.sub:		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
config.sub:		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
config.sub:		basic_machine=m68k-rom68k
config.sub:		os=-coff
config.sub:		basic_machine=powerpc-unknown
config.sub:		os=-morphos
config.sub:		basic_machine=i386-pc
config.sub:		os=-msdos
config.sub:	ms1-*)
config.sub:		basic_machine=`echo $basic_machine | sed -e 's/ms1-/mt-/'`
config.sub:		basic_machine=i370-ibm
config.sub:		os=-mvs
config.sub:		basic_machine=i486-ncr
config.sub:		os=-sysv4
config.sub:		basic_machine=i386-unknown
config.sub:		os=-netbsd
config.sub:		basic_machine=armv4l-rebel
config.sub:		os=-linux
config.sub:		basic_machine=m68k-sony
config.sub:		os=-newsos
config.sub:		basic_machine=m68030-sony
config.sub:		os=-newsos
config.sub:	news-3600 | risc-news)
config.sub:		basic_machine=mips-sony
config.sub:		os=-newsos
config.sub:		basic_machine=v70-nec
config.sub:		os=-sysv
config.sub:	next | m*-next )
config.sub:		basic_machine=m68k-next
config.sub:		    -nextstep* )
config.sub:		    -ns2*)
config.sub:		      os=-nextstep2
config.sub:		      os=-nextstep3
config.sub:		basic_machine=m68k-harris
config.sub:		os=-cxux
config.sub:		basic_machine=m88k-harris
config.sub:		os=-cxux
config.sub:		basic_machine=i960-intel
config.sub:		os=-nindy
config.sub:		basic_machine=i960-intel
config.sub:		os=-mon960
config.sub:		basic_machine=mips-compaq
config.sub:		os=-nonstopux
config.sub:		basic_machine=np1-gould
config.sub:	nsr-tandem)
config.sub:		basic_machine=nsr-tandem
config.sub:	op50n-* | op60c-*)
config.sub:		basic_machine=hppa1.1-oki
config.sub:		os=-proelf
config.sub:	openrisc | openrisc-*)
config.sub:		basic_machine=or32-unknown
config.sub:		basic_machine=powerpc-ibm
config.sub:		os=-os400
config.sub:		basic_machine=m68000-ericsson
config.sub:		os=-ose
config.sub:		basic_machine=m68k-none
config.sub:		os=-os68k
config.sub:	pa-hitachi)
config.sub:		basic_machine=hppa1.1-hitachi
config.sub:		os=-hiuxwe2
config.sub:		basic_machine=i860-intel
config.sub:		os=-osf
config.sub:		basic_machine=hppa-unknown
config.sub:		os=-linux
config.sub:	parisc-*)
config.sub:		basic_machine=hppa-`echo $basic_machine | sed 's/^[^-]*-//'`
config.sub:		os=-linux
config.sub:		basic_machine=sparc-tti
config.sub:		basic_machine=m68k-tti
config.sub:	pc532 | pc532-*)
config.sub:		basic_machine=ns32k-pc532
config.sub:		basic_machine=i386-pc
config.sub:	pc98-*)
config.sub:		basic_machine=i386-`echo $basic_machine | sed 's/^[^-]*-//'`
config.sub:		basic_machine=i586-pc
config.sub:		basic_machine=i686-pc
config.sub:		basic_machine=i686-pc
config.sub:		basic_machine=i786-pc
config.sub:	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
config.sub:		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
config.sub:	pentiumpro-* | p6-* | 6x86-* | athlon-*)
config.sub:		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
config.sub:	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
config.sub:		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
config.sub:	pentium4-*)
config.sub:		basic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`
config.sub:		basic_machine=pn-gould
config.sub:	power)	basic_machine=power-ibm
config.sub:	ppc)	basic_machine=powerpc-unknown
config.sub:	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
config.sub:	ppcle | powerpclittle | ppc-le | powerpc-little)
config.sub:		basic_machine=powerpcle-unknown
config.sub:	ppcle-* | powerpclittle-*)
config.sub:		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
config.sub:	ppc64)	basic_machine=powerpc64-unknown
config.sub:	ppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`
config.sub:	ppc64le | powerpc64little | ppc64-le | powerpc64-little)
config.sub:		basic_machine=powerpc64le-unknown
config.sub:	ppc64le-* | powerpc64little-*)
config.sub:		basic_machine=powerpc64le-`echo $basic_machine | sed 's/^[^-]*-//'`
config.sub:		basic_machine=i386-ibm
config.sub:		basic_machine=i586-unknown
config.sub:		os=-pw32
config.sub:		basic_machine=i386-pc
config.sub:		os=-rdos
config.sub:		basic_machine=m68k-rom68k
config.sub:		os=-coff
config.sub:		basic_machine=mips-siemens
config.sub:	rtpc | rtpc-*)
config.sub:		basic_machine=romp-ibm
config.sub:	s390 | s390-*)
config.sub:		basic_machine=s390-ibm
config.sub:	s390x | s390x-*)
config.sub:		basic_machine=s390x-ibm
config.sub:		basic_machine=a29k-amd
config.sub:		os=-udi
config.sub:		basic_machine=mipsisa64sb1-unknown
config.sub:		basic_machine=mipsisa64sb1el-unknown
config.sub:		basic_machine=mipsisa32-sde
config.sub:		os=-elf
config.sub:		basic_machine=mips-sei
config.sub:		os=-seiux
config.sub:		basic_machine=i386-sequent
config.sub:		basic_machine=sh-hitachi
config.sub:		os=-hms
config.sub:		basic_machine=sh5le-unknown
config.sub:		basic_machine=sh64-unknown
config.sub:	sparclite-wrs | simso-wrs)
config.sub:		basic_machine=sparclite-wrs
config.sub:		os=-vxworks
config.sub:		basic_machine=m68k-bull
config.sub:		os=-sysv2
config.sub:		basic_machine=spur-unknown
config.sub:		basic_machine=m68k-tandem
config.sub:		basic_machine=i860-stratus
config.sub:		os=-sysv4
config.sub:		basic_machine=m68000-sun
config.sub:		basic_machine=m68000-sun
config.sub:		os=-sunos3
config.sub:		basic_machine=m68000-sun
config.sub:		os=-sunos4
config.sub:		basic_machine=m68k-sun
config.sub:		os=-sunos3
config.sub:		basic_machine=m68k-sun
config.sub:		os=-sunos4
config.sub:		basic_machine=sparc-sun
config.sub:		os=-sunos3
config.sub:		basic_machine=sparc-sun
config.sub:		os=-sunos4
config.sub:		basic_machine=sparc-sun
config.sub:		os=-solaris2
config.sub:	sun3 | sun3-*)
config.sub:		basic_machine=m68k-sun
config.sub:		basic_machine=sparc-sun
config.sub:		basic_machine=i386-sun
config.sub:		basic_machine=sv1-cray
config.sub:		os=-unicos
config.sub:		basic_machine=i386-sequent
config.sub:		os=-dynix
config.sub:		basic_machine=alphaev5-cray
config.sub:		os=-unicos
config.sub:		basic_machine=t90-cray
config.sub:		os=-unicos
config.sub:		basic_machine=tic54x-unknown
config.sub:		os=-coff
config.sub:		basic_machine=tic55x-unknown
config.sub:		os=-coff
config.sub:		basic_machine=tic6x-unknown
config.sub:		os=-coff
config.sub:		basic_machine=tile-unknown
config.sub:		os=-linux-gnu
config.sub:		basic_machine=mipstx39-unknown
config.sub:		basic_machine=mipstx39el-unknown
config.sub:		basic_machine=pdp10-xkl
config.sub:		os=-tops20
config.sub:	tower | tower-32)
config.sub:		basic_machine=m68k-ncr
config.sub:		basic_machine=s390x-ibm
config.sub:		os=-tpf
config.sub:		basic_machine=a29k-amd
config.sub:		os=-udi
config.sub:		basic_machine=a29k-nyu
config.sub:		os=-sym1
config.sub:		basic_machine=v810-nec
config.sub:		os=-none
config.sub:		basic_machine=vax-dec
config.sub:		os=-sysv
config.sub:		basic_machine=vax-dec
config.sub:		os=-vms
config.sub:	vpp*|vx|vx-*)
config.sub:		basic_machine=f301-fujitsu
config.sub:		basic_machine=i960-wrs
config.sub:		os=-vxworks
config.sub:		basic_machine=m68k-wrs
config.sub:		os=-vxworks
config.sub:		basic_machine=a29k-wrs
config.sub:		os=-vxworks
config.sub:		basic_machine=w65-wdc
config.sub:		os=-none
config.sub:	w89k-*)
config.sub:		basic_machine=hppa1.1-winbond
config.sub:		os=-proelf
config.sub:		basic_machine=i686-pc
config.sub:		os=-mingw32
config.sub:		basic_machine=xps100-honeywell
config.sub:		basic_machine=ymp-cray
config.sub:		os=-unicos
config.sub:	z8k-*-coff)
config.sub:		basic_machine=z8k-unknown
config.sub:		os=-sim
config.sub:		basic_machine=none-none
config.sub:		os=-none
config.sub:		basic_machine=hppa1.1-winbond
config.sub:		basic_machine=hppa1.1-oki
config.sub:		basic_machine=hppa1.1-oki
config.sub:		basic_machine=romp-ibm
config.sub:		basic_machine=mmix-knuth
config.sub:		basic_machine=rs6000-ibm
config.sub:		basic_machine=vax-dec
config.sub:		basic_machine=pdp10-unknown
config.sub:		basic_machine=pdp11-dec
config.sub:		basic_machine=we32k-att
config.sub:		basic_machine=sh-unknown
config.sub:		basic_machine=sparc-sun
config.sub:		basic_machine=cydra-cydrome
config.sub:		basic_machine=orion-highlevel
config.sub:		basic_machine=clipper-highlevel
config.sub:	mac | mpw | mac-mpw)
config.sub:		basic_machine=m68k-apple
config.sub:	pmac | pmac-mpw)
config.sub:		basic_machine=powerpc-apple
config.sub:	*-unknown)
config.sub:		# Make sure to match an already-canonicalized machine name.
config.sub:	*-digital*)
config.sub:	*-commodore*)
config.sub:# Decode manufacturer-specific aliases for certain operating systems.
config.sub:	# -solaris* is a basic system type, with this one exception.
config.sub:	-solaris1 | -solaris1.*)
config.sub:		os=`echo $os | sed -e 's|solaris1|sunos4|'`
config.sub:	-solaris)
config.sub:		os=-solaris2
config.sub:	-svr4*)
config.sub:		os=-sysv4
config.sub:	-unixware*)
config.sub:		os=-sysv4.2uw
config.sub:	-gnu/linux*)
config.sub:		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
config.sub:	# -sysv* is not here because it comes later, after sysvr4.
config.sub:	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
config.sub:	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\
config.sub:	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
config.sub:	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
config.sub:	      | -aos* \
config.sub:	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
config.sub:	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
config.sub:	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
config.sub:	      | -openbsd* | -solidbsd* \
config.sub:	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
config.sub:	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
config.sub:	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
config.sub:	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
config.sub:	      | -chorusos* | -chorusrdb* \
config.sub:	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
config.sub:	      | -mingw32* | -linux-gnu* | -linux-newlib* | -linux-uclibc* \
config.sub:	      | -uxpv* | -beos* | -mpeix* | -udk* \
config.sub:	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
config.sub:	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
config.sub:	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
config.sub:	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
config.sub:	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
config.sub:	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
config.sub:	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops*)
config.sub:	-qnx*)
config.sub:		    x86-* | i*86-*)
config.sub:			os=-nto$os
config.sub:	-nto-qnx*)
config.sub:	-nto*)
config.sub:		os=`echo $os | sed -e 's|nto|nto-qnx|'`
config.sub:	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
config.sub:	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* | -haiku* \
config.sub:	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
config.sub:	-mac*)
config.sub:		os=`echo $os | sed -e 's|mac|macos|'`
config.sub:	-linux-dietlibc)
config.sub:		os=-linux-dietlibc
config.sub:	-linux*)
config.sub:		os=`echo $os | sed -e 's|linux|linux-gnu|'`
config.sub:	-sunos5*)
config.sub:		os=`echo $os | sed -e 's|sunos5|solaris2|'`
config.sub:	-sunos6*)
config.sub:		os=`echo $os | sed -e 's|sunos6|solaris3|'`
config.sub:	-opened*)
config.sub:		os=-openedition
config.sub:        -os400*)
config.sub:		os=-os400
config.sub:	-wince*)
config.sub:		os=-wince
config.sub:	-osfrose*)
config.sub:		os=-osfrose
config.sub:	-osf*)
config.sub:		os=-osf
config.sub:	-utek*)
config.sub:		os=-bsd
config.sub:	-dynix*)
config.sub:		os=-bsd
config.sub:	-acis*)
config.sub:		os=-aos
config.sub:	-atheos*)
config.sub:		os=-atheos
config.sub:	-syllable*)
config.sub:		os=-syllable
config.sub:	-386bsd)
config.sub:		os=-bsd
config.sub:	-ctix* | -uts*)
config.sub:		os=-sysv
config.sub:	-nova*)
config.sub:		os=-rtmk-nova
config.sub:	-ns2 )
config.sub:		os=-nextstep2
config.sub:	-nsk*)
config.sub:		os=-nsk
config.sub:	-sinix5.*)
config.sub:		os=`echo $os | sed -e 's|sinix|sysv|'`
config.sub:	-sinix*)
config.sub:		os=-sysv4
config.sub:        -tpf*)
config.sub:		os=-tpf
config.sub:	-triton*)
config.sub:		os=-sysv3
config.sub:	-oss*)
config.sub:		os=-sysv3
config.sub:	-svr4)
config.sub:		os=-sysv4
config.sub:	-svr3)
config.sub:		os=-sysv3
config.sub:	-sysvr4)
config.sub:		os=-sysv4
config.sub:	# This must come after -sysvr4.
config.sub:	-sysv*)
config.sub:	-ose*)
config.sub:		os=-ose
config.sub:	-es1800*)
config.sub:		os=-ose
config.sub:	-xenix)
config.sub:		os=-xenix
config.sub:	-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
config.sub:		os=-mint
config.sub:	-aros*)
config.sub:		os=-aros
config.sub:	-kaos*)
config.sub:		os=-kaos
config.sub:	-zvmoe)
config.sub:		os=-zvmoe
config.sub:	-none)
config.sub:		# Get rid of the `-' at the beginning of $os.
config.sub:		os=`echo $os | sed 's/[^-]*-//'`
config.sub:# Note that if you're going to try to match "-MANUFACTURER" here (say,
config.sub:# "-sun"), then you have to tell the case statement up towards the top
config.sub:        score-*)
config.sub:		os=-elf
config.sub:        spu-*)
config.sub:		os=-elf
config.sub:	*-acorn)
config.sub:		os=-riscix1.2
config.sub:	arm*-rebel)
config.sub:		os=-linux
config.sub:	arm*-semi)
config.sub:		os=-aout
config.sub:        c4x-* | tic4x-*)
config.sub:        	os=-coff
config.sub:	# This must come before the *-dec entry.
config.sub:	pdp10-*)
config.sub:		os=-tops20
config.sub:	pdp11-*)
config.sub:		os=-none
config.sub:	*-dec | vax-*)
config.sub:		os=-ultrix4.2
config.sub:	m68*-apollo)
config.sub:		os=-domain
config.sub:	i386-sun)
config.sub:		os=-sunos4.0.2
config.sub:	m68000-sun)
config.sub:		os=-sunos3
config.sub:		# os=-sunos4
config.sub:	m68*-cisco)
config.sub:		os=-aout
config.sub:        mep-*)
config.sub:		os=-elf
config.sub:	mips*-cisco)
config.sub:		os=-elf
config.sub:	mips*-*)
config.sub:		os=-elf
config.sub:	or32-*)
config.sub:		os=-coff
config.sub:	*-tti)	# must be before sparc entry or we get the wrong os.
config.sub:		os=-sysv3
config.sub:	sparc-* | *-sun)
config.sub:		os=-sunos4.1.1
config.sub:	*-be)
config.sub:		os=-beos
config.sub:	*-haiku)
config.sub:		os=-haiku
config.sub:	*-ibm)
config.sub:		os=-aix
config.sub:    	*-knuth)
config.sub:		os=-mmixware
config.sub:	*-wec)
config.sub:		os=-proelf
config.sub:	*-winbond)
config.sub:		os=-proelf
config.sub:	*-oki)
config.sub:		os=-proelf
config.sub:	*-hp)
config.sub:		os=-hpux
config.sub:	*-hitachi)
config.sub:		os=-hiux
config.sub:	i860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)
config.sub:		os=-sysv
config.sub:	*-cbm)
config.sub:		os=-amigaos
config.sub:	*-dg)
config.sub:		os=-dgux
config.sub:	*-dolphin)
config.sub:		os=-sysv3
config.sub:	m68k-ccur)
config.sub:		os=-rtu
config.sub:	m88k-omron*)
config.sub:		os=-luna
config.sub:	*-next )
config.sub:		os=-nextstep
config.sub:	*-sequent)
config.sub:		os=-ptx
config.sub:	*-crds)
config.sub:		os=-unos
config.sub:	*-ns)
config.sub:		os=-genix
config.sub:	i370-*)
config.sub:		os=-mvs
config.sub:	*-next)
config.sub:		os=-nextstep3
config.sub:	*-gould)
config.sub:		os=-sysv
config.sub:	*-highlevel)
config.sub:		os=-bsd
config.sub:	*-encore)
config.sub:		os=-bsd
config.sub:	*-sgi)
config.sub:		os=-irix
config.sub:	*-siemens)
config.sub:		os=-sysv4
config.sub:	*-masscomp)
config.sub:		os=-rtu
config.sub:	f30[01]-fujitsu | f700-fujitsu)
config.sub:		os=-uxpv
config.sub:	*-rom68k)
config.sub:		os=-coff
config.sub:	*-*bug)
config.sub:		os=-coff
config.sub:	*-apple)
config.sub:		os=-macos
config.sub:	*-atari*)
config.sub:		os=-mint
config.sub:		os=-none
config.sub:	*-unknown)
config.sub:			-riscix*)
config.sub:			-sunos*)
config.sub:			-aix*)
config.sub:			-beos*)
config.sub:			-hpux*)
config.sub:			-mpeix*)
config.sub:			-hiux*)
config.sub:			-unos*)
config.sub:			-dgux*)
config.sub:			-luna*)
config.sub:			-genix*)
config.sub:			-mvs* | -opened*)
config.sub:			-os400*)
config.sub:			-ptx*)
config.sub:			-tpf*)
config.sub:			-vxsim* | -vxworks* | -windiss*)
config.sub:			-aux*)
config.sub:			-hms*)
config.sub:			-mpw* | -macos*)
config.sub:			-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
config.sub:			-vos*)
config.sub:# eval: (add-hook 'write-file-hooks 'time-stamp)
config.sub:# time-stamp-start: "timestamp='"
config.sub:# time-stamp-format: "%:y-%02m-%02d"
config.sub:# time-stamp-end: "'"
configure.in:	[  --with-baseruby=RUBY use RUBY as baseruby; RUBY is the pathname of ruby],
configure.in:test "`RUBYOPT=- $BASERUBY -e 'p 42' 2>/dev/null`" = 42 ||
configure.in:    BASERUBY="echo executable host ruby is required.  use --with-baseruby option.; false"
configure.in:rm -f conftest*])
configure.in:[AC_CACHE_CHECK(whether ${CPP} accepts -o, rb_cv_cppoutfile,
configure.in:CPPFLAGS='-o conftest.i'
configure.in:rm -f conftest*])
configure.in:  CPPOUTFILE='-o conftest.i'
configure.in:elif test -n "$rb_cv_cppoutfile"; then
configure.in:[if `$CC $CFLAGS $CPPFLAGS $LDFLAGS --print-prog-name=ld 2>&1` -v 2>&1 | grep "GNU ld" > /dev/null; then
configure.in:MAJOR=`expr "$rb_version" : '#define RUBY_VERSION "\([0-9][0-9]*\)\.[0-9][0-9]*\.[0-9][0-9]*"'`
configure.in:MINOR=`expr "$rb_version" : '#define RUBY_VERSION "[0-9][0-9]*\.\([0-9][0-9]*\)\.[0-9][0-9]*"'`
configure.in:TEENY=`expr "$rb_version" : '#define RUBY_VERSION "[0-9][0-9]*\.[0-9][0-9]*\.\([0-9][0-9]*\)"'`
configure.in:AC_ARG_WITH(gcc, [  --without-gcc           never use gcc], [
configure.in:if test ! -z "$ac_cv_prog_CC" -a ! -z "$CC" -a "$CC" != "$ac_cv_prog_CC"
configure.in:  AC_MSG_ERROR(cached CC is different -- throw away $cache_file
configure.in:target_os=`echo $target_os | sed 's/linux-gnu$/linux/;s/linux-gnu/linux-/'`
configure.in:dnl checks for fat-binary
configure.in:AC_ARG_ENABLE(fat-binary,
configure.in:       [  --enable-fat-binary=ARCHS
configure.in:                          ARCHS is a comma-delimited list of architectures for
configure.in:    if test -z "$TARGET_ARCHS"; then
configure.in:	# Respect ARCH given to --enable-fat-binary if present.
configure.in:    # /usr/lib/arch_tool -archify_list $TARGET_ARCHS
configure.in:        ARCH_FLAG="$ARCH_FLAG -arch $archs"
configure.in:AC_ARG_ENABLE(frame-address,
configure.in:       [  --enable-frame-address  use GCC __builtin_frame_address(). ],
configure.in:test $ac_cv_prog_cc_g = yes && : ${debugflags=-g}
configure.in:    linker_flag=-Wl,
configure.in:    : ${optflags=-O2} ${warnflags="-Wall -Wno-parentheses"}
configure.in:: ${OUTFLAG='-o '}
configure.in:if test -z "$AR"; then
configure.in:		    [rb_cv_msvcrt=`$OBJDUMP -p conftest$ac_exeext |
configure.in:				   tr A-Z a-z |
configure.in:				   sed -n '/^[[ 	]]*dll name: \(msvc.*\)\.dll$/{s//\1/p;q;}'`],
configure.in:AC_SUBST(RM, ['rm -f'])
configure.in:  MAKEDIRS='mkdir -p'
configure.in:  MAKEDIRS='install -d'
configure.in:AC_SUBST(RMALL, ['rm -fr'])
configure.in:				      [$4], [(rb_[$1])-1 > 0])],
configure.in:#define test_for_stringization -.real_test_for_stringization.-
configure.in:if test x"$rb_cv_stringization" != xno -a "$rb_cv_stringization" != "#expr"; then
configure.in:XCFLAGS="$XCFLAGS -DRUBY_EXPORT"
configure.in:       [  --enable-pthread        use pthread library.],
configure.in:darwin*)	LIBS="-lobjc $LIBS"
configure.in:		CPPFLAGS="$CPPFLAGS -D_XOPEN_SOURCE -D_DARWIN_C_SOURCE"
configure.in:hpux*)		LIBS="-lm $LIBS"
configure.in:mingw*)		LIBS="-lshell32 -lws2_32 $LIBS"
configure.in:os2-emx*)	LIBS="-lm $LIBS"
configure.in:msdosdjgpp*)	LIBS="-lm $LIBS"
configure.in:bsdi*)          LIBS="-lm $LIBS"
configure.in:freebsd*)	LIBS="-lm $LIBS"
configure.in:dragonfly*)	LIBS="-lm $LIBS"
configure.in:*) LIBS="-lm $LIBS";;
configure.in:AC_CHECK_LIB(dld, shl_load)	# Dynamic linking for HP-UX
configure.in:		*::yes)	CFLAGS="-mieee $CFLAGS" ;;   # gcc
configure.in:		osf*)   CFLAGS="-ieee $CFLAGS" ;;    # ccc
configure.in:dnl RUBY_DEFINT TYPENAME, SIZE, [SIGNED-OR-UNSIGNED], [INCLUDES = DEFAULT-INCLUDES]
configure.in:   [case m4_bmatch([$2], [^[1-9][0-9]*$], $2, [$ac_cv_sizeof_]AS_TR_SH($2)) in
configure.in:case "${target_cpu}-${target_os}" in
configure.in:powerpc-darwin*)
configure.in:# http://sources.redhat.com/ml/libc-hacker/2005-08/msg00008.html
configure.in:# Debian GNU/Linux Etch's libc6.1 2.3.6.ds1-13etch5 has this problem.
configure.in:# Debian GNU/Linux Lenny's libc6.1 2.7-10 has no problem.
configure.in:AC_CACHE_CHECK(for broken erfc of glibc-2.3.6 on IA64, rb_cv_broken_glibc_ia64_erfc,
configure.in:AC_ARG_WITH(setjmp-type, 
configure.in:	[  --with-setjmp-type      select setjmp type], [
configure.in:       [  --enable-setreuid       use setreuid()/setregid() according to need even if obsolete.],
configure.in:	tm->tm_year != y ||
configure.in:	tm->tm_mon  != m-1 ||
configure.in:	tm->tm_mday != d ||
configure.in:	tm->tm_hour != h ||
configure.in:	tm->tm_sec  != s) {
configure.in:   time_t t = -1;
configure.in:    [AC_COMPILE_IFELSE(AC_LANG_BOOL_COMPILE_TRY([], [(-1==(-1>>1))]),
configure.in:	[FILE *f = stdin; f->$fcnt = 0;],
configure.in:	[FILE *f = stdin; char buf[256]; f->$frptr = buf;],
configure.in:	[FILE *f = stdin; char buf[256]; f->$frend = buf;],
configure.in:m68*|i?86|ia64|sparc*|alpha*) rb_cv_stack_grow_dir=-1;;
configure.in:	return *addr = stack_growup_p(addr, n - 1);
configure.in:], rb_cv_stack_grow_dir=-1, rb_cv_stack_grow_dir=+1, rb_cv_stack_grow_dir=0)])
configure.in:	    MAINLIBS="-pthread $MAINLIBS"
configure.in:	    LIBS="-l$pthread_lib $LIBS"
configure.in:	AC_MSG_WARN("Don't know how to find pthread library on your system -- thread support disabled")
configure.in:if test "$ac_cv_func_fork" = "yes" -a "$rb_with_pthread" = "yes"; then
configure.in:	return -1;
configure.in:	return -1;
configure.in:        [  --with-valgrind         enable valgrind memcheck support.],
configure.in:AC_ARG_WITH(dln-a-out, 
configure.in:	[  --with-dln-a-out        use dln_a_out if possible], [
configure.in:case "`head -1 conftest$EXEEXT | cat -e`" in
configure.in:linux* | gnu* | k*bsd*-gnu | bsdi*)
configure.in:	LDFLAGS="$LDFLAGS -rdynamic"
configure.in:    nextstep*)	CCDLFLAGS="$CCDLFLAGS -fno-common";;
configure.in:    openstep*)	CCDLFLAGS="$CCDLFLAGS -fno-common";;
configure.in:    rhapsody*)	CCDLFLAGS="$CCDLFLAGS -fno-common";;
configure.in:    darwin*)	CCDLFLAGS="$CCDLFLAGS -fno-common";;
configure.in:    *) CCDLFLAGS="$CCDLFLAGS -fPIC";;
configure.in:	solaris*|irix*)	CCDLFLAGS="$CCDLFLAGS -KPIC" ;;
configure.in:	sunos*)		CCDLFLAGS="$CCDLFLAGS -PIC" ;;
configure.in:	esix*|uxpds*)   CCDLFLAGS="$CCDLFLAGS -KPIC" ;;
configure.in:       [  --disable-rpath         embed run path into extension libraries.],
configure.in:    RPATHFLAG=" ${linker_flag}-R%1\$-s"
configure.in:	hpux*)		DLDFLAGS="$DLDFLAGS -E"
configure.in:			: ${LDSHARED='ld -b'}
configure.in:			XLDFLAGS="$XLDFLAGS -Wl,-E"
configure.in:			    RPATHFLAG=' +b %1$-s'
configure.in:                          : ${LDSHARED='$(CC) -shared'}
configure.in:			       LDFLAGS="$LDFLAGS -Wl,-E"
configure.in:			   : ${LDSHARED='ld -G'}
configure.in:	sunos*) 	: ${LDSHARED='ld -assert nodefinitions'}
configure.in:	irix*)		: ${LDSHARED='ld -shared'}
configure.in:	sysv4*) 	: ${LDSHARED='ld -G'}
configure.in:        nto-qnx*)       : ${LDSHARED="qcc -shared"}
configure.in:	esix*|uxpds*) 	: ${LDSHARED="ld -G"}
configure.in:	osf*) 		: ${LDSHARED="ld -shared -expect_unresolved \"*\""}
configure.in:			*shlicc*)	: ${LDSHARED="$CC -r"}
configure.in:	linux* | gnu* | k*bsd*-gnu | netbsd* | bsdi*)
configure.in:			: ${LDSHARED='${CC} -shared'}
configure.in:			    LDFLAGS="$LDFLAGS -Wl,-export-dynamic"
configure.in:	interix*) 	: ${LDSHARED="$CC -shared"}
configure.in:			XLDFLAGS="$XLDFLAGS -Wl,-E"
configure.in:			LIBPATHFLAG=" -L%1\$-s"
configure.in:	freebsd*|dragonfly*)       : ${LDSHARED="$CC -shared"}
configure.in:			    LDFLAGS="$LDFLAGS -rdynamic"
configure.in:			    DLDFLAGS="$DLDFLAGS "'-Wl,-soname,$(.TARGET)'
configure.in:			  test "$GCC" = yes && test "$rb_cv_prog_gnu_ld" = yes || LDSHARED="ld -Bshareable"
configure.in:	openbsd*) 	: ${LDSHARED="\$(CC) -shared ${CCDLFLAGS}"}
configure.in:			    LDFLAGS="$LDFLAGS -Wl,-E"
configure.in:	nextstep*)	: ${LDSHARED='cc -r -nostdlib'}
configure.in:			LDFLAGS="$LDFLAGS -u libsys_s"
configure.in:	openstep*)	: ${LDSHARED='cc -dynamic -bundle -undefined suppress'}
configure.in:	rhapsody*)	: ${LDSHARED='cc -dynamic -bundle -undefined suppress'}
configure.in:	darwin*)	: ${LDSHARED='cc -dynamic -bundle -undefined suppress -flat_namespace'}
configure.in:			hdr=`find /usr/local/include -name \*.h -type f | sed 's:^/usr/local/include/::;q'`
configure.in:			if test -n "$hdr" && $CC -E -include "$hdr" -xc /dev/null | fgrep -q "$hdr"; then
configure.in:			    $CC -print-search-dirs | grep -q '^libraries:.*:/usr/local/lib/*' ||
configure.in:			    echo " $LDFLAGS " | grep -q ' -L */usr/local/lib/* ' ||
configure.in:			    LDFLAGS="${LDFLAGS:+$LDFLAGS }-L/usr/local/lib"
configure.in:			    : ${LDSHARED='$(CC) -shared'}
configure.in:			LDSHARED="$LDSHARED ${linker_flag}-G"
configure.in:			DLDFLAGS='-eInit_$(TARGET)'
configure.in:			XLDFLAGS="${linker_flag}-bE:ruby.imp ${linker_flag}-brtl"
configure.in:			XLDFLAGS="$XLDFLAGS ${linker_flag}-blibpath:${prefix}/lib:${LIBPATH:-/usr/lib:/lib}"
configure.in:                        TRY_LINK='$(CC) $(LDFLAGS) -oconftest $(INCFLAGS) -I$(hdrdir) $(CPPFLAGS)'
configure.in:			RPATHFLAG=" ${linker_flag}-blibpath:%1\$-s"
configure.in:			    : ${LDSHARED="ld -xms"}
configure.in:			    DLDFLAGS="$DLDFLAGS "'-export Init_$(TARGET) -lbe -lroot glue-noinit.a init_term_dyn.o start_dyn.o'
configure.in:			    LDFLAGS="$LDFLAGS -L/boot/home/config/lib -lbe -lroot"
configure.in:			    : ${LDSHARED="ld -shared"}
configure.in:			    DLDFLAGS="$DLDFLAGS -L/boot/develop/lib/x86 -L/boot/home/config/lib \$(topdir)/_APP_ -lbe -lroot"
configure.in:			    LDFLAGS="$LDFLAGS -L/boot/develop/lib/x86 -L/boot/home/config/lib -lbe -lroot"
configure.in:			    : ${LDSHARED="ld -xms"}
configure.in:			    DLDFLAGS="$DLDFLAGS "'-export Init_$(TARGET) -lbe -lroot glue-noinit.a init_term_dyn.o start_dyn.o'
configure.in:			    : ${LDSHARED="ld -shared"}
configure.in:			    DLDFLAGS="$DLDFLAGS -L/boot/develop/lib/x86 -lbe -lroot"
configure.in:	nto-qnx*)	DLDFLAGS="$DLDFLAGS -L/lib -L/usr/lib -L/usr/local/lib"
configure.in:			: ${LDSHARED='ld -Bshareable -x'}
configure.in:			LDFLAGS="$LDFLAGS -L/lib -L/usr/lib -L/usr/local/lib"
configure.in:	cygwin*|mingw*)	: ${LDSHARED="${CC} -shared "'$(if $(filter-out -g -g0,$(debugflags)),,-s)'}
configure.in:			XLDFLAGS="$XLDFLAGS -Wl,--stack,0x00200000,--enable-auto-import"
configure.in:			DLDFLAGS="${DLDFLAGS} -Wl,--enable-auto-image-base,--enable-auto-import"
configure.in:	hiuxmpp)	: ${LDSHARED='ld -r'} ;;
configure.in:	atheos*) 	: ${LDSHARED="$CC -shared"}
configure.in:	os2-emx*)	LDFLAGS="$LDFLAGS -Zomf"
configure.in:    : ${LIBPATHFLAG=' -L%1$-s'};;
configure.in:    : ${LIBPATHFLAG=' -L%s'};;
configure.in:AC_SUBST(LIBPATHENV, "${LIBPATHENV-LD_LIBRARY_PATH}")
configure.in:    STATIC=-static
configure.in:    STATIC=-Bstatic
configure.in:    os2-emx*)	DLEXT=dll;;
configure.in:n=`expr "$DLEXT"  : '.*'`; test "$n" -gt "$len" && len=$n
configure.in:n=`expr "$DLEXT2" : '.*'`; test "$n" -gt "$len" && len=$n
configure.in:  linux* | gnu* | k*bsd*-gnu)
configure.in:	STRIP='strip -S -x';;
configure.in:	STRIP='strip -A -n';;
configure.in:	STRIP='strip -A -n';;
configure.in:	STRIP='strip -A -n';;
configure.in:	STRIP='strip -A -n';;
configure.in:AC_ARG_WITH(static-linked-ext,
configure.in:	    [  --with-static-linked-ext link external modules statically],
configure.in:    CFLAGS="$CFLAGS -fansi-only"
configure.in:    XCFLAGS="$XCFLAGS -cc1-stack=262144 -cpp-stack=2694144"
configure.in:  os2-emx)
configure.in:  test x"$MINIRUBY" = x && MINIRUBY="${RUBY-ruby} -I`pwd` "-r'$(arch)-fake'
configure.in:  PREP='$(arch)-fake.rb'
configure.in:  RUNRUBY='$(MINIRUBY) -I`cd $(srcdir)/lib; pwd`'
configure.in:  MINIRUBY='./miniruby$(EXEEXT) -I$(srcdir)/lib'
configure.in:  MINIRUBY="$MINIRUBY"' -I$(EXTOUT)/common -I./- -r$(srcdir)/ext/purelib.rb'
configure.in:  RUNRUBY='$(MINIRUBY) $(srcdir)/runruby.rb --extout=$(EXTOUT)'
configure.in:LIBRUBY_A='lib$(RUBY_SO_NAME)-static.a'
configure.in:LIBRUBYARG_STATIC='-l$(RUBY_SO_NAME)-static'
configure.in:  cygwin*|mingw*|beos*|haiku*|openstep*|nextstep*|rhapsody*|darwin*|os2-emx*)
configure.in:    DLDLIBS="$DLDLIBS -lc"
configure.in:       [  --enable-shared         build a shared library for Ruby. ],
configure.in:LIBRUBYARG_SHARED='-l$(RUBY_SO_NAME)'
configure.in:    linux* | gnu* | k*bsd*-gnu | atheos*)
configure.in:	LIBRUBY_DLDFLAGS='-Wl,-soname,lib$(RUBY_SO_NAME).so.$(MAJOR).$(MINOR)'
configure.in:	LIBRUBY_DLDFLAGS='-Wl,-soname,lib$(RUBY_SO_NAME).so.$(MAJOR)$(MINOR)'
configure.in:	    LIBRUBY_DLDFLAGS="$DLDFLAGS "'-Wl,-h,$(@F)'
configure.in:	XLDFLAGS="$XLDFLAGS "'-R${libdir}'
configure.in:	XLDFLAGS="$XLDFLAGS "'-Wl,+s,+b,$(libdir)'
configure.in:	LIBRUBY_DLDFLAGS="${linker_flag}-bnoentry $XLDFLAGS"
configure.in:	LIBRUBYARG_SHARED='-L${libdir} -l${RUBY_SO_NAME}'
configure.in:	SOLIBS='-lm -lc'
configure.in:	    LIBRUBY_DLDFLAGS='-f ruby.exp -lnet -lbe -lroot glue-noinit.a init_term_dyn.o start_dyn.o'
configure.in:	LIBRUBY_LDSHARED='cc -dynamiclib -undefined suppress -flat_namespace'
configure.in:	LIBRUBY_DLDFLAGS='-install_name $(libdir)/lib$(RUBY_SO_NAME).dylib -current_version $(MAJOR).$(MINOR).$(TEENY) -compatibility_version $(ruby_version)'
configure.in:	LIBRUBYARG_SHARED='-L. -L${libdir} -l$(RUBY_SO_NAME)'
configure.in:    LIBRUBY_RPATHFLAGS="${linker_flag}-R ${linker_flag}\$(libdir) -L\$(libdir)"
configure.in:LDFLAGS="-L. $LDFLAGS"
configure.in:AC_ARG_ENABLE(install-doc,
configure.in:       [  --disable-install-doc    do not install rdoc indexes during install ],
configure.in:   RDOCTARGET="install-doc"
configure.in:	CFLAGS="$CFLAGS -pipe"
configure.in:	# The -fno-common is needed if we wish to embed the Ruby interpreter
configure.in:	# within the project's application).  The -I/usr/local/include is
configure.in:	# needed because CPP as discovered by configure (cc -E -traditional)
configure.in:	CFLAGS="$CFLAGS -pipe -fno-common"
configure.in:	CPPFLAGS="$CPPFLAGS -I/usr/local/include"
configure.in:	CFLAGS="$CFLAGS -pipe -no-precomp -fno-common"
configure.in:	CFLAGS="$CFLAGS -pipe -fno-common"
configure.in:    os2-emx)
configure.in:    	CFLAGS="$CFLAGS -DOS2"
configure.in:	  # the main point is the '-v' flag of 'cc'.
configure.in:	  case "`cc -v -I. -c main.c -o /tmp/main.o 2>&1`" in
configure.in:                        CFLAGS="$CFLAGS -oldc"
configure.in:	  rm -f /tmp/main.o
configure.in:	  CFLAGS="$CFLAGS -std"
configure.in:	    CFLAGS="$CFLAGS -relax_pointers"
configure.in:	CPPFLAGS="$CPPFLAGS -I/boot/home/config/include"
configure.in:	LIBRUBY_DLDFLAGS="${DLDFLAGS}"' -Wl,--out-implib=$(LIBRUBY)'
configure.in:	    RUBY_SO_NAME=${rb_cv_msvcrt}-'$(RUBY_INSTALL_NAME)'${MAJOR}${MINOR}${TEENY}
configure.in:	    LIBRUBYARG='-l$(RUBY_SO_NAME)'
configure.in:	    XCFLAGS="$XCFLAGS -DYYMAXDEPTH=300"
configure.in:	    YACC="$YACC -Nl40000 -Nm40000"
configure.in:    AC_MSG_CHECKING([for if ${MAKE-make} is GNU make])
configure.in:    gnumake=`(cd conftest.dir; ${MAKE-make})`
configure.in:    rm -fr conftest.dir
configure.in:	echo "-include uncommon.mk" >> GNUmakefile
configure.in:test -z "$CPPFLAGS" || CPPFLAGS="$CPPFLAGS "; CPPFLAGS="$CPPFLAGS"'${cppflags}'
configure.in:AC_ARG_WITH(ruby-version,
configure.in:	    [  --with-ruby-version=STR ruby version string for version specific directories [[full]] (full|minor|STR)],
configure.in:	    [  --with-sitedir=DIR      site libraries in DIR [[LIBDIR/ruby/site_ruby]]],
configure.in:	    [  --with-vendordir=DIR    vendor libraries in DIR [[LIBDIR/ruby/vendor_ruby]]],
configure.in:  cygwin*|mingw*|*djgpp*|os2-emx*)
configure.in:    arch="fat-${target_os}"
configure.in:                 "${RUBY_LIB_PATH}/" __ARCHITECTURE__ "-${target_os}")
configure.in:                 "${RUBY_SITE_LIB_PATH}/" __ARCHITECTURE__ "-${target_os}")
configure.in:                 "${RUBY_VENDOR_LIB_PATH}/" __ARCHITECTURE__ "-${target_os}")
configure.in:    AC_DEFINE_UNQUOTED(RUBY_PLATFORM, __ARCHITECTURE__ "-${target_os}")
configure.in:    arch="${target_cpu}-${target_os}"
configure.in:  mingw*) sitearch="$target_cpu-$rb_cv_msvcrt" ;;
configure.in:AC_ARG_WITH(search-path,
configure.in:		[  --with-search-path=DIR specify the additional search path],
configure.in:	    [  --with-ruby-hdrdir=DIR  core headers in DIR [INCLUDEDIR]],
configure.in:	    [rubyhdrdir='${includedir}/${RUBY_INSTALL_NAME}-${ruby_version}'])
configure.in:	    [  --with-site-hdrdir=DIR  core headers in DIR [INCLUDEDIR]],
configure.in:	    [  --with-vendor-hdrdir=DIR core headers in DIR [INCLUDEDIR]],
configure.in:		[  --with-mantype=TYPE specify man page type; TYPE is one of man and doc],
configure.in:if test -z "$MANTYPE"; then
configure.in:	if ${NROFF} -mdoc ${srcdir}/man/ruby.1 >/dev/null 2>&1; then
configure.in:if test -f "${config_h}" && tr -d '\015' < confdefs.h | cmp -s "${config_h}" -; then
configure.in:  tr -d '\015' < confdefs.h > "${config_h}"
configure.in:tr -d '\015' < largefile.h > confdefs.h
configure.in:BUILTIN_ENCS=["`sed -n -e '/^BUILTIN_ENCS[ 	]*=/{' \
configure.in:	-e s/// -e :l -e '/\\\\$/N' -e 's/\\\\\\n/ /' -e 't l' -e p \
configure.in:	-e '}' "${srcdir}/enc/Makefile.in"`"]
configure.in:BUILTIN_TRANSES=["`sed -n -e '/^BUILTIN_TRANSES[ 	]*=/{' \
configure.in:	-e s/// -e :l -e '/\\\\$/N' -e 's/\\\\\\n/ /' -e 't l' -e p \
configure.in:	-e '}' "${srcdir}/enc/Makefile.in"`"]
configure.in:	if test -d "$srcdir/.svn"; then
configure.in:	elif test -d "$srcdir/.git/svn"; then
configure.in:	elif test -d "$srcdir/.git"; then
configure.in:	    echo 'distclean-local::; @$(RM) GNUmakefile uncommon.mk'
configure.in:      } >> confmk$$.tmp && mv -f confmk$$.tmp Makefile],
cont.c:  cont.c - 
cont.c:    int vm_stack_slen;  /* length of stack (head of th->stack) */
cont.c:    int vm_stack_clen;  /* length of control frames (tail of th->stack) */
cont.c:	rb_gc_mark(cont->value);
cont.c:	rb_thread_mark(&cont->saved_thread);
cont.c:	if (cont->vm_stack) {
cont.c:	    rb_gc_mark_locations(cont->vm_stack,
cont.c:				 cont->vm_stack + cont->vm_stack_slen + cont->vm_stack_clen);
cont.c:	    rb_gc_mark_localtion(cont->vm_stack,
cont.c:				 cont->vm_stack, cont->saved_thread.stack_size);
cont.c:	if (cont->machine_stack) {
cont.c:	    rb_gc_mark_locations(cont->machine_stack,
cont.c:				 cont->machine_stack + cont->machine_stack_size);
cont.c:	if (cont->machine_register_stack) {
cont.c:	    rb_gc_mark_locations(cont->machine_register_stack,
cont.c:				 cont->machine_register_stack + cont->machine_register_stack_size);
cont.c:	RUBY_FREE_UNLESS_NULL(cont->saved_thread.stack); fflush(stdout);
cont.c:	RUBY_FREE_UNLESS_NULL(cont->machine_stack);
cont.c:	RUBY_FREE_UNLESS_NULL(cont->machine_register_stack);
cont.c:	RUBY_FREE_UNLESS_NULL(cont->vm_stack);
cont.c:	rb_gc_mark(fib->prev);
cont.c:	cont_mark(&fib->cont);
cont.c:    fib->next_fiber = current_fib->next_fiber;
cont.c:    fib->prev_fiber = current_fib;
cont.c:    current_fib->next_fiber->prev_fiber = fib;
cont.c:    current_fib->next_fiber = fib;
cont.c:    fib->prev_fiber->next_fiber = fib->next_fiber;
cont.c:    fib->next_fiber->prev_fiber = fib->prev_fiber;
cont.c:	if (fib->cont.type != ROOT_FIBER_CONTEXT) {
cont.c:	    st_free_table(fib->cont.saved_thread.local_storage);
cont.c:	cont_free(&fib->cont);
cont.c:    rb_thread_t *sth = &cont->saved_thread;
cont.c:    SET_MACHINE_STACK_END(&th->machine_stack_end);
cont.c:    th->machine_register_stack_end = rb_ia64_bsp();
cont.c:    if (th->machine_stack_start > th->machine_stack_end) {
cont.c:	size = cont->machine_stack_size = th->machine_stack_start - th->machine_stack_end;
cont.c:	cont->machine_stack_src = th->machine_stack_end;
cont.c:	size = cont->machine_stack_size = th->machine_stack_end - th->machine_stack_start;
cont.c:	cont->machine_stack_src = th->machine_stack_start;
cont.c:    if (cont->machine_stack) {
cont.c:	REALLOC_N(cont->machine_stack, VALUE, size);
cont.c:	cont->machine_stack = ALLOC_N(VALUE, size);
cont.c:    MEMCPY(cont->machine_stack, cont->machine_stack_src, VALUE, size);
cont.c:    size = cont->machine_register_stack_size = th->machine_register_stack_end - th->machine_register_stack_start;
cont.c:    cont->machine_register_stack_src = th->machine_register_stack_start;
cont.c:    if (cont->machine_register_stack) {
cont.c:	REALLOC_N(cont->machine_register_stack, VALUE, size);
cont.c:	cont->machine_register_stack = ALLOC_N(VALUE, size);
cont.c:    MEMCPY(cont->machine_register_stack, cont->machine_register_stack_src, VALUE, size);
cont.c:    sth->machine_stack_start = sth->machine_stack_end = 0;
cont.c:    sth->machine_register_stack_start = sth->machine_register_stack_end = 0;
cont.c:    cont->saved_thread = *th;
cont.c:    cont->self = contval;
cont.c:    contval = cont->self;
cont.c:    sth = &cont->saved_thread;
cont.c:    cont->vm_stack_slen = th->cfp->sp + th->mark_stack_len - th->stack;
cont.c:    cont->vm_stack_clen = th->stack + th->stack_size - (VALUE*)th->cfp;
cont.c:    cont->vm_stack = ALLOC_N(VALUE, cont->vm_stack_slen + cont->vm_stack_clen);
cont.c:    MEMCPY(cont->vm_stack, th->stack, VALUE, cont->vm_stack_slen);
cont.c:    MEMCPY(cont->vm_stack + cont->vm_stack_slen, (VALUE*)th->cfp, VALUE, cont->vm_stack_clen);
cont.c:    cont->vm_stack = ALLOC_N(VALUE, th->stack_size);
cont.c:    MEMCPY(cont->vm_stack, th->stack, VALUE, th->stack_size);
cont.c:    sth->stack = 0;
cont.c:    if (ruby_setjmp(cont->jmpbuf)) {
cont.c:	value = cont->value;
cont.c:	if (cont->argc == -1) rb_exc_raise(value);
cont.c:	cont->value = Qnil;
cont.c:	return cont->self;
cont.c:    rb_thread_t *th = GET_THREAD(), *sth = &cont->saved_thread;
cont.c:    if (cont->type == CONTINUATION_CONTEXT) {
cont.c:	th->fiber = sth->fiber;
cont.c:	fib = th->fiber ? th->fiber : th->root_fiber;
cont.c:	    th->stack_size = fcont->saved_thread.stack_size;
cont.c:	    th->stack = fcont->saved_thread.stack;
cont.c:	MEMCPY(th->stack, cont->vm_stack, VALUE, cont->vm_stack_slen);
cont.c:	MEMCPY(th->stack + sth->stack_size - cont->vm_stack_clen,
cont.c:	       cont->vm_stack + cont->vm_stack_slen, VALUE, cont->vm_stack_clen);
cont.c:	MEMCPY(th->stack, cont->vm_stack, VALUE, sth->stack_size);
cont.c:	th->stack = sth->stack;
cont.c:	th->stack_size = sth->stack_size;
cont.c:	th->local_storage = sth->local_storage;
cont.c:	th->fiber = cont->self;
cont.c:    th->cfp = sth->cfp;
cont.c:    th->safe_level = sth->safe_level;
cont.c:    th->raised_flag = sth->raised_flag;
cont.c:    th->state = sth->state;
cont.c:    th->status = sth->status;
cont.c:    th->tag = sth->tag;
cont.c:    th->trap_tag = sth->trap_tag;
cont.c:    th->errinfo = sth->errinfo;
cont.c:    th->first_proc = sth->first_proc;
cont.c:	((_JUMP_BUFFER*)(&cont->jmpbuf))->Frame =
cont.c:	    ((_JUMP_BUFFER*)(&buf))->Frame;
cont.c:    if (cont->machine_stack_src) {
cont.c:	MEMCPY(cont->machine_stack_src, cont->machine_stack,
cont.c:	       VALUE, cont->machine_stack_size);
cont.c:    if (cont->machine_register_stack_src) {
cont.c:	MEMCPY(cont->machine_register_stack_src, cont->machine_register_stack,
cont.c:	       VALUE, cont->machine_register_stack_size);
cont.c:    ruby_longjmp(cont->jmpbuf, 1);
cont.c:    if (curr_bsp < cont->machine_register_stack_src+cont->machine_register_stack_size) {
cont.c:    if (cont->machine_stack_src) {
cont.c:	if (addr_in_prev_frame > cont->machine_stack_src) {
cont.c:	if (addr_in_prev_frame < cont->machine_stack_src + cont->machine_stack_size) {
cont.c:	    cont_restore_0(cont, &space[STACK_PAD_SIZE-1]);
cont.c:	    if (addr_in_prev_frame > cont->machine_stack_src) {
cont.c:	    if (addr_in_prev_frame < cont->machine_stack_src + cont->machine_stack_size) {
cont.c:		cont_restore_0(cont, &space[STACK_PAD_SIZE-1]);
cont.c: *  Document-class: Continuation
cont.c: *  call-seq:
cont.c: *  call-seq:
cont.c:    if (cont->saved_thread.self != th->self) {
cont.c:    if (cont->saved_thread.trap_tag != th->trap_tag) {
cont.c:    if (cont->saved_thread.fiber) {
cont.c:	GetContPtr(cont->saved_thread.fiber, fcont);
cont.c:	if (th->fiber != cont->saved_thread.fiber) {
cont.c:    cont->argc = argc;
cont.c:    cont->value = make_passing_arg(argc, argv);
cont.c: *  Document-class: Fiber
cont.c:    fib->cont.self = fibval;
cont.c:    fib->cont.type = FIBER_CONTEXT;
cont.c:    cont_init(&fib->cont);
cont.c:    fib->prev = Qnil;
cont.c:    fib->status = CREATED;
cont.c:    rb_context_t *cont = &fib->cont;
cont.c:    rb_thread_t *th = &cont->saved_thread;
cont.c:    cont->vm_stack = 0;
cont.c:    th->stack = 0;
cont.c:    th->stack_size = FIBER_VM_STACK_SIZE;
cont.c:    th->stack = ALLOC_N(VALUE, th->stack_size);
cont.c:    th->cfp = (void *)(th->stack + th->stack_size);
cont.c:    th->cfp--;
cont.c:    th->cfp->pc = 0;
cont.c:    th->cfp->sp = th->stack + 1;
cont.c:    th->cfp->bp = 0;
cont.c:    th->cfp->lfp = th->stack;
cont.c:    *th->cfp->lfp = 0;
cont.c:    th->cfp->dfp = th->stack;
cont.c:    th->cfp->self = Qnil;
cont.c:    th->cfp->flag = 0;
cont.c:    th->cfp->iseq = 0;
cont.c:    th->cfp->proc = 0;
cont.c:    th->cfp->block_iseq = 0;
cont.c:    th->tag = 0;
cont.c:    th->local_storage = st_init_numtable();
cont.c:    th->first_proc = proc;
cont.c:    MEMCPY(&cont->jmpbuf, &th->root_jmpbuf, rb_jmpbuf_t, 1);
cont.c:    if (fib->prev == Qnil) {
cont.c:	if (th->root_fiber != curr) {
cont.c:	    return th->root_fiber;
cont.c:	VALUE prev = fib->prev;
cont.c:	fib->prev = Qnil;
cont.c:    VALUE value = fib->cont.value;
cont.c:    fib->status = TERMINATED;
cont.c:    GetFiberPtr(th->fiber, fib);
cont.c:    cont = &fib->cont;
cont.c:	GetProcPtr(cont->saved_thread.first_proc, proc);
cont.c:	args = cont->value;
cont.c:	argv = (argc = cont->argc) > 1 ? RARRAY_PTR(args) : &args;
cont.c:	cont->value = Qnil;
cont.c:	th->errinfo = Qnil;
cont.c:	th->local_lfp = proc->block.lfp;
cont.c:	th->local_svar = Qnil;
cont.c:	fib->status = RUNNING;
cont.c:	cont->value = rb_vm_invoke_proc(th, proc, proc->block.self, argc, argv, 0);
cont.c:	    th->thrown_errinfo = th->errinfo;
cont.c:	    th->thrown_errinfo =
cont.c:	      rb_vm_make_jump_tag_but_local_jump(state, th->errinfo);
cont.c:    fib->cont.type = ROOT_FIBER_CONTEXT;
cont.c:    fib->prev_fiber = fib->next_fiber = fib;
cont.c:    if (th->fiber == 0) {
cont.c:	th->root_fiber = th->fiber = fib->cont.self;
cont.c:    return th->fiber;
cont.c:    if (th->fiber) {
cont.c:	GetFiberPtr(th->fiber, fib);
cont.c:	fib->cont.saved_thread = *th;
cont.c:	th->root_fiber = th->fiber = fib->cont.self;
cont.c:    cont_save_machine_stack(th, &fib->cont);
cont.c:    if (ruby_setjmp(fib->cont.jmpbuf)) {
cont.c:	GetFiberPtr(th->fiber, fib);
cont.c:	if (fib->cont.argc == -1) rb_exc_raise(fib->cont.value);
cont.c:	return fib->cont.value;
cont.c:    cont = &fib->cont;
cont.c:    if (cont->saved_thread.self != th->self) {
cont.c:    else if (cont->saved_thread.trap_tag != th->trap_tag) {
cont.c:    else if (fib->status == TERMINATED) {
cont.c:	if (th->fiber != fibval) rb_exc_raise(value);
cont.c:	fibval = fib->prev;
cont.c:	if (NIL_P(fibval)) fibval = th->root_fiber;
cont.c:	cont = &fib->cont;
cont.c:	cont->argc = -1;
cont.c:	cont->value = value;
cont.c:	fib->prev = rb_fiber_current();
cont.c:    cont->argc = argc;
cont.c:    cont->value = make_passing_arg(argc, argv);
cont.c:    if (fib->prev != Qnil) {
cont.c: *  call-seq:
cont.c: *     fiber.alive? -> true or false
cont.c:    return fib->status != TERMINATED;
cont.c: *  call-seq:
cont.c: *     fiber.resume(args, ...) -> obj
cont.c: *  call-seq:
cont.c: *     fiber.transfer(args, ...) -> obj
cont.c: *  call-seq:
cont.c: *     Fiber.yield(args, ...) -> obj
cont.c: *  call-seq:
cont.c: *     Fiber.current() -> fiber
cont.c:    rb_define_singleton_method(rb_cFiber, "yield", rb_fiber_s_yield, -1);
cont.c:    rb_define_method(rb_cFiber, "resume", rb_fiber_m_resume, -1);
cont.c:    rb_define_method(rb_cContinuation, "call", rb_cont_call, -1);
cont.c:    rb_define_method(rb_cContinuation, "[]", rb_cont_call, -1);
cont.c:    rb_define_method(rb_cFiber, "transfer", rb_fiber_m_transfer, -1);
ãã¤ããªã¼ã»ãã¡ã¤ã«cont.oã¯ä¸è´ãã¾ãã
debug.c:  debug.c -
debug.c:  Copyright (C) 2004-2007 Koichi Sasada
debug.c:		obj == -1 ? "" : StringValueCStr(str));
debug.c:	if (len == sizeof(name) - 1 &&	    \
debug.h:  debug.h - YARV Debug function interface
debug.h:  Copyright (C) 2004-2007 Koichi Sasada
debug.h:#define dpv(h,v) ruby_debug_print_value(-1, 0, h, v)
debug.h:#define dp(v)    ruby_debug_print_value(-1, 0, "", v)
debug.h:#define dpi(i)   ruby_debug_print_id(-1, 0, "", i)
debug.h:#define dpn(n)   ruby_debug_print_node(-1, 0, "", n)
ãã¤ããªã¼ã»ãã¡ã¤ã«debug.oã¯ä¸è´ãã¾ãã
diff.txt:diff --git a/#id.h# b/#id.h#
diff.txt:--- a/#id.h#
diff.txt:@@ -1,163 +0,0 @@
diff.txt:-/* DO NOT EDIT THIS FILE DIRECTLY */
diff.txt:-/**********************************************************************
diff.txt:-
diff.txt:-  id.h - 
diff.txt:-
diff.txt:-  $Author: nobu $
diff.txt:-  created at: Sun Oct 19 21:12:51 2008
diff.txt:-
diff.txt:-  Copyright (C) 2007 Koichi Sasada
diff.txt:-
diff.txt:-**********************************************************************/
diff.txt:-
diff.txt:-#ifndef RUBY_ID_H
diff.txt:-#define RUBY_ID_H
diff.txt:-
diff.txt:-#define ID_SCOPE_SHIFT 3
diff.txt:-#define ID_SCOPE_MASK 0x07
diff.txt:-#define ID_LOCAL      0x00
diff.txt:-#define ID_INSTANCE   0x01
diff.txt:-#define ID_GLOBAL     0x03
diff.txt:-#define ID_ATTRSET    0x04
diff.txt:-#define ID_CONST      0x05
diff.txt:-#define ID_CLASS      0x06
diff.txt:-#define ID_JUNK       0x07
diff.txt:-#define ID_INTERNAL   ID_JUNK
diff.txt:-
diff.txt:-#ifdef USE_PARSE_H
diff.txt:-#include "parse.h"
diff.txt:-#endif
diff.txt:-
diff.txt:-#define symIFUNC ID2SYM(idIFUNC)
diff.txt:-#define symCFUNC ID2SYM(idCFUNC)
diff.txt:-
diff.txt:-#if !defined tLAST_TOKEN && defined YYTOKENTYPE
diff.txt:-#define tLAST_TOKEN tLAST_TOKEN
diff.txt:-#endif
diff.txt:-
diff.txt:-enum ruby_method_ids {
diff.txt:-#ifndef tLAST_TOKEN
diff.txt:-  tUPLUS = 322,
diff.txt:-    tUMINUS = 323,
diff.txt:-    tPOW = 324,
diff.txt:-    tCMP = 325,
diff.txt:-    tEQ = 326,
diff.txt:-    tEQQ = 327,
diff.txt:-    tNEQ = 328,
diff.txt:-    tGEQ = 329,
diff.txt:-    tLEQ = 330,
diff.txt:-    tANDOP = 331,
diff.txt:-    tOROP = 332,
diff.txt:-    tMATCH = 333,
diff.txt:-    tNMATCH = 334,
diff.txt:-    tDOT2 = 335,
diff.txt:-    tDOT3 = 336,
diff.txt:-    tAREF = 337,
diff.txt:-    tASET = 338,
diff.txt:-    tLSHFT = 339,
diff.txt:-    tRSHFT = 340,
diff.txt:-    tLAMBDA = 353,
diff.txt:-    idNULL = 366,
diff.txt:-    idRespond_to = 367,
diff.txt:-    idIFUNC = 368,
diff.txt:-    idCFUNC = 369,
diff.txt:-    idThrowState = 370,
diff.txt:-    id_core_set_method_alias = 371,
diff.txt:-    id_core_set_variable_alias = 372,
diff.txt:-    id_core_undef_method = 373,
diff.txt:-    id_core_define_method = 374,
diff.txt:-    id_core_define_singleton_method = 375,
diff.txt:-    id_core_set_postexe = 376,
diff.txt:-    tLAST_TOKEN = 377,
diff.txt:-#endif
diff.txt:-    idPLUS = '+',
diff.txt:-    idMINUS = '-',
diff.txt:-    idMULT = '*',
diff.txt:-    idDIV = '/',
diff.txt:-    idMOD = '%',
diff.txt:-    idLT = '<',
diff.txt:-    idLTLT = tLSHFT,
diff.txt:-    idLE = tLEQ,
diff.txt:-    idGT = '>',
diff.txt:-    idGE = tGEQ,
diff.txt:-    idEq = tEQ,
diff.txt:-    idEqq = tEQQ,
diff.txt:-    idNeq = tNEQ,
diff.txt:-    idNot = '!',
diff.txt:-    idBackquote = '`',
diff.txt:-    idEqTilde = tMATCH,
diff.txt:-    idAREF = tAREF,
diff.txt:-    idASET = tASET,
diff.txt:-    idLAST_TOKEN = tLAST_TOKEN >> ID_SCOPE_SHIFT,
diff.txt:-    tIntern,
diff.txt:-    tMethodMissing,
diff.txt:-    tLength,
diff.txt:-    tGets,
diff.txt:-    tSucc,
diff.txt:-    tEach,
diff.txt:-    tLambda,
diff.txt:-    tSend,
diff.txt:-    t__send__,
diff.txt:-    tInitialize,
diff.txt:-#if SUPPORT_JOKE
diff.txt:-    tBitblt,
diff.txt:-    tAnswer,
diff.txt:-#endif
diff.txt:-    tLAST_ID,
diff.txt:-#define TOKEN2ID(n) id##n = ((t##n<<ID_SCOPE_SHIFT)|ID_LOCAL)
diff.txt:-#if SUPPORT_JOKE
diff.txt:-    TOKEN2ID(Bitblt),
diff.txt:-    TOKEN2ID(Answer),
diff.txt:-#endif
diff.txt:-    TOKEN2ID(Intern),
diff.txt:-    TOKEN2ID(MethodMissing),
diff.txt:-    TOKEN2ID(Length),
diff.txt:-    TOKEN2ID(Gets),
diff.txt:-    TOKEN2ID(Succ),
diff.txt:-    TOKEN2ID(Each),
diff.txt:-    TOKEN2ID(Lambda),
diff.txt:-    TOKEN2ID(Send),
diff.txt:-    TOKEN2ID(__send__),
diff.txt:-    TOKEN2ID(Initialize)
diff.txt:-};
diff.txt:-
diff.txt:-#ifdef tLAST_TOKEN
diff.txt:-struct ruby_method_ids_check {
diff.txt:-#define ruby_method_id_check_for(name, value) \
diff.txt:-    int checking_for_##name[name == value ? 1 : -1]
diff.txt:-ruby_method_id_check_for(tUPLUS, 322);
diff.txt:-ruby_method_id_check_for(tUMINUS, 323);
diff.txt:-ruby_method_id_check_for(tPOW, 324);
diff.txt:-ruby_method_id_check_for(tCMP, 325);
diff.txt:-ruby_method_id_check_for(tEQ, 326);
diff.txt:-ruby_method_id_check_for(tEQQ, 327);
diff.txt:-ruby_method_id_check_for(tNEQ, 328);
diff.txt:-ruby_method_id_check_for(tGEQ, 329);
diff.txt:-ruby_method_id_check_for(tLEQ, 330);
diff.txt:-ruby_method_id_check_for(tANDOP, 331);
diff.txt:-ruby_method_id_check_for(tOROP, 332);
diff.txt:-ruby_method_id_check_for(tMATCH, 333);
diff.txt:-ruby_method_id_check_for(tNMATCH, 334);
diff.txt:-ruby_method_id_check_for(tDOT2, 335);
diff.txt:-ruby_method_id_check_for(tDOT3, 336);
diff.txt:-ruby_method_id_check_for(tAREF, 337);
diff.txt:-ruby_method_id_check_for(tASET, 338);
diff.txt:-ruby_method_id_check_for(tLSHFT, 339);
diff.txt:-ruby_method_id_check_for(tRSHFT, 340);
diff.txt:-ruby_method_id_check_for(tLAMBDA, 353);
diff.txt:-ruby_method_id_check_for(idNULL, 366);
diff.txt:-ruby_method_id_check_for(idRespond_to, 367);
diff.txt:-ruby_method_id_check_for(idIFUNC, 368);
diff.txt:-ruby_method_id_check_for(idCFUNC, 369);
diff.txt:-ruby_method_id_check_for(idThrowState, 370);
diff.txt:-ruby_method_id_check_for(id_core_set_method_alias, 371);
diff.txt:-ruby_method_id_check_for(id_core_set_variable_alias, 372);
diff.txt:-ruby_method_id_check_for(id_core_undef_method, 373);
diff.txt:-ruby_method_id_check_for(id_core_define_method, 374);
diff.txt:-ruby_method_id_check_for(id_core_define_singleton_method, 375);
diff.txt:-ruby_method_id_cck_for(id_core_set_postexe, 376);
diff.txt:-ruby_method_id_check_for(tLAST_TOKEN, 377);
diff.txt:-};
diff.txt:-#endif
diff.txt:-
diff.txt:-#endif /* RUBY_ID_H */
diff.txt:diff --git a/.#id.h b/.#id.h
diff.txt:--- a/.#id.h
diff.txt:@@ -1 +0,0 @@
diff.txt:-masahiro@malaptop.19845:1251433649
diff.txt:diff --git a/array.c b/array.c
diff.txt:--- a/array.c
diff.txt:@@ -27,6 +27,7 @@ static ID id_cmp;
diff.txt:@@ -2650,6 +2651,25 @@ rb_ary_rassoc(VALUE ary, VALUE value)
diff.txt:+  result = rb_funcall(obj1, rb_intern("p-match"), 1, obj2);
diff.txt:@@ -2677,7 +2697,19 @@ recursive_equal(VALUE ary1, VALUE ary2, int recur)
diff.txt:-
diff.txt:@@ -3801,6 +3833,7 @@ Init_Array(void)
diff.txt:+    rb_define_method(rb_cArray, "patern-match",rb_patern_match,1);
diff.txt:diff --git a/array.o b/array.o
diff.txt:diff --git a/class.o b/class.o
diff.txt:diff --git a/compile.c b/compile.c
diff.txt:--- a/compile.c
diff.txt:@@ -2229,6 +2229,111 @@ compile_branch_condition(rb_iseq_t *iseq, LINK_ANCHOR *ret, NODE * cond,
diff.txt:+  //unsigned long flag=n->flags;
diff.txt:+  switch(nd_type(n)-1){
diff.txt:+     n->u1.value = ID2SYM(n->nd_mid);
diff.txt:+    n->u1.value = ID2SYM(n->nd_vid);
diff.txt:+  n->flags = 0;
diff.txt:+  n->flags |= T_NODE;
diff.txt:+    n->u1.value = ID2SYM(n->nd_mid);
diff.txt:+    printf("id: %s\n", rb_id2name(n->nd_mid));
diff.txt:+    n->u1.value = ID2SYM(n->nd_vid);
diff.txt:+  n->u2.value = 0;
diff.txt:+  n->u3.value = 0;
diff.txt:+    int len = node->nd_alen, line = nd_line(node), i=0;
diff.txt:+	   switch(nd_type(node->nd_head)-1){
diff.txt:+	      var2sym(node->nd_head);
diff.txt:+	      COMPILE_(anchor, "array element", node->nd_head, poped);
diff.txt:+	    /*if(nd_type(node->nd_head)-1==NODE_LVAR){
diff.txt:+	      //printf("id: %s\n", rb_id2name(node->nd_head->nd_vid));
diff.txt:+	      var2sym(node->nd_head);
diff.txt:+	      //ADD_INSN1(anchor, nd_line(node->nd_head), putobject, ID2SYM(node->nd_head->nd_vid));
diff.txt:+	      COMPILE_(anchor, "array element", node->nd_head, poped);
diff.txt:+	      COMPILE_(anchor, "array element", node->nd_head, poped);
diff.txt:+	    if (opt_p && nd_type(node->nd_head) != NODE_LIT) {
diff.txt:+	    node = node->nd_next;
diff.txt:+	    rb_bug("node error: compile_array (%d: %d-%d)",
diff.txt:+		rb_ary_push(ary, node->nd_head->nd_lit);
diff.txt:+		node = node->nd_next;
diff.txt:@@ -2237,7 +2342,7 @@ compile_array_(rb_iseq_t *iseq, LINK_ANCHOR *ret, NODE* node_root,
diff.txt:     int len = node->nd_alen, line = nd_line(node), i=0;
diff.txt:-
diff.txt:@@ -2309,6 +2414,40 @@ case_when_optimizable_literal(NODE * node)
diff.txt:+	val = vals->nd_head;
diff.txt:+	ADD_SEND(cond_seq, nd_line(val), ID2SYM(rb_intern("patern-match")), INT2FIX(1));
diff.txt:+	vals = vals->nd_next;
diff.txt:@@ -3004,6 +3143,103 @@ iseq_compile_each(rb_iseq_t *iseq, LINK_ANCHOR *ret, NODE * node, int poped)
diff.txt:+	if (node->nd_head == 0) {
diff.txt:+	    COMPILE_(ret, "when", node->nd_body, poped);
diff.txt:+	COMPILE(head, "match base", node->nd_head);
diff.txt:+	node = node->nd_body;
diff.txt:+	    COMPILE_(body_seq, "when body", node->nd_body, poped);
diff.txt:+	    vals = node->nd_head;
diff.txt:+	    node = node->nd_next;
diff.txt:@@ -4266,7 +4502,7 @@ iseq_compile_each(rb_iseq_t *iseq, LINK_ANCHOR *ret, NODE * node, int poped)
diff.txt: 	    ID id = node->nd_vid;
diff.txt: 	    int idx = iseq->local_iseq->local_size - get_local_var_idx(iseq, id);
diff.txt:-
diff.txt:diff --git a/compile.o b/compile.o
diff.txt:diff --git a/cont.o b/cont.o
diff.txt:diff --git a/debug.o b/debug.o
diff.txt:diff --git a/defs/keywords b/defs/keywords
diff.txt:--- a/defs/keywords
diff.txt:@@ -16,7 +16,7 @@ and, {keyword_and, keyword_and}, EXPR_VALUE
diff.txt:-match, {keyword_match, keyword_match}, EXPR_VALUE
diff.txt:diff --git a/defs/lex.c.src b/defs/lex.c.src
diff.txt:--- a/defs/lex.c.src
diff.txt:@@ -16,7 +16,7 @@ and, {keyword_and, keyword_and}, EXPR_VALUE
diff.txt:-match, {keyword_match, keyword_match}, EXPR_VALUE
diff.txt:diff --git a/enum.o b/enum.o
diff.txt:diff --git a/error.o b/error.o
diff.txt:diff --git a/eval.o b/eval.o
diff.txt:diff --git a/gc.o b/gc.o
diff.txt:diff --git a/iseq.c b/iseq.c
diff.txt:--- a/iseq.c
diff.txt:@@ -333,6 +333,7 @@ rb_iseq_new_with_bopt_and_opt(NODE *node, VALUE name, VALUE filename,
diff.txt:     iseq->self = self;
diff.txt:diff --git a/iseq.o b/iseq.o
diff.txt:diff --git a/lex.c.blt b/lex.c.blt
diff.txt:--- a/lex.c.blt
diff.txt:@@ -176,7 +176,7 @@ rb_reserved_word (str, len)
diff.txt:-      {"match", {keyword_match, keyword_match}, EXPR_VALUE},
diff.txt:diff --git a/load.o b/load.o
diff.txt:diff --git a/match.rb b/match.rb
diff.txt:--- a/match.rb
diff.txt:@@ -1,14 +1,13 @@
diff.txt: # -*- coding: utf-8  -*
diff.txt:-match [1,2,3,9,4,5,6] #ä»ã®Rubyã§å®è¡ã§ãããã©
diff.txt:-    y=10
diff.txt:-  when 5
diff.txt:-   
diff.txt:-puts y
diff.txt:-puts RubyVM::InstructionSequence.compile_file(__FILE__).disasm
diff.txt:diff --git a/node.h b/node.h
diff.txt:--- a/node.h
diff.txt:@@ -34,8 +34,8 @@ enum node_type {
diff.txt:-    NODE_MATCH,
diff.txt:-#define NODE_MATCH       NODE_MATCH
diff.txt:@@ -368,7 +368,7 @@ typedef struct RNode {
diff.txt:-#define NEW_MATCH(h,b) NEW_NODE(NODE_MATCH,h,b,0)
diff.txt:diff --git a/object.c b/object.c
diff.txt:--- a/object.c
diff.txt:@@ -31,7 +31,7 @@ VALUE rb_cNilClass;
diff.txt:-static ID id_eq, id_eql, id_match, id_inspect, id_init_copy;
diff.txt:  *  call-seq:
diff.txt:@@ -41,12 +41,26 @@ static ID id_eq, id_eql, id_match, id_inspect, id_init_copy;
diff.txt:-
diff.txt:@@ -2513,6 +2527,8 @@ Init_Object(void)
diff.txt:+    rb_define_method(rb_mKernel, "patern-match", rb_patern_match, 1);
diff.txt:+    rb_define_method(rb_mKernel, "p-match", rb_pmatch, 1);
diff.txt:@@ -2650,8 +2666,10 @@ Init_Object(void)
diff.txt:+    id_peq = rb_intern("p-match");
diff.txt:+    id_patern_match = rb_intern("patern-match");
diff.txt:diff --git a/object.o b/object.o
diff.txt:diff --git a/parse.o b/parse.o
diff.txt:diff --git a/parse.y b/parse.y
diff.txt:--- a/parse.y
diff.txt:@@ -473,7 +473,7 @@ static int lvar_defined_gen(struct parser_params*, ID);
diff.txt: #define nd_paren(node) (char)((node)->u2.id >> CHAR_BIT*2)
diff.txt:-
diff.txt:@@ -622,7 +622,7 @@ static void token_info_pop(struct parser_params*, const char *token);
diff.txt:-        keyword_match
diff.txt:@@ -658,6 +658,7 @@ static void token_info_pop(struct parser_params*, const char *token);
diff.txt:@@ -669,10 +670,10 @@ static void token_info_pop(struct parser_params*, const char *token);
diff.txt:-%type <node> bodystmt compstmt stmts stmt expr arg primary command command_call method_call
diff.txt:-%type <node> expr_value arg_value primary_value
diff.txt:-%type <node> if_tail opt_else case_body cases opt_rescue exc_list exc_var opt_ensure
diff.txt:-%type <node> args call_args opt_call_args
diff.txt:@@ -1839,7 +1840,7 @@ op		: '|'		{ ifndef_ripper($$ = '|'); }
diff.txt:-		| keyword_break | keyword_case| keyword_match | keyword_class 
diff.txt:@@ -1850,7 +1851,11 @@ reswords	: keyword__LINE__ | keyword__FILE__ | keyword__ENCODING__
diff.txt:-
diff.txt:@@ -2325,7 +2330,17 @@ arg		: lhs '=' arg
diff.txt:-
diff.txt:@@ -2458,6 +2473,16 @@ opt_block_arg	: ',' block_arg
diff.txt:@@ -2543,7 +2568,20 @@ mrhs		: args ',' arg_value
diff.txt:-
diff.txt:@@ -2555,6 +2593,7 @@ primary		: literal
diff.txt:@@ -2700,6 +2739,7 @@ primary		: literal
diff.txt: 			$2->nd_iter = NEW_FCALL($1, 0);
diff.txt: 			fixpos($2->nd_iter, $2);
diff.txt:@@ -2770,12 +2810,12 @@ primary		: literal
diff.txt:-                | k_match expr_value opt_terms
diff.txt:-                  case_body
diff.txt:-			$$ = NEW_CASE($2, $4);
diff.txt:@@ -3075,7 +3115,7 @@ k_case		: keyword_case
diff.txt:-k_match         : keyword_match
diff.txt:@@ -3589,6 +3629,7 @@ block_call	: command do_block
diff.txt:@@ -3664,7 +3705,7 @@ method_call	: operation paren_args
diff.txt:-			if ($1 && nd_type($1) == NODE_SELF)
diff.txt:@@ -3716,6 +3757,22 @@ brace_block	: '{'
diff.txt:@@ -3732,7 +3789,9 @@ case_body	: keyword_when args then
diff.txt:-
diff.txt:@@ -4182,6 +4241,7 @@ variable	: tIDENTIFIER
diff.txt:@@ -8020,8 +8080,14 @@ gettable_gen(struct parser_params *parser, ID id)
diff.txt:-	if (local_id(id)) return NEW_LVAR(id);
diff.txt:@@ -10038,7 +10104,7 @@ static const struct kw_assoc {
diff.txt:-    {keyword_match,     "match"},
diff.txt:diff --git a/proc.o b/proc.o
diff.txt:diff --git a/process.o b/process.o
diff.txt:diff --git a/ruby.o b/ruby.o
diff.txt:diff --git a/safe.o b/safe.o
diff.txt:diff --git a/signal.o b/signal.o
diff.txt:diff --git a/string.c b/string.c
diff.txt:--- a/string.c
diff.txt:@@ -6885,6 +6885,17 @@ sym_equal(VALUE sym1, VALUE sym2)
diff.txt:@@ -7253,6 +7264,7 @@ Init_String(void)
diff.txt:+    rb_define_method(rb_cSymbol, "p-match", patern_equal,1); 
diff.txt:diff --git a/string.o b/string.o
diff.txt:diff --git a/thread.o b/thread.o
diff.txt:diff --git a/variable.o b/variable.o
diff.txt:diff --git a/vm.o b/vm.o
diff.txt:diff --git a/vm_dump.o b/vm_dump.o
diff.txt:diff --git a/vm_insnhelper.c b/vm_insnhelper.c
diff.txt:--- a/vm_insnhelper.c
diff.txt:@@ -566,6 +566,7 @@ vm_call_method(rb_thread_t * const th, rb_control_frame_t * const cfp,
diff.txt:@@ -598,6 +599,7 @@ vm_call_method(rb_thread_t * const th, rb_control_frame_t * const cfp,
diff.txt:@@ -605,10 +607,12 @@ vm_call_method(rb_thread_t * const th, rb_control_frame_t * const cfp,
diff.txt: 	    vm_method_missing_args(th, argv, num - 1, 0, stat);
dir.c:  dir.c -
dir.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
dir.c:  Copyright (C) 2000  Information-technology Promotion Agency, Japan
dir.c:# define NAMLEN(dirent) strlen((dirent)->d_name)
dir.c:# define NAMLEN(dirent) strlen((dirent)->d_name)
dir.c:#  define NAMLEN(dirent) (dirent)->d_namlen
dir.c:#  define NAMLEN(dirent) strlen((dirent)->d_name)
dir.c:	if (p[0] == '-' && p[1] != ']') {
dir.c:	    if ((r <= (send-s) && memcmp(t1, s, r) == 0) ||
dir.c:		(r2 <= (send-s) && memcmp(t2, s, r) == 0)) {
dir.c:	    if (r <= (send-s) && memcmp(t1, s, r) == 0) {
dir.c:	if (r <= (send-s) && memcmp(p, s, r) == 0) {
dir.c:    rb_gc_mark(dir->path);
dir.c:	if (dir->dir) closedir(dir->dir);
dir.c:    dirp->dir = NULL;
dir.c:    dirp->path = Qnil;
dir.c:    dirp->enc = NULL;
dir.c: *  call-seq:
dir.c: *     Dir.new( string ) -> aDir
dir.c:    if (dp->dir) closedir(dp->dir);
dir.c:    dp->dir = NULL;
dir.c:    dp->path = Qnil;
dir.c:    dp->enc = fsenc;
dir.c:    dp->dir = opendir(RSTRING_PTR(dirname));
dir.c:    if (dp->dir == NULL) {
dir.c:	    dp->dir = opendir(RSTRING_PTR(dirname));
dir.c:	if (dp->dir == NULL) {
dir.c:    dp->path = rb_str_dup_frozen(dirname);
dir.c: *  call-seq:
dir.c:    if (dirp->dir == NULL) dir_closed();\
dir.c: *  call-seq:
dir.c:    if (!NIL_P(dirp->path)) {
dir.c:	return rb_sprintf("#<%s:%s>", c, RSTRING_PTR(dirp->path));
dir.c: *  call-seq:
dir.c:    if (NIL_P(dirp->path)) return Qnil;
dir.c:    return rb_str_dup(dirp->path);
dir.c: *  call-seq:
dir.c:    dp = readdir(dirp->dir);
dir.c:	return rb_external_str_new_with_enc(dp->d_name, NAMLEN(dp), dirp->enc);
dir.c: *  call-seq:
dir.c:    rewinddir(dirp->dir);
dir.c:    for (dp = readdir(dirp->dir); dp != NULL; dp = readdir(dirp->dir)) {
dir.c:	rb_yield(rb_external_str_new_with_enc(dp->d_name, NAMLEN(dp), dirp->enc));
dir.c:	if (dirp->dir == NULL) dir_closed();
dir.c: *  call-seq:
dir.c:    pos = telldir(dirp->dir);
dir.c: *  call-seq:
dir.c:    seekdir(dirp->dir, p);
dir.c: *  call-seq:
dir.c: *  call-seq:
dir.c:    rewinddir(dirp->dir);
dir.c: *  call-seq:
dir.c:    closedir(dirp->dir);
dir.c:    dirp->dir = NULL;
dir.c:    dir_chdir(args->new_path);
dir.c:    args->done = Qtrue;
dir.c:    return rb_yield(args->new_path);
dir.c:    if (args->done) {
dir.c:	chdir_blocking--;
dir.c:	dir_chdir(args->old_path);
dir.c: *  call-seq:
dir.c: *  multi-threaded program an error will be raised if a thread attempts
dir.c: *  call-seq:
dir.c:	*dir = rb_str_new(path, pend - path);
dir.c: *  call-seq:
dir.c:    if (chroot(RSTRING_PTR(path)) == -1)
dir.c: *  call-seq:
dir.c:    if (mkdir(RSTRING_PTR(path), mode) == -1)
dir.c: *  call-seq:
dir.c:#define GLOB_VERBOSE	(1UL << (sizeof(int) * CHAR_BIT - 1))
dir.c:#define GLOB_JUMP_TAG(status) ((status == -1) ? rb_memerror() : rb_jump_tag(status))
dir.c: * ENOTDIR can be returned by stat(2) if a non-leaf element of the path
dir.c:	p = Next(p-1, pend, enc);
dir.c:		return (char *)p-1;
dir.c:		return (char *)p-1;
dir.c:	p = Next(p-1, pend, enc);
dir.c:    return (char *)p-1;
dir.c:		memmove(t, s, p - s);
dir.c:	    t += p - s;
dir.c:	memmove(t, s, p - s); /* move '\0' too */
dir.c:	    tmp->type = RECURSIVE;
dir.c:	    tmp->str = 0;
dir.c:	    char *buf = GLOB_ALLOC_N(char, m-p+1);
dir.c:	    memcpy(buf, p, m-p);
dir.c:	    buf[m-p] = '\0';
dir.c:	    tmp->type = has_magic(buf, flags, enc) ? MAGICAL : PLAIN;
dir.c:	    tmp->str = buf;
dir.c:	tail = &tmp->next;
dir.c:    tmp->type = dirsep ? MATCH_DIR : MATCH_ALL;
dir.c:    tmp->str = 0;
dir.c:    tmp->next = 0;
dir.c:	list = list->next;
dir.c:	if (tmp->str)
dir.c:	    GLOB_FREE(tmp->str);
dir.c:    (*args->func)(args->path, args->value, args->enc);
dir.c:	if (p->type == RECURSIVE) {
dir.c:	    p = p->next;
dir.c:	switch (p->type) {
dir.c:	    if (!tmp) return -1;
dir.c:	    char *buf = join_path(path, dirsep, dp->d_name);
dir.c:		status = -1;
dir.c:	    if (recursive && strcmp(dp->d_name, ".") != 0 && strcmp(dp->d_name, "..") != 0
dir.c:		&& fnmatch("*", rb_usascii_encoding(), dp->d_name, flags) == 0) {
dir.c:		new_isdir = dp->d_isdir ? (!dp->d_isrep ? YES : UNKNOWN) : NO;
dir.c:	    new_beg = new_end = GLOB_ALLOC_N(struct glob_pattern *, (end - beg) * 2);
dir.c:		status = -1;
dir.c:		if (p->type == RECURSIVE) {
dir.c:		    p = p->next; /* 0 times recursion */
dir.c:		if (p->type == PLAIN || p->type == MAGICAL) {
dir.c:		    if (fnmatch(p->str, enc, dp->d_name, flags) == 0)
dir.c:			*new_end++ = p->next;
dir.c:	copy_beg = copy_end = GLOB_ALLOC_N(struct glob_pattern *, end - beg);
dir.c:	if (!copy_beg) return -1;
dir.c:	    *copy_end++ = (*cur)->type == PLAIN ? *cur : 0;
dir.c:		size_t len = strlen((*cur)->str) + 1;
dir.c:		    status = -1;
dir.c:		memcpy(name, (*cur)->str, len);
dir.c:		new_beg = new_end = GLOB_ALLOC_N(struct glob_pattern *, end - beg);
dir.c:		    status = -1;
dir.c:		*new_end++ = (*cur)->next;
dir.c:		    if (*cur2 && fnmatch((*cur2)->str, enc, name, flags) == 0) {
dir.c:			*new_end++ = (*cur2)->next;
dir.c:		    status = -1;
dir.c:    n = root - start;
dir.c:    if (!buf) return -1;
dir.c:	return -1;
dir.c:    args->path = path;
dir.c:	if (*p == '}' && --nest <= 0) {
dir.c:	if (!buf) return -1;
dir.c:	memcpy(buf, s, lbrace-s);
dir.c:	shift = (lbrace-s);
dir.c:		if (*p == '}') nest--;
dir.c:	    memcpy(buf+shift, t, p-t);
dir.c:	    strcpy(buf+shift+(p-t), rbrace+1);
dir.c:    return ruby_glob0(path, arg->flags, arg->func, arg->value, enc);
dir.c:	offset = p - RSTRING_PTR(str);
dir.c: *  call-seq:
dir.c: *  call-seq:
dir.c: *                          (<code>[^a-z]</code>).
dir.c: *     Dir.glob("*.[a-z][a-z]")            #=> ["main.rb"]
dir.c:	RDATA(dir)->dfree != (RUBY_DATA_FUNC)free_dir) {
dir.c: *  call-seq:
dir.c: *  call-seq:
dir.c: *  call-seq:
dir.c: *                          (<code>[^a-z]</code>).
dir.c: *     File.fnmatch('ca[a-z]', 'cat')          #=> true  # inclusive bracket expression
dir.c:    rb_define_singleton_method(rb_cDir, "open", dir_s_open, -1);
dir.c:    rb_define_singleton_method(rb_cDir, "foreach", dir_foreach, -1);
dir.c:    rb_define_singleton_method(rb_cDir, "entries", dir_entries, -1);
dir.c:    rb_define_method(rb_cDir,"initialize", dir_initialize, -1);
dir.c:    rb_define_singleton_method(rb_cDir,"chdir", dir_s_chdir, -1);
dir.c:    rb_define_singleton_method(rb_cDir,"mkdir", dir_s_mkdir, -1);
dir.c:    rb_define_singleton_method(rb_cDir,"glob", dir_s_glob, -1);
dir.c:    rb_define_singleton_method(rb_cDir,"[]", dir_s_aref, -1);
dir.c:    rb_define_singleton_method(rb_cFile,"fnmatch", file_s_fnmatch, -1);
dir.c:    rb_define_singleton_method(rb_cFile,"fnmatch?", file_s_fnmatch, -1);
ãã¤ããªã¼ã»ãã¡ã¤ã«dir.oã¯ä¸è´ãã¾ãã
dln.c:  dln.c -
dln.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
dln.c:    for (slash = file-1; *file; file++) /* Find position of last '/' */
dln.c:    return p - *buf;
dln.c:    if (size == -1) {
dln.c:	return -1;
dln.c:	return -1;
dln.c:#define RELOC_SYMBOL(r)			((r)->r_symbolnum)
dln.c:#define RELOC_MEMORY_SUB_P(r)		((r)->r_bsr)
dln.c:#define RELOC_PCREL_P(r)		((r)->r_pcrel || (r)->r_bsr)
dln.c:#define RELOC_TARGET_SIZE(r)		((r)->r_length)
dln.c:#define RELOC_ADDRESS(r)		((r)->r_address)
dln.c:#define RELOC_EXTERN_P(r)		((r)->r_extern)
dln.c:#define RELOC_SYMBOL(r)			((r)->r_symbolnum)
dln.c:#define RELOC_PCREL_P(r)		((r)->r_pcrel)
dln.c:#define RELOC_TARGET_SIZE(r)		((r)->r_length)
dln.c:#  define R_RIGHTSHIFT(r)	(reloc_r_rightshift[(r)->r_type])
dln.c:#  define R_BITSIZE(r) 		(reloc_r_bitsize[(r)->r_type])
dln.c:#  define R_LENGTH(r)		(reloc_r_length[(r)->r_type])
dln.c:    ((r)->r_type >= RELOC_DISP8 && (r)->r_type <= RELOC_WDISP22)
dln.c:#  define R_SYMBOL(r) ((r)->r_index)
dln.c:#define R_SYMBOL(r)		((r)->r_symbolnum)
dln.c:#define R_MEMORY_SUB(r)		((r)->r_bsr)
dln.c:#define R_PCREL(r)		((r)->r_pcrel || (r)->r_bsr)
dln.c:#define R_LENGTH(r)		((r)->r_length)
dln.c:#  define R_SYMBOL(r) 		((r)->r_symbolnum)
dln.c:#  define R_PCREL(r)  		((r)->r_pcrel)
dln.c:#  define R_LENGTH(r) 		((r)->r_length)
dln.c:    lseek(fd, disp + N_TXTOFF(*hdrp) + hdrp->a_text + hdrp->a_data, 0);
dln.c:    size = hdrp->a_trsize + hdrp->a_drsize;
dln.c:    lseek(fd, N_SYMOFF(*hdrp) + hdrp->a_syms + disp, 0);
dln.c:    buffer = (struct nlist*)xmalloc(hdrp->a_syms + size);
dln.c:    if (read(fd, buffer, hdrp->a_syms + size) != hdrp->a_syms + size) {
dln.c:    end = sym + hdrp->a_syms / sizeof(struct nlist);
dln.c:    displ = (long)buffer + (long)(hdrp->a_syms);
dln.c:	sym->n_un.n_name = (char*)sym->n_un.n_strx + displ;
dln.c:    struct nlist *end = syms + (hdrp->a_syms / sizeof(struct nlist));
dln.c:	st_insert(tbl, sym->n_un.n_name, sym);
dln.c:	return -1;
dln.c:    if (load_header(fd, &hdr, 0) == -1) return -1;
dln.c:	return -1;
dln.c:	if (read(fd, &c, 1) == -1) {
dln.c:	    return -1;
dln.c:	if (read(fd, &c, 1) == -1) {
dln.c:	    return -1;
dln.c:	    if (p-buf >= MAXPATHLEN) {
dln.c:		return -1;
dln.c:    return -1;
dln.c:    size = hdrp->a_text + hdrp->a_data;
dln.c:    if (bss == -1) size += hdrp->a_bss;
dln.c:    if (bss == -1) {
dln.c:	memset(addr +  hdrp->a_text + hdrp->a_data, 0, hdrp->a_bss);
dln.c:	memset(addr +  hdrp->a_text + hdrp->a_data, 0, bss);
dln.c:    if (undef_tbl->num_entries > 0) {
dln.c:    char *addr = (char*)(reloc->r_address + base);
dln.c:    obj->name = strdup(name);
dln.c:    obj->reloc = *reloc;
dln.c:    obj->base = base;
dln.c:	obj->u.c = *addr;
dln.c:	obj->u.s = *(short*)addr;
dln.c:	obj->u.l = *(long*)addr;
dln.c:    if (strcmp(arg->name, undef->name) != 0) return ST_CONTINUE;
dln.c:    address = (char*)(undef->base + undef->reloc.r_address);
dln.c:    datum = arg->value;
dln.c:    if (R_PCREL(&(undef->reloc))) datum -= undef->base;
dln.c:    datum += undef->reloc.r_addend;
dln.c:    datum >>= R_RIGHTSHIFT(&(undef->reloc));
dln.c:    mask = (1 << R_BITSIZE(&(undef->reloc))) - 1;
dln.c:    mask |= mask -1;
dln.c:    switch (R_LENGTH(&(undef->reloc))) {
dln.c:	*address = undef->u.c;
dln.c:	*(short *)address = undef->u.s;
dln.c:	*(long *)address = undef->u.l;
dln.c:    switch (R_LENGTH(&(undef->reloc))) {
dln.c:	if (R_MEMORY_SUB(&(undef->reloc)))
dln.c:	    *address = datum - *address;
dln.c:	else *address = undef->u.c + datum;
dln.c:	if (R_MEMORY_SUB(&(undef->reloc)))
dln.c:	    *(short*)address = datum - *(short*)address;
dln.c:	else *(short*)address = undef->u.s + datum;
dln.c:	if (R_MEMORY_SUB(&(undef->reloc)))
dln.c:	    *(long*)address = datum - *(long*)address;
dln.c:	else *(long*)address = undef->u.l + datum;
dln.c:    free(undef->name);
dln.c:    if (strcmp(data->name0, undef->name) == 0) {
dln.c:	free(undef->name);
dln.c:	undef->name = strdup(data->name1);
dln.c:    if (load_header(fd, &hdr, disp) == -1) return -1;
dln.c:	return -1;
dln.c:    if (reloc == NULL) return -1;
dln.c:	return -1;
dln.c:	int value = sym->n_value;
dln.c:	if (sym->n_type == (N_INDR | N_EXT)) {
dln.c:	    char *key = sym->n_un.n_name;
dln.c:		    unlink_undef(key, old_sym->n_value);
dln.c:		data.name0 = sym->n_un.n_name;
dln.c:	if (sym->n_type == (N_UNDF | N_EXT)) {
dln.c:	    if (st_lookup(sym_tbl, sym->n_un.n_name, &old_sym) == 0) {
dln.c:		    sym->n_type = N_EXT | N_COMM;
dln.c:		    sym->n_value = old_sym->n_value;
dln.c:			value >= sizeof(double) ? sizeof(double) - 1
dln.c:			    : value >= sizeof(long) ? sizeof(long) - 1
dln.c:				: sizeof(short) - 1;
dln.c:		    sym->n_type = N_COMM;
dln.c:		    sym->n_value = new_common;
dln.c:		    sym->n_type = N_EXT | N_COMM;
dln.c:		    sym->n_value = old_sym->n_value;
dln.c:		    sym->n_value = (long)dln_undefined;
dln.c:		    st_insert(undef_tbl, strdup(sym->n_un.n_name), NULL);
dln.c:	switch (sym->n_type) {
dln.c:	    sym->n_value += hdr.a_text + hdr.a_data;
dln.c:	    sym->n_value += block;
dln.c:	    if (st_lookup(sym_tbl, sym->n_un.n_name, &new_sym) != 0
dln.c:		&& new_sym->n_value != (long)dln_undefined) {
dln.c:	    key = sym->n_un.n_name;
dln.c:		unlink_undef(key, sym->n_value);
dln.c:	    new_sym->n_un.n_name = strdup(sym->n_un.n_name);
dln.c:	    st_insert(sym_tbl, new_sym->n_un.n_name, new_sym);
dln.c:	    sym->n_value += block;
dln.c:     * First comes the text-relocation
dln.c:	    char *address = (char*)(rel->r_address + block);
dln.c:	    if (rel->r_extern) { /* Look it up in symbol-table */
dln.c:		switch (sym->n_type) {
dln.c:		    link_undef(sym->n_un.n_name, block, rel);
dln.c:		    datum = sym->n_value;
dln.c:	    if (R_PCREL(rel)) datum -= block;
dln.c:	    datum += rel->r_addend;
dln.c:	    mask = (1 << R_BITSIZE(rel)) - 1;
dln.c:	    mask |= mask -1;
dln.c:		if (datum < -128 || datum > 127) goto err_exit;
dln.c:	if (undef_tbl->num_entries > 0) {
dln.c:	    if (load_lib(libc) == -1) goto err_exit;
dln.c:	    char *name = sym->n_un.n_name;
dln.c:	    if (name[0] == '_' && sym->n_value >= block) {
dln.c:		    libs_to_be_linked = (char**)sym->n_value;
dln.c:		    ((int (*)())sym->n_value)();
dln.c:	if (libs_to_be_linked && undef_tbl->num_entries > 0) {
dln.c:	    return -1;
dln.c:	if (undef_tbl->num_entries > 0) {
dln.c:	    if (load_lib(libc) == -1) goto err_exit;
dln.c:	    if (undef_tbl->num_entries > 0) {
dln.c:		return -1;
dln.c:    return -1;
dln.c:	return -1;
dln.c:    if (undef_tbl->num_entries == 0) return 0;
dln.c:    if (lib[0] == '-' && lib[1] == 'l') {
dln.c:    if (fd == -1) goto syserr;
dln.c:    if (size == -1) goto syserr;
dln.c:    if (size == -1) goto syserr;
dln.c:	    char *name = name_base + base->rb_str_index;
dln.c:	    st_insert(lib_tbl, name, base->lib_offset + sizeof(ahdr));
dln.c:	    nsym--;
dln.c:	    target_offset = -1;
dln.c:	    if (target_offset == -1) break;
dln.c:	    if (load_1(fd, target_offset, 0) == -1) {
dln.c:	    if (undef_tbl->num_entries == 0) break;
dln.c:	    while (undef_tbl->num_entries > 0) {
dln.c:		if (size == -1) goto syserr;
dln.c:		if (load_header(fd, &hdr, offset) == -1)
dln.c:		    if (sym->n_type == N_EXT|N_TEXT
dln.c:			&& st_lookup(undef_tbl, sym->n_un.n_name, NULL)) {
dln.c:		    if (load_1(fd, offset, 0) == -1) {
dln.c:    return -1;
dln.c:	if (dln_init(dln_argv0) == -1) return -1;
dln.c:    if (file[result-1] == 'a') {
dln.c:    if (fd == -1) {
dln.c:	return -1;
dln.c:	return (void*)sym->n_value;
dln.c:#include <mach-o/rld.h>
dln.c:#include <mach-o/dyld.h>
dln.c:#include <mach-o/dyld.h>
dln.c:	sizeof message - strlen(message),
dln.c:#define ERRBUF_APPEND(s) strncat(errbuf, s, sizeof(errbuf)-strlen(errbuf)-1)
dln.c:    snprintf(errbuf, 1024, "load failed - %s ", pathname);
dln.c:    errbuf[strlen(errbuf)-1] = '\0';	/* trim off last newline */
dln.c:	rb_loaderror("%s - %s\n%s", dln_strerror(), buf, file);
dln.c:    if (load(file) == -1) {
dln.c:	    rb_loaderror("%s - %s", strerror(errno), file);
dln.c:		rb_loaderror("%s - %s", strerror(ENOSYM), file);
dln.c:	if (loadbind(0, (void*)dln_load, (void*)init_fct) == -1) {
dln.c:/*----------------------------------------------------
dln.c:    Yu tomoak-i@is.aist-nara.ac.jp,
dln.c: ----------------------------------------------------*/
dln.c:    rb_loaderror("%s - %s", error, file);
dln.c:    if (((p[0] | 0x20) - 'a') < 26  && p[1] == ':') {
dln.c:	i = p - fname;
dln.c:	fspace = size - i - 1;
dln.c:	l = ep - dp;
dln.c:	fspace = size - 2;
dln.c:		    if ((fspace -= i) < 0)
dln.c:		l--;
dln.c:		if ((fspace -= l) < 0)
dln.c:	    if (ep[-1] != '/')
dln.c:	if ((fspace -= i) < 0) {
dln.c:		    fprintf(stderr, "\tDirectory \"%.*s\"\n", (int) (bp - fbuf), fbuf);
dln.h:  dln.h -
dln.h:  Copyright (C) 1993-2007 Yukihiro Matsumoto
ãã¤ããªã¼ã»ãã¡ã¤ã«dln.oã¯ä¸è´ãã¾ãã
ãã¤ããªã¼ã»ãã¡ã¤ã«dmyencoding.oã¯ä¸è´ãã¾ãã
ãã¤ããªã¼ã»ãã¡ã¤ã«dmyext.oã¯ä¸è´ãã¾ãã
enc.mk:arch = i686-linux
enc.mk:LIBRUBYARG_SHARED = -Wl,-R -Wl,$(libdir) -L$(libdir) -l$(RUBY_SO_NAME)
enc.mk:OUTFLAG = -o $(empty)
enc.mk:COUTFLAG = -o $(empty)
enc.mk:optflags = -O2
enc.mk:debugflags = -g
enc.mk:warnflags = -Wall -Wno-parentheses
enc.mk:CCDLFLAGS =  -fPIC
enc.mk:INCFLAGS = -I. -I$(arch_hdrdir) -I$(hdrdir) -I$(top_srcdir)
enc.mk:DEFS = -D_FILE_OFFSET_BITS=64
enc.mk:CPPFLAGS =  $(DEFS) $(cppflags) -DONIG_ENC_REGISTER=rb_enc_register
enc.mk:LDFLAGS = -L.  -rdynamic -Wl,-export-dynamic
enc.mk:LDSHARED = $(CC) -shared
enc.mk:RM = rm -f
enc.mk:MAKEDIRS = mkdir -p
enc.mk:all: make-workdir
enc.mk:make-workdir:
enc.mk:distclean: clean clean-srcs
enc.mk:LIBPATH =  -L. -L$(topdir)
enc.mk:LIBS =  -lpthread -lrt -ldl -lcrypt -lm  $(EXTLIBS)
enc.mk:	$(MINIRUBY) "$(srcdir)/tool/transcode-tblgen.rb" -vo "$@" "$<"
enc.mk:enc/trans/big5.c: enc/trans/big5-tbl.rb $(srcdir)/tool/transcode-tblgen.rb
enc.mk:enc/trans/chinese.c:  $(srcdir)/tool/transcode-tblgen.rb
enc.mk:enc/trans/escape.c:  $(srcdir)/tool/transcode-tblgen.rb
enc.mk:enc/trans/gb18030.c: enc/trans/gb18030-tbl.rb $(srcdir)/tool/transcode-tblgen.rb
enc.mk:enc/trans/gbk.c: enc/trans/gbk-tbl.rb $(srcdir)/tool/transcode-tblgen.rb
enc.mk:enc/trans/iso2022.c:  $(srcdir)/tool/transcode-tblgen.rb
enc.mk:enc/trans/japanese.c:  $(srcdir)/tool/transcode-tblgen.rb
enc.mk:enc/trans/japanese_euc.c:  $(srcdir)/tool/transcode-tblgen.rb
enc.mk:enc/trans/japanese_sjis.c:  $(srcdir)/tool/transcode-tblgen.rb
enc.mk:enc/trans/korean.c: enc/trans/euckr-tbl.rb enc/trans/cp949-tbl.rb $(srcdir)/tool/transcode-tblgen.rb
enc.mk:enc/trans/single_byte.c:  $(srcdir)/tool/transcode-tblgen.rb
enc.mk:enc/trans/utf_16_32.c:  $(srcdir)/tool/transcode-tblgen.rb
enc.mk:	$(LDSHARED) -o $@ enc/encdb.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/big5.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/cp949.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/emacs_mule.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/euc_jp.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/euc_kr.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/euc_tw.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/gb2312.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/gb18030.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/gbk.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/iso_8859_1.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/iso_8859_2.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/iso_8859_3.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/iso_8859_4.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/iso_8859_5.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/iso_8859_6.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/iso_8859_7.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/iso_8859_8.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/iso_8859_9.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/iso_8859_10.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/iso_8859_11.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/iso_8859_13.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/iso_8859_14.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/iso_8859_15.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/iso_8859_16.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/koi8_r.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/koi8_u.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/shift_jis.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/utf_16be.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/utf_16le.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/utf_32be.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/utf_32le.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/windows_1251.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/trans/transdb.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/trans/big5.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/trans/chinese.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/trans/escape.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/trans/gb18030.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/trans/gbk.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/trans/iso2022.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/trans/japanese.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/trans/japanese_euc.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/trans/japanese_sjis.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/trans/korean.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/trans/single_byte.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	$(LDSHARED) -o $@ enc/trans/utf_16_32.$(OBJEXT) $(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/encdb.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/big5.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/cp949.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/emacs_mule.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/euc_jp.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/euc_kr.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/euc_tw.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/gb2312.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/gb18030.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/gbk.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/iso_8859_1.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/iso_8859_2.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/iso_8859_3.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/iso_8859_4.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/iso_8859_5.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/iso_8859_6.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/iso_8859_7.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/iso_8859_8.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/iso_8859_9.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/iso_8859_10.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/iso_8859_11.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/iso_8859_13.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/iso_8859_14.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/iso_8859_15.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/iso_8859_16.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/koi8_r.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/koi8_u.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/shift_jis.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/utf_16be.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/utf_16le.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/utf_32be.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/utf_32le.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/windows_1251.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/trans/transdb.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/trans/big5.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/trans/chinese.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/trans/escape.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/trans/gb18030.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/trans/gbk.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/trans/iso2022.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/trans/japanese.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/trans/japanese_euc.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/trans/japanese_sjis.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/trans/korean.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/trans/single_byte.c
enc.mk:	-@$(MAKEDIRS) "$(@D)"
enc.mk:	$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) $(COUTFLAG)$@ -c $(encsrcdir)/trans/utf_16_32.c
enc.mk:	@-rmdir $(TRANSSODIR)
enc.mk:	@-rmdir $(ENCSODIR)
enc.mk:clean-srcs:
enc.mk:	@-rmdir enc/trans
enc.mk:	@-rmdir enc
encdb.h:ENC_DEFINE("ASCII-8BIT");
encdb.h:ENC_DEFINE("Emacs-Mule");
encdb.h:ENC_DEFINE("EUC-JP");
encdb.h:ENC_DEFINE("EUC-KR");
encdb.h:ENC_DEFINE("EUC-TW");
encdb.h:ENC_DEFINE("ISO-8859-1");
encdb.h:ENC_DEFINE("ISO-8859-2");
encdb.h:ENC_DEFINE("ISO-8859-3");
encdb.h:ENC_DEFINE("ISO-8859-4");
encdb.h:ENC_DEFINE("ISO-8859-5");
encdb.h:ENC_DEFINE("ISO-8859-6");
encdb.h:ENC_DEFINE("ISO-8859-7");
encdb.h:ENC_DEFINE("ISO-8859-8");
encdb.h:ENC_DEFINE("ISO-8859-9");
encdb.h:ENC_DEFINE("ISO-8859-10");
encdb.h:ENC_DEFINE("ISO-8859-11");
encdb.h:ENC_DEFINE("ISO-8859-13");
encdb.h:ENC_DEFINE("ISO-8859-14");
encdb.h:ENC_DEFINE("ISO-8859-15");
encdb.h:ENC_DEFINE("ISO-8859-16");
encdb.h:ENC_DEFINE("KOI8-R");
encdb.h:ENC_DEFINE("KOI8-U");
encdb.h:ENC_DEFINE("US-ASCII");
encdb.h:ENC_DEFINE("UTF-8");
encdb.h:ENC_DEFINE("UTF-16BE");
encdb.h:ENC_DEFINE("UTF-16LE");
encdb.h:ENC_DEFINE("UTF-32BE");
encdb.h:ENC_DEFINE("UTF-32LE");
encdb.h:ENC_DEFINE("Windows-1251");
encdb.h:ENC_ALIAS("BINARY", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("IBM437", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("IBM737", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("IBM775", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("CP850", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("IBM852", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("IBM855", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("IBM857", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("IBM860", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("IBM861", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("IBM862", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("IBM863", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("IBM864", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("IBM865", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("IBM866", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("IBM869", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("Windows-1258", "ASCII-8BIT");
encdb.h:ENC_ALIAS("CP1258", "Windows-1258");
encdb.h:ENC_REPLICATE("GB1988", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("macCentEuro", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("macCroatian", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("macCyrillic", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("macGreek", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("macIceland", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("macRoman", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("macRomania", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("macThai", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("macTurkish", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("macUkraine", "ASCII-8BIT");
encdb.h:ENC_REPLICATE("stateless-ISO-2022-JP", "Emacs-Mule");
encdb.h:ENC_ALIAS("eucJP", "EUC-JP") /* UI-OSF Application Platform Profile for Japanese Environment Version 1.1 */;
encdb.h:ENC_REPLICATE("eucJP-ms", "EUC-JP") /* TOG/JVC CDE/Motif Technical WG */;
encdb.h:ENC_ALIAS("euc-jp-ms", "eucJP-ms");
encdb.h:ENC_REPLICATE("CP51932", "EUC-JP");
encdb.h:ENC_ALIAS("eucKR", "EUC-KR");
encdb.h:ENC_ALIAS("eucTW", "EUC-TW");
encdb.h:ENC_ALIAS("EUC-CN", "GB2312");
encdb.h:ENC_DUMMY("ISO-2022-JP");
encdb.h:ENC_ALIAS("ISO2022-JP", "ISO-2022-JP");
encdb.h:ENC_REPLICATE("ISO-2022-JP-2", "ISO-2022-JP");
encdb.h:ENC_ALIAS("ISO2022-JP2", "ISO-2022-JP-2");
encdb.h:ENC_ALIAS("ISO8859-1", "ISO-8859-1");
encdb.h:ENC_REPLICATE("Windows-1252", "ISO-8859-1");
encdb.h:ENC_ALIAS("CP1252", "Windows-1252");
encdb.h:ENC_ALIAS("ISO8859-2", "ISO-8859-2");
encdb.h:ENC_REPLICATE("Windows-1250", "ISO-8859-2");
encdb.h:ENC_ALIAS("CP1250", "Windows-1250");
encdb.h:ENC_ALIAS("ISO8859-3", "ISO-8859-3");
encdb.h:ENC_ALIAS("ISO8859-4", "ISO-8859-4");
encdb.h:ENC_ALIAS("ISO8859-5", "ISO-8859-5");
encdb.h:ENC_ALIAS("ISO8859-6", "ISO-8859-6");
encdb.h:ENC_REPLICATE("Windows-1256", "ISO-8859-6");
encdb.h:ENC_ALIAS("CP1256", "Windows-1256");
encdb.h:ENC_ALIAS("ISO8859-7", "ISO-8859-7");
encdb.h:ENC_REPLICATE("Windows-1253", "ISO-8859-7");
encdb.h:ENC_ALIAS("CP1253", "Windows-1253");
encdb.h:ENC_ALIAS("ISO8859-8", "ISO-8859-8");
encdb.h:ENC_REPLICATE("Windows-1255", "ISO-8859-8");
encdb.h:ENC_ALIAS("CP1255", "Windows-1255");
encdb.h:ENC_ALIAS("ISO8859-9", "ISO-8859-9");
encdb.h:ENC_REPLICATE("Windows-1254", "ISO-8859-9");
encdb.h:ENC_ALIAS("CP1254", "Windows-1254");
encdb.h:ENC_ALIAS("ISO8859-10", "ISO-8859-10");
encdb.h:ENC_ALIAS("ISO8859-11", "ISO-8859-11");
encdb.h:ENC_REPLICATE("TIS-620", "ISO-8859-11");
encdb.h:ENC_REPLICATE("Windows-874", "ISO-8859-11");
encdb.h:ENC_ALIAS("CP874", "Windows-874");
encdb.h:ENC_ALIAS("ISO8859-13", "ISO-8859-13");
encdb.h:ENC_REPLICATE("Windows-1257", "ISO-8859-13");
encdb.h:ENC_ALIAS("CP1257", "Windows-1257");
encdb.h:ENC_ALIAS("ISO8859-14", "ISO-8859-14");
encdb.h:ENC_ALIAS("ISO8859-15", "ISO-8859-15");
encdb.h:ENC_ALIAS("ISO8859-16", "ISO-8859-16");
encdb.h:ENC_ALIAS("CP878", "KOI8-R");
encdb.h:ENC_REPLICATE("Windows-31J", "Shift_JIS");
encdb.h:ENC_ALIAS("CP932", "Windows-31J");
encdb.h:ENC_ALIAS("csWindows31J", "Windows-31J") /* IANA.  IE6 don't accept Windows-31J but csWindows31J. */;
encdb.h:ENC_ALIAS("ASCII", "US-ASCII");
encdb.h:ENC_ALIAS("ANSI_X3.4-1968", "US-ASCII");
encdb.h:ENC_ALIAS("646", "US-ASCII");
encdb.h:ENC_DUMMY("UTF-7");
encdb.h:ENC_ALIAS("CP65000", "UTF-7");
encdb.h:ENC_ALIAS("CP65001", "UTF-8");
encdb.h:ENC_REPLICATE("UTF8-MAC", "UTF-8");
encdb.h:ENC_ALIAS("UTF-8-MAC", "UTF8-MAC");
encdb.h:ENC_ALIAS("UCS-2BE", "UTF-16BE");
encdb.h:ENC_ALIAS("UCS-4BE", "UTF-32BE");
encdb.h:ENC_ALIAS("UCS-4LE", "UTF-32LE");
encdb.h:ENC_ALIAS("CP1251", "Windows-1251");
encoding.c:  encoding.c -
encoding.c:	return -1;
encoding.c:	RDATA(obj)->dmark != enc_mark) {
encoding.c:	return -1;
encoding.c:    return check_encoding(RDATA(obj)->data);
encoding.c:	return -1;
encoding.c:	return -1;
encoding.c:	rb_raise(rb_eArgError, "unknown encoding name - %s", RSTRING_PTR(enc));
encoding.c:    if (enc_check_encoding(enc) >= 0) return RDATA(enc)->data;
encoding.c:    if (!ent) return -1;
encoding.c:    memset(ent + enc_table.size, 0, sizeof(*ent)*(newsize - enc_table.size));
encoding.c:    if (!ent->name) {
encoding.c:	ent->name = name = strdup(name);
encoding.c:    else if (STRCASECMP(name, ent->name)) {
encoding.c:	return -1;
encoding.c:    if (!ent->enc) {
encoding.c:	ent->enc = xmalloc(sizeof(rb_encoding));
encoding.c:	*ent->enc = *encoding;
encoding.c:	memset(ent->enc, 0, sizeof(*ent->enc));
encoding.c:    encoding = ent->enc;
encoding.c:    encoding->name = name;
encoding.c:    encoding->ruby_encoding_index = index;
encoding.c:    if ((index = enc_table_expand(index + 1)) < 0) return -1;
encoding.c:    return enc_register_at(index - 1, name, encoding);
encoding.c: * call-seq:
encoding.c:	return -1;
encoding.c:    if (!name) return -1;
encoding.c:    if (!enc_table.list) return -1;
encoding.c:    return -1;
encoding.c:    char *s = RSTRING_PTR(enclib) + 4, *e = RSTRING_END(enclib) - 3;
encoding.c:    if (NIL_P(loaded)) return -1;
encoding.c:    if ((idx = rb_enc_registered(name)) < 0) return -1;
encoding.c:    if (enc_autoload_p(enc_table.list[idx].enc)) return -1;
encoding.c:	    if (i >= enc_table.count) return -1;
encoding.c:	    if (enc_autoload(base) < 0) return -1;
encoding.c:	    rb_warn("failed to load encoding (%s); use ASCII-8BIT instead",
encoding.c:	if (RDATA(obj)->dmark == enc_mark) return Qtrue;
encoding.c:    int i = -1;
encoding.c:	    if (RDATA(obj)->dmark == enc_mark) {
encoding.c: *  call-seq:
encoding.c:    if (MBCLEN_CHARFOUND_P(n) && MBCLEN_CHARFOUND_LEN(n) <= e-p)
encoding.c:        return min <= e-p ? min : e-p;
encoding.c:    if (e-p < n)
encoding.c:        return ONIGENC_CONSTRUCT_MBCLEN_NEEDMORE(n-(e-p));
encoding.c:        return -1;
encoding.c:            return -1;
encoding.c:        return -1;
encoding.c:        return -1;
encoding.c: * call-seq:
encoding.c: *   Encoding::UTF_8.inspect       #=> "#<Encoding:UTF-8>"
encoding.c: *   Encoding::ISO_2022_JP.inspect #=> "#<Encoding:ISO-2022-JP (dummy)>"
encoding.c: * call-seq:
encoding.c: *   Encoding::UTF_8.name       => "UTF-8"
encoding.c: * call-seq:
encoding.c: *   Encoding::WINDOWS_31J.names => ["Windows-31J", "CP932", "csWindows31J"]
encoding.c: * call-seq:
encoding.c: *   => [#<Encoding:ASCII-8BIT>, #<Encoding:UTF-8>,
encoding.c: *       #<Encoding:ISO-2022-JP (dummy)>]
encoding.c: *   Encoding.find("US-ASCII")
encoding.c: *   => #<Encoding:US-ASCII>
encoding.c: *   => [#<Encoding:ASCII-8BIT>, #<Encoding:UTF-8>,
encoding.c: *       #<Encoding:US-ASCII>, #<Encoding:ISO-2022-JP (dummy)>]
encoding.c: * call-seq:
encoding.c: *   Encoding.find("US-ASCII")  => #<Encoding:US-ASCII>
encoding.c: * call-seq:
encoding.c: *   Encoding.compatible?("\xa1".force_encoding("iso-8859-1"), "b")
encoding.c: *   => #<Encoding:ISO-8859-1>
encoding.c: *     "\xa1".force_encoding("iso-8859-1"),
encoding.c: *     "\xa1\xa1".force_encoding("euc-jp"))
encoding.c:    enc = rb_enc_find("UTF8-MAC");
encoding.c:    int index;			/* -2 => not yet set, -1 => nil */
encoding.c:    if (def->index != -2)
encoding.c:	def->index = -1;
encoding.c:	def->enc = 0;
encoding.c:	def->index = rb_enc_to_index(rb_to_encoding(encoding));
encoding.c:	def->enc = 0;
encoding.c:	enc_alias_internal(name, def->index);
encoding.c: * call-seq:
encoding.c: * It is initialized by the locale or -E option.
encoding.c: * call-seq:
encoding.c:static struct default_encoding default_internal = {-2};
encoding.c: * call-seq:
encoding.c: * It is initialized by the source internal_encoding or -E option.
encoding.c: * call-seq:
encoding.c: * call-seq:
encoding.c: *       Encoding.locale_charmap  => "ANSI_X3.4-1968"
encoding.c: *     LANG=ja_JP.EUC-JP
encoding.c: *       Encoding.locale_charmap  => "EUC-JP"
encoding.c:    return rb_usascii_str_new2("ASCII-8BIT");
encoding.c: * call-seq:
encoding.c: *   => ["US-ASCII", "ASCII-8BIT", "UTF-8",
encoding.c: *       "ISO-8859-1", "Shift_JIS", "EUC-JP",
encoding.c: *       "Windows-31J",
encoding.c:    VALUE ary = rb_ary_new2(enc_table.names->num_entries);
encoding.c: * call-seq:
encoding.c: *   => {"BINARY"=>"ASCII-8BIT", "ASCII"=>"US-ASCII", "ANSI_X3.4-1986"=>"US-ASCII",
encoding.c: *       "SJIS"=>"Shift_JIS", "eucJP"=>"EUC-JP", "CP932"=>"Windows-31J"}
encoding.c:    rb_define_method(rb_cEncoding, "_dump", enc_dump, -1);
encoding.c:    RBASIC(list)->klass = 0;
ãã¤ããªã¼ã»ãã¡ã¤ã«encoding.oã¯ä¸è´ãã¾ãã
enum.c:  enum.c -
enum.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
enum.c: *  call-seq:
enum.c: *  call-seq:
enum.c: *  call-seq:
enum.c: *  call-seq:
enum.c: *  evaluated value is non-false.  If no object matches, returns
enum.c: *  call-seq:
enum.c: *  call-seq:
enum.c: *  call-seq:
enum.c: *  call-seq:
enum.c: *  call-seq:
enum.c: *  call-seq:
enum.c: *  call-seq:
enum.c:	n--;
enum.c: *  call-seq:
enum.c: *     enum.first      -> obj or nil
enum.c: *     enum.first(n)   -> an_array
enum.c: *  call-seq:
enum.c: *  the results of the supplied block. The block should return -1, 0, or
enum.c: *  built-in Schwartzian Transform, useful when key computation or
enum.c:    if (RBASIC(ary)->klass) {
enum.c:    /* use NODE_DOT2 as memo(v, v, -) */
enum.c:    VALUE a = (*(NODE *const *)ap)->u1.value;
enum.c:    VALUE b = (*(NODE *const *)bp)->u1.value;
enum.c:    if (RBASIC(ary)->klass) {
enum.c: *  call-seq:
enum.c: *  However, consider the case where comparing the keys is a non-trivial
enum.c:    RBASIC(ary)->klass = 0;
enum.c:    if (RBASIC(ary)->klass) {
enum.c:	RARRAY_PTR(ary)[i] = RNODE(RARRAY_PTR(ary)[i])->u2.value;
enum.c:    RBASIC(ary)->klass = rb_cArray;
enum.c: *  call-seq:
enum.c: *  call-seq:
enum.c: *  call-seq:
enum.c: *  call-seq:
enum.c: *  call-seq:
enum.c: *  call-seq:
enum.c: *  call-seq:
enum.c: *  call-seq:
enum.c: *  call-seq:
enum.c: *  call-seq:
enum.c: *  call-seq:
enum.c: *  call-seq:
enum.c: *     enum.each_with_index {|obj, i| block }  -> enum
enum.c: *  call-seq:
enum.c:    for (i = RARRAY_LEN(ary); --i >= 0; ) {
enum.c:    volatile VALUE result = memo->u1.value;
enum.c:    volatile VALUE args = memo->u2.value;
enum.c:    int n = memo->u3.cnt++;
enum.c:    volatile VALUE result = memo->u1.value;
enum.c:    volatile VALUE args = memo->u2.value;
enum.c: *  call-seq:
enum.c: *  <em>n</em>-element arrays, where <em>n</em> is one more than the
enum.c:    /* use NODE_DOT2 as memo(v, v, -) */
enum.c:    if (--arg[1] == 0) rb_iter_break();
enum.c: *  call-seq:
enum.c: *  call-seq:
enum.c:	arg[1]--;
enum.c: *  call-seq:
enum.c: *  call-seq:
enum.c: *  call-seq:
enum.c: *  times or forever if none or nil is given.  If a non-positive
enum.c:        n = -1;
enum.c:    RBASIC(ary)->klass = 0;
enum.c:    while (n < 0 || 0 < --n) {
enum.c:    rb_define_method(rb_mEnumerable, "to_a", enum_to_a, -1);
enum.c:    rb_define_method(rb_mEnumerable, "entries", enum_to_a, -1);
enum.c:    rb_define_method(rb_mEnumerable, "count", enum_count, -1);
enum.c:    rb_define_method(rb_mEnumerable, "find", enum_find, -1);
enum.c:    rb_define_method(rb_mEnumerable, "detect", enum_find, -1);
enum.c:    rb_define_method(rb_mEnumerable, "find_index", enum_find_index, -1);
enum.c:    rb_define_method(rb_mEnumerable, "inject", enum_inject, -1);
enum.c:    rb_define_method(rb_mEnumerable, "reduce", enum_inject, -1);
enum.c:    rb_define_method(rb_mEnumerable, "first", enum_first, -1);
enum.c:    rb_define_method(rb_mEnumerable, "each_with_index", enum_each_with_index, -1);
enum.c:    rb_define_method(rb_mEnumerable, "reverse_each", enum_reverse_each, -1);
enum.c:    rb_define_method(rb_mEnumerable, "zip", enum_zip, -1);
enum.c:    rb_define_method(rb_mEnumerable, "cycle", enum_cycle, -1);
ãã¤ããªã¼ã»ãã¡ã¤ã«enum.oã¯ä¸è´ãã¾ãã
enumerator.c:  enumerator.c - provides Enumerator class
enumerator.c:  Copyright (C) 2001-2003 Akinori MUSHA
enumerator.c:  $Id: enumerator.c 24122 2009-07-15 12:00:57Z yugui $
enumerator.c: * Document-class: Enumerator
enumerator.c:    rb_gc_mark(ptr->obj);
enumerator.c:    rb_gc_mark(ptr->args);
enumerator.c:    rb_gc_mark(ptr->fib);
enumerator.c:    rb_gc_mark(ptr->dst);
enumerator.c:    if (RDATA(obj)->dmark != enumerator_mark) {
enumerator.c:    if (!ptr || ptr->obj == Qundef) {
enumerator.c: *  call-seq:
enumerator.c:	--argc;
enumerator.c: *  call-seq:
enumerator.c: *  call-seq:
enumerator.c: *  call-seq:
enumerator.c:    enum_obj = Data_Make_Struct(klass, struct enumerator, enumerator_mark, -1, ptr);
enumerator.c:    ptr->obj = Qundef;
enumerator.c:    ptr->obj  = obj;
enumerator.c:    ptr->meth = rb_to_id(meth);
enumerator.c:    if (argc) ptr->args = rb_ary_new4(argc, argv);
enumerator.c:    ptr->fib = 0;
enumerator.c:    ptr->dst = Qnil;
enumerator.c:    ptr->no_next = Qfalse;
enumerator.c: *  call-seq:
enumerator.c: *        #-> ObjectSpace.enum_for(:each_object)
enumerator.c:	if (--argc) {
enumerator.c:	    --argc;
enumerator.c:    if (ptr0->fib) {
enumerator.c:    ptr1->obj  = ptr0->obj;
enumerator.c:    ptr1->meth = ptr0->meth;
enumerator.c:    ptr1->args = ptr0->args;
enumerator.c:    ptr1->fib  = 0;
enumerator.c: *  call-seq:
enumerator.c:    if (e->args) {
enumerator.c:	argc = RARRAY_LEN(e->args);
enumerator.c:	argv = RARRAY_PTR(e->args);
enumerator.c:    return rb_block_call(e->obj, e->meth, argc, argv,
enumerator.c: *  call-seq:
enumerator.c:    if (e->args) {
enumerator.c:	argc = RARRAY_LEN(e->args);
enumerator.c:	argv = RARRAY_PTR(e->args);
enumerator.c:    return rb_block_call(e->obj, e->meth, argc, argv,
enumerator.c: *  call-seq:
enumerator.c:    if (e->args) {
enumerator.c:	argc = RARRAY_LEN(e->args);
enumerator.c:	argv = RARRAY_PTR(e->args);
enumerator.c:    rb_block_call(e->obj, e->meth, argc, argv,
enumerator.c:    e->no_next = Qtrue;
enumerator.c:    e->dst = curr;
enumerator.c:    e->fib = rb_fiber_new(next_i, obj);
enumerator.c: * call-seq:
enumerator.c: * non-external enumeration methods, unless underlying iteration
enumerator.c: * methods itself has side-effect, e.g. IO#each_line.
enumerator.c:    if (!e->fib || !rb_fiber_alive_p(e->fib)) {
enumerator.c:    v = rb_fiber_resume(e->fib, 1, &curr);
enumerator.c:    if (e->no_next) {
enumerator.c:	e->fib = 0;
enumerator.c:	e->dst = Qnil;
enumerator.c:	e->no_next = Qfalse;
enumerator.c: * call-seq:
enumerator.c:    if (rb_respond_to(e->obj, id_rewind))
enumerator.c:	rb_funcall(e->obj, id_rewind, 0);
enumerator.c:    e->fib = 0;
enumerator.c:    e->dst = Qnil;
enumerator.c:    e->no_next = Qfalse;
enumerator.c:    rb_gc_mark(ptr->proc);
enumerator.c:    if (RDATA(obj)->dmark != yielder_mark) {
enumerator.c:    if (!ptr || ptr->proc == Qundef) {
enumerator.c:    obj = Data_Make_Struct(klass, struct yielder, yielder_mark, -1, ptr);
enumerator.c:    ptr->proc = Qundef;
enumerator.c:    ptr->proc = proc;
enumerator.c:    rb_proc_call(ptr->proc, args);
enumerator.c:    rb_gc_mark(ptr->proc);
enumerator.c:    if (RDATA(obj)->dmark != generator_mark) {
enumerator.c:    if (!ptr || ptr->proc == Qundef) {
enumerator.c:    obj = Data_Make_Struct(klass, struct generator, generator_mark, -1, ptr);
enumerator.c:    ptr->proc = Qundef;
enumerator.c:    ptr->proc = proc;
enumerator.c:    ptr1->proc = ptr0->proc;
enumerator.c:    rb_proc_call(ptr->proc, rb_ary_new3(1, yielder));
enumerator.c:    rb_define_method(rb_mKernel, "to_enum", obj_to_enum, -1);
enumerator.c:    rb_define_method(rb_mKernel, "enum_for", obj_to_enum, -1);
enumerator.c:    rb_define_method(rb_cEnumerator, "initialize", enumerator_initialize, -1);
enumerator.c:    rb_define_method(rb_cGenerator, "initialize", generator_initialize, -1);
enumerator.c:    rb_define_method(rb_cYielder, "yield", yielder_yield, -2);
enumerator.c:    rb_define_method(rb_cYielder, "<<", yielder_yield, -2);
ãã¤ããªã¼ã»ãã¡ã¤ã«enumerator.oã¯ä¸è´ãã¾ãã
error.c:  error.c -
error.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
error.c:	vsnprintf((char*)buf+n, len-n, fmt, args);
error.c:	vsnprintf((char*)buf+n, len-n, fmt, args);
error.c: * call-seq:
error.c: * warnings are disabled (for example with the <code>-W0</code> flag).
error.c:		"For details: http://www.ruby-lang.org/bugreport.html\n\n");
error.c:    {T_ICLASS,	"iClass"},	/* internal use: mixed-in module holder */
error.c:	    if (type->type == t) {
error.c:			 etype, type->name);
error.c: * call-seq:
error.c: *  Document-method: exception
error.c: *  call-seq:
error.c: *     exc.exception(string) -> an_exception or exc
error.c: * call-seq:
error.c: * call-seq:
error.c: * call-seq:
error.c: *  call-seq:
error.c: *  call-seq:
error.c: *  call-seq:
error.c: *  Equality---If <i>obj</i> is not an <code>Exception</code>, returns
error.c: * call-seq:
error.c:	--argc;
error.c: * call-seq:
error.c: * call-seq:
error.c: * call-seq:
error.c:    name = (argc > 1) ? argv[--argc] : Qnil;
error.c: *  call-seq:
error.c: * call-seq:
error.c: * Produce a nicely-formatted string representing the +NameError+.
error.c: * call-seq:
error.c:    VALUE args = (argc > 2) ? argv[--argc] : Qnil;
error.c:    return Data_Wrap_Struct(rb_cNameErrorMesg, name_err_mesg_mark, -1, ptr);
error.c: * call-seq:
error.c: *  Document-module: Errno
error.c: * call-seq:
error.c:	    RBASIC(self)->klass = klass;
error.c:	mesg = rb_sprintf("%s - %.*s", err,
error.c: * call-seq:
error.c: * call-seq:
error.c: *  objects carry information about the exception---its type (the
error.c:    rb_define_singleton_method(rb_eException, "exception", rb_class_new_instance, -1);
error.c:    rb_define_method(rb_eException, "exception", exc_exception, -1);
error.c:    rb_define_method(rb_eException, "initialize", exc_initialize, -1);
error.c:    rb_define_method(rb_eSystemExit, "initialize", exit_initialize, -1);
error.c:    rb_define_method(rb_eNameError, "initialize", name_err_initialize, -1);
error.c:    rb_define_method(rb_eNoMethodError, "initialize", nometh_err_initialize, -1);
error.c:    rb_define_method(rb_eSystemCallError, "initialize", syserr_initialize, -1);
error.c:	rb_bug("rb_sys_fail(%s) - errno == 0", mesg ? mesg : "");
error.c:    snprintf(buf+strlen(buf), BUFSIZ-strlen(buf), ": %s", strerror(errno_save));
error.c:    rb_loaderror("%s -- %s", strerror(errno), path);
error.c:    VALUE err = th->errinfo;
error.c:    if (th->mild_compile_error) {
error.c:	    th->errinfo = err;
error.c:	    th->errinfo = rb_exc_new3(rb_eSyntaxError, str);
error.c:	    th->errinfo = err;
ãã¤ããªã¼ã»ãã¡ã¤ã«error.oã¯ä¸è´ãã¾ãã
eval.c:  eval.c -
eval.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
eval.c:  Copyright (C) 2000  Information-technology Promotion Agency, Japan
eval.c:#define exception_error GET_VM()->special_exceptions[ruby_error_reenter]
eval.c:    GET_VM()->running = 1;
eval.c:    GET_THREAD()->errinfo = Qnil;
eval.c:    errs[1] = th->errinfo;
eval.c:    th->safe_level = 0;
eval.c:    errs[0] = th->errinfo;
eval.c:    th->errinfo = errs[1];
eval.c:	/* th->errinfo contains a NODE while break'ing */
eval.c:	    th->base_block = 0;
eval.c: *  call-seq:
eval.c:    while (cref && cref->nd_next) {
eval.c:	VALUE klass = cref->nd_clss;
eval.c:	cref = cref->nd_next;
eval.c: *  call-seq:
eval.c:	klass = cref->nd_clss;
eval.c:	    data = rb_mod_const_at(cref->nd_clss, data);
eval.c:	cref = cref->nd_next;
eval.c:	th->errinfo = exception_error;
eval.c:	mesg = th->errinfo;
eval.c:	th->errinfo = mesg;
eval.c:    if (RTEST(ruby_debug) && !NIL_P(e = th->errinfo) &&
eval.c:		warn_printf("Exception `%s' at %s:%d - %s\n",
eval.c:			    rb_obj_classname(th->errinfo),
eval.c:		warn_printf("Exception `%s' - %s\n",
eval.c:			    rb_obj_classname(th->errinfo),
eval.c:	if (status == TAG_FATAL && th->errinfo == exception_error) {
eval.c:	    th->errinfo = mesg;
eval.c:	EXEC_EVENT_HOOK(th, RUBY_EVENT_RAISE, th->cfp->self,
eval.c: *  call-seq:
eval.c:    th->cfp = RUBY_VM_PREVIOUS_CONTROL_FRAME(th->cfp);
eval.c:    if ((th->cfp->lfp[0] & 0x02) == 0 &&
eval.c:	GC_GUARDED_PTR_REF(th->cfp->lfp[0])) {
eval.c:    rb_control_frame_t *cfp = th->cfp;
eval.c:    volatile VALUE e_info = th->errinfo;
eval.c:	th->cfp = cfp; /* restore */
eval.c:		if (rb_obj_is_kind_of(th->errinfo, eclass)) {
eval.c:			result = (*r_proc) (data2, th->errinfo);
eval.c:			th->errinfo = Qnil;
eval.c:		    th->errinfo = e_info;
eval.c:    rb_control_frame_t *cfp = th->cfp;
eval.c:    trap_tag.prev = th->trap_tag;
eval.c:    th->trap_tag = &trap_tag;
eval.c:    MEMCPY(&org_jmpbuf, &(th)->root_jmpbuf, rb_jmpbuf_t, 1);
eval.c:    MEMCPY(&(th)->root_jmpbuf, &org_jmpbuf, rb_jmpbuf_t, 1);
eval.c:    th->trap_tag = trap_tag.prev;
eval.c:	th->cfp = cfp;
eval.c:    /* retval = prot_tag ? prot_tag->retval : Qnil; */     /* save retval */
eval.c:    rb_iseq_t *iseq = cfp->iseq;
eval.c:	return cfp->method_id;
eval.c:	if (iseq->defined_method_id) {
eval.c:	    return iseq->defined_method_id;
eval.c:	if (iseq->local_iseq == iseq) {
eval.c:	iseq = iseq->parent_iseq;
eval.c:    return frame_func_id(GET_THREAD()->cfp);
eval.c:    return frame_func_id(GET_THREAD()->cfp);
eval.c:    rb_control_frame_t *prev_cfp = RUBY_VM_PREVIOUS_CONTROL_FRAME(th->cfp);
eval.c:    if ((void *)(th->stack + th->stack_size) == (void *)(prev_cfp)) {
eval.c:    th->cfp = RUBY_VM_PREVIOUS_CONTROL_FRAME(th->cfp);
eval.c: *  call-seq:
eval.c: *  call-seq:
eval.c:    while (argc--) {
eval.c: *  call-seq:
eval.c: *  call-seq:
eval.c:    while (argc--) {
eval.c: *  call-seq:
eval.c:    if (th->top_wrapper) {
eval.c:	return rb_mod_include(argc, argv, th->top_wrapper);
eval.c:    rb_control_frame_t *cfp = th->cfp;
eval.c:	if (RUBY_VM_NORMAL_ISEQ_P(cfp->iseq)) {
eval.c:	    if (cfp->iseq->type == ISEQ_TYPE_RESCUE) {
eval.c:		return &cfp->dfp[-2];
eval.c:	    else if (cfp->iseq->type == ISEQ_TYPE_ENSURE &&
eval.c:		     TYPE(cfp->dfp[-2]) != T_NODE &&
eval.c:		     !FIXNUM_P(cfp->dfp[-2])) {
eval.c:		return &cfp->dfp[-2];
eval.c:	return th->errinfo;
eval.c:	rb_raise(rb_eTypeError, "assigning non-exception to $!");
eval.c:    return th->errinfo;
eval.c:	rb_raise(rb_eTypeError, "assigning non-exception to $!");
eval.c:    GET_THREAD()->errinfo = err;
eval.c: *  call-seq:
eval.c:    rb_define_global_function("raise", rb_f_raise, -1);
eval.c:    rb_define_global_function("fail", rb_f_raise, -1);
eval.c:    rb_define_private_method(rb_cModule, "include", rb_mod_include, -1);
eval.c:    rb_define_singleton_method(rb_cModule, "constants", rb_mod_s_constants, -1);
eval.c:    rb_define_singleton_method(rb_vm_top_self(), "include", top_include, -1);
eval.c:    rb_define_method(rb_mKernel, "extend", rb_obj_extend, -1);
eval.c:    rb_define_global_function("trace_var", rb_f_trace_var, -1);	/* in variable.c */
eval.c:    rb_define_global_function("untrace_var", rb_f_untrace_var, -1);	/* in variable.c */
ãã¤ããªã¼ã»ãã¡ã¤ã«eval.oã¯ä¸è´ãã¾ãã
eval_error.c:/* -*-c-*- */
eval_error.c:    VALUE errinfo = GET_THREAD()->errinfo;
eval_error.c:		len = tail - einfo;
eval_error.c:		warn_print2(tail, elen - len - 1);
eval_error.c:		if (einfo[elen-1] != '\n') warn_print2("\n", 1);
eval_error.c:			    len - TRACE_HEAD - TRACE_TAIL);
eval_error.c:		i = len - TRACE_TAIL;
eval_error.c:	VALUE errinfo = GET_THREAD()->errinfo;
eval_intern.h:    (th)->passed_block = GC_GUARDED_PTR_REF((rb_block_t *)(th)->cfp->lfp[0]); \
eval_intern.h:    (th)->cfp->flag |= VM_FRAME_FLAG_PASSED; \
eval_intern.h:  if (ruby_setjmp((th)->root_jmpbuf) == 0) { \
eval_intern.h:  _tag.prev = _th->tag; \
eval_intern.h:  _th->tag = &_tag;
eval_intern.h:  _th->tag = _tag.prev; \
eval_intern.h:  _th->tag = _tag.prev
eval_intern.h:#define TH_EXEC_TAG() ruby_setjmp(_th->tag->buf)
eval_intern.h:  ruby_longjmp(th->tag->buf,(st)); \
eval_intern.h:  (RNODE((obj))->u2.value = (val))
eval_intern.h:  (RNODE((obj))->u3.value = (val))
eval_intern.h:#define GET_THROWOBJ_VAL(obj)         ((VALUE)RNODE((obj))->u1.value)
eval_intern.h:#define GET_THROWOBJ_CATCH_POINT(obj) ((VALUE*)RNODE((obj))->u2.value)
eval_intern.h:#define GET_THROWOBJ_STATE(obj)       ((int)RNODE((obj))->u3.value)
eval_intern.h:#define SCOPE_TEST(f)  (rb_vm_cref()->nd_visi & (f))
eval_intern.h:#define SCOPE_CHECK(f) (rb_vm_cref()->nd_visi == (f))
eval_intern.h:#define SCOPE_SET(f)   (rb_vm_cref()->nd_visi = (f))
eval_intern.h:  if (((VALUE *)(cfp)->sp) + (margin) + sizeof(rb_control_frame_t) >= ((VALUE *)cfp)) { \
eval_intern.h:#define rb_thread_raised_set(th, f)   ((th)->raised_flag |= (f))
eval_intern.h:#define rb_thread_raised_reset(th, f) ((th)->raised_flag &= ~(f))
eval_intern.h:#define rb_thread_raised_p(th, f)     (((th)->raised_flag & (f)) != 0)
eval_intern.h:#define rb_thread_raised_clear(th)    ((th)->raised_flag = 0)
eval_jump.c:/* -*-c-*- */
eval_jump.c: *  call-seq:
eval_jump.c: *     at_exit { block } -> proc
eval_jump.c:    if (th->top_wrapper) {
eval_jump.c:    link->next = *list;
eval_jump.c:    link->func = func;
eval_jump.c:    link->data = data;
eval_jump.c:    link->safe = rb_safe_level();
eval_jump.c:	rb_gc_mark(link->data);
eval_jump.c:	link = link->next;
eval_jump.c:	rb_gc_mark(link->data);
eval_jump.c:	link = link->next;
eval_jump.c:	rb_gc_mark(link->data);
eval_jump.c:	link = link->next;
eval_jump.c:		rb_set_safe_level_force(link->safe);
eval_jump.c:		(*link->func) (link->data);
eval_jump.c:	    tmp_end_procs = link = link->next;
eval_jump.c:		rb_set_safe_level_force(link->safe);
eval_jump.c:		(*link->func) (link->data);
eval_jump.c:	    tmp_end_procs = link = link->next;
file.c:  file.c -
file.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
file.c:  Copyright (C) 2000  Information-technology Promotion Agency, Japan
file.c:#ifdef __BEOS__ /* should not change ID if -1 */
file.c:    if (owner == -1 || group == -1) {
file.c:	if (stat(path, &st) < 0) return -1;
file.c:	if (owner == -1) owner = st.st_uid;
file.c:	if (group == -1) group = st.st_gid;
file.c:    if (owner == -1 || group == -1) {
file.c:	if (fstat(fd, &st) < 0) return -1;
file.c:	if (owner == -1) owner = st.st_uid;
file.c:	if (group == -1) group = st.st_gid;
file.c: *  call-seq:
file.c: *     file.path -> filename
file.c:    fptr = RFILE(rb_io_taint_check(obj))->fptr;
file.c:    if (NIL_P(fptr->pathv)) return Qnil;
file.c:    return rb_obj_taint(rb_str_dup(fptr->pathv));
file.c:    return Data_Wrap_Struct(klass, NULL, -1, nst);
file.c: *  call-seq:
file.c: *     stat <=> other_stat    => -1, 0, 1
file.c: *     f1.stat <=> f2.stat   #=> -1
file.c:            if (ts1.tv_nsec < ts2.tv_nsec) return INT2FIX(-1);
file.c:        if (ts1.tv_sec < ts2.tv_sec) return INT2FIX(-1);
file.c:#define ST2UINT(val) ((val) & ~(~1UL << (sizeof(val) * CHAR_BIT - 1)))
file.c: *  call-seq:
file.c:    return INT2NUM(get_stat(self)->st_dev);
file.c: *  call-seq:
file.c:    long dev = get_stat(self)->st_dev;
file.c: *  call-seq:
file.c:    long dev = get_stat(self)->st_dev;
file.c: *  call-seq:
file.c:    return ULL2NUM(get_stat(self)->st_ino);
file.c:    return ULONG2NUM(get_stat(self)->st_ino);
file.c: *  call-seq:
file.c:    return UINT2NUM(ST2UINT(get_stat(self)->st_mode));
file.c: *  call-seq:
file.c:    return UINT2NUM(get_stat(self)->st_nlink);
file.c: *  call-seq:
file.c:    return UIDT2NUM(get_stat(self)->st_uid);
file.c: *  call-seq:
file.c:    return GIDT2NUM(get_stat(self)->st_gid);
file.c: *  call-seq:
file.c:    return ULONG2NUM(get_stat(self)->st_rdev);
file.c: *  call-seq:
file.c:    long rdev = get_stat(self)->st_rdev;
file.c: *  call-seq:
file.c:    long rdev = get_stat(self)->st_rdev;
file.c: *  call-seq:
file.c:    return OFFT2NUM(get_stat(self)->st_size);
file.c: *  call-seq:
file.c:    return ULONG2NUM(get_stat(self)->st_blksize);
file.c: *  call-seq:
file.c:    return ULONG2NUM(get_stat(self)->st_blocks);
file.c:    ts.tv_sec = st->st_atime;
file.c:    ts.tv_nsec = st->st_atim.tv_nsec;
file.c:    ts.tv_nsec = st->st_atimespec.tv_nsec;
file.c:    ts.tv_nsec = st->st_atimensec;
file.c:    ts.tv_sec = st->st_mtime;
file.c:    ts.tv_nsec = st->st_mtim.tv_nsec;
file.c:    ts.tv_nsec = st->st_mtimespec.tv_nsec;
file.c:    ts.tv_nsec = st->st_mtimensec;
file.c:    ts.tv_sec = st->st_ctime;
file.c:    ts.tv_nsec = st->st_ctim.tv_nsec;
file.c:    ts.tv_nsec = st->st_ctimespec.tv_nsec;
file.c:    ts.tv_nsec = st->st_ctimensec;
file.c: *  call-seq:
file.c: *  call-seq:
file.c: *     stat.mtime -> aTime
file.c: *  call-seq:
file.c: *     stat.ctime -> aTime
file.c: * call-seq:
file.c:	return fstat(fptr->fd, st);
file.c:	f = (HANDLE)rb_w32_get_osfhandle(fptr->fd);
file.c:	if (f == (HANDLE)-1) return INVALID_HANDLE_VALUE;
file.c: *  call-seq:
file.c: *  call-seq:
file.c:    if (fstat(fptr->fd, &st) == -1) {
file.c:	rb_sys_fail_path(fptr->pathv);
file.c: *  call-seq:
file.c:    if (lstat(StringValueCStr(fname), &st) == -1) {
file.c: *  call-seq:
file.c:    if (NIL_P(fptr->pathv)) return Qnil;
file.c:    if (lstat(RSTRING_PTR(fptr->pathv), &st) == -1) {
file.c:	rb_sys_fail_path(fptr->pathv);
file.c:	while (--anum >= 0)
file.c:    if (stat(path, &st) < 0) return -1;
file.c:	return -1;
file.c:    return -1;
file.c: * Document-class: FileTest
file.c: * Document-method: exist?
file.c: * call-seq:
file.c: * Document-method: directory?
file.c: * call-seq:
file.c: * call-seq:
file.c: * call-seq:
file.c: * call-seq:
file.c: * call-seq:
file.c: * call-seq:
file.c: * call-seq:
file.c: * call-seq:
file.c: * call-seq:
file.c: * call-seq:
file.c: * call-seq:
file.c: * call-seq:
file.c: * call-seq:
file.c: * call-seq:
file.c: * call-seq:
file.c: * call-seq:
file.c: * call-seq:
file.c: * call-seq:
file.c: * call-seq:
file.c: * call-seq:
file.c: * call-seq:
file.c: * call-seq:
file.c: * call-seq:
file.c: * call-seq:
file.c: * call-seq:
file.c:    if (S_ISREG(st->st_mode)) {
file.c:    else if (S_ISDIR(st->st_mode)) {
file.c:    else if (S_ISCHR(st->st_mode)) {
file.c:    else if (S_ISBLK(st->st_mode)) {
file.c:    else if (S_ISFIFO(st->st_mode)) {
file.c:    else if (S_ISLNK(st->st_mode)) {
file.c:    else if (S_ISSOCK(st->st_mode)) {
file.c: *  call-seq:
file.c: *     File.ftype("/tmp/.X11-unix/X0")   #=> "socket"
file.c:    if (lstat(StringValueCStr(fname), &st) == -1) {
file.c: *  call-seq:
file.c: *  call-seq:
file.c:    if (fstat(fptr->fd, &st) == -1) {
file.c:	rb_sys_fail_path(fptr->pathv);
file.c: *  call-seq:
file.c: *  call-seq:
file.c: *     file.mtime -> time
file.c:    if (fstat(fptr->fd, &st) == -1) {
file.c:	rb_sys_fail_path(fptr->pathv);
file.c: *  call-seq:
file.c: *  call-seq:
file.c: *     file.ctime -> time
file.c:    if (fstat(fptr->fd, &st) == -1) {
file.c:	rb_sys_fail_path(fptr->pathv);
file.c: *  call-seq:
file.c: *     File.chmod(mode_int, file_name, ... ) -> integer
file.c: *  call-seq:
file.c:    if (fchmod(fptr->fd, mode) == -1)
file.c:	rb_sys_fail_path(fptr->pathv);
file.c:    if (NIL_P(fptr->pathv)) return Qnil;
file.c:    if (chmod(RSTRING_PTR(fptr->pathv), mode) == -1)
file.c:	rb_sys_fail_path(fptr->pathv);
file.c: *  call-seq:
file.c:    if (chown(path, args->owner, args->group) < 0)
file.c: *  call-seq:
file.c: *     File.chown(owner_int, group_int, file_name,... ) -> integer
file.c: *  belongs. A <code>nil</code> or -1 owner or group id is ignored.
file.c:	arg.owner = -1;
file.c:	arg.group = -1;
file.c: *  call-seq:
file.c: *  <code>nil</code> or -1 owner or group id is ignored. Follows
file.c:    o = NIL_P(owner) ? -1 : NUM2INT(owner);
file.c:    g = NIL_P(group) ? -1 : NUM2INT(group);
file.c:    if (NIL_P(fptr->pathv)) return Qnil;
file.c:    if (chown(RSTRING_PTR(fptr->pathv), o, g) == -1)
file.c:	rb_sys_fail_path(fptr->pathv);
file.c:    if (fchown(fptr->fd, o, g) == -1)
file.c:	rb_sys_fail_path(fptr->pathv);
file.c:    if (lchown(path, args->owner, args->group) < 0)
file.c: *  call-seq:
file.c:	arg.owner = -1;
file.c:	arg.group = -1;
file.c: * call-seq:
file.c:	l1 = max_pathlen - 3;
file.c:	l2 = max_pathlen - 3;
file.c: *  call-seq:
file.c: *  call-seq:
file.c: *  call-seq:
file.c: *     File.readlink(link_name) -> file_name
file.c: *  call-seq:
file.c: *  call-seq:
file.c: *  call-seq:
file.c: *  file read-only for everyone.
file.c:    long bdiff = p - buf;\
file.c:		rb_raise(rb_eArgError, "couldn't find HOME environment -- expanding `%s'", s);
file.c:	    BUFCHECK(bdiff + (s-b) >= buflen);
file.c:	    memcpy(p, b, s-b);
file.c:	    p += s-b;
file.c:	    dirlen = strlen(pwPtr->pw_dir);
file.c:	    strcpy(buf, pwPtr->pw_dir);
file.c:	    p = buf + strlen(pwPtr->pw_dir);
file.c:	p = buf + (s - b);
file.c:	memset(buf, '/', p - buf);
file.c:    if (p > buf && p[-1] == '/')
file.c:	--p;
file.c:		--s;
file.c:		long rootdiff = root - buf;
file.c:		BUFCHECK(bdiff + (s-b+1) >= buflen);
file.c:		memcpy(++p, b, s-b);
file.c:		p += s-b;
file.c:	if (s > b + 6 && strncasecmp(s - 6, ":$DATA", 6) == 0) {
file.c:	    if (*(s-7) == ':') s -= 7;			/* prime */
file.c:	    else if (memchr(b, ':', s - 6 - b)) s -= 6; /* alternative */
file.c:	BUFCHECK(bdiff + (s-b) >= buflen);
file.c:	memcpy(++p, b, s-b);
file.c:	p += s-b;
file.c:    if (p == skiproot(buf) - 1) p++;
file.c:	    if (len > 4 && STRCASECMP(p + len - 4, ".lnk") != 0) {
file.c:		STRCASECMP(wfd.cFileName + len - 4, ".lnk") == 0) {
file.c:		wfd.cFileName[len -= 4] = '\0';
file.c:    rb_str_set_len(result, p - buf);
file.c: *  call-seq:
file.c: *     File.expand_path(file_name [, dir_string] ) -> abs_file_name
file.c: *  call-seq:
file.c: *     File.absolute_path(file_name [, dir_string] ) -> abs_file_name
file.c:	} while (*--e != c);
file.c:	return e - p;
file.c:    if (fncomp(p+l1-l2, e, l2) == 0) {
file.c:	return l1-l2;
file.c: *  call-seq:
file.c: *     File.basename(file_name [, suffix] ) -> base_name
file.c:	p = name - 1;
file.c:	n = ntfs_tail(p) - p;
file.c:	n = chompdirsep(p) - p;
file.c: *  call-seq:
file.c: *     File.dirname(file_name ) -> dir_name
file.c:	root = skipprefix(name = root - 2);
file.c:	name = root - 1;
file.c:	rb_str_cat(dirname, top, p - top);
file.c:    dirname = rb_str_new(name, p - name);
file.c:    if (has_drive_letter(name) && root == name + 2 && p - name == 2)
file.c: *  call-seq:
file.c: *     File.extname(path) -> string
file.c:    extname = rb_str_new(e, p - e);	/* keep the dot, too! */
file.c: *  call-seq:
file.c: *     File.path(path) -> string
file.c: *  call-seq:
file.c: *  returns them in a two-element array. See also
file.c:	len += RSTRING_LEN(sep) * RARRAY_LEN(ary) - 1;
file.c:		rb_str_set_len(result, tail - name);
file.c: *  call-seq:
file.c: *     File.join(string, ...) -> path
file.c: *  call-seq:
file.c: *  call-seq:
file.c:    if (!(fptr->mode & FMODE_WRITABLE)) {
file.c:    if (ftruncate(fptr->fd, pos) < 0)
file.c:	rb_sys_fail_path(fptr->pathv);
file.c:    if (chsize(fptr->fd, pos) < 0)
file.c:	rb_sys_fail(fptr->pathv);
file.c: *  call-seq:
file.c: *     ----------+------------------------------------------------
file.c: *     ----------+------------------------------------------------
file.c: *     ----------+------------------------------------------------
file.c:    op[0] = fptr->fd;
file.c:    if (fptr->mode & FMODE_WRITABLE) {
file.c:	    rb_sys_fail_path(fptr->pathv);
file.c: *  call-seq:
file.c: *     ?-  | boolean | True if file1 and file2 are identical
file.c:	if (rb_stat(fname, &st) == -1) {
file.c:    if (cmd == '-') {
file.c: *  Document-class: File::Stat
file.c: *  methods return platform-specific values, and not all values are
file.c: * call-seq:
file.c:    if (stat(StringValueCStr(fname), &st) == -1) {
file.c: *  call-seq:
file.c: *  call-seq:
file.c:    if (S_ISDIR(get_stat(obj)->st_mode)) return Qtrue;
file.c: *  call-seq:
file.c:    if (S_ISFIFO(get_stat(obj)->st_mode)) return Qtrue;
file.c: *  call-seq:
file.c:    if (S_ISLNK(get_stat(obj)->st_mode)) return Qtrue;
file.c: *  call-seq:
file.c:    if (S_ISSOCK(get_stat(obj)->st_mode)) return Qtrue;
file.c: *  call-seq:
file.c:    if (S_ISBLK(get_stat(obj)->st_mode)) return Qtrue;
file.c: *  call-seq:
file.c:    if (S_ISCHR(get_stat(obj)->st_mode)) return Qtrue;
file.c: *  call-seq:
file.c:    if (get_stat(obj)->st_uid == geteuid()) return Qtrue;
file.c:    if (get_stat(obj)->st_uid == getuid()) return Qtrue;
file.c: *  call-seq:
file.c:    if (group_member(get_stat(obj)->st_gid)) return Qtrue;
file.c: *  call-seq:
file.c:	return st->st_mode & S_IRUSR ? Qtrue : Qfalse;
file.c:	return st->st_mode & S_IRGRP ? Qtrue : Qfalse;
file.c:    if (!(st->st_mode & S_IROTH)) return Qfalse;
file.c: *  call-seq:
file.c: *     stat.readable_real? -> true or false
file.c:	return st->st_mode & S_IRUSR ? Qtrue : Qfalse;
file.c:    if (group_member(get_stat(obj)->st_gid))
file.c:	return st->st_mode & S_IRGRP ? Qtrue : Qfalse;
file.c:    if (!(st->st_mode & S_IROTH)) return Qfalse;
file.c: * call-seq:
file.c:    if ((get_stat(obj)->st_mode & (S_IROTH)) == S_IROTH) {
file.c:	return UINT2NUM(get_stat(obj)->st_mode & (S_IRUGO|S_IWUGO|S_IXUGO));
file.c: *  call-seq:
file.c: *     stat.writable? -> true or false
file.c:	return st->st_mode & S_IWUSR ? Qtrue : Qfalse;
file.c:	return st->st_mode & S_IWGRP ? Qtrue : Qfalse;
file.c:    if (!(st->st_mode & S_IWOTH)) return Qfalse;
file.c: *  call-seq:
file.c: *     stat.writable_real? -> true or false
file.c:	return st->st_mode & S_IWUSR ? Qtrue : Qfalse;
file.c:    if (group_member(get_stat(obj)->st_gid))
file.c:	return st->st_mode & S_IWGRP ? Qtrue : Qfalse;
file.c:    if (!(st->st_mode & S_IWOTH)) return Qfalse;
file.c: * call-seq:
file.c:    if ((get_stat(obj)->st_mode & (S_IWOTH)) == S_IWOTH) {
file.c:	return UINT2NUM(get_stat(obj)->st_mode & (S_IRUGO|S_IWUGO|S_IXUGO));
file.c: *  call-seq:
file.c:	return st->st_mode & S_IXUGO ? Qtrue : Qfalse;
file.c:	return st->st_mode & S_IXUSR ? Qtrue : Qfalse;
file.c:	return st->st_mode & S_IXGRP ? Qtrue : Qfalse;
file.c:    if (!(st->st_mode & S_IXOTH)) return Qfalse;
file.c: *  call-seq:
file.c:	return st->st_mode & S_IXUGO ? Qtrue : Qfalse;
file.c:	return st->st_mode & S_IXUSR ? Qtrue : Qfalse;
file.c:    if (group_member(get_stat(obj)->st_gid))
file.c:	return st->st_mode & S_IXGRP ? Qtrue : Qfalse;
file.c:    if (!(st->st_mode & S_IXOTH)) return Qfalse;
file.c: *  call-seq:
file.c:    if (S_ISREG(get_stat(obj)->st_mode)) return Qtrue;
file.c: *  call-seq:
file.c: *  Returns <code>true</code> if <i>stat</i> is a zero-length file;
file.c:    if (get_stat(obj)->st_size == 0) return Qtrue;
file.c: *  call-seq:
file.c:    off_t size = get_stat(obj)->st_size;
file.c: *  call-seq:
file.c: *  Returns <code>true</code> if <i>stat</i> has the set-user-id
file.c:    if (get_stat(obj)->st_mode & S_ISUID) return Qtrue;
file.c: *  call-seq:
file.c: *  Returns <code>true</code> if <i>stat</i> has the set-group-id
file.c:    if (get_stat(obj)->st_mode & S_ISGID) return Qtrue;
file.c: *  call-seq:
file.c:    if (get_stat(obj)->st_mode & S_ISVTX) return Qtrue;
file.c:	if (!path_check_0(rb_str_new(p0, p - p0), Qtrue)) {
file.c:    if (fd == -1) return 0;
file.c:    RBASIC(fname)->klass = 0;
file.c:		RBASIC(tmp)->klass = rb_obj_class(*filep);
file.c:	rb_raise(rb_eSecurityError, "loading from non-absolute path %s", f);
file.c:	RBASIC(tmp)->klass = rb_obj_class(path);
file.c: *  <em>permission bits</em> are a platform-specific
file.c: *  set of bits that indicate permissions of a file. On Unix-based
file.c: *  interpreted as read/write for owner, and read-only for group and
file.c: *  other. Higher-order bits may also be used to indicate the type of
file.c: *  On non-Posix operating systems, there may be only the ability to
file.c: *  make a file read-only or read-write. In this case, the remaining
file.c: *  <code>0644</code>, which means read/write for owner, read-only for
file.c: *  read-only, which is reported as <code>0444</code>.
file.c:    rb_define_singleton_method(rb_cFile, "utime", rb_file_s_utime, -1);
file.c:    rb_define_singleton_method(rb_cFile, "chmod", rb_file_s_chmod, -1);
file.c:    rb_define_singleton_method(rb_cFile, "chown", rb_file_s_chown, -1);
file.c:    rb_define_singleton_method(rb_cFile, "lchmod", rb_file_s_lchmod, -1);
file.c:    rb_define_singleton_method(rb_cFile, "lchown", rb_file_s_lchown, -1);
file.c:    rb_define_singleton_method(rb_cFile, "unlink", rb_file_s_unlink, -2);
file.c:    rb_define_singleton_method(rb_cFile, "delete", rb_file_s_unlink, -2);
file.c:    rb_define_singleton_method(rb_cFile, "umask", rb_file_s_umask, -1);
file.c:    rb_define_singleton_method(rb_cFile, "expand_path", rb_file_s_expand_path, -1);
file.c:    rb_define_singleton_method(rb_cFile, "absolute_path", rb_file_s_absolute_path, -1);
file.c:    rb_define_singleton_method(rb_cFile, "basename", rb_file_s_basename, -1);
file.c:    rb_define_singleton_method(rb_cFile, "join",   rb_file_s_join, -2);
file.c:    rb_define_global_function("test", rb_f_test, -1);
ãã¤ããªã¼ã»ãã¡ã¤ã«file.oã¯ä¸è´ãã¾ãã
gc.c:  gc.c -
gc.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
gc.c:  Copyright (C) 2000  Information-technology Promotion Agency, Japan
gc.c:#define nomem_error GET_VM()->special_exceptions[ruby_error_nomemory]
gc.c:    return time.tv_sec + time.tv_usec * 1e-6;
gc.c:    t = (DWORD)(q % 1000000L) * 1e-6;
gc.c:	if (objspace->profile.run) {\
gc.c:	    if (!objspace->profile.record) {\
gc.c:		objspace->profile.size = 1000;\
gc.c:		objspace->profile.record = malloc(sizeof(gc_profile_record) * objspace->profile.size);\
gc.c:	    if (count >= objspace->profile.size) {\
gc.c:		objspace->profile.size += 1000;\
gc.c:		objspace->profile.record = realloc(objspace->profile.record, sizeof(gc_profile_record) * objspace->profile.size);\
gc.c:	    if (!objspace->profile.record) {\
gc.c:	    MEMZERO(&objspace->profile.record[count], gc_profile_record, 1);\
gc.c:	    objspace->profile.record[count].gc_invoke_time = gc_time - objspace->profile.invoke_time;\
gc.c:	if (objspace->profile.run) {\
gc.c:	    gc_time = getrusage_time() - gc_time;\
gc.c:	    objspace->profile.record[count].gc_time = gc_time;\
gc.c:	    objspace->profile.count++;\
gc.c:    size_t count = objspace->profile.count
gc.c:	if (objspace->profile.run) {\
gc.c:	if (objspace->profile.run) {\
gc.c:	    mark_time = getrusage_time() - mark_time;\
gc.c:	    objspace->profile.record[count].gc_mark_time = mark_time;\
gc.c:	if (objspace->profile.run) {\
gc.c:	if (objspace->profile.run) {\
gc.c:	    sweep_time = getrusage_time() - sweep_time;\
gc.c:	    objspace->profile.record[count].gc_sweep_time = sweep_time;\
gc.c:	if (objspace->profile.run) {\
gc.c:	    size_t count = objspace->profile.count;\
gc.c:	    objspace->profile.record[count].allocate_increase = malloc_increase;\
gc.c:	    objspace->profile.record[count].allocate_limit = malloc_limit; \
gc.c:	if (objspace->profile.run) {\
gc.c:	    size_t count = objspace->profile.count;\
gc.c:	    objspace->profile.record[count].heap_use_slots = heaps_used;\
gc.c:	    objspace->profile.record[count].heap_live_objects = live;\
gc.c:	    objspace->profile.record[count].heap_free_objects = freed;\
gc.c:	    objspace->profile.record[count].heap_total_objects = heaps_used * HEAP_OBJ_LIMIT;\
gc.c:	    objspace->profile.record[count].have_finalize = final_list ? Qtrue : Qfalse;\
gc.c:	    objspace->profile.record[count].heap_use_size = live * sizeof(RVALUE);\
gc.c:	    objspace->profile.record[count].heap_total_size = heaps_used * (HEAP_OBJ_LIMIT * sizeof(RVALUE));\
gc.c:    size_t count = objspace->profile.count
gc.c:	if (objspace->profile.run) {\
gc.c:	    size_t count = objspace->profile.count;\
gc.c:	    objspace->profile.record[count].heap_total_objects = heaps_used * HEAP_OBJ_LIMIT;\
gc.c:	    objspace->profile.record[count].heap_use_size = live * sizeof(RVALUE);\
gc.c:	    objspace->profile.record[count].heap_total_size = heaps_used * HEAP_SIZE;\
gc.c:#pragma pack(push, 1) /* magic for reducing sizeof(RVALUE): 24 -> 20 */
gc.c:#define rb_objspace (*GET_VM()->objspace)
gc.c:#define malloc_limit		objspace->malloc_params.limit
gc.c:#define malloc_increase 	objspace->malloc_params.increase
gc.c:#define heap_slots		objspace->heap.slots
gc.c:#define heaps			objspace->heap.ptr
gc.c:#define heaps_length		objspace->heap.length
gc.c:#define heaps_used		objspace->heap.used
gc.c:#define freelist		objspace->heap.freelist
gc.c:#define lomem			objspace->heap.range[0]
gc.c:#define himem			objspace->heap.range[1]
gc.c:#define heaps_inc		objspace->heap.increment
gc.c:#define heaps_freed		objspace->heap.freed
gc.c:#define dont_gc 		objspace->flags.dont_gc
gc.c:#define during_gc		objspace->flags.during_gc
gc.c:#define finalizer_table 	objspace->final.table
gc.c:#define deferred_final_list	objspace->final.deferred
gc.c:#define mark_stack		objspace->markstack.buffer
gc.c:#define mark_stack_ptr		objspace->markstack.ptr
gc.c:#define mark_stack_overflow	objspace->markstack.overflow
gc.c:#define global_List		objspace->global_list
gc.c:#define ruby_gc_stress		objspace->gc_stress
gc.c:#define need_call_final 	(finalizer_table && finalizer_table->num_entries)
gc.c:	GET_THREAD()->errinfo = nomem_error;
gc.c: *  call-seq:
gc.c: *  call-seq:
gc.c: *  call-seq:
gc.c:    return objspace->profile.run;
gc.c: *  call-seq:
gc.c:    objspace->profile.run = Qtrue;
gc.c: *  call-seq:
gc.c:    objspace->profile.run = Qfalse;
gc.c: *  call-seq:
gc.c:    MEMZERO(objspace->profile.record, gc_profile_record, objspace->profile.size);
gc.c:    objspace->profile.count = 0;
gc.c:    objspace->malloc_params.allocated_size += size;
gc.c:    objspace->malloc_params.allocations++;
gc.c:	negative_size_allocation_error("negative re-allocation size");
gc.c:    objspace->malloc_params.allocated_size -= size;
gc.c:    ptr = (size_t *)ptr - 1;
gc.c:    objspace->malloc_params.allocated_size += size;
gc.c:    ptr = ((size_t *)ptr) - 1;
gc.c:    objspace->malloc_params.allocated_size -= size;
gc.c:    objspace->malloc_params.allocations--;
gc.c: *  call-seq:
gc.c: *  call-seq:
gc.c:    VALUE ary = GET_THREAD()->vm->mark_object_ary;
gc.c:    tmp->next = global_List;
gc.c:    tmp->varptr = addr;
gc.c:    if (tmp->varptr == addr) {
gc.c:	global_List = tmp->next;
gc.c:    while (tmp->next) {
gc.c:	if (tmp->next->varptr == addr) {
gc.c:	    struct gc_list *t = tmp->next;
gc.c:	    tmp->next = tmp->next->next;
gc.c:	tmp = tmp->next;
gc.c:	p = (RVALUE*)((VALUE)p + sizeof(RVALUE) - ((VALUE)p % sizeof(RVALUE)));
gc.c:	if ((HEAP_SIZE - HEAP_OBJ_LIMIT * sizeof(RVALUE)) < ((char*)p - (char*)membase)) {
gc.c:	    objs--;
gc.c:	MEMMOVE(&heaps[hi+1], &heaps[hi], struct heaps_slot, heaps_used - hi);
gc.c:	p->as.free.flags = 0;
gc.c:	p->as.free.next = freelist;
gc.c:    objspace->profile.invoke_time = getrusage_time();
gc.c:    heaps_inc = next_heaps_length - heaps_used;
gc.c:	heaps_inc--;
gc.c:    freelist = freelist->as.free.next;
gc.c:    RANY(obj)->file = rb_sourcefile();
gc.c:    RANY(obj)->line = rb_sourceline();
gc.c:	th->value_cache[i] = v;
gc.c:	RBASIC(v)->flags = FL_MARK;
gc.c:    th->value_cache_ptr = &th->value_cache[0];
gc.c:    VALUE v = *th->value_cache_ptr;
gc.c:    rb_objspace_t *objspace = th->vm->objspace;
gc.c:	RBASIC(v)->flags = 0;
gc.c:	th->value_cache_ptr++;
gc.c:	   th->value_cache_ptr - th->value_cache, v, th);
gc.c:    n->flags |= T_NODE;
gc.c:    n->u1.value = a0;
gc.c:    n->u2.value = a1;
gc.c:    n->u3.value = a2;
gc.c:    data->data = datap;
gc.c:    data->dfree = dfree;
gc.c:    data->dmark = dmark;
gc.c:#define SET_STACK_END (SET_MACHINE_STACK_END(&th->machine_stack_end), th->machine_register_stack_end = rb_ia64_bsp())
gc.c:#define SET_STACK_END SET_MACHINE_STACK_END(&th->machine_stack_end)
gc.c:#define STACK_START (th->machine_stack_start)
gc.c:#define STACK_END (th->machine_stack_end)
gc.c:#define STACK_LEVEL_MAX (th->machine_stack_maxsize/sizeof(VALUE))
gc.c:# define STACK_LENGTH  (STACK_START - STACK_END)
gc.c:# define STACK_LENGTH  (STACK_END - STACK_START + 1)
gc.c:# define STACK_LENGTH  ((STACK_END < STACK_START) ? STACK_START - STACK_END\
gc.c:                                           : STACK_END - STACK_START + 1)
gc.c:    return ruby_stack_grow_direction = -1;
gc.c:    ret = STACK_LENGTH > STACK_LEVEL_MAX - GC_WATER_MARK;
gc.c:        ret = (VALUE*)rb_ia64_bsp() - th->machine_register_stack_start >
gc.c:              th->machine_register_stack_maxsize/sizeof(VALUE) - GC_WATER_MARK;
gc.c:	    if ((p->as.basic.flags & FL_MARK) &&
gc.c:		(p->as.basic.flags != FL_MARK)) {
gc.c:    p = (mark_stack_ptr - mark_stack) + tmp_arry;
gc.c:    MEMCPY(tmp_arry, mark_stack, VALUE, p - tmp_arry);
gc.c:	p--;
gc.c:	if (heap->slot <= p) {
gc.c:	    if (p < heap->slot + heap->limit)
gc.c:    while (n--) {
gc.c:    n = end - start;
gc.c:    gc_mark(arg->objspace, value, arg->lev);
gc.c:    gc_mark(arg->objspace, key, arg->lev);
gc.c:    gc_mark(arg->objspace, key, arg->lev);
gc.c:    gc_mark(arg->objspace, value, arg->lev);
gc.c:    if (obj->as.basic.flags == 0) return;       /* free cell */
gc.c:    if (obj->as.basic.flags & FL_MARK) return;  /* already marked */
gc.c:    obj->as.basic.flags |= FL_MARK;
gc.c:	    if (mark_stack_ptr - mark_stack < MARK_STACK_MAX) {
gc.c:    if (obj->as.basic.flags == 0) return;       /* free cell */
gc.c:    if (obj->as.basic.flags & FL_MARK) return;  /* already marked */
gc.c:    obj->as.basic.flags |= FL_MARK;
gc.c:	    gc_mark(objspace, (VALUE)obj->as.node.u2.node, lev);
gc.c:	    gc_mark(objspace, (VALUE)obj->as.node.u1.node, lev);
gc.c:	    ptr = (VALUE)obj->as.node.u3.node;
gc.c:	    gc_mark(objspace, (VALUE)obj->as.node.u1.node, lev);
gc.c:	    ptr = (VALUE)obj->as.node.u2.node;
gc.c:	    ptr = (VALUE)obj->as.node.u1.node;
gc.c:	    gc_mark(objspace, (VALUE)obj->as.node.u3.node, lev);
gc.c:	    ptr = (VALUE)obj->as.node.u2.node;
gc.c:	  case NODE_ZARRAY:	/* - */
gc.c:				 (VALUE*)obj->as.node.u1.value,
gc.c:				 obj->as.node.u3.cnt);
gc.c:	    ptr = (VALUE)obj->as.node.u2.node;
gc.c:	    if (is_pointer_to_heap(objspace, obj->as.node.u1.node)) {
gc.c:		gc_mark(objspace, (VALUE)obj->as.node.u1.node, lev);
gc.c:	    if (is_pointer_to_heap(objspace, obj->as.node.u2.node)) {
gc.c:		gc_mark(objspace, (VALUE)obj->as.node.u2.node, lev);
gc.c:	    if (is_pointer_to_heap(objspace, obj->as.node.u3.node)) {
gc.c:		gc_mark(objspace, (VALUE)obj->as.node.u3.node, lev);
gc.c:    gc_mark(objspace, obj->as.basic.klass, lev);
gc.c:	    ptr = obj->as.array.as.heap.aux.shared;
gc.c:	mark_hash(objspace, obj->as.hash.ntbl, lev);
gc.c:	ptr = obj->as.hash.ifnone;
gc.c:	    ptr = obj->as.string.as.heap.aux.shared;
gc.c:	if (obj->as.data.dmark) (*obj->as.data.dmark)(DATA_PTR(obj));
gc.c:        if (obj->as.file.fptr) {
gc.c:            gc_mark(objspace, obj->as.file.fptr->pathv, lev);
gc.c:            gc_mark(objspace, obj->as.file.fptr->tied_io_for_writing, lev);
gc.c:            gc_mark(objspace, obj->as.file.fptr->writeconv_asciicompat, lev);
gc.c:            gc_mark(objspace, obj->as.file.fptr->writeconv_pre_ecopts, lev);
gc.c:            gc_mark(objspace, obj->as.file.fptr->encs.ecopts, lev);
gc.c:            gc_mark(objspace, obj->as.file.fptr->write_lock, lev);
gc.c:        gc_mark(objspace, obj->as.regexp.src, lev);
gc.c:	gc_mark(objspace, obj->as.match.regexp, lev);
gc.c:	if (obj->as.match.str) {
gc.c:	    ptr = obj->as.match.str;
gc.c:	gc_mark(objspace, obj->as.rational.num, lev);
gc.c:	gc_mark(objspace, obj->as.rational.den, lev);
gc.c:	gc_mark(objspace, obj->as.complex.real, lev);
gc.c:	gc_mark(objspace, obj->as.complex.imag, lev);
gc.c:	    while (len--) {
gc.c:    p->as.free.flags = 0;
gc.c:    p->as.free.next = freelist;
gc.c:	RVALUE *tmp = p->as.free.next;
gc.c:	    struct heaps_slot *slot = (struct heaps_slot *)RDATA(p)->dmark;
gc.c:	    slot->limit--;
gc.c:	    heaps_used--;
gc.c:	    if (!(p->as.basic.flags & FL_MARK)) {
gc.c:		if (p->as.basic.flags &&
gc.c:			p->as.free.flags = T_ZOMBIE;
gc.c:			RDATA(p)->dfree = 0;
gc.c:		    p->as.free.flags |= FL_MARK;
gc.c:		    p->as.free.next = final_list;
gc.c:		RBASIC(p)->flags &= ~FL_MARK;
gc.c:	    for (pp = final_list; pp != final; pp = pp->as.free.next) {
gc.c:		RDATA(pp)->dmark = (void *)&heaps[i];
gc.c:		pp->as.free.flags |= FL_SINGLETON; /* freeing page mark */
gc.c:	malloc_limit += (malloc_increase - malloc_limit) * (double)live / (live + freed);
gc.c:    p->as.basic.flags = (p->as.basic.flags & ~T_MASK) | T_ZOMBIE;
gc.c:    rb_io_t *fptr = p->as.file.fptr;
gc.c:    p->as.data.dfree = (void (*)(void*))rb_io_fptr_finalize;
gc.c:    p->as.data.data = fptr;
gc.c:	if (!(RANY(obj)->as.basic.flags & ROBJECT_EMBED) &&
gc.c:            RANY(obj)->as.object.as.heap.ivptr) {
gc.c:	    xfree(RANY(obj)->as.object.as.heap.ivptr);
gc.c:        xfree(RANY(obj)->as.klass.ptr);
gc.c:	if (RANY(obj)->as.hash.ntbl) {
gc.c:	    st_free_table(RANY(obj)->as.hash.ntbl);
gc.c:	if (RANY(obj)->as.regexp.ptr) {
gc.c:	    onig_free(RANY(obj)->as.regexp.ptr);
gc.c:	    if ((long)RANY(obj)->as.data.dfree == -1) {
gc.c:	    else if (RANY(obj)->as.data.dfree) {
gc.c:	if (RANY(obj)->as.match.rmatch) {
gc.c:            struct rmatch *rm = RANY(obj)->as.match.rmatch;
gc.c:	    onig_region_free(&rm->regs, 0);
gc.c:            if (rm->char_offset)
gc.c:		xfree(rm->char_offset);
gc.c:	if (RANY(obj)->as.file.fptr) {
gc.c:	if (!(RBASIC(obj)->flags & RBIGNUM_EMBED_FLAG) && RBIGNUM_DIGITS(obj)) {
gc.c:	    if (RANY(obj)->as.node.u1.tbl) {
gc.c:		xfree(RANY(obj)->as.node.u1.tbl);
gc.c:	    xfree(RANY(obj)->as.node.u1.node);
gc.c:	if ((RBASIC(obj)->flags & RSTRUCT_EMBED_LEN_MASK) == 0 &&
gc.c:	    RANY(obj)->as.rstruct.as.heap.ptr) {
gc.c:	    xfree(RANY(obj)->as.rstruct.as.heap.ptr);
gc.c:    stack_start = th->machine_stack_end;
gc.c:    stack_end = th->machine_stack_start;
gc.c:    stack_start = th->machine_stack_start;
gc.c:    stack_end = th->machine_stack_end + 1;
gc.c:    if (th->machine_stack_end < th->machine_stack_start) {
gc.c:        stack_start = th->machine_stack_end;
gc.c:        stack_end = th->machine_stack_start;
gc.c:        stack_start = th->machine_stack_start;
gc.c:        stack_end = th->machine_stack_end + 1;
gc.c:    rb_gc_mark_locations(th->machine_register_stack_start, th->machine_register_stack_end);
gc.c:			 (STACK_START - STACK_END));
gc.c:    objspace->count++;
gc.c:    th->vm->self ? rb_gc_mark(th->vm->self) : rb_vm_mark(th->vm);
gc.c:    for (list = global_List; list; list = list->next) {
gc.c:	rb_gc_mark_maybe(*list->varptr);
gc.c:    rb_gc_mark_locations(th->machine_stack_end, th->machine_stack_start);
gc.c:    rb_gc_mark_locations(th->machine_stack_start, th->machine_stack_end);
gc.c:    if (th->machine_stack_start < th->machine_stack_end) {
gc.c:	rb_gc_mark_locations(th->machine_stack_start, th->machine_stack_end);
gc.c:	rb_gc_mark_locations(th->machine_stack_end, th->machine_stack_start);
gc.c:    rb_gc_mark_locations(th->machine_register_stack_start, th->machine_register_stack_end);
gc.c: *  call-seq:
gc.c: * Document-class: ObjectSpace
gc.c:        while (0 < i && (uintptr_t)membase < (uintptr_t)heaps[i-1].membase)
gc.c:            i--;
gc.c:	    if (p->as.basic.flags) {
gc.c:		    if (!p->as.basic.klass) continue;
gc.c: *  call-seq:
gc.c: *     2.22044604925031e-16
gc.c: *     2.2250738585072e-308
gc.c: *  call-seq:
gc.c: *  call-seq:
gc.c:    RBASIC(obj)->flags |= FL_FINALIZE;
gc.c:	RBASIC(table)->klass = 0;
gc.c:    RBASIC(obj)->klass = 0;
gc.c:    if (RDATA(obj)->dfree) {
gc.c:	(*RDATA(obj)->dfree)(DATA_PTR(obj));
gc.c:    if (p->as.basic.flags & FL_FINALIZE) {
gc.c:	    p->as.free.flags = FL_MARK | T_ZOMBIE; /* remain marked */
gc.c:	    RDATA(p)->dfree = 0;
gc.c:	p->as.free.next = *final_list;
gc.c:	while (finalizer_table->num_entries > 0) {
gc.c:		final_list = p->as.free.next;
gc.c:		DATA_PTR(p) && RANY(p)->as.data.dfree &&
gc.c:		RANY(p)->as.basic.klass != rb_cThread && RANY(p)->as.basic.klass != rb_cMutex) {
gc.c:		p->as.free.flags = 0;
gc.c:		if ((long)RANY(p)->as.data.dfree == -1) {
gc.c:		else if (RANY(p)->as.data.dfree) {
gc.c:		    RANY(p)->as.free.next = final_list;
gc.c:		if (RANY(p)->as.file.fptr) {
gc.c:		    RANY(p)->as.free.next = final_list;
gc.c: *  call-seq:
gc.c: *     ObjectSpace._id2ref(object_id) -> an_object
gc.c:    if (BUILTIN_TYPE(ptr) == 0 || RBASIC(ptr)->klass == 0) {
gc.c: *  Document-method: __id__
gc.c: *  Document-method: object_id
gc.c: *  call-seq:
gc.c: *  call-seq:
gc.c:     *                32-bit VALUE space
gc.c:     *          MSB ------------------------ LSB
gc.c:     *  20 if 32-bit, double is 4-byte aligned
gc.c:     *  24 if 32-bit, double is 8-byte aligned
gc.c:     *  40 if 64-bit
gc.c: *  call-seq:
gc.c: *     ObjectSpace.count_objects([result_hash]) -> hash
gc.c:            rb_raise(rb_eTypeError, "non-hash given");
gc.c:            if (p->as.basic.flags) {
gc.c: *  call-seq:
gc.c: *     GC.count -> Integer
gc.c:    return UINT2NUM((&rb_objspace)->count);
gc.c: *  call-seq:
gc.c: *     GC.malloc_allocated_size -> Integer
gc.c:    return UINT2NUM((&rb_objspace)->malloc_params.allocated_size);
gc.c: *  call-seq:
gc.c: *     GC.malloc_allocations -> Integer
gc.c:    return UINT2NUM((&rb_objspace)->malloc_params.allocations);
gc.c:    if (!objspace->profile.run) {
gc.c:    for (i =0; i < objspace->profile.count; i++) {
gc.c:        rb_hash_aset(prof, ID2SYM(rb_intern("GC_TIME")), DBL2NUM(objspace->profile.record[i].gc_time));
gc.c:        rb_hash_aset(prof, ID2SYM(rb_intern("GC_INVOKE_TIME")), DBL2NUM(objspace->profile.record[i].gc_invoke_time));
gc.c:        rb_hash_aset(prof, ID2SYM(rb_intern("HEAP_USE_SIZE")), rb_uint2inum(objspace->profile.record[i].heap_use_size));
gc.c:        rb_hash_aset(prof, ID2SYM(rb_intern("HEAP_TOTAL_SIZE")), rb_uint2inum(objspace->profile.record[i].heap_total_size));
gc.c:        rb_hash_aset(prof, ID2SYM(rb_intern("HEAP_TOTAL_OBJECTS")), rb_uint2inum(objspace->profile.record[i].heap_total_objects));
gc.c:        rb_hash_aset(prof, ID2SYM(rb_intern("GC_MARK_TIME")), DBL2NUM(objspace->profile.record[i].gc_mark_time));
gc.c:        rb_hash_aset(prof, ID2SYM(rb_intern("GC_SWEEP_TIME")), DBL2NUM(objspace->profile.record[i].gc_sweep_time));
gc.c:        rb_hash_aset(prof, ID2SYM(rb_intern("ALLOCATE_INCREASE")), rb_uint2inum(objspace->profile.record[i].allocate_increase));
gc.c:        rb_hash_aset(prof, ID2SYM(rb_intern("ALLOCATE_LIMIT")), rb_uint2inum(objspace->profile.record[i].allocate_limit));
gc.c:        rb_hash_aset(prof, ID2SYM(rb_intern("HEAP_USE_SLOTS")), rb_uint2inum(objspace->profile.record[i].heap_use_slots));
gc.c:        rb_hash_aset(prof, ID2SYM(rb_intern("HEAP_LIVE_OBJECTS")), rb_uint2inum(objspace->profile.record[i].heap_live_objects));
gc.c:        rb_hash_aset(prof, ID2SYM(rb_intern("HEAP_FREE_OBJECTS")), rb_uint2inum(objspace->profile.record[i].heap_free_objects));
gc.c:        rb_hash_aset(prof, ID2SYM(rb_intern("HAVE_FINALIZE")), objspace->profile.record[i].have_finalize);
gc.c: *  call-seq:
gc.c: *     GC::Profiler.result -> string
gc.c:    if (objspace->profile.run && objspace->profile.count) {
gc.c: *  call-seq:
gc.c:    rb_define_singleton_method(rb_mProfiler, "report", gc_profile_report, -1);
gc.c:    rb_define_module_function(rb_mObSpace, "each_object", os_each_obj, -1);
gc.c:    rb_define_module_function(rb_mObSpace, "define_finalizer", define_final, -1);
gc.c:    rb_define_module_function(rb_mObSpace, "count_objects", count_objects, -1);
gc.h:	ruby_gc_debug_indent--;
gc.h:    printf("%s: %s %s (%p)\n", mode, st ? "->" : "<-", msg, ptr);
ãã¤ããªã¼ã»ãã¡ã¤ã«gc.oã¯ä¸è´ãã¾ãã
gem_prelude.rb:#   * Encoding.default_external does not reflects -E.
gem_prelude.rb:    # Deduce Ruby's --program-prefix and --program-suffix from its install name
gem_prelude.rb:    # The default system-wide source info cache directory
gem_prelude.rb:    # The default user-specific source info cache directory
gem_prelude.rb:              dash = gem_directory_name.rindex("-")
gem_prelude.rb:              new_version = calculate_integers_for_gem_version(gem_directory_name[dash+1..-1])
gem_prelude.rb:                if (current_version <=> new_version) == -1
gem_prelude.rb:        # gem directories must come after -I and ENV['RUBYLIB']
golf_prelude.c:"  (Array.instance_methods-instance_methods-[:to_ary,:transpose,:flatten,:flatten!,:compact,:compact!,:assoc,:rassoc]).each{|meth|\n"
golf_prelude.c:"  (Array.instance_methods-instance_methods-[:replace]+[:to_s]).each{|meth|\n"
golf_prelude.c:    rb_usascii_str_new(prelude_code0, sizeof(prelude_code0) - 1),
golf_prelude.c:    rb_usascii_str_new(prelude_name0, sizeof(prelude_name0) - 1),
golf_prelude.rb:  (Array.instance_methods-instance_methods-[:to_ary,:transpose,:flatten,:flatten!,:compact,:compact!,:assoc,:rassoc]).each{|meth|
golf_prelude.rb:  (Array.instance_methods-instance_methods-[:replace]+[:to_s]).each{|meth|
hash.c:  hash.c -
hash.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
hash.c:  Copyright (C) 2000  Information-technology Promotion Agency, Japan
hash.c:    if (TYPE(a) == T_STRING && RBASIC(a)->klass == rb_cString &&
hash.c:	TYPE(b) == T_STRING && RBASIC(b)->klass == rb_cString) {
hash.c:    if (a == Qundef || b == Qundef) return -1;
hash.c:    status = (*arg->func)(key, value, arg->arg);
hash.c:    tbl = RHASH(arg->hash)->ntbl;
hash.c:    status = (*arg->func)(key, value, arg->arg);
hash.c:    if (RHASH(arg->hash)->ntbl != tbl) {
hash.c:	FL_SET(arg->hash, HASH_DELETED);
hash.c:    RHASH(hash)->iter_lev--;
hash.c:    if (RHASH(hash)->iter_lev == 0) {
hash.c:	    st_cleanup_safe(RHASH(hash)->ntbl, Qundef);
hash.c:    if (st_foreach(RHASH(arg->hash)->ntbl, hash_foreach_iter, (st_data_t)arg)) {
hash.c:    if (!RHASH(hash)->ntbl)
hash.c:    RHASH(hash)->iter_lev++;
hash.c:    hash->ifnone = Qnil;
hash.c:        ret->ntbl = st_copy(RHASH(hash)->ntbl);
hash.c:    ret->ifnone = RHASH(hash)->ifnone;
hash.c:    if (!RHASH(hash)->ntbl) {
hash.c:        RHASH(hash)->ntbl = st_init_table(&objhash);
hash.c:    return RHASH(hash)->ntbl;
hash.c: *  call-seq:
hash.c:	RHASH(hash)->ifnone = rb_block_proc();
hash.c:	RHASH(hash)->ifnone = ifnone;
hash.c: *  call-seq:
hash.c:	    if (RHASH(tmp)->ntbl) {
hash.c:		RHASH(hash)->ntbl = st_copy(RHASH(tmp)->ntbl);
hash.c: *  call-seq:
hash.c: *     Hash.try_convert(obj) -> hash or nil
hash.c: *  call-seq:
hash.c: *     hsh.rehash -> hsh
hash.c:    if (RHASH(hash)->iter_lev > 0) {
hash.c:    if (!RHASH(hash)->ntbl)
hash.c:    tbl = st_init_table_with_size(RHASH(hash)->ntbl->type, RHASH(hash)->ntbl->num_entries);
hash.c:    st_free_table(RHASH(hash)->ntbl);
hash.c:    RHASH(hash)->ntbl = tbl;
hash.c: *  call-seq:
hash.c: *  Element Reference---Retrieves the <i>value</i> object corresponding
hash.c:    if (!RHASH(hash)->ntbl || !st_lookup(RHASH(hash)->ntbl, key, &val)) {
hash.c:    if (!RHASH(hash)->ntbl || !st_lookup(RHASH(hash)->ntbl, key, &val)) {
hash.c: *  call-seq:
hash.c:    if (!RHASH(hash)->ntbl || !st_lookup(RHASH(hash)->ntbl, key, &val)) {
hash.c: *  call-seq:
hash.c:	return rb_funcall(RHASH(hash)->ifnone, id_yield, 2, hash, key);
hash.c:    return RHASH(hash)->ifnone;
hash.c: *  call-seq:
hash.c: *     h[2]       #=> #<Proc:0x401b3948@-:6>
hash.c: *     h["cat"]   #=> #<Proc:0x401b3948@-:6>
hash.c:    RHASH(hash)->ifnone = ifnone;
hash.c: *  call-seq:
hash.c: *     hsh.default_proc -> anObject
hash.c: *     p = h.default_proc                 #=> #<Proc:0x401b3d08@-:1>
hash.c:	return RHASH(hash)->ifnone;
hash.c: *  call-seq:
hash.c:    RHASH(hash)->ifnone = proc;
hash.c: *  call-seq:
hash.c:    if (!RHASH(hash)->ntbl)
hash.c:    if (RHASH(hash)->iter_lev > 0) {
hash.c:	if (st_delete_safe(RHASH(hash)->ntbl, &ktmp, &val, Qundef)) {
hash.c:    else if (st_delete(RHASH(hash)->ntbl, &ktmp, &val))
hash.c: *  call-seq:
hash.c: *  Deletes and returns a key-value pair from <i>hsh</i> whose key is
hash.c:    if (var->key != Qundef) return ST_STOP;
hash.c:    var->key = key;
hash.c:    var->val = value;
hash.c:    var->key = key;
hash.c:    var->val = value;
hash.c: *  call-seq:
hash.c: *     hsh.shift -> anArray or obj
hash.c: *  Removes a key-value pair from <i>hsh</i> and returns it as the
hash.c: *  two-item array <code>[</code> <i>key, value</i> <code>]</code>, or
hash.c:    rb_hash_foreach(hash, RHASH(hash)->iter_lev > 0 ? shift_i_safe : shift_i,
hash.c:	if (RHASH(hash)->iter_lev > 0) {
hash.c:	return rb_funcall(RHASH(hash)->ifnone, id_yield, 2, hash, Qnil);
hash.c:	return RHASH(hash)->ifnone;
hash.c: *  call-seq:
hash.c: *     hsh.delete_if {| key, value | block }  -> hsh
hash.c: *  Deletes every key-value pair from <i>hsh</i> for which <i>block</i>
hash.c: *  call-seq:
hash.c: *     hsh.reject! {| key, value | block }  -> hsh or nil
hash.c:    if (!RHASH(hash)->ntbl)
hash.c:    n = RHASH(hash)->ntbl->num_entries;
hash.c:    if (n == RHASH(hash)->ntbl->num_entries) return Qnil;
hash.c: *  call-seq:
hash.c: *     hsh.reject {| key, value | block }  -> a_hash
hash.c: * call-seq:
hash.c: *  call-seq:
hash.c: *  call-seq:
hash.c: *     hsh.clear -> hsh
hash.c: *  Removes all key-value pairs from <i>hsh</i>.
hash.c:    if (!RHASH(hash)->ntbl)
hash.c:    if (RHASH(hash)->ntbl->num_entries > 0) {
hash.c:	if (RHASH(hash)->iter_lev > 0)
hash.c:	    st_clear(RHASH(hash)->ntbl);
hash.c: *  call-seq:
hash.c: *  Element Assignment---Associates the value given by
hash.c:    if (RHASH(hash)->ntbl->type == &identhash ||
hash.c:	TYPE(key) != T_STRING || st_lookup(RHASH(hash)->ntbl, key, 0)) {
hash.c:	st_insert(RHASH(hash)->ntbl, key, val);
hash.c:	st_add_direct(RHASH(hash)->ntbl, rb_str_new4(key), val);
hash.c: *  call-seq:
hash.c: *     hsh.replace(other_hash) -> hsh
hash.c:    RHASH(hash)->ifnone = RHASH(hash2)->ifnone;
hash.c: *  call-seq:
hash.c: *  Returns the number of key-value pairs in the hash.
hash.c:    if (!RHASH(hash)->ntbl)
hash.c:    return INT2FIX(RHASH(hash)->ntbl->num_entries);
hash.c: *  call-seq:
hash.c: *  Returns <code>true</code> if <i>hsh</i> contains no key-value pairs.
hash.c: *  call-seq:
hash.c: *     hsh.each_value {| value | block } -> hsh
hash.c: *  call-seq:
hash.c: *     hsh.each_key {| key | block } -> hsh
hash.c: *  call-seq:
hash.c: *     hsh.each {| key, value | block } -> hsh
hash.c: *     hsh.each_pair {| key, value | block } -> hsh
hash.c: *  Calls <i>block</i> once for each key in <i>hsh</i>, passing the key-value
hash.c: *  call-seq:
hash.c: *     hsh.to_a -> array
hash.c: * call-seq:
hash.c: * call-seq:
hash.c: *  call-seq:
hash.c: *  call-seq:
hash.c: *  call-seq:
hash.c:    if (!RHASH(hash)->ntbl)
hash.c:    if (st_lookup(RHASH(hash)->ntbl, key, 0)) {
hash.c: *  call-seq:
hash.c:    if (!st_lookup(data->tbl, key, &val2)) {
hash.c:	data->result = Qfalse;
hash.c:    if (!(data->eql ? rb_eql(val1, val2) : rb_equal(val1, val2))) {
hash.c:	data->result = Qfalse;
hash.c:    data->result = Qtrue;
hash.c:    return data->result;
hash.c:    if (!RHASH(hash1)->ntbl || !RHASH(hash2)->ntbl)
hash.c:    if (RHASH(hash1)->ntbl->type != RHASH(hash2)->ntbl->type)
hash.c:    if (!(rb_equal(RHASH(hash1)->ifnone, RHASH(hash2)->ifnone) &&
hash.c:    data.tbl = RHASH(hash2)->ntbl;
hash.c: *  call-seq:
hash.c: *  Equality---Two hashes are equal if they each contain the same number
hash.c: *  of keys and if each key-value pair is equal to (according to
hash.c: *  call-seq:
hash.c: *     hash.eql?(other)  -> true or false
hash.c:    if (!RHASH(hash)->ntbl)
hash.c:    hval = RHASH(hash)->ntbl->num_entries;
hash.c: *  call-seq:
hash.c: *     hsh.hash   -> fixnum
hash.c: *  Compute a hash-code for this hash. Two hashes with the same content
hash.c: *  call-seq:
hash.c: *     hsh.invert -> aHash
hash.c: *  call-seq:
hash.c: *  call-seq:
hash.c: *     hsh.merge(other_hash)                              -> a_hash
hash.c: *     hsh.merge(other_hash){|key, oldval, newval| block} -> a_hash
hash.c: *  call-seq:
hash.c: *     hash.assoc(obj)   ->  an_array  or  nil
hash.c: *  Returns the key-value pair (two elements array) or +nil+
hash.c: *  call-seq:
hash.c: *     hash.rassoc(key) -> an_array or nil
hash.c: *  Returns the first key-value pair (two elements array) that matches. See
hash.c: *  call-seq:
hash.c: *     hash.flatten -> an_array
hash.c: *     hash.flatten(level) -> an_array
hash.c: *  Returns a new array that is a one-dimensional flattening of this
hash.c: *  call-seq:
hash.c:    RHASH(hash)->ntbl->type = &identhash;
hash.c: *  call-seq:
hash.c:    if (!RHASH(hash)->ntbl)
hash.c:    if (RHASH(hash)->ntbl->type == &identhash) {
hash.c:static int path_tainted = -1;
hash.c:     * GSAR 97-06-07
hash.c:	    rb_ary_push(ary, env_str_new(*env, s-*env));
hash.c:	    rb_ary_push(ary, env_str_new(*env, s-*env));
hash.c:	    VALUE k = env_str_new(*env, s-*env);
hash.c:	    rb_str_buf_cat(str, *env, s-*env);
hash.c:	    rb_ary_push(ary, rb_assoc_new(env_str_new(*env, s-*env),
hash.c:		VALUE result = rb_assoc_new(rb_tainted_str_new(*env, s-*env-1), obj);
hash.c:		str = env_str_new(*env, s-*env-1);
hash.c:	    rb_hash_aset(hash, env_str_new(*env, s-*env),
hash.c:	    VALUE key = env_str_new(*env, s-*env);
hash.c: *  A <code>Hash</code> is a collection of key-value pairs. It is
hash.c:    rb_define_singleton_method(rb_cHash, "[]", rb_hash_s_create, -1);
hash.c:    rb_define_method(rb_cHash,"initialize", rb_hash_initialize, -1);
hash.c:    rb_define_method(rb_cHash,"fetch", rb_hash_fetch_m, -1);
hash.c:    rb_define_method(rb_cHash,"default", rb_hash_default, -1);
hash.c:    rb_define_method(rb_cHash,"values_at", rb_hash_values_at, -1);
hash.c:    rb_define_method(rb_cHash, "flatten", rb_hash_flatten, -1);
hash.c:    rb_define_singleton_method(envtbl,"fetch", env_fetch, -1);
hash.c:    rb_define_singleton_method(envtbl,"values_at", env_values_at, -1);
ãã¤ããªã¼ã»ãã¡ã¤ã«hash.oã¯ä¸è´ãã¾ãã
ia64.s:	.ident	"GCC: (GNU) 3.3.5 (Debian 1:3.3.5-13)"
id.c:  id.c - 
id.c:  Copyright (C) 2004-2007 Koichi Sasada
id.h:  id.h - 
id.h:    idMINUS = '-',
id.h:    int checking_for_##name[name == value ? 1 : -1]
id.h~:  id.h - 
id.h~:    idMINUS = '-',
id.h~:    int checking_for_##name[name == value ? 1 : -1]
inits.c:  inits.c -
inits.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
ãã¤ããªã¼ã»ãã¡ã¤ã«inits.oã¯ä¸è´ãã¾ãã
insns.def:/** ##skip -*- mode:c; style:ruby -*-
insns.def:  insns.def - YARV instruction definitions
insns.def:  Copyright (C) 2004-2007 Koichi Sasada
insns.def:    val = *(GET_LFP() - idx);
insns.def:    (*(GET_LFP() - idx)) = val;
insns.def:    val = *(dfp2 - idx);
insns.def:    *(dfp2 - idx) = val;
insns.def:    ret = iseq->self;
insns.def:(VALUE val) // inc += 1 - num;
insns.def:    for (i = num - 1; i >= 0; i--) {
insns.def:(VALUE val) // inc += 1 - cnt;
insns.def:    RBASIC(ary)->klass = 0;
insns.def:        rb_ary_store(ary, cnt-i-1, TOPN(i));
insns.def:(VALUE val) // inc += 1 - num;
insns.def:     zñIuWFNgÅÈ¯êÎAnum - 1 ÂÌ nil ðÏÞB
insns.def:     flag: 0x01 - ÅãðzñÉ
insns.def:     flag: 0x02 - postarg p
insns.def:     flag: 0x04 - reverse?
insns.def:(...) // inc += num - 1 + (flag & 1 ? 1 : 0);
insns.def:(VALUE val) // inc += 1 - num;
insns.def:    for (i = num; i > 0; i -= 2) {
insns.def:	const VALUE v = TOPN(i - 2);
insns.def:	const VALUE k = TOPN(i - 1);
insns.def:    TOPN(n-1) = val;
insns.def:(...) // inc -= n
insns.def:	    expr_type = "instance-variable";
insns.def:	    expr_type = "global-variable";
insns.def:	      if (!(method->nd_noex & NOEX_PRIVATE)) {
insns.def:		  if (!((method->nd_noex & NOEX_PROTECTED) &&
insns.def:	      if (ip->defined_method_id) {
insns.def:	      ip = ip->parent_iseq;
insns.def:	      VALUE klass = vm_search_normal_superclass(ip->klass, GET_SELF());
insns.def:	      if (rb_method_boundp(klass, ip->defined_method_id, 0)) {
insns.def:	      expr_type = "global-variable";
insns.def:    COPY_CREF(class_iseq->cref_stack, vm_cref_push(th, klass, NOEX_PUBLIC));
insns.def:		  class_iseq->iseq_encoded, GET_SP(), 0,
insns.def:		  class_iseq->local_size);
insns.def:    flag & VM_CALL_ARGS_SPLAT_BIT    != 0 -> splat last arg
insns.def:    flag & VM_CALL_ARGS_BLOCKARG_BIT != 0 -> Proc as Block
insns.def:    flag & VM_CALL_FCALL_BIT         != 0 -> FCALL ( func() )
insns.def:    flag & VM_CALL_VCALL_BIT         != 0 -> VCALL ( func   )
insns.def:(VALUE val) // inc += - (op_argc + ((op_flag & VM_CALL_ARGS_BLOCKARG_BIT) ? 1 : 0));
insns.def:(VALUE val) // inc += - (op_argc + ((op_flag & VM_CALL_ARGS_BLOCKARG_BIT) ? 1 : 0));
insns.def:(VALUE val)  // inc += 1 - num;
insns.def:	if (reg_cfp->sp != reg_cfp->bp) {
insns.def:		   VM_SP_CNT(th, reg_cfp->sp), VM_SP_CNT(th, reg_cfp->bp));
insns.def:    th->cfp++;
insns.def:    if (ic->ic_vmstat == GET_VM_STATE_VERSION()) {
insns.def:	val = ic->ic_value;
insns.def:    if (ic->ic_vmstat) {
insns.def:	val = ic->ic_value;
insns.def:    ic->ic_value = val;
insns.def:    ic->ic_vmstat = GET_VM_STATE_VERSION() - ruby_vm_const_missing_count;
insns.def:() // inc += -1;
insns.def:    if (GET_CFP()->bp != GET_DFP() + 1) {
insns.def:	VALUE *new_dfp = GET_CFP()->bp - 1;
insns.def:	    ((VALUE)0x01 << ((sizeof(VALUE) * CHAR_BIT) - 1))) {
insns.def:  @e optimized X-Y.
insns.def:  @j ÅK»³ê½ X-YB
insns.def:	c = a - b;
insns.def:		    div = -x / -y;
insns.def:		    div = -(x / -y);
insns.def:		    div = -(-x / y);
insns.def:	    mod = x - div * y;
insns.def:		div -= 1;
insns.def:		    div = -x / -y;
insns.def:		    div = -(x / -y);
insns.def:		    div = -(-x / y);
insns.def:	    mod = x - div * y;
insns.def:		div -= 1;
insns.def:		mod = x - z * y;
insns.def:	    div = (x - mod) / y;
insns.def:		div -= 1.0;
insns.def:	VALUE err = th->errinfo;
insns.def:	th->errinfo = Qnil;
insns.inc:/** -*-c-*-
insns.inc:  ----
insns_info.inc:/** -*-c-*-
insns_info.inc:  ----
insns_info.inc:          return depth + -1;
insns_info.inc:          return depth + -1;
insns_info.inc:          return depth + -1;
insns_info.inc:          return depth + -1;
insns_info.inc:          return depth + -1;
insns_info.inc:          return depth + -2;
insns_info.inc:          return depth + -1;
insns_info.inc:        inc += 1 - num;;
insns_info.inc:        inc += 1 - cnt;;
insns_info.inc:        inc += 1 - num;;
insns_info.inc:        inc += num - 1 + (flag & 1 ? 1 : 0);;
insns_info.inc:          return depth + -1;
insns_info.inc:        inc += 1 - num;;
insns_info.inc:          return depth + -1;
insns_info.inc:          return depth + -1;
insns_info.inc:        inc -= n;
insns_info.inc:          return depth + -1;
insns_info.inc:        inc += - (op_argc + ((op_flag & VM_CALL_ARGS_BLOCKARG_BIT) ? 1 : 0));;
insns_info.inc:        inc += - (op_argc + ((op_flag & VM_CALL_ARGS_BLOCKARG_BIT) ? 1 : 0));;
insns_info.inc:        inc += 1 - num;;
insns_info.inc:          return depth + -1;
insns_info.inc:          return depth + -1;
insns_info.inc:        inc += -1;;
insns_info.inc:          return depth + -1;
insns_info.inc:          return depth + -1;
insns_info.inc:          return depth + -1;
insns_info.inc:          return depth + -1;
insns_info.inc:          return depth + -1;
insns_info.inc:          return depth + -1;
insns_info.inc:          return depth + -1;
insns_info.inc:          return depth + -1;
insns_info.inc:          return depth + -1;
insns_info.inc:          return depth + -1;
insns_info.inc:          return depth + -1;
insns_info.inc:          return depth + -1;
insns_info.inc:          return depth + -1;
insns_info.inc:          return depth + -2;
insns_info.inc:          return depth + -1;
insns_info.inc:  int len = insn_len(insn) - 1;
instruby.rb:  opt.on('-n') {$dryrun = true}
instruby.rb:  opt.on('--dest-dir=DIR') {|dir| $destdir = dir}
instruby.rb:  opt.on('--extout=DIR') {|dir| $extout = (dir unless dir.empty?)}
instruby.rb:  opt.on('--make=COMMAND') {|make| $make = make}
instruby.rb:  opt.on('--mantype=MAN') {|man| $mantype = man}
instruby.rb:  opt.on('--make-flags=FLAGS', '--mflags', Shellwords) do |v|
instruby.rb:      arg.insert(0, '-') if /\A[^-][^=]*\Z/ =~ arg
instruby.rb:  opt.on('-i', '--install=TYPE',
instruby.rb:         [:local, :bin, :"bin-arch", :"bin-comm", :lib, :man, :ext, :"ext-arch", :"ext-comm", :rdoc]) do |ins|
instruby.rb:  opt.on('--data-mode=OCTAL-MODE', OptionParser::OctalInteger) do |mode|
instruby.rb:  opt.on('--prog-mode=OCTAL-MODE', OptionParser::OctalInteger) do |mode|
instruby.rb:  opt.on('--dir-mode=OCTAL-MODE', OptionParser::OctalInteger) do |mode|
instruby.rb:  opt.on('--script-mode=OCTAL-MODE', OptionParser::OctalInteger) do |mode|
instruby.rb:  opt.on('--installed-list [FILENAME]') {|name| $installed_list = name}
instruby.rb:  opt.on('--rdoc-output [DIR]') {|dir| $rdocdir = dir}
instruby.rb:  opt.on('--cmd-type=TYPE', %w[bat cmd plain]) {|cmd| $cmdtype = (cmd unless cmd == 'plain')}
instruby.rb:    when /\AINSTALL[-_]([-\w]+)=(.*)/
instruby.rb:      argv.unshift("--#{$1.tr('_', '-')}=#{$2}")
instruby.rb:    when /\A\w[-\w+]*=\z/
instruby.rb:    when /\A\w[-\w+]*\z/
instruby.rb:    grep(/\A-(?!-).*#{flag.chr}/i) { return true }
instruby.rb:    $mflags << '-n' if $dryrun
instruby.rb:  subpath = srcdir.size..-1
instruby.rb:install?(:local, :arch, :bin, :'bin-arch') do
instruby.rb:  install?(:ext, :arch, :'ext-arch') do
instruby.rb:  install?(:ext, :comm, :'ext-comm') do
instruby.rb:install?(:local, :comm, :bin, :'bin-comm') do
instruby.rb:#{ruby_bin} -x "#{cmd}" %1 %2 %3 %4 %5 %6 %7 %8 %9
instruby.rb:"%~dp0#{ruby_install_name}" -x "%~f0" %*
instruby.rb:@"%~dp0#{ruby_install_name}" -x "%~f0" %*
instruby.rb:  for mdoc in Dir["*.[1-9]"]
instruby.rb:    next warn("unknown install target - #{inst}")
io.c:  io.c -
io.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
io.c:  Copyright (C) 2000  Information-technology Promotion Agency, Japan
io.c:#    define STDIO_READ_DATA_PENDING(fp) ((fp)->_IO_read_ptr != (fp)->_IO_read_end)
io.c:#    define STDIO_READ_DATA_PENDING(fp) ((fp)->_gptr < (fp)->_egptr)
io.c:#  define STDIO_READ_DATA_PENDING(fp) ((fp)->FILE_COUNT > 0)
io.c:#  define STDIO_READ_DATA_PENDING(fp) ((fp)->FILE_READPTR < (fp)->FILE_READEND)
io.c:#  define STDIO_READ_DATA_PENDING(fp) (fp->_state._eof == 0)
io.c:#define READ_DATA_PENDING(fptr) ((fptr)->rbuf_len)
io.c:#define READ_DATA_PENDING_COUNT(fptr) ((fptr)->rbuf_len)
io.c:#define READ_DATA_PENDING_PTR(fptr) ((fptr)->rbuf+(fptr)->rbuf_off)
io.c:	rb_thread_wait_fd((fptr)->fd);\
io.c:    if (fptr->fd < 0) {
io.c:    rb_io_check_initialized(RFILE(io)->fptr);
io.c:    write_io = RFILE(io)->fptr->tied_io_for_writing;
io.c: *  call-seq:
io.c: *     IO.try_convert(obj) -> io or nil
io.c:    if (fptr->rbuf_len == 0 || fptr->mode & FMODE_DUPLEX)
io.c:    r = lseek(fptr->fd, -fptr->rbuf_len, SEEK_CUR);
io.c:            fptr->mode |= FMODE_DUPLEX;
io.c:    fptr->rbuf_off = 0;
io.c:    fptr->rbuf_len = 0;
io.c:    if (fptr->rbuf == NULL) {
io.c:        fptr->rbuf_off = 0;
io.c:        fptr->rbuf_len = 0;
io.c:	    fptr->rbuf_capa = len;
io.c:	    fptr->rbuf_capa = 8192;
io.c:        fptr->rbuf = ALLOC_N(char, fptr->rbuf_capa);
io.c:    if (fptr->rbuf_capa < len + fptr->rbuf_len) {
io.c:    if (fptr->rbuf_off < len) {
io.c:        MEMMOVE(fptr->rbuf+fptr->rbuf_capa-fptr->rbuf_len,
io.c:                fptr->rbuf+fptr->rbuf_off,
io.c:                char, fptr->rbuf_len);
io.c:        fptr->rbuf_off = fptr->rbuf_capa-fptr->rbuf_len;
io.c:    fptr->rbuf_off-=len;
io.c:    fptr->rbuf_len+=len;
io.c:    MEMMOVE(fptr->rbuf+fptr->rbuf_off, RSTRING_PTR(str), char, len);
io.c:#define io_set_eof(fptr) (void)(((fptr)->mode & FMODE_TTY) && ((fptr)->mode |= FMODE_EOF))
io.c:#define io_unset_eof(fptr) (fptr->mode &= ~FMODE_EOF)
io.c:#define io_seek(fptr, ofs, whence) (io_unset_eof(fptr), lseek(flush_before_seek(fptr)->fd, ofs, whence))
io.c:#define io_tell(fptr) lseek(flush_before_seek(fptr)->fd, 0, SEEK_CUR)
io.c:    if (!(fptr->mode & FMODE_READABLE)) {
io.c:    if (fptr->wbuf_len) {
io.c:    if (fptr->tied_io_for_writing) {
io.c:	GetOpenFile(fptr->tied_io_for_writing, wfptr);
io.c:    if (fptr->encs.enc) {
io.c:	return fptr->encs.enc;
io.c:    if (fptr->encs.enc2) {
io.c:	return fptr->encs.enc2;
io.c:    if (!(fptr->mode & FMODE_WRITABLE)) {
io.c:    if (fptr->rbuf_len) {
io.c:	rb_thread_wait_fd(fptr->fd);
io.c:    io->fptr = 0;
io.c:    if (!(fptr->mode & FMODE_WSPLIT_INITIALIZED)) {
io.c:        if (fstat(fptr->fd, &buf) == 0 &&
io.c:            && (r = fcntl(fptr->fd, F_GETFL)) != -1 &&
io.c:            fptr->mode |= FMODE_WSPLIT;
io.c:        fptr->mode |= FMODE_WSPLIT_INITIALIZED;
io.c:    return fptr->mode & FMODE_WSPLIT;
io.c:    return read(iis->fd, iis->buf, iis->capa);
io.c:    return write(iis->fd, iis->buf, iis->capa);
io.c:    long l = io_writable_length(fptr, fptr->wbuf_len);
io.c:    return rb_write_internal(fptr->fd, fptr->wbuf+fptr->wbuf_off, l);
io.c:    if (fptr->wbuf_len == 0)
io.c:    if (!rb_thread_fd_writable(fptr->fd)) {
io.c:    if (fptr->wbuf_len == 0)
io.c:    if (fptr->write_lock) {
io.c:	r = rb_mutex_synchronize(fptr->write_lock, io_flush_buffer, (VALUE)fptr);
io.c:	long l = io_writable_length(fptr, fptr->wbuf_len);
io.c:	r = rb_write_internal(fptr->fd, fptr->wbuf+fptr->wbuf_off, l);
io.c:    if (fptr->wbuf_len <= r) {
io.c:        fptr->wbuf_off = 0;
io.c:        fptr->wbuf_len = 0;
io.c:        fptr->wbuf_off += r;
io.c:        fptr->wbuf_len -= r;
io.c:    if (rb_io_wait_writable(fptr->fd)) {
io.c:    return -1;
io.c:# define NEED_NEWLINE_DECORATOR_ON_READ(fptr) (!(fptr->mode & FMODE_BINMODE))
io.c:# define NEED_NEWLINE_DECORATOR_ON_WRITE(fptr) (!(fptr->mode & FMODE_BINMODE))
io.c:# define NEED_NEWLINE_DECORATOR_ON_READ(fptr) (fptr->mode & FMODE_TEXTMODE)
io.c:#define NEED_READCONV(fptr) (fptr->encs.enc2 != NULL || NEED_NEWLINE_DECORATOR_ON_READ(fptr))
io.c:#define NEED_WRITECONV(fptr) ((fptr->encs.enc != NULL && fptr->encs.enc != rb_ascii8bit_encoding()) || NEED_NEWLINE_DECORATOR_ON_WRITE(fptr) || (fptr->encs.ecflags & (ECONV_DECORATOR_MASK|ECONV_STATEFUL_DECORATOR_MASK)))
io.c:    if (!fptr->writeconv_initialized) {
io.c:        fptr->writeconv_initialized = 1;
io.c:        ecflags = fptr->encs.ecflags;
io.c:        ecopts = fptr->encs.ecopts;
io.c:        if (!fptr->encs.enc || (fptr->encs.enc == rb_ascii8bit_encoding() && !fptr->encs.enc2)) {
io.c:            fptr->writeconv_pre_ecflags = 0;
io.c:            fptr->writeconv_pre_ecopts = Qnil;
io.c:            fptr->writeconv = rb_econv_open_opts("", "", ecflags, ecopts);
io.c:            if (!fptr->writeconv)
io.c:            fptr->writeconv_asciicompat = Qnil;
io.c:            enc = fptr->encs.enc2 ? fptr->encs.enc2 : fptr->encs.enc;
io.c:            if (!senc && !(fptr->encs.ecflags & ECONV_STATEFUL_DECORATOR_MASK)) {
io.c:                fptr->writeconv_pre_ecflags = ecflags;
io.c:                fptr->writeconv_pre_ecopts = ecopts;
io.c:                fptr->writeconv = NULL;
io.c:                fptr->writeconv_asciicompat = Qnil;
io.c:                fptr->writeconv_pre_ecflags = ecflags & ~ECONV_STATEFUL_DECORATOR_MASK;
io.c:                fptr->writeconv_pre_ecopts = ecopts;
io.c:                    fptr->writeconv_asciicompat = rb_str_new2(senc);
io.c:                    fptr->writeconv_asciicompat = rb_str_new2(rb_enc_name(enc));
io.c:                ecflags = fptr->encs.ecflags & (ECONV_ERROR_HANDLER_MASK|ECONV_STATEFUL_DECORATOR_MASK);
io.c:                ecopts = fptr->encs.ecopts;
io.c:                fptr->writeconv = rb_econv_open_opts(senc, denc, ecflags, ecopts);
io.c:                if (!fptr->writeconv)
io.c:    long l = io_writable_length(p->fptr, p->length);
io.c:    return rb_write_internal(p->fptr->fd, RSTRING_PTR(p->str)+p->offset, l);
io.c:    if (fptr->wbuf == NULL && !(!nosync && (fptr->mode & FMODE_SYNC))) {
io.c:        fptr->wbuf_off = 0;
io.c:        fptr->wbuf_len = 0;
io.c:        fptr->wbuf_capa = 8192;
io.c:        fptr->wbuf = ALLOC_N(char, fptr->wbuf_capa);
io.c:	fptr->write_lock = rb_mutex_new();
io.c:    if ((!nosync && (fptr->mode & (FMODE_SYNC|FMODE_TTY))) ||
io.c:        (fptr->wbuf && fptr->wbuf_capa <= fptr->wbuf_len + len)) {
io.c:        if (fptr->wbuf_len && fptr->wbuf_len+len <= fptr->wbuf_capa) {
io.c:            if (fptr->wbuf_capa < fptr->wbuf_off+fptr->wbuf_len+len) {
io.c:                MEMMOVE(fptr->wbuf, fptr->wbuf+fptr->wbuf_off, char, fptr->wbuf_len);
io.c:                fptr->wbuf_off = 0;
io.c:            MEMMOVE(fptr->wbuf+fptr->wbuf_off+fptr->wbuf_len, RSTRING_PTR(str)+offset, char, len);
io.c:            fptr->wbuf_len += len;
io.c:            return -1L;
io.c:           [ruby-dev:25080] */
io.c:	if (fptr->stdio_file != stderr && !rb_thread_fd_writable(fptr->fd)) {
io.c:	if (fptr->write_lock) {
io.c:	    r = rb_mutex_synchronize(fptr->write_lock, io_binwrite_string, (VALUE)&arg);
io.c:	    r = rb_write_internal(fptr->fd, RSTRING_PTR(str)+offset, l);
io.c:            n -= r;
io.c:        if (rb_io_wait_writable(fptr->fd)) {
io.c:        return -1L;
io.c:    if (fptr->wbuf_off) {
io.c:        if (fptr->wbuf_len)
io.c:            MEMMOVE(fptr->wbuf, fptr->wbuf+fptr->wbuf_off, char, fptr->wbuf_len);
io.c:        fptr->wbuf_off = 0;
io.c:    MEMMOVE(fptr->wbuf+fptr->wbuf_off+fptr->wbuf_len, RSTRING_PTR(str)+offset, char, len);
io.c:    fptr->wbuf_len += len;
io.c:        if (fptr->writeconv) {
io.c:            if (!NIL_P(fptr->writeconv_asciicompat))
io.c:                common_encoding = fptr->writeconv_asciicompat;
io.c:            if (fptr->encs.enc2)
io.c:                common_encoding = rb_enc_from_encoding(fptr->encs.enc2);
io.c:            else if (fptr->encs.enc != rb_ascii8bit_encoding())
io.c:                common_encoding = rb_enc_from_encoding(fptr->encs.enc);
io.c:                fptr->writeconv_pre_ecflags, fptr->writeconv_pre_ecopts);
io.c:        if (fptr->writeconv) {
io.c:            str = rb_econv_str_convert(fptr->writeconv, str, ECONV_PARTIAL_INPUT);
io.c:    if (n == -1L) rb_sys_fail_path(fptr->pathv);
io.c: *  call-seq:
io.c: *  call-seq:
io.c: *  String Output---Writes <i>obj</i> to <em>ios</em>.
io.c: *  call-seq:
io.c:    if (fptr->mode & FMODE_WRITABLE) {
io.c:	fsync(fptr->fd);
io.c:    if (fptr->mode & FMODE_READABLE) {
io.c: *  call-seq:
io.c:    if (pos < 0 && errno) rb_sys_fail_path(fptr->pathv);
io.c:    if (pos < 0 && errno) rb_sys_fail_path(fptr->pathv);
io.c: *  call-seq:
io.c: *     ios.seek(amount, whence=SEEK_SET) -> 0
io.c: *    --------------+----------------------------------------------------
io.c: *    --------------+----------------------------------------------------
io.c: *     f.seek(-13, IO::SEEK_END)   #=> 0
io.c: *  call-seq:
io.c:    if (pos < 0) rb_sys_fail_path(fptr->pathv);
io.c: *  call-seq:
io.c:    if (io_seek(fptr, 0L, 0) < 0) rb_sys_fail_path(fptr->pathv);
io.c:	ARGF.lineno -= fptr->lineno;
io.c:    fptr->lineno = 0;
io.c:    if (fptr->readconv) {
io.c:    if (fptr->mode & FMODE_EOF) {
io.c:	return -1;
io.c:    if (fptr->rbuf == NULL) {
io.c:        fptr->rbuf_off = 0;
io.c:        fptr->rbuf_len = 0;
io.c:        fptr->rbuf_capa = 8192;
io.c:        fptr->rbuf = ALLOC_N(char, fptr->rbuf_capa);
io.c:    if (fptr->rbuf_len == 0) {
io.c:	    r = rb_read_internal(fptr->fd, fptr->rbuf, fptr->rbuf_capa);
io.c:            if (rb_io_wait_readable(fptr->fd))
io.c:            rb_sys_fail_path(fptr->pathv);
io.c:        fptr->rbuf_off = 0;
io.c:        fptr->rbuf_len = r;
io.c:            return -1; /* EOF */
io.c: *  call-seq:
io.c: *  call-seq:
io.c:    return (fptr->mode & FMODE_SYNC) ? Qtrue : Qfalse;
io.c: *  call-seq:
io.c:	fptr->mode |= FMODE_SYNC;
io.c:	fptr->mode &= ~FMODE_SYNC;
io.c: *  call-seq:
io.c:    if (fsync(fptr->fd) < 0)
io.c:	rb_sys_fail_path(fptr->pathv);
io.c: *  call-seq:
io.c:    fd = fptr->fd;
io.c: *  call-seq:
io.c: *     pipe = IO.popen("-")
io.c:    if (!fptr->pid)
io.c:    return PIDT2NUM(fptr->pid);
io.c: * call-seq:
io.c:    fptr = RFILE(rb_io_taint_check(obj))->fptr;
io.c:    if (!fptr || NIL_P(fptr->pathv)) return rb_any_to_s(obj);
io.c:    if (fptr->fd < 0) {
io.c:    return rb_sprintf("#<%s:%s%s>", cname, RSTRING_PTR(fptr->pathv), st);
io.c: *  call-seq:
io.c: *     ios.to_io -> ios
io.c:    MEMMOVE(ptr, fptr->rbuf+fptr->rbuf_off, char, n);
io.c:    fptr->rbuf_off += n;
io.c:    fptr->rbuf_len -= n;
io.c:    long len = RSTRING_LEN(str) - offset;
io.c:	    c = rb_read_internal(fptr->fd, RSTRING_PTR(str)+offset, n);
io.c:                if (rb_io_wait_readable(fptr->fd))
io.c:		rb_sys_fail_path(fptr->pathv);
io.c:	    if ((n -= c) <= 0) break;
io.c:	    rb_thread_wait_fd(fptr->fd);
io.c:	return len - n;
io.c:	    if ((n -= c) <= 0) break;
io.c:	rb_thread_wait_fd(fptr->fd);
io.c:    return len - n;
io.c:    if (fstat(fptr->fd, &st) == 0  && S_ISREG(st.st_mode)
io.c:	pos = lseek(fptr->fd, 0, SEEK_CUR);
io.c:	    siz += st.st_size - pos;
io.c:    if (!fptr->readconv) {
io.c:        ecflags = fptr->encs.ecflags;
io.c:        ecopts = fptr->encs.ecopts;
io.c:        if (fptr->encs.enc2) {
io.c:            sname = rb_enc_name(fptr->encs.enc2);
io.c:            dname = rb_enc_name(fptr->encs.enc);
io.c:        fptr->readconv = rb_econv_open_opts(sname, dname, ecflags, ecopts);
io.c:        if (!fptr->readconv)
io.c:        fptr->cbuf_off = 0;
io.c:        fptr->cbuf_len = 0;
io.c:        fptr->cbuf_capa = size < 1024 ? 1024 : size;
io.c:        fptr->cbuf = ALLOC_N(char, fptr->cbuf_capa);
io.c:    if (fptr->cbuf_len == fptr->cbuf_capa)
io.c:    if (fptr->cbuf_len == 0)
io.c:        fptr->cbuf_off = 0;
io.c:    else if (fptr->cbuf_off + fptr->cbuf_len == fptr->cbuf_capa) {
io.c:        memmove(fptr->cbuf, fptr->cbuf+fptr->cbuf_off, fptr->cbuf_len);
io.c:        fptr->cbuf_off = 0;
io.c:    cbuf_len0 = fptr->cbuf_len;
io.c:        ss = sp = (const unsigned char *)fptr->rbuf + fptr->rbuf_off;
io.c:        se = sp + fptr->rbuf_len;
io.c:        ds = dp = (unsigned char *)fptr->cbuf + fptr->cbuf_off + fptr->cbuf_len;
io.c:        de = (unsigned char *)fptr->cbuf + fptr->cbuf_capa;
io.c:        res = rb_econv_convert(fptr->readconv, &sp, se, &dp, de, ECONV_PARTIAL_INPUT|ECONV_AFTER_OUTPUT);
io.c:        fptr->rbuf_off += sp - ss;
io.c:        fptr->rbuf_len -= sp - ss;
io.c:        fptr->cbuf_len += dp - ds;
io.c:        putbackable = rb_econv_putbackable(fptr->readconv);
io.c:            rb_econv_putback(fptr->readconv, (unsigned char *)fptr->rbuf + fptr->rbuf_off - putbackable, putbackable);
io.c:            fptr->rbuf_off -= putbackable;
io.c:            fptr->rbuf_len += putbackable;
io.c:        rb_econv_check_error(fptr->readconv);
io.c:        if (cbuf_len0 != fptr->cbuf_len)
io.c:            return -1;
io.c:            if (fptr->rbuf_len == 0) {
io.c:                rb_thread_wait_fd(fptr->fd);
io.c:                if (io_fillbuf(fptr) == -1) {
io.c:                    ds = dp = (unsigned char *)fptr->cbuf + fptr->cbuf_off + fptr->cbuf_len;
io.c:                    de = (unsigned char *)fptr->cbuf + fptr->cbuf_capa;
io.c:                    res = rb_econv_convert(fptr->readconv, NULL, NULL, &dp, de, 0);
io.c:                    fptr->cbuf_len += dp - ds;
io.c:                    rb_econv_check_error(fptr->readconv);
io.c:        *strp = str = rb_str_new(fptr->cbuf+fptr->cbuf_off, len);
io.c:        memcpy(RSTRING_PTR(str)+slen, fptr->cbuf+fptr->cbuf_off, len);
io.c:    fptr->cbuf_off += len;
io.c:    fptr->cbuf_len -= len;
io.c:    rb_enc_associate(str, fptr->encs.enc);
io.c:    if (fptr->cbuf_len == 0)
io.c:        fptr->cbuf_off = 0;
io.c:    if (fptr->cbuf_off < fptr->cbuf_capa/2) {
io.c:        memmove(fptr->cbuf, fptr->cbuf+fptr->cbuf_off, fptr->cbuf_len);
io.c:        fptr->cbuf_off = 0;
io.c:            if (fptr->cbuf_len) {
io.c:                io_shift_cbuf(fptr, fptr->cbuf_len, &str);
io.c:            if (more_char(fptr) == -1) {
io.c:    oflags = fcntl(fptr->fd, F_GETFL);
io.c:    if (oflags == -1) {
io.c:        rb_sys_fail_path(fptr->pathv);
io.c:        if (fcntl(fptr->fd, F_SETFL, oflags) == -1) {
io.c:            rb_sys_fail_path(fptr->pathv);
io.c:	n = rb_read_internal(fptr->fd, RSTRING_PTR(str), len);
io.c:            if (!nonblock && rb_io_wait_readable(fptr->fd))
io.c:            rb_sys_fail_path(fptr->pathv);
io.c: *  call-seq:
io.c: *  The later means that readpartial is nonblocking-flag insensitive.
io.c: *  call-seq:
io.c: *  except the non-blocking flag is set.
io.c: *  call-seq:
io.c:    n = write(fptr->fd, RSTRING_PTR(str), RSTRING_LEN(str));
io.c:    if (n == -1) rb_sys_fail_path(fptr->pathv);
io.c: *  call-seq:
io.c: *  <i>length</i> must be a non-negative integer or nil.
io.c: *  <code><i>ios</i>.read(<i>positive-integer</i>)</code> returns nil.
io.c:	if (fptr->fd < 0) return Qnil;
io.c:            if (fptr->cbuf_len) {
io.c:                p = fptr->cbuf+fptr->cbuf_off;
io.c:                searchlen = fptr->cbuf_len;
io.c:                        *strp = str = rb_str_new(p, e-p+1);
io.c:                        rb_str_buf_cat(str, p, e-p+1);
io.c:                    fptr->cbuf_off += e-p+1;
io.c:                    fptr->cbuf_len -= e-p+1;
io.c:                    limit -= e-p+1;
io.c:                fptr->cbuf_off += searchlen;
io.c:                fptr->cbuf_len -= searchlen;
io.c:                limit -= searchlen;
io.c:                    return (unsigned char)RSTRING_PTR(str)[RSTRING_LEN(str)-1];
io.c:        } while (more_char(fptr) != -1);
io.c:	    if (e) pending = e - p + 1;
io.c:	    limit -= pending;
io.c:		return (unsigned char)RSTRING_PTR(str)[RSTRING_LEN(str)-1];
io.c:	rb_thread_wait_fd(fptr->fd);
io.c:	    while (--i && *++p == term);
io.c:	    if (!read_buffered_data(buf, cnt - i, fptr)) /* must not fail */
io.c:		rb_sys_fail_path(fptr->pathv);
io.c:	rb_thread_wait_fd(fptr->fd);
io.c:                pending = e - p + 1;
io.c:		fptr->rbuf_off += pending;
io.c:		fptr->rbuf_len -= pending;
io.c:	rb_thread_wait_fd(fptr->fd);
io.c:    fptr->lineno++;
io.c:    ARGF.last_lineno = fptr->lineno;
io.c:    *limit = NIL_P(lim) ? -1L : NUM2LONG(lim);
io.c:	int c, newline = -1;
io.c:	    newline = (unsigned char)rsptr[rslen - 1];
io.c:	/* MS - Optimisation */
io.c:		p = e - rslen;
io.c:		pp = rb_enc_left_char_head(s, p-1, p, enc);
io.c:                    extra_limit--;
io.c:	    fptr->lineno++;
io.c:	    ARGF.last_lineno = fptr->lineno;
io.c:    return rb_io_getline_1(rb_default_rs, -1, io);
io.c: *  call-seq:
io.c: *  contents, and a zero-length separator reads the input a paragraph at
io.c: *  call-seq:
io.c:    return INT2NUM(fptr->lineno);
io.c: *  call-seq:
io.c:    fptr->lineno = NUM2INT(lineno);
io.c: *  call-seq:
io.c: *  call-seq:
io.c: *  call-seq:
io.c: *  call-seq:
io.c:	p = fptr->rbuf+fptr->rbuf_off;
io.c:	e = p + fptr->rbuf_len;
io.c:	    fptr->rbuf_off++;
io.c:	    fptr->rbuf_len--;
io.c:            if (fptr->cbuf_len) {
io.c:                if (fptr->encs.enc)
io.c:                    r = rb_enc_precise_mbclen(fptr->cbuf+fptr->cbuf_off,
io.c:                                              fptr->cbuf+fptr->cbuf_off+fptr->cbuf_len,
io.c:                                              fptr->encs.enc);
io.c:                if (fptr->cbuf_len == fptr->cbuf_capa) {
io.c:            if (more_char(fptr) == -1) {
io.c:                if (fptr->cbuf_len == 0)
io.c:                return io_shift_cbuf(fptr, fptr->cbuf_len, &str);
io.c:            r = rb_enc_mbclen(fptr->cbuf+fptr->cbuf_off,
io.c:                              fptr->cbuf+fptr->cbuf_off+fptr->cbuf_len,
io.c:                              fptr->encs.enc);
io.c:    if (rb_enc_asciicompat(enc) && ISASCII(fptr->rbuf[fptr->rbuf_off])) {
io.c:	str = rb_str_new(fptr->rbuf+fptr->rbuf_off, 1);
io.c:	fptr->rbuf_off += 1;
io.c:	fptr->rbuf_len -= 1;
io.c:	r = rb_enc_precise_mbclen(fptr->rbuf+fptr->rbuf_off, fptr->rbuf+fptr->rbuf_off+fptr->rbuf_len, enc);
io.c:	    (n = MBCLEN_CHARFOUND_LEN(r)) <= fptr->rbuf_len) {
io.c:	    str = rb_str_new(fptr->rbuf+fptr->rbuf_off, n);
io.c:	    fptr->rbuf_off += n;
io.c:	    fptr->rbuf_len -= n;
io.c:	    str = rb_str_new(fptr->rbuf+fptr->rbuf_off, fptr->rbuf_len);
io.c:	    fptr->rbuf_len = 0;
io.c:	    if (io_fillbuf(fptr) != -1) {
io.c:		rb_str_cat(str, fptr->rbuf+fptr->rbuf_off, 1);
io.c:		fptr->rbuf_off++;
io.c:		fptr->rbuf_len--;
io.c:	    str = rb_str_new(fptr->rbuf+fptr->rbuf_off, 1);
io.c:	    fptr->rbuf_off++;
io.c:	    fptr->rbuf_len--;
io.c: *  call-seq:
io.c: *  call-seq:
io.c: *  call-seq:
io.c: *  call-seq:
io.c: *  call-seq:
io.c: *  Reads a one-character string from <em>ios</em>. Returns
io.c: *  call-seq:
io.c: *  Reads a one-character string from <em>ios</em>. Raises an
io.c: *  call-seq:
io.c: *  Gets the next 8-bit byte (0..255) from <em>ios</em>. Returns
io.c:    if (fptr->fd == 0 && (fptr->mode & FMODE_TTY) && TYPE(rb_stdout) == T_FILE) {
io.c:        if (ofp->mode & FMODE_TTY) {
io.c:    fptr->rbuf_off++;
io.c:    fptr->rbuf_len--;
io.c:    c = (unsigned char)fptr->rbuf[fptr->rbuf_off-1];
io.c: *  call-seq:
io.c: *  call-seq:
io.c: *  call-seq:
io.c:        if (fptr->cbuf_capa - fptr->cbuf_len < len)
io.c:        if (fptr->cbuf_off < len) {
io.c:            MEMMOVE(fptr->cbuf+fptr->cbuf_capa-fptr->cbuf_len,
io.c:                    fptr->cbuf+fptr->cbuf_off,
io.c:                    char, fptr->cbuf_len);
io.c:            fptr->cbuf_off = fptr->cbuf_capa-fptr->cbuf_len;
io.c:        fptr->cbuf_off -= len;
io.c:        fptr->cbuf_len += len;
io.c:        MEMMOVE(fptr->cbuf+fptr->cbuf_off, RSTRING_PTR(c), char, len);
io.c: *  call-seq:
io.c:    if (isatty(fptr->fd) == 0)
io.c: *  call-seq:
io.c:        if (fptr && 0 <= (fd = fptr->fd)) {
io.c:            if ((ret = fcntl(fd, F_GETFD)) == -1) rb_sys_fail_path(fptr->pathv);
io.c:    if (fptr && 0 <= (fd = fptr->fd)) {
io.c:        if ((ret = fcntl(fd, F_GETFD)) == -1) rb_sys_fail_path(fptr->pathv);
io.c: *  call-seq:
io.c: *  Sets a close-on-exec flag.
io.c:        if (fptr && 0 <= (fd = fptr->fd)) {
io.c:            if ((ret = fcntl(fptr->fd, F_GETFD)) == -1) rb_sys_fail_path(fptr->pathv);
io.c:                if (ret == -1) rb_sys_fail_path(fptr->pathv);
io.c:    if (fptr && 0 <= (fd = fptr->fd)) {
io.c:        if ((ret = fcntl(fd, F_GETFD)) == -1) rb_sys_fail_path(fptr->pathv);
io.c:            if (ret == -1) rb_sys_fail_path(fptr->pathv);
io.c:#define IS_PREP_STDIO(f) ((f)->mode & FMODE_PREP)
io.c:#define PREP_STDIO_NAME(f) (RSTRING_PTR((f)->pathv))
io.c:    if (!fptr->wbuf) {
io.c:            res = rb_econv_convert(fptr->writeconv, NULL, NULL, &dp, de, 0);
io.c:            while (dp-ds) {
io.c:                r = rb_write_internal(fptr->fd, ds, dp-ds);
io.c:                if (r == dp-ds)
io.c:                if (rb_io_wait_writable(fptr->fd)) {
io.c:                    if (fptr->fd < 0)
io.c:                return noalloc ? Qtrue : rb_econv_make_exception(fptr->writeconv);
io.c:        if (fptr->wbuf_len == fptr->wbuf_capa) {
io.c:        ds = dp = (unsigned char *)fptr->wbuf + fptr->wbuf_off + fptr->wbuf_len;
io.c:        de = (unsigned char *)fptr->wbuf + fptr->wbuf_capa;
io.c:        res = rb_econv_convert(fptr->writeconv, NULL, NULL, &dp, de, 0);
io.c:        fptr->wbuf_len += dp - ds;
io.c:            return noalloc ? Qtrue : rb_econv_make_exception(fptr->writeconv);
io.c:    return finish_writeconv(p->fptr, p->noalloc);
io.c:    if (fptr->writeconv) {
io.c:	if (fptr->write_lock) {
io.c:            err = rb_mutex_synchronize(fptr->write_lock, finish_writeconv_sync, (VALUE)&arg);
io.c:    if (fptr->wbuf_len) {
io.c:    if (IS_PREP_STDIO(fptr) || fptr->fd <= 2) {
io.c:    if (fptr->stdio_file) {
io.c:        /* fptr->stdio_file is deallocated anyway
io.c:        if (fclose(fptr->stdio_file) < 0 && NIL_P(err))
io.c:    else if (0 <= fptr->fd) {
io.c:        /* fptr->fd may be closed even if close fails.
io.c:        if (close(fptr->fd) < 0 && NIL_P(err))
io.c:    fptr->fd = -1;
io.c:    fptr->stdio_file = 0;
io.c:    fptr->mode &= ~(FMODE_READABLE|FMODE_WRITABLE);
io.c:            rb_sys_fail_path(fptr->pathv);
io.c:    if (fptr->finalize) {
io.c:	(*fptr->finalize)(fptr, noraise);
io.c:    if (fptr->readconv) {
io.c:        rb_econv_close(fptr->readconv);
io.c:        fptr->readconv = NULL;
io.c:    if (fptr->cbuf) {
io.c:        free(fptr->cbuf);
io.c:        fptr->cbuf = NULL;
io.c:    if (fptr->writeconv) {
io.c:        rb_econv_close(fptr->writeconv);
io.c:        fptr->writeconv = NULL;
io.c:    fptr->writeconv_initialized = 0;
io.c:    fptr->pathv = Qnil;
io.c:    fptr->write_lock = 0;
io.c:    if (0 <= fptr->fd)
io.c:    if (fptr->rbuf) {
io.c:        free(fptr->rbuf);
io.c:        fptr->rbuf = 0;
io.c:    if (fptr->wbuf) {
io.c:        free(fptr->wbuf);
io.c:        fptr->wbuf = 0;
io.c:        write_fptr = RFILE(write_io)->fptr;
io.c:        if (write_fptr && 0 <= write_fptr->fd) {
io.c:    fptr = RFILE(io)->fptr;
io.c:    if (fptr->fd < 0) return Qnil;
io.c:    fd = fptr->fd;
io.c:    if (fptr->pid) {
io.c:	rb_syswait(fptr->pid);
io.c:	fptr->pid = 0;
io.c: *  call-seq:
io.c:    rb_io_check_closed(RFILE(io)->fptr);
io.c: *  call-seq:
io.c:        write_fptr = RFILE(write_io)->fptr;
io.c:        if (write_fptr && 0 <= write_fptr->fd) {
io.c:    fptr = RFILE(io)->fptr;
io.c:    return 0 <= fptr->fd ? Qfalse : Qtrue;
io.c: *  call-seq:
io.c:    if (is_socket(fptr->fd, fptr->pathv)) {
io.c:        if (shutdown(fptr->fd, SHUT_RD) < 0)
io.c:            rb_sys_fail_path(fptr->pathv);
io.c:        fptr->mode &= ~FMODE_READABLE;
io.c:        if (!(fptr->mode & FMODE_WRITABLE))
io.c:        RFILE(io)->fptr = wfptr;
io.c:        RFILE(write_io)->fptr = NULL;
io.c:    if (fptr->mode & FMODE_WRITABLE) {
io.c:	rb_raise(rb_eIOError, "closing non-duplex IO for reading");
io.c: *  call-seq:
io.c:    if (is_socket(fptr->fd, fptr->pathv)) {
io.c:        if (shutdown(fptr->fd, SHUT_WR) < 0)
io.c:            rb_sys_fail_path(fptr->pathv);
io.c:        fptr->mode &= ~FMODE_WRITABLE;
io.c:        if (!(fptr->mode & FMODE_READABLE))
io.c:    if (fptr->mode & FMODE_READABLE) {
io.c:	rb_raise(rb_eIOError, "closing non-duplex IO for writing");
io.c:	fptr->tied_io_for_writing = 0;
io.c:	fptr->mode &= ~FMODE_DUPLEX;
io.c: *  call-seq:
io.c: *     f.sysseek(-13, IO::SEEK_END)   #=> 53
io.c:    if ((fptr->mode & FMODE_READABLE) && READ_DATA_BUFFERED(fptr)) {
io.c:    if ((fptr->mode & FMODE_WRITABLE) && fptr->wbuf_len) {
io.c:    pos = lseek(fptr->fd, pos, whence);
io.c:    if (pos == -1) rb_sys_fail_path(fptr->pathv);
io.c: *  call-seq:
io.c: *  Writes the given string to <em>ios</em> using a low-level write.
io.c:    if (fptr->wbuf_len) {
io.c:    if (!rb_thread_fd_writable(fptr->fd)) {
io.c:    n = write(fptr->fd, RSTRING_PTR(str), RSTRING_LEN(str));
io.c:    if (n == -1) rb_sys_fail_path(fptr->pathv);
io.c: *  call-seq:
io.c: *  Reads <i>integer</i> bytes from <em>ios</em> using a low-level
io.c:    n = fptr->fd;
io.c:    rb_thread_wait_fd(fptr->fd);
io.c:    n = rb_read_internal(fptr->fd, RSTRING_PTR(str), ilen);
io.c:    if (n == -1) {
io.c:	rb_sys_fail_path(fptr->pathv);
io.c:    if (fptr->readconv)
io.c:        rb_econv_binmode(fptr->readconv);
io.c:    if (fptr->writeconv)
io.c:        rb_econv_binmode(fptr->writeconv);
io.c:    fptr->mode |= FMODE_BINMODE;
io.c:    fptr->mode &= ~FMODE_TEXTMODE;
io.c:    fptr->writeconv_pre_ecflags &= ~(ECONV_UNIVERSAL_NEWLINE_DECORATOR|ECONV_CRLF_NEWLINE_DECORATOR|ECONV_CR_NEWLINE_DECORATOR);
io.c:    if (fptr->readconv) {
io.c:        rb_econv_close(fptr->readconv);
io.c:        fptr->readconv = NULL;
io.c:    if (fptr->writeconv) {
io.c:        rb_econv_close(fptr->writeconv);
io.c:        fptr->writeconv = NULL;
io.c:    fptr->mode |= FMODE_BINMODE;
io.c:    fptr->mode &= ~FMODE_TEXTMODE;
io.c:    fptr->encs.enc = rb_ascii8bit_encoding();
io.c:    fptr->encs.enc2 = NULL;
io.c:    fptr->encs.ecflags = 0;
io.c:    fptr->encs.ecopts = Qnil;
io.c: *  call-seq:
io.c: *  - newline conversion disabled
io.c: *  - encoding conversion disabled
io.c: *  - content is treated as ASCII-8BIT
io.c: *  call-seq:
io.c:    return fptr->mode & FMODE_BINMODE ? Qtrue : Qfalse;
io.c:	/* If external is ASCII-8BIT, no default transcoding */
io.c:    /* parse estr as "enc" or "enc2:enc" or "enc:-" */
io.c:	int len = (p++) - estr;
io.c:	    idx = -1;
io.c:	if (idx != -2)
io.c:	if (*p == '-' && *(p+1) == '\0') {
io.c:	    /* Special case - "-" => no transcoding */
io.c:    parse_mode_enc(estr, &fptr->encs.enc, &fptr->encs.enc2);
io.c:	    if (*p == '-' && *(p+1) == '\0') {
io.c:		/* Special case - "-" => no transcoding */
io.c:    convconfig_p->enc = enc;
io.c:    convconfig_p->enc2 = enc2;
io.c:    convconfig_p->ecflags = ecflags;
io.c:    convconfig_p->ecopts = ecopts;
io.c:    return (VALUE)open(data->fname, data->oflags, data->perm);
io.c:    if (isatty(fptr->fd))
io.c:        fptr->mode |= FMODE_TTY|FMODE_DUPLEX;
io.c:    validate_enc_binmode(fmode, convconfig->enc, convconfig->enc2);
io.c:    fptr->mode = fmode;
io.c:    fptr->encs = *convconfig;
io.c:    fptr->pathv = rb_str_new_frozen(filename);
io.c:    fptr->fd = rb_sysopen(RSTRING_PTR(fptr->pathv), oflags, perm);
io.c:    list->fptr = fptr;
io.c:    list->next = pipe_list;
io.c:    if (list->fptr == fptr) {
io.c:	pipe_list = list->next;
io.c:    while (list->next) {
io.c:	if (list->next->fptr == fptr) {
io.c:	    tmp = list->next;
io.c:	    list->next = list->next->next;
io.c:	list = list->next;
io.c:	tmp = list->next;
io.c:	rb_io_fptr_finalize(list->fptr);
io.c:    if (fptr->stdio_file) {
io.c:	status = pclose(fptr->stdio_file);
io.c:    fptr->fd = -1;
io.c:    fptr->stdio_file = 0;
io.c:    rb_last_status_set(status, fptr->pid);
io.c:    fptr->mode |= FMODE_SYNC;
io.c:    if (ret == -1) {
io.c:    if ((p->modef & FMODE_READABLE) && (p->modef & FMODE_WRITABLE)) {
io.c:        close(p->write_pair[1]);
io.c:        if (p->write_pair[0] != 0) {
io.c:            dup2(p->write_pair[0], 0);
io.c:            close(p->write_pair[0]);
io.c:        close(p->pair[0]);
io.c:        if (p->pair[1] != 1) {
io.c:            dup2(p->pair[1], 1);
io.c:            close(p->pair[1]);
io.c:    else if (p->modef & FMODE_READABLE) {
io.c:        close(p->pair[0]);
io.c:        if (p->pair[1] != 1) {
io.c:            dup2(p->pair[1], 1);
io.c:            close(p->pair[1]);
io.c:        close(p->pair[1]);
io.c:        if (p->pair[0] != 0) {
io.c:            dup2(p->pair[0], 0);
io.c:            close(p->pair[0]);
io.c:	if (ret != -1 && !(ret & FD_CLOEXEC)) {
io.c:    return rb_exec(p->execp);
io.c:    int fd = -1;
io.c:    int write_fd = -1;
io.c:        /* fork : IO.popen("-") */
io.c:    else if (eargp->argc) {
io.c:        argc = eargp->argc;
io.c:        argv = eargp->argv;
io.c:    arg.pair[0] = arg.pair[1] = -1;
io.c:    arg.write_pair[0] = arg.write_pair[1] = -1;
io.c:	pid = rb_fork(&status, popen_exec, &arg, arg.execp->redirect_fds);
io.c:	    rb_io_synchronized(RFILE(orig_stdout)->fptr);
io.c:	    rb_io_synchronized(RFILE(orig_stderr)->fptr);
io.c:    if (pid == -1) {
io.c:		   rb_w32_spawn(P_NOWAIT, cmd, 0))) == -1) {
io.c:    fptr->fd = fd;
io.c:    fptr->stdio_file = fp;
io.c:    fptr->mode = fmode | FMODE_SYNC|FMODE_DUPLEX;
io.c:        fptr->encs = *convconfig;
io.c:    fptr->pid = pid;
io.c:        write_fptr->fd = write_fd;
io.c:        write_fptr->mode = (fmode & ~FMODE_READABLE)| FMODE_SYNC|FMODE_DUPLEX;
io.c:        fptr->mode &= ~FMODE_WRITABLE;
io.c:        fptr->tied_io_for_writing = write_port;
io.c:    fptr->finalize = pipe_finalize;
io.c:    if (RSTRING_LEN(prog) == 1 && cmd[0] == '-') {
io.c:    last = argv[*argc_p-1];
io.c:    (*argc_p)--;
io.c: *  call-seq:
io.c: *  ``<code>-</code>'', then a new instance of Ruby is started as the
io.c: *    nkf_io = IO.popen("nkf -e filename", :external_encoding=>"EUC-JP")
io.c: *  If a block is given with a _cmd_ of ``<code>-</code>'',
io.c: *     IO.popen("-") {|f| $stderr.puts "#{Process.pid} is here, f is #{f}"}
io.c: *     IO.popen(%w"sed -e s|^|<foo>| -e s&$&;zot;&", "r+") {|f|
io.c:	RBASIC(tmp)->klass = 0;
io.c:    RBASIC(port)->klass = klass;
io.c: *  Document-method: File::open
io.c: *  call-seq:
io.c: *  Document-method: IO::open
io.c: *  call-seq:
io.c: *  call-seq:
io.c:        VALUE cmd = rb_str_new(s+chlen, l-chlen);
io.c: *  call-seq:
io.c: *  bitwise-or of open(2) flags, such as File::RDWR or File::EXCL.
io.c: *  The mode can be followed by "b" (means binary-mode), or "+"
io.c: *  is not ``<code>-</code>'', the subprocess runs the command. If a
io.c: *  block is associated with an <code>open("|-")</code> call, that block
io.c: *  will be run twice---once in the parent and once in the child. The
io.c: *     f = open("|-", "w+")
io.c: *     open("|-") do |f|
io.c:	VALUE io = rb_funcall2(argv[0], to_open, argc-1, argv+1);
io.c:        if ((fptr->stdio_file == stdin && !(orig->mode & FMODE_READABLE)) ||
io.c:            (fptr->stdio_file == stdout && !(orig->mode & FMODE_WRITABLE)) ||
io.c:            (fptr->stdio_file == stderr && !(orig->mode & FMODE_WRITABLE))) {
io.c:		     PREP_STDIO_NAME(fptr), rb_io_fmode_modestr(fptr->mode),
io.c:		     rb_io_fmode_modestr(orig->mode));
io.c:    if (orig->mode & FMODE_READABLE) {
io.c:    if (orig->mode & FMODE_WRITABLE) {
io.c:    if (fptr->mode & FMODE_WRITABLE) {
io.c:    fptr->mode = orig->mode | (fptr->mode & FMODE_PREP);
io.c:    fptr->pid = orig->pid;
io.c:    fptr->lineno = orig->lineno;
io.c:    if (RTEST(orig->pathv)) fptr->pathv = orig->pathv;
io.c:    else if (!IS_PREP_STDIO(fptr)) fptr->pathv = Qnil;
io.c:    fptr->finalize = orig->finalize;
io.c:    if (fptr->finalize == pipe_finalize)
io.c:    fd = fptr->fd;
io.c:    fd2 = orig->fd;
io.c:		rb_sys_fail_path(orig->pathv);
io.c:            if (fptr->stdio_file)
io.c:                fclose(fptr->stdio_file);
io.c:                close(fptr->fd);
io.c:            fptr->stdio_file = 0;
io.c:            fptr->fd = -1;
io.c:		rb_sys_fail_path(orig->pathv);
io.c:            fptr->fd = fd;
io.c:	if ((orig->mode & FMODE_READABLE) && pos >= 0) {
io.c:		rb_sys_fail_path(fptr->pathv);
io.c:		rb_sys_fail_path(orig->pathv);
io.c:    if (fptr->mode & FMODE_BINMODE) {
io.c:    RBASIC(io)->klass = rb_obj_class(nfile);
io.c: *  call-seq:
io.c:    fptr = RFILE(file)->fptr;
io.c:	fptr = RFILE(file)->fptr = ALLOC(rb_io_t);
io.c:            ((fptr->mode & FMODE_READWRITE) & (fmode & FMODE_READWRITE)) !=
io.c:            (fptr->mode & FMODE_READWRITE)) {
io.c:		     PREP_STDIO_NAME(fptr), rb_io_fmode_modestr(fptr->mode),
io.c:	fptr->mode = fmode;
io.c:        fptr->encs.ecflags = 0;
io.c:        fptr->encs.ecopts = Qnil;
io.c:    fptr->pathv = rb_str_new_frozen(fname);
io.c:    oflags = rb_io_fmode_oflags(fptr->mode);
io.c:    if (fptr->fd < 0) {
io.c:        fptr->fd = rb_sysopen(RSTRING_PTR(fptr->pathv), oflags, 0666);
io.c:	fptr->stdio_file = 0;
io.c:    if (fptr->mode & FMODE_WRITABLE) {
io.c:    fptr->rbuf_off = fptr->rbuf_len = 0;
io.c:    if (fptr->stdio_file) {
io.c:        if (freopen(RSTRING_PTR(fptr->pathv), rb_io_oflags_modestr(oflags), fptr->stdio_file) == 0) {
io.c:            rb_sys_fail_path(fptr->pathv);
io.c:        fptr->fd = fileno(fptr->stdio_file);
io.c:        if (setvbuf(fptr->stdio_file, NULL, _IOFBF, 0) != 0)
io.c:            rb_warn("setvbuf() can't be honoured for %s", RSTRING_PTR(fptr->pathv));
io.c:        if (close(fptr->fd) < 0)
io.c:            rb_sys_fail_path(fptr->pathv);
io.c:        fptr->fd = -1;
io.c:        fptr->fd = rb_sysopen(RSTRING_PTR(fptr->pathv), oflags, 0666);
io.c:    fptr->mode = orig->mode & ~FMODE_PREP;
io.c:    fptr->encs = orig->encs;
io.c:    fptr->pid = orig->pid;
io.c:    fptr->lineno = orig->lineno;
io.c:    if (!NIL_P(orig->pathv)) fptr->pathv = orig->pathv;
io.c:    fptr->finalize = orig->finalize;
io.c:    if (fptr->finalize == pipe_finalize)
io.c:    fd = ruby_dup(orig->fd);
io.c:    fptr->fd = fd;
io.c:    if (fptr->mode & FMODE_BINMODE) {
io.c:        fptr->tied_io_for_writing = write_io;
io.c: *  call-seq:
io.c: *  call-seq:
io.c:	argc--;
io.c: *  call-seq:
io.c: *  call-seq:
io.c: *  call-seq:
io.c: *  call-seq:
io.c: *  call-seq:
io.c:            RSTRING_PTR(line)[RSTRING_LEN(line)-1] != '\n') {
io.c: *  call-seq:
io.c: *  call-seq:
io.c: *  call-seq:
io.c:    if (rb_stderr == orig_stderr || RFILE(orig_stderr)->fptr->fd < 0) {
io.c:    fp->fd = fd;
io.c:    fp->mode = fmode;
io.c:    if (path) fp->pathv = rb_obj_freeze(rb_str_new_cstr(path));
io.c:    if (path && strcmp(path, "-")) klass = rb_cFile;
io.c:    fptr->stdio_file = f;
io.c:    if (!fptr->stdio_file) {
io.c:        int oflags = rb_io_fmode_oflags(fptr->mode);
io.c:        fptr->stdio_file = rb_fdopen(fptr->fd, rb_io_oflags_modestr(oflags));
io.c:    return fptr->stdio_file;
io.c: *  call-seq:
io.c: *  - "fmode",
io.c: *  - "fmode:extern",
io.c: *  - "fmode:extern:intern".
io.c: *    external encoding for the IO. "-" is a 
io.c: *    "-" is a synonym for the default internal encoding.
io.c: *     io = IO.new(2, mode: 'w:UTF-16LE', cr_newline: true)
io.c: *  both of aboves print "Hello, World!" in UTF-16LE to standard error output with 
io.c:    if (fstat(fd, &st) == -1) rb_sys_fail(0);
io.c:        if (oflags == -1) rb_sys_fail(0);
io.c:    fp->fd = fd;
io.c:    fp->mode = fmode;
io.c:    fp->encs = convconfig;
io.c:	fp->stdio_file = stdin;
io.c:	fp->stdio_file = stdout;
io.c:	fp->stdio_file = stderr;
io.c: *  call-seq:
io.c: *  by _or_-ing together the flags (O_RDONLY etc, 
io.c:    if (RFILE(io)->fptr) {
io.c: *  call-seq:
io.c:    rb_gc_mark(p->filename);
io.c:    rb_gc_mark(p->current_file);
io.c:    rb_gc_mark(p->argv);
io.c:    rb_gc_mark(p->encs.ecopts);
io.c:    free(p->inplace);
io.c:    p->filename = Qnil;
io.c:    p->current_file = Qnil;
io.c:    p->lineno = 0;
io.c:    p->argv = v;
io.c:        if (fptr->mode & FMODE_BINMODE)
io.c:	    ARGF.next_p = -1;
io.c:	    if (strlen(fn) == 1 && fn[0] == '-') {
io.c:		fptr->encs = ARGF.encs;
io.c:    else if (ARGF.next_p == -1) {
io.c:	ARGF.filename = rb_str_new2("-");
io.c:	if (NIL_P(line) && ARGF.next_p != -1) {
io.c: *  call-seq:
io.c: *  of +nil+ reads the entire contents, and a zero-length separator
io.c:    if (NIL_P(line) && ARGF.next_p != -1) {
io.c: *  call-seq:
io.c: *  call-seq:
io.c: *  call-seq:
io.c: *  The built-in syntax <code>%x{...}</code> uses
io.c:	    rb_fd_set(fptr->fd, &fds[0]);
io.c:		rb_fd_set(fptr->fd, &fds[3]);
io.c:	    if (max < fptr->fd) max = fptr->fd;
io.c:	    rb_fd_set(fptr->fd, &fds[1]);
io.c:	    if (max < fptr->fd) max = fptr->fd;
io.c:	    rb_fd_set(fptr->fd, &fds[2]);
io.c:	    if (max < fptr->fd) max = fptr->fd;
io.c:                rb_fd_set(fptr->fd, &fds[2]);
io.c:                if (max < fptr->fd) max = fptr->fd;
io.c:		if (rb_fd_isset(fptr->fd, &fds[0]) ||
io.c:		    rb_fd_isset(fptr->fd, &fds[3])) {
io.c:		if (rb_fd_isset(fptr->fd, &fds[1])) {
io.c:		if (rb_fd_isset(fptr->fd, &fds[2])) {
io.c:                    if (rb_fd_isset(fptr->fd, &fds[2])) {
io.c:    return select_internal(p->read, p->write, p->except, p->timeout, p->fdsets);
io.c:    for (i = 0; i < sizeof(p->fdsets) / sizeof(p->fdsets[0]); ++i)
io.c:	rb_fd_term(&p->fdsets[i]);
io.c: *  call-seq:
io.c:    retval = io_cntl(fptr->fd, cmd, narg, io_p);
io.c:    if (retval < 0) rb_sys_fail_path(fptr->pathv);
io.c:        fptr->mode |= FMODE_WSPLIT_INITIALIZED;
io.c:        fptr->mode &= ~FMODE_WSPLIT;
io.c:        fptr->mode &= ~(FMODE_WSPLIT_INITIALIZED|FMODE_WSPLIT);
io.c: *  call-seq:
io.c: *  Provides a mechanism for issuing low-level commands to control or
io.c: *  call-seq:
io.c: *  Provides a mechanism for issuing low-level commands to control or
io.c: *  query file-oriented I/O streams. Arguments and results are platform
io.c: *  call-seq:
io.c: *  on the Atari-ST). The function identified by _fixnum_ is system
io.c:    int retval = -1;
io.c:    int items = argc - 1;
io.c:    while (items--) {
io.c:	    if (*p == '-' && *(p+1) == '\0') {
io.c:		/* Special case - "-" => no transcoding */
io.c:		/* Special case - "-" => no transcoding */
io.c:    validate_enc_binmode(fptr->mode, enc, enc2);
io.c:    fptr->encs.enc = enc;
io.c:    fptr->encs.enc2 = enc2;
io.c:    fptr->encs.ecflags = ecflags;
io.c:    fptr->encs.ecopts = ecopts;
io.c: *  call-seq:
io.c: *     IO.pipe                            -> [read_io, write_io]
io.c: *     IO.pipe(ext_enc)                   -> [read_io, write_io]
io.c: *     IO.pipe("ext_enc:int_enc" [, opt]) -> [read_io, write_io]
io.c: *     IO.pipe(ext_enc, int_enc [, opt])  -> [read_io, write_io]
io.c: *  returns them as a two-element array of <code>IO</code> objects:
io.c:    if (rb_pipe(pipes) == -1)
io.c:    fptr->mode |= fmode;
io.c:    fptr2->mode |= fmode;
io.c:    arg->io = 0;
io.c:    arg->argc = argc - 1;
io.c:    arg->argv = argv + 1;
io.c:	arg->io = rb_io_open(argv[0], INT2NUM(O_RDONLY), INT2FIX(0666), Qnil);
io.c:    opt = pop_last_hash(&arg->argc, arg->argv);
io.c:	arg->io = rb_io_open_with_args(RARRAY_LEN(args), RARRAY_PTR(args));
io.c:    arg->io = rb_io_open(argv[0], Qnil, Qnil, opt);
io.c:    while (!NIL_P(str = rb_io_gets_m(arg->argc, arg->argv, arg->io))) {
io.c: *  call-seq:
io.c:    return rb_io_readlines(arg->argc, arg->argv, arg->io);
io.c: *  call-seq:
io.c:    return io_read(arg->argc, arg->argv, arg->io);
io.c: *  call-seq:
io.c: *  call-seq:
io.c: *  The open mode would be "rb:ASCII-8BIT".
io.c:    arg.io = rb_io_open(argv[0], rb_str_new_cstr("rb:ASCII-8BIT"), Qnil, Qnil);
io.c:    off_t copy_length; /* (off_t)-1 if not specified */
io.c:    off_t src_offset; /* (off_t)-1 if not specified */
io.c:    rb_fd_zero(&stp->fds);
io.c:    rb_fd_set(stp->src_fd, &stp->fds);
io.c:    ret = rb_fd_select(rb_fd_max(&stp->fds), &stp->fds, NULL, NULL, NULL);
io.c:    if (ret == -1) {
io.c:        stp->syserr = "select";
io.c:        stp->error_no = errno;
io.c:        return -1;
io.c:    rb_fd_zero(&stp->fds);
io.c:    rb_fd_set(stp->dst_fd, &stp->fds);
io.c:    ret = rb_fd_select(rb_fd_max(&stp->fds), NULL, &stp->fds, NULL, NULL);
io.c:    if (ret == -1) {
io.c:        stp->syserr = "select";
io.c:        stp->error_no = errno;
io.c:        return -1;
io.c:    ret = fstat(stp->src_fd, &src_stat);
io.c:    if (ret == -1) {
io.c:        stp->syserr = "fstat";
io.c:        stp->error_no = errno;
io.c:        return -1;
io.c:    ret = fstat(stp->dst_fd, &dst_stat);
io.c:    if (ret == -1) {
io.c:        stp->syserr = "fstat";
io.c:        stp->error_no = errno;
io.c:        return -1;
io.c:    src_offset = stp->src_offset;
io.c:    use_pread = src_offset != (off_t)-1;
io.c:    copy_length = stp->copy_length;
io.c:    if (copy_length == (off_t)-1) {
io.c:            copy_length = src_stat.st_size - src_offset;
io.c:            off_t cur = lseek(stp->src_fd, 0, SEEK_CUR);
io.c:            if (cur == (off_t)-1) {
io.c:                stp->syserr = "lseek";
io.c:                stp->error_no = errno;
io.c:                return -1;
io.c:            copy_length = src_stat.st_size - cur;
io.c:        ss = simple_sendfile(stp->dst_fd, stp->src_fd, &src_offset, copy_length);
io.c:        ss = simple_sendfile(stp->dst_fd, stp->src_fd, NULL, copy_length);
io.c:        stp->total += ss;
io.c:        copy_length -= ss;
io.c:            ss = -1;
io.c:    if (ss == -1) {
io.c:            if (nogvl_copy_stream_wait_write(stp) == -1)
io.c:                return -1;
io.c:            if (rb_thread_interrupted(stp->th))
io.c:                return -1;
io.c:        stp->syserr = "sendfile";
io.c:        stp->error_no = errno;
io.c:        return -1;
io.c:    if (offset == (off_t)-1)
io.c:        ss = read(stp->src_fd, buf, len);
io.c:        ss = pread(stp->src_fd, buf, len, offset);
io.c:        stp->notimp = "pread";
io.c:        return -1;
io.c:    if (ss == -1) {
io.c:            if (maygvl_copy_stream_wait_read(stp) == -1)
io.c:                return -1;
io.c:            stp->notimp = "pread";
io.c:            return -1;
io.c:        stp->syserr = offset == (off_t)-1 ?  "read" : "pread";
io.c:        stp->error_no = errno;
io.c:        return -1;
io.c:        ss = write(stp->dst_fd, buf+off, len);
io.c:        if (ss == -1) {
io.c:                if (nogvl_copy_stream_wait_write(stp) == -1)
io.c:                    return -1;
io.c:            stp->syserr = "write";
io.c:            stp->error_no = errno;
io.c:            return -1;
io.c:        len -= ss;
io.c:        stp->total += ss;
io.c:    copy_length = stp->copy_length;
io.c:    use_eof = copy_length == (off_t)-1;
io.c:    src_offset = stp->src_offset;
io.c:    use_pread = src_offset != (off_t)-1;
io.c:    if (use_pread && stp->close_src) {
io.c:        r = lseek(stp->src_fd, src_offset, SEEK_SET);
io.c:        if (r == (off_t)-1) {
io.c:            stp->syserr = "lseek";
io.c:            stp->error_no = errno;
io.c:        src_offset = (off_t)-1;
io.c:            ss = maygvl_copy_stream_read(stp, buf, len, (off_t)-1);
io.c:            copy_length -= ss;
io.c:        if (rb_thread_interrupted(stp->th))
io.c:    off_t rest = stp->copy_length;
io.c:    off_t off = stp->src_offset;
io.c:    if (stp->src_fd == -1) {
io.c:	if (!rb_respond_to(stp->src, read_method)) {
io.c:        if (stp->copy_length == (off_t)-1) {
io.c:        if (stp->src_fd == -1) {
io.c:            rb_funcall(stp->src, read_method, 2, INT2FIX(l), buf);
io.c:            rb_thread_wait_fd(stp->src_fd);
io.c:            if (ss == -1)
io.c:            if (off != (off_t)-1)
io.c:        n = rb_io_write(stp->dst, buf);
io.c:        stp->total += numwrote;
io.c:        rest -= numwrote;
io.c:    if (stp->src_fd == -1 && stp->src_offset != (off_t)-1) {
io.c:	rb_raise(rb_eArgError, "cannot specify src_offset for non-IO");
io.c:    stp->th = rb_thread_current();
io.c:    stp->total = 0;
io.c:    if (stp->src == argf ||
io.c:        !(TYPE(stp->src) == T_FILE ||
io.c:          TYPE(stp->src) == T_STRING ||
io.c:          rb_respond_to(stp->src, rb_intern("to_path")))) {
io.c:        src_fd = -1;
io.c:        src_io = TYPE(stp->src) == T_FILE ? stp->src : Qnil;
io.c:            FilePathValue(stp->src);
io.c:            args[0] = stp->src;
io.c:            stp->src = src_io;
io.c:            stp->close_src = 1;
io.c:        src_fd = src_fptr->fd;
io.c:    stp->src_fd = src_fd;
io.c:    if (stp->dst == argf ||
io.c:        !(TYPE(stp->dst) == T_FILE ||
io.c:          TYPE(stp->dst) == T_STRING ||
io.c:          rb_respond_to(stp->dst, rb_intern("to_path")))) {
io.c:        dst_fd = -1;
io.c:        dst_io = TYPE(stp->dst) == T_FILE ? stp->dst : Qnil;
io.c:            FilePathValue(stp->dst);
io.c:            args[0] = stp->dst;
io.c:            stp->dst = dst_io;
io.c:            stp->close_dst = 1;
io.c:            stp->dst = dst_io;
io.c:        dst_fd = dst_fptr->fd;
io.c:    stp->dst_fd = dst_fd;
io.c:    if (stp->src_offset == (off_t)-1 && src_fptr && src_fptr->rbuf_len) {
io.c:        long len = src_fptr->rbuf_len;
io.c:        if (stp->copy_length != (off_t)-1 && stp->copy_length < len) {
io.c:            len = stp->copy_length;
io.c:            rb_io_write(stp->dst, str);
io.c:        stp->total += len;
io.c:        if (stp->copy_length != (off_t)-1)
io.c:            stp->copy_length -= len;
io.c:    if (stp->copy_length == 0)
io.c:    if (src_fd == -1 || dst_fd == -1) {
io.c:    rb_fd_init(&stp->fds);
io.c:    rb_fd_set(src_fd, &stp->fds);
io.c:    rb_fd_set(dst_fd, &stp->fds);
io.c:    if (stp->close_src) {
io.c:        rb_io_close_m(stp->src);
io.c:    if (stp->close_dst) {
io.c:        rb_io_close_m(stp->dst);
io.c:    rb_fd_term(&stp->fds);
io.c:    if (stp->syserr) {
io.c:        errno = stp->error_no;
io.c:        rb_sys_fail(stp->syserr);
io.c:    if (stp->notimp) {
io.c:	rb_raise(rb_eNotImpError, "%s() not implemented", stp->notimp);
io.c: *  call-seq:
io.c:        st.copy_length = (off_t)-1;
io.c:        st.src_offset = (off_t)-1;
io.c: *  call-seq:
io.c:    if (fptr->encs.enc2) {
io.c:	return rb_enc_from_encoding(fptr->encs.enc2);
io.c:    if (fptr->mode & FMODE_WRITABLE) {
io.c:	if (fptr->encs.enc)
io.c:	    return rb_enc_from_encoding(fptr->encs.enc);
io.c: *  call-seq:
io.c:    if (!fptr->encs.enc2) return Qnil;
io.c: *  call-seq:
io.c:    ARGF.encs = fptr->encs;
io.c:	if (ARGF.next_p != -1) {
io.c:	    len -= RSTRING_LEN(str);
io.c:    argf_forward(p->argc, p->argv, p->argf);
io.c:        if (ARGF.next_p == -1) {
io.c:    if (NIL_P(ch) && ARGF.next_p != -1) {
io.c:    if (NIL_P(ch) && ARGF.next_p != -1) {
io.c:    if (NIL_P(ch) && ARGF.next_p != -1) {
io.c:    if (ARGF.next_p != -1) {
io.c: *  * A string equal to ``<code>|-</code>'' will create another Ruby
io.c: *  Windows-style filename in a Ruby string, remember to escape the
io.c: *  Our examples here will use the Unix-style forward slashes;
io.c: *  platform-specific separator character.
io.c: *    -----+--------------------------------------------------------
io.c: *    "r"  |  Read-only, starts at beginning of file  (default mode).
io.c: *    -----+--------------------------------------------------------
io.c: *    "r+" |  Read-write, starts at beginning of file.
io.c: *    -----+--------------------------------------------------------
io.c: *    "w"  |  Write-only, truncates existing file
io.c: *    -----+--------------------------------------------------------
io.c: *    "w+" |  Read-write, truncates existing file to zero length
io.c: *    -----+--------------------------------------------------------
io.c: *    "a"  |  Write-only, starts at end of file if file exists,
io.c: *    -----+--------------------------------------------------------
io.c: *    "a+" |  Read-write, starts at end of file if file exists,
io.c: *    -----+--------------------------------------------------------
io.c: *         |  Suppresses EOL <-> CRLF conversion on Windows. And
io.c: *         |  sets external encoding to ASCII-8BIT unless explicitly
io.c: *    -----+--------------------------------------------------------
io.c: *  IO-like stream which allows access to all files mentioned on the
io.c:    rb_define_global_function("syscall", rb_f_syscall, -1);
io.c:    rb_define_global_function("open", rb_f_open, -1);
io.c:    rb_define_global_function("printf", rb_f_printf, -1);
io.c:    rb_define_global_function("print", rb_f_print, -1);
io.c:    rb_define_global_function("puts", rb_f_puts, -1);
io.c:    rb_define_global_function("gets", rb_f_gets, -1);
io.c:    rb_define_global_function("readline", rb_f_readline, -1);
io.c:    rb_define_global_function("select", rb_f_select, -1);
io.c:    rb_define_global_function("readlines", rb_f_readlines, -1);
io.c:    rb_define_global_function("p", rb_f_p, -1);
io.c:    rb_define_method(rb_mKernel, "display", rb_obj_display, -1);
io.c:    rb_define_singleton_method(rb_cFile, "open",  rb_io_s_open, -1);
io.c:    rb_define_singleton_method(rb_cIO, "new", rb_io_s_new, -1);
io.c:    rb_define_singleton_method(rb_cIO, "open",  rb_io_s_open, -1);
io.c:    rb_define_singleton_method(rb_cIO, "sysopen",  rb_io_s_sysopen, -1);
io.c:    rb_define_singleton_method(rb_cIO, "for_fd", rb_io_s_for_fd, -1);
io.c:    rb_define_singleton_method(rb_cIO, "popen", rb_io_s_popen, -1);
io.c:    rb_define_singleton_method(rb_cIO, "foreach", rb_io_s_foreach, -1);
io.c:    rb_define_singleton_method(rb_cIO, "readlines", rb_io_s_readlines, -1);
io.c:    rb_define_singleton_method(rb_cIO, "read", rb_io_s_read, -1);
io.c:    rb_define_singleton_method(rb_cIO, "binread", rb_io_s_binread, -1);
io.c:    rb_define_singleton_method(rb_cIO, "select", rb_f_select, -1);
io.c:    rb_define_singleton_method(rb_cIO, "pipe", rb_io_s_pipe, -1);
io.c:    rb_define_singleton_method(rb_cIO, "copy_stream", rb_io_s_copy_stream, -1);
io.c:    rb_define_method(rb_cIO, "initialize", rb_io_initialize, -1);
io.c:    rb_define_hooked_variable("$-0", &rb_rs, 0, rb_str_setter);
io.c:    rb_define_method(rb_cIO, "reopen", rb_io_reopen, -1);
io.c:    rb_define_method(rb_cIO, "print", rb_io_print, -1);
io.c:    rb_define_method(rb_cIO, "puts", rb_io_puts, -1);
io.c:    rb_define_method(rb_cIO, "printf", rb_io_printf, -1);
io.c:    rb_define_method(rb_cIO, "each",  rb_io_each_line, -1);
io.c:    rb_define_method(rb_cIO, "each_line",  rb_io_each_line, -1);
io.c:    rb_define_method(rb_cIO, "lines",  rb_io_lines, -1);
io.c:    rb_define_method(rb_cIO, "sysread",  rb_io_sysread, -1);
io.c:    rb_define_method(rb_cIO, "readlines",  rb_io_readlines, -1);
io.c:    rb_define_method(rb_cIO, "read_nonblock",  io_read_nonblock, -1);
io.c:    rb_define_method(rb_cIO, "readpartial",  io_readpartial, -1);
io.c:    rb_define_method(rb_cIO, "read",  io_read, -1);
io.c:    rb_define_method(rb_cIO, "gets",  rb_io_gets_m, -1);
io.c:    rb_define_method(rb_cIO, "readline",  rb_io_readline, -1);
io.c:    rb_define_method(rb_cIO, "seek", rb_io_seek_m, -1);
io.c:    rb_define_method(rb_cIO, "sysseek", rb_io_sysseek, -1);
io.c:    rb_define_method(rb_cIO, "ioctl", rb_io_ioctl, -1);
io.c:    rb_define_method(rb_cIO, "fcntl", rb_io_fcntl, -1);
io.c:    rb_define_method(rb_cIO, "set_encoding", rb_io_set_encoding, -1);
io.c:    rb_define_method(rb_cARGF, "initialize", argf_initialize, -2);
io.c:    rb_define_method(rb_cARGF, "each",  argf_each_line, -1);
io.c:    rb_define_method(rb_cARGF, "each_line",  argf_each_line, -1);
io.c:    rb_define_method(rb_cARGF, "lines", argf_each_line, -1);
io.c:    rb_define_method(rb_cARGF, "read",  argf_read, -1);
io.c:    rb_define_method(rb_cARGF, "readpartial",  argf_readpartial, -1);
io.c:    rb_define_method(rb_cARGF, "readlines", argf_readlines, -1);
io.c:    rb_define_method(rb_cARGF, "to_a", argf_readlines, -1);
io.c:    rb_define_method(rb_cARGF, "gets", argf_gets, -1);
io.c:    rb_define_method(rb_cARGF, "readline", argf_readline, -1);
io.c:    rb_define_method(rb_cARGF, "seek", argf_seek_m, -1);
io.c:    rb_define_method(rb_cARGF, "set_encoding", argf_set_encoding, -1);
io.c:    ARGF.filename = rb_str_new2("-");
io.c:    rb_define_hooked_variable("$-i", &argf, opt_i_get, opt_i_set);
io.c:    rb_define_method(rb_cFile, "initialize",  rb_file_initialize, -1);
ãã¤ããªã¼ã»ãã¡ã¤ã«io.oã¯ä¸è´ãã¾ãã
iseq.c:  iseq.c -
iseq.c:  created at: 2006-07-11(Tue) 09:00:03 +0900
iseq.c:#define hidden_obj_p(obj) (!SPECIAL_CONST_P(obj) && !RBASIC(obj)->klass)
iseq.c:	cur = compile_data->storage_head;
iseq.c:	    next = cur->next;
iseq.c:	if (!iseq->orig) {
iseq.c:	     * GC_INFO("%s @ %s\n", RSTRING_PTR(iseq->name),
iseq.c:	     *                      RSTRING_PTR(iseq->filename));
iseq.c:	    if (iseq->iseq != iseq->iseq_encoded) {
iseq.c:		RUBY_FREE_UNLESS_NULL(iseq->iseq_encoded);
iseq.c:	    RUBY_FREE_UNLESS_NULL(iseq->iseq);
iseq.c:	    RUBY_FREE_UNLESS_NULL(iseq->insn_info_table);
iseq.c:	    RUBY_FREE_UNLESS_NULL(iseq->local_table);
iseq.c:	    RUBY_FREE_UNLESS_NULL(iseq->catch_table);
iseq.c:	    RUBY_FREE_UNLESS_NULL(iseq->arg_opt_table);
iseq.c:	    compile_data_free(iseq->compile_data);
iseq.c:	RUBY_GC_INFO("%s @ %s\n", RSTRING_PTR(iseq->name), RSTRING_PTR(iseq->filename));
iseq.c:	RUBY_MARK_UNLESS_NULL(iseq->mark_ary);
iseq.c:	RUBY_MARK_UNLESS_NULL(iseq->name);
iseq.c:	RUBY_MARK_UNLESS_NULL(iseq->filename);
iseq.c:	RUBY_MARK_UNLESS_NULL((VALUE)iseq->cref_stack);
iseq.c:	RUBY_MARK_UNLESS_NULL(iseq->klass);
iseq.c:	RUBY_MARK_UNLESS_NULL(iseq->coverage);
iseq.c:/* 	RUBY_MARK_UNLESS_NULL((VALUE)iseq->node); */
iseq.c:/*	RUBY_MARK_UNLESS_NULL(iseq->cached_special_block); */
iseq.c:	RUBY_MARK_UNLESS_NULL(iseq->orig);
iseq.c:	if (iseq->compile_data != 0) {
iseq.c:	    RUBY_MARK_UNLESS_NULL(iseq->compile_data->mark_ary);
iseq.c:	    RUBY_MARK_UNLESS_NULL(iseq->compile_data->err_info);
iseq.c:	    RUBY_MARK_UNLESS_NULL(iseq->compile_data->catch_table_ary);
iseq.c:    const int type = iseq->type;
iseq.c:	iseq->cref_stack = NEW_BLOCK(th->top_wrapper ? th->top_wrapper : rb_cObject);
iseq.c:	iseq->cref_stack->nd_file = 0;
iseq.c:	iseq->cref_stack->nd_visi = NOEX_PRIVATE;
iseq.c:	iseq->cref_stack = NEW_BLOCK(0); /* place holder */
iseq.c:	iseq->cref_stack->nd_file = 0;
iseq.c:	iseq->cref_stack = piseq->cref_stack;
iseq.c:	iseq->local_iseq = iseq;
iseq.c:	iseq->local_iseq = piseq->local_iseq;
iseq.c:	iseq->parent_iseq = piseq;
iseq.c:    iseq->name = name;
iseq.c:    iseq->filename = filename;
iseq.c:    iseq->defined_method_id = 0;
iseq.c:    iseq->mark_ary = rb_ary_new();
iseq.c:    RBASIC(iseq->mark_ary)->klass = 0;
iseq.c:    iseq->type = type;
iseq.c:    iseq->arg_rest = -1;
iseq.c:    iseq->arg_block = -1;
iseq.c:    iseq->klass = 0;
iseq.c:     * iseq->special_block_builder = GC_GUARDED_PTR_REF(block_opt);
iseq.c:     * iseq->cached_special_block_builder = 0;
iseq.c:     * iseq->cached_special_block = 0;
iseq.c:    iseq->compile_data = ALLOC(struct iseq_compile_data);
iseq.c:    MEMZERO(iseq->compile_data, struct iseq_compile_data, 1);
iseq.c:    iseq->compile_data->mark_ary = rb_ary_new();
iseq.c:    RBASIC(iseq->compile_data->mark_ary)->klass = 0;
iseq.c:    iseq->compile_data->storage_head = iseq->compile_data->storage_current =
iseq.c:    iseq->compile_data->catch_table_ary = rb_ary_new();
iseq.c:    iseq->compile_data->storage_head->pos = 0;
iseq.c:    iseq->compile_data->storage_head->next = 0;
iseq.c:    iseq->compile_data->storage_head->size =
iseq.c:    iseq->compile_data->storage_head->buff =
iseq.c:      (char *)(&iseq->compile_data->storage_head->buff + 1);
iseq.c:    iseq->compile_data->option = option;
iseq.c:    iseq->coverage = Qfalse;
iseq.c:    if (!GET_THREAD()->parse_in_eval) {
iseq.c:	    iseq->coverage = rb_hash_lookup(coverages, filename);
iseq.c:	    if (NIL_P(iseq->coverage)) iseq->coverage = Qfalse;
iseq.c:    struct iseq_compile_data *data = iseq->compile_data;
iseq.c:    VALUE err = data->err_info;
iseq.c:    iseq->compile_data = 0;
iseq.c:	rb_funcall2(err, rb_intern("set_backtrace"), 1, &iseq->filename);
iseq.c:      if (flag == Qtrue)  { o->mem = 1; } \
iseq.c:      else if (flag == Qfalse)  { o->mem = 0; } \
iseq.c:      if (!NIL_P(num)) o->mem = NUM2INT(num); \
iseq.c:  rb_hash_aset(h, ID2SYM(rb_intern(#mem)), o->mem ? Qtrue : Qfalse)
iseq.c:  rb_hash_aset(h, ID2SYM(rb_intern(#mem)), INT2NUM(o->mem))
iseq.c:    VALUE parent = th->base_block->iseq->self;
iseq.c:    iseq->self = self;
iseq.c:    iseq->self = iseqval;
iseq.c:	rb_exc_raise(GET_THREAD()->errinfo);	/* TODO: check err */
iseq.c:    if (th->base_block && th->base_block->iseq) {
iseq.c:	return rb_iseq_new_with_opt(node, th->base_block->iseq->name,
iseq.c:				    file, th->base_block->iseq->self,
iseq.c:    if (!iseq->name) {
iseq.c:    if (!iseq->name) {
iseq.c:		      RSTRING_PTR(iseq->name), RSTRING_PTR(iseq->filename));
iseq.c:    return iseq->insn_info_table[0].line_no;
iseq.c:    unsigned long i, size = iseq->insn_info_size;
iseq.c:    struct iseq_insn_info_entry *table = iseq->insn_info_table;
iseq.c:	return entry->line_no;
iseq.c:    unsigned long i, size = iseqdat->insn_info_size;
iseq.c:    struct iseq_insn_info_entry *iiary = iseqdat->insn_info_table;
iseq.c:		return iiary[i - 1].line_no;
iseq.c:	    rb_iseq_t *ip = iseq->local_iseq;
iseq.c:	    int lidx = ip->local_size - op;
iseq.c:	    const char *name = rb_id2name(ip->local_table[lidx]);
iseq.c:		ip = ip->parent_iseq;
iseq.c:	    name = rb_id2name(ip->local_table[ip->local_size - op]);
iseq.c:		ret = iseq->name;
iseq.c:		    rb_ary_push(child, iseq->self);
iseq.c:	    ret = rb_str_dup(rb_id2str(entry->id));
iseq.c: * Iseq -> Iseq inspect object
iseq.c:	rb_str_catf(str, "%04d %-16s ", pos, insn_name_buff);
iseq.c:	rb_str_catf(str, "%04d %-16.*s ", pos,
iseq.c:	    slen = (slen > 70) ? 0 : (70 - slen);
iseq.c:	slen = (slen > 60) ? 0 : (60 - slen);
iseq.c:			  (int)slen, "", entry->line_no, entry->sp);
iseq.c:    iseq = iseqdat->iseq;
iseq.c:    size = iseqdat->iseq_size;
iseq.c:    rb_str_concat(str, iseq_inspect(iseqdat->self));
iseq.c:	memset(RSTRING_PTR(str) + l, '=', header_minlen - l);
iseq.c:    if (iseqdat->catch_table_size != 0) {
iseq.c:    for (i = 0; i < iseqdat->catch_table_size; i++) {
iseq.c:	struct iseq_catch_table_entry *entry = &iseqdat->catch_table[i];
iseq.c:		    "| catch type: %-6s st: %04d ed: %04d sp: %04d cont: %04d\n",
iseq.c:		    catch_type((int)entry->type), (int)entry->start,
iseq.c:		    (int)entry->end, (int)entry->sp, (int)entry->cont);
iseq.c:	if (entry->iseq) {
iseq.c:	    rb_str_concat(str, rb_iseq_disasm(entry->iseq));
iseq.c:    if (iseqdat->catch_table_size != 0) {
iseq.c:	rb_str_cat2(str, "|-------------------------------------"
iseq.c:		    "-----------------------------------\n");
iseq.c:    tbl = iseqdat->local_table;
iseq.c:		    iseqdat->local_size, iseqdat->argc,
iseq.c:		    iseqdat->arg_opts, iseqdat->arg_rest,
iseq.c:		    iseqdat->arg_post_len, iseqdat->arg_block,
iseq.c:		    iseqdat->arg_simple);
iseq.c:	for (i = 0; i < iseqdat->local_table_size; i++) {
iseq.c:	    if (iseqdat->arg_opts) {
iseq.c:		int argc = iseqdat->argc;
iseq.c:		int opts = iseqdat->arg_opts;
iseq.c:		if (i >= argc && i < argc + opts - 1) {
iseq.c:			     iseqdat->arg_opt_table[i - argc]);
iseq.c:		     iseqdat->argc > i ? "Arg" : "",
iseq.c:		     iseqdat->arg_rest == i ? "Rest" : "",
iseq.c:		     (iseqdat->arg_post_start <= i &&
iseq.c:		      i < iseqdat->arg_post_start + iseqdat->arg_post_len) ? "Post" : "",
iseq.c:		     iseqdat->arg_block == i ? "Block" : "");
iseq.c:	    rb_str_catf(str, "[%2d] %-11s", iseqdat->local_size - i, info);
iseq.c: 	    VALUE iseqval = (VALUE)node->nd_body;
iseq.c:    switch(iseq->type) {
iseq.c:    for (i=0; i<iseq->local_table_size; i++) {
iseq.c:	ID lid = iseq->local_table[i];
iseq.c:	for (j=0; j<iseq->arg_opts; j++) {
iseq.c:			register_label(labels_table, iseq->arg_opt_table[j]));
iseq.c:	if (iseq->arg_simple == 1) {
iseq.c:	    args = INT2FIX(iseq->argc);
iseq.c:	    rb_ary_push(args, INT2FIX(iseq->argc));
iseq.c:	    rb_ary_push(args, INT2FIX(iseq->arg_post_len));
iseq.c:	    rb_ary_push(args, INT2FIX(iseq->arg_post_start));
iseq.c:	    rb_ary_push(args, INT2FIX(iseq->arg_rest));
iseq.c:	    rb_ary_push(args, INT2FIX(iseq->arg_block));
iseq.c:	    rb_ary_push(args, INT2FIX(iseq->arg_simple));
iseq.c:    for (seq = iseq->iseq; seq < iseq->iseq + iseq->iseq_size; ) {
iseq.c:	VALUE *nseq = seq + len - 1;
iseq.c:	for (j=0; j<len-1; j++, seq++) {
iseq.c:		unsigned int idx = nseq - iseq->iseq + *seq;
iseq.c:		    rb_ary_push(ary, ID2SYM(entry->id));
iseq.c:			unsigned int idx = nseq - iseq->iseq + pos;
iseq.c:    for (i=0; i<iseq->catch_table_size; i++) {
iseq.c:	struct iseq_catch_table_entry *entry = &iseq->catch_table[i];
iseq.c:	rb_ary_push(ary, exception_type2symbol(entry->type));
iseq.c:	if (entry->iseq) {
iseq.c:	    GetISeqPtr(entry->iseq, eiseq);
iseq.c:	rb_ary_push(ary, register_label(labels_table, entry->start));
iseq.c:	rb_ary_push(ary, register_label(labels_table, entry->end));
iseq.c:	rb_ary_push(ary, register_label(labels_table, entry->cont));
iseq.c:	rb_ary_push(ary, INT2FIX(entry->sp));
iseq.c:	if (iseq->insn_info_table[i].line_no != line) {
iseq.c:	    line = iseq->insn_info_table[i].line_no;
iseq.c:    rb_hash_aset(misc, ID2SYM(rb_intern("arg_size")), INT2FIX(iseq->arg_size));
iseq.c:    rb_hash_aset(misc, ID2SYM(rb_intern("local_size")), INT2FIX(iseq->local_size));
iseq.c:    rb_hash_aset(misc, ID2SYM(rb_intern("stack_max")), INT2FIX(iseq->stack_max));
iseq.c:    rb_ary_push(val, iseq->name);
iseq.c:    rb_ary_push(val, iseq->filename);
iseq.c:    iseq1->self = newiseq;
iseq.c:    if (!iseq1->orig) {
iseq.c:	iseq1->orig = iseqval;
iseq.c:	iseq1->cref_stack = NEW_BLOCK(newcbase);
iseq.c:	if (iseq0->cref_stack->nd_next) {
iseq.c:	    iseq1->cref_stack->nd_next = iseq0->cref_stack->nd_next;
iseq.c:    iseq->name = rb_str_new2(name);
iseq.c:    iseq->filename = rb_str_new2(filename);
iseq.c:    iseq->mark_ary = rb_ary_new();
iseq.c:    iseq->self = iseqval;
iseq.c:    iseq->iseq = ALLOC_N(VALUE, iseq->iseq_size);
iseq.c:    for (i=0; i<iseq->iseq_size; i+=2) {
iseq.c:	iseq->iseq[i] = BIN(opt_call_c_function);
iseq.c:	iseq->iseq[i+1] = (VALUE)func;
iseq.c:    ALLOC_AND_COPY(iseq->insn_info_table, insn_info_table,
iseq.c:		   struct iseq_insn_info_entry, iseq->insn_info_size);
iseq.c:    ALLOC_AND_COPY(iseq->catch_table, catch_table,
iseq.c:		   struct iseq_catch_table_entry, iseq->catch_table_size);
iseq.c:    ALLOC_AND_COPY(iseq->arg_opt_table, arg_opt_table,
iseq.c:		   VALUE, iseq->arg_opts);
iseq.c:    /* rb_define_singleton_method(rb_cISeq, "load", iseq_s_load, -1); */
iseq.c:    rb_define_singleton_method(rb_cISeq, "compile", iseq_s_compile, -1);
iseq.c:    rb_define_singleton_method(rb_cISeq, "new", iseq_s_compile, -1);
iseq.c:    rb_define_singleton_method(rb_cISeq, "compile_file", iseq_s_compile_file, -1);
iseq.c~:  iseq.c -
iseq.c~:  created at: 2006-07-11(Tue) 09:00:03 +0900
iseq.c~:#define hidden_obj_p(obj) (!SPECIAL_CONST_P(obj) && !RBASIC(obj)->klass)
iseq.c~:	cur = compile_data->storage_head;
iseq.c~:	    next = cur->next;
iseq.c~:	if (!iseq->orig) {
iseq.c~:	     * GC_INFO("%s @ %s\n", RSTRING_PTR(iseq->name),
iseq.c~:	     *                      RSTRING_PTR(iseq->filename));
iseq.c~:	    if (iseq->iseq != iseq->iseq_encoded) {
iseq.c~:		RUBY_FREE_UNLESS_NULL(iseq->iseq_encoded);
iseq.c~:	    RUBY_FREE_UNLESS_NULL(iseq->iseq);
iseq.c~:	    RUBY_FREE_UNLESS_NULL(iseq->insn_info_table);
iseq.c~:	    RUBY_FREE_UNLESS_NULL(iseq->local_table);
iseq.c~:	    RUBY_FREE_UNLESS_NULL(iseq->catch_table);
iseq.c~:	    RUBY_FREE_UNLESS_NULL(iseq->arg_opt_table);
iseq.c~:	    compile_data_free(iseq->compile_data);
iseq.c~:	RUBY_GC_INFO("%s @ %s\n", RSTRING_PTR(iseq->name), RSTRING_PTR(iseq->filename));
iseq.c~:	RUBY_MARK_UNLESS_NULL(iseq->mark_ary);
iseq.c~:	RUBY_MARK_UNLESS_NULL(iseq->name);
iseq.c~:	RUBY_MARK_UNLESS_NULL(iseq->filename);
iseq.c~:	RUBY_MARK_UNLESS_NULL((VALUE)iseq->cref_stack);
iseq.c~:	RUBY_MARK_UNLESS_NULL(iseq->klass);
iseq.c~:	RUBY_MARK_UNLESS_NULL(iseq->coverage);
iseq.c~:/* 	RUBY_MARK_UNLESS_NULL((VALUE)iseq->node); */
iseq.c~:/*	RUBY_MARK_UNLESS_NULL(iseq->cached_special_block); */
iseq.c~:	RUBY_MARK_UNLESS_NULL(iseq->orig);
iseq.c~:	if (iseq->compile_data != 0) {
iseq.c~:	    RUBY_MARK_UNLESS_NULL(iseq->compile_data->mark_ary);
iseq.c~:	    RUBY_MARK_UNLESS_NULL(iseq->compile_data->err_info);
iseq.c~:	    RUBY_MARK_UNLESS_NULL(iseq->compile_data->catch_table_ary);
iseq.c~:    const int type = iseq->type;
iseq.c~:	iseq->cref_stack = NEW_BLOCK(th->top_wrapper ? th->top_wrapper : rb_cObject);
iseq.c~:	iseq->cref_stack->nd_file = 0;
iseq.c~:	iseq->cref_stack->nd_visi = NOEX_PRIVATE;
iseq.c~:	iseq->cref_stack = NEW_BLOCK(0); /* place holder */
iseq.c~:	iseq->cref_stack->nd_file = 0;
iseq.c~:	iseq->cref_stack = piseq->cref_stack;
iseq.c~:	iseq->local_iseq = iseq;
iseq.c~:	iseq->local_iseq = piseq->local_iseq;
iseq.c~:	iseq->parent_iseq = piseq;
iseq.c~:    iseq->name = name;
iseq.c~:    iseq->filename = filename;
iseq.c~:    iseq->defined_method_id = 0;
iseq.c~:    iseq->mark_ary = rb_ary_new();
iseq.c~:    RBASIC(iseq->mark_ary)->klass = 0;
iseq.c~:    iseq->type = type;
iseq.c~:    iseq->arg_rest = -1;
iseq.c~:    iseq->arg_block = -1;
iseq.c~:    iseq->klass = 0;
iseq.c~:     * iseq->special_block_builder = GC_GUARDED_PTR_REF(block_opt);
iseq.c~:     * iseq->cached_special_block_builder = 0;
iseq.c~:     * iseq->cached_special_block = 0;
iseq.c~:    iseq->compile_data = ALLOC(struct iseq_compile_data);
iseq.c~:    MEMZERO(iseq->compile_data, struct iseq_compile_data, 1);
iseq.c~:    iseq->compile_data->mark_ary = rb_ary_new();
iseq.c~:    RBASIC(iseq->compile_data->mark_ary)->klass = 0;
iseq.c~:    iseq->compile_data->storage_head = iseq->compile_data->storage_current =
iseq.c~:    iseq->compile_data->catch_table_ary = rb_ary_new();
iseq.c~:    iseq->compile_data->storage_head->pos = 0;
iseq.c~:    iseq->compile_data->storage_head->next = 0;
iseq.c~:    iseq->compile_data->storage_head->size =
iseq.c~:    iseq->compile_data->storage_head->buff =
iseq.c~:      (char *)(&iseq->compile_data->storage_head->buff + 1);
iseq.c~:    iseq->compile_data->option = option;
iseq.c~:    iseq->coverage = Qfalse;
iseq.c~:    if (!GET_THREAD()->parse_in_eval) {
iseq.c~:	    iseq->coverage = rb_hash_lookup(coverages, filename);
iseq.c~:	    if (NIL_P(iseq->coverage)) iseq->coverage = Qfalse;
iseq.c~:    struct iseq_compile_data *data = iseq->compile_data;
iseq.c~:    VALUE err = data->err_info;
iseq.c~:    iseq->compile_data = 0;
iseq.c~:	rb_funcall2(err, rb_intern("set_backtrace"), 1, &iseq->filename);
iseq.c~:      if (flag == Qtrue)  { o->mem = 1; } \
iseq.c~:      else if (flag == Qfalse)  { o->mem = 0; } \
iseq.c~:      if (!NIL_P(num)) o->mem = NUM2INT(num); \
iseq.c~:  rb_hash_aset(h, ID2SYM(rb_intern(#mem)), o->mem ? Qtrue : Qfalse)
iseq.c~:  rb_hash_aset(h, ID2SYM(rb_intern(#mem)), INT2NUM(o->mem))
iseq.c~:    VALUE parent = th->base_block->iseq->self;
iseq.c~:    iseq->self = self;
iseq.c~:    iseq->self = iseqval;
iseq.c~:	rb_exc_raise(GET_THREAD()->errinfo);	/* TODO: check err */
iseq.c~:    if (th->base_block && th->base_block->iseq) {
iseq.c~:	return rb_iseq_new_with_opt(node, th->base_block->iseq->name,
iseq.c~:				    file, th->base_block->iseq->self,
iseq.c~:    if (!iseq->name) {
iseq.c~:    if (!iseq->name) {
iseq.c~:		      RSTRING_PTR(iseq->name), RSTRING_PTR(iseq->filename));
iseq.c~:    return iseq->insn_info_table[0].line_no;
iseq.c~:    unsigned long i, size = iseq->insn_info_size;
iseq.c~:    struct iseq_insn_info_entry *table = iseq->insn_info_table;
iseq.c~:	return entry->line_no;
iseq.c~:    unsigned long i, size = iseqdat->insn_info_size;
iseq.c~:    struct iseq_insn_info_entry *iiary = iseqdat->insn_info_table;
iseq.c~:		return iiary[i - 1].line_no;
iseq.c~:	    rb_iseq_t *ip = iseq->local_iseq;
iseq.c~:	    int lidx = ip->local_size - op;
iseq.c~:	    const char *name = rb_id2name(ip->local_table[lidx]);
iseq.c~:		ip = ip->parent_iseq;
iseq.c~:	    name = rb_id2name(ip->local_table[ip->local_size - op]);
iseq.c~:		ret = iseq->name;
iseq.c~:		    rb_ary_push(child, iseq->self);
iseq.c~:	    ret = rb_str_dup(rb_id2str(entry->id));
iseq.c~: * Iseq -> Iseq inspect object
iseq.c~:	rb_str_catf(str, "%04d %-16s ", pos, insn_name_buff);
iseq.c~:	rb_str_catf(str, "%04d %-16.*s ", pos,
iseq.c~:	    slen = (slen > 70) ? 0 : (70 - slen);
iseq.c~:	slen = (slen > 60) ? 0 : (60 - slen);
iseq.c~:			  (int)slen, "", entry->line_no, entry->sp);
iseq.c~:    iseq = iseqdat->iseq;
iseq.c~:    size = iseqdat->iseq_size;
iseq.c~:    rb_str_concat(str, iseq_inspect(iseqdat->self));
iseq.c~:	memset(RSTRING_PTR(str) + l, '=', header_minlen - l);
iseq.c~:    if (iseqdat->catch_table_size != 0) {
iseq.c~:    for (i = 0; i < iseqdat->catch_table_size; i++) {
iseq.c~:	struct iseq_catch_table_entry *entry = &iseqdat->catch_table[i];
iseq.c~:		    "| catch type: %-6s st: %04d ed: %04d sp: %04d cont: %04d\n",
iseq.c~:		    catch_type((int)entry->type), (int)entry->start,
iseq.c~:		    (int)entry->end, (int)entry->sp, (int)entry->cont);
iseq.c~:	if (entry->iseq) {
iseq.c~:	    rb_str_concat(str, rb_iseq_disasm(entry->iseq));
iseq.c~:    if (iseqdat->catch_table_size != 0) {
iseq.c~:	rb_str_cat2(str, "|-------------------------------------"
iseq.c~:		    "-----------------------------------\n");
iseq.c~:    tbl = iseqdat->local_table;
iseq.c~:		    iseqdat->local_size, iseqdat->argc,
iseq.c~:		    iseqdat->arg_opts, iseqdat->arg_rest,
iseq.c~:		    iseqdat->arg_post_len, iseqdat->arg_block,
iseq.c~:		    iseqdat->arg_simple);
iseq.c~:	for (i = 0; i < iseqdat->local_table_size; i++) {
iseq.c~:	    if (iseqdat->arg_opts) {
iseq.c~:		int argc = iseqdat->argc;
iseq.c~:		int opts = iseqdat->arg_opts;
iseq.c~:		if (i >= argc && i < argc + opts - 1) {
iseq.c~:			     iseqdat->arg_opt_table[i - argc]);
iseq.c~:		     iseqdat->argc > i ? "Arg" : "",
iseq.c~:		     iseqdat->arg_rest == i ? "Rest" : "",
iseq.c~:		     (iseqdat->arg_post_start <= i &&
iseq.c~:		      i < iseqdat->arg_post_start + iseqdat->arg_post_len) ? "Post" : "",
iseq.c~:		     iseqdat->arg_block == i ? "Block" : "");
iseq.c~:	    rb_str_catf(str, "[%2d] %-11s", iseqdat->local_size - i, info);
iseq.c~: 	    VALUE iseqval = (VALUE)node->nd_body;
iseq.c~:    switch(iseq->type) {
iseq.c~:    for (i=0; i<iseq->local_table_size; i++) {
iseq.c~:	ID lid = iseq->local_table[i];
iseq.c~:	for (j=0; j<iseq->arg_opts; j++) {
iseq.c~:			register_label(labels_table, iseq->arg_opt_table[j]));
iseq.c~:	if (iseq->arg_simple == 1) {
iseq.c~:	    args = INT2FIX(iseq->argc);
iseq.c~:	    rb_ary_push(args, INT2FIX(iseq->argc));
iseq.c~:	    rb_ary_push(args, INT2FIX(iseq->arg_post_len));
iseq.c~:	    rb_ary_push(args, INT2FIX(iseq->arg_post_start));
iseq.c~:	    rb_ary_push(args, INT2FIX(iseq->arg_rest));
iseq.c~:	    rb_ary_push(args, INT2FIX(iseq->arg_block));
iseq.c~:	    rb_ary_push(args, INT2FIX(iseq->arg_simple));
iseq.c~:    for (seq = iseq->iseq; seq < iseq->iseq + iseq->iseq_size; ) {
iseq.c~:	VALUE *nseq = seq + len - 1;
iseq.c~:	for (j=0; j<len-1; j++, seq++) {
iseq.c~:		unsigned int idx = nseq - iseq->iseq + *seq;
iseq.c~:		    rb_ary_push(ary, ID2SYM(entry->id));
iseq.c~:			unsigned int idx = nseq - iseq->iseq + pos;
iseq.c~:    for (i=0; i<iseq->catch_table_size; i++) {
iseq.c~:	struct iseq_catch_table_entry *entry = &iseq->catch_table[i];
iseq.c~:	rb_ary_push(ary, exception_type2symbol(entry->type));
iseq.c~:	if (entry->iseq) {
iseq.c~:	    GetISeqPtr(entry->iseq, eiseq);
iseq.c~:	rb_ary_push(ary, register_label(labels_table, entry->start));
iseq.c~:	rb_ary_push(ary, register_label(labels_table, entry->end));
iseq.c~:	rb_ary_push(ary, register_label(labels_table, entry->cont));
iseq.c~:	rb_ary_push(ary, INT2FIX(entry->sp));
iseq.c~:	if (iseq->insn_info_table[i].line_no != line) {
iseq.c~:	    line = iseq->insn_info_table[i].line_no;
iseq.c~:    rb_hash_aset(misc, ID2SYM(rb_intern("arg_size")), INT2FIX(iseq->arg_size));
iseq.c~:    rb_hash_aset(misc, ID2SYM(rb_intern("local_size")), INT2FIX(iseq->local_size));
iseq.c~:    rb_hash_aset(misc, ID2SYM(rb_intern("stack_max")), INT2FIX(iseq->stack_max));
iseq.c~:    rb_ary_push(val, iseq->name);
iseq.c~:    rb_ary_push(val, iseq->filename);
iseq.c~:    iseq1->self = newiseq;
iseq.c~:    if (!iseq1->orig) {
iseq.c~:	iseq1->orig = iseqval;
iseq.c~:	iseq1->cref_stack = NEW_BLOCK(newcbase);
iseq.c~:	if (iseq0->cref_stack->nd_next) {
iseq.c~:	    iseq1->cref_stack->nd_next = iseq0->cref_stack->nd_next;
iseq.c~:    iseq->name = rb_str_new2(name);
iseq.c~:    iseq->filename = rb_str_new2(filename);
iseq.c~:    iseq->mark_ary = rb_ary_new();
iseq.c~:    iseq->self = iseqval;
iseq.c~:    iseq->iseq = ALLOC_N(VALUE, iseq->iseq_size);
iseq.c~:    for (i=0; i<iseq->iseq_size; i+=2) {
iseq.c~:	iseq->iseq[i] = BIN(opt_call_c_function);
iseq.c~:	iseq->iseq[i+1] = (VALUE)func;
iseq.c~:    ALLOC_AND_COPY(iseq->insn_info_table, insn_info_table,
iseq.c~:		   struct iseq_insn_info_entry, iseq->insn_info_size);
iseq.c~:    ALLOC_AND_COPY(iseq->catch_table, catch_table,
iseq.c~:		   struct iseq_catch_table_entry, iseq->catch_table_size);
iseq.c~:    ALLOC_AND_COPY(iseq->arg_opt_table, arg_opt_table,
iseq.c~:		   VALUE, iseq->arg_opts);
iseq.c~:    /* rb_define_singleton_method(rb_cISeq, "load", iseq_s_load, -1); */
iseq.c~:    rb_define_singleton_method(rb_cISeq, "compile", iseq_s_compile, -1);
iseq.c~:    rb_define_singleton_method(rb_cISeq, "new", iseq_s_compile, -1);
iseq.c~:    rb_define_singleton_method(rb_cISeq, "compile_file", iseq_s_compile_file, -1);
iseq.h:  iseq.h -
iseq.h:  Copyright (C) 2004-2008 Koichi Sasada
ãã¤ããªã¼ã»ãã¡ã¤ã«iseq.oã¯ä¸è´ãã¾ãã
known_errors.inc:/** -*-c-*- 
lex.c:/* Command-line: gperf -C -p -j1 -i 1 -g -o -t -N rb_reserved_word -k'1,3,$' defs/keywords  */
lex.c:      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
lex.c:/* The character set is not based on ISO-646.  */
lex.c:error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
lex.c:  return hval + asso_values[(unsigned char)str[len - 1]];
lex.c.blt:/* Command-line: gperf -C -p -j1 -i 1 -g -o -t -N rb_reserved_word -k'1,3,$' defs/keywords  */
lex.c.blt:      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
lex.c.blt:/* The character set is not based on ISO-646.  */
lex.c.blt:error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
lex.c.blt:  return hval + asso_values[(unsigned char)str[len - 1]];
ãã¤ããªã¼ã»ãã¡ã¤ã«libruby-static.aã¯ä¸è´ãã¾ãã
load.c:    VALUE load_path = GET_VM()->load_path;
load.c:    return vm->load_path;
load.c:    return GET_VM()->loaded_features;
load.c:    return GET_VM()->loading_table;
load.c:    VALUE p = loaded_feature_path(s, strlen(s), fp->name, fp->len,
load.c:				  fp->type, fp->load_path);
load.c:    fp->result = s;
load.c:	len = strlen(feature) - elen;
load.c:    volatile VALUE wrapper = th->top_wrapper;
load.c:    volatile VALUE self = th->top_self;
load.c:    th->errinfo = Qnil; /* ensure */
load.c:	th->top_wrapper = 0;
load.c:	th->top_self = rb_obj_clone(rb_vm_top_self());
load.c:	th->top_wrapper = rb_module_new();
load.c:	rb_extend_object(th->top_self, th->top_wrapper);
load.c:    mild_compile_error = th->mild_compile_error;
load.c:	th->mild_compile_error++;
load.c:	th->mild_compile_error--;
load.c:    th->mild_compile_error = mild_compile_error;
load.c:    th->top_self = self;
load.c:    th->top_wrapper = wrapper;
load.c:	rb_exc_raise(GET_THREAD()->errinfo);
load.c:    if (!NIL_P(GET_THREAD()->errinfo)) {
load.c:	rb_exc_raise(th->errinfo);
load.c: *  call-seq:
load.c:	    GET_VM()->loading_table = loading_tbl = st_init_strtable();
load.c: *  call-seq:
load.c: *     require "my-library.rb"
load.c: *     require "db-driver"
load.c:	    tmp = rb_str_new(RSTRING_PTR(fname), ext - RSTRING_PTR(fname));
load.c:	if (rb_feature_p(ftptr, ext, !--type, Qtrue, &loading) && !loading)
load.c:    rb_raise(rb_eLoadError, "no such file to load -- %s",
load.c:    volatile VALUE errinfo = th->errinfo;
load.c:		    rb_raise(rb_eSecurityError, "cannot load from insecure path - %s",
load.c:    th->errinfo = errinfo;
load.c: *  call-seq:
load.c: *  call-seq:
load.c:    ID id_load_path = rb_intern2(var_load_path, sizeof(var_load_path)-1);
load.c:    rb_alias_variable(rb_intern("$-I"), id_load_path);
load.c:    vm->load_path = rb_ary_new();
load.c:    vm->loaded_features = rb_ary_new();
load.c:    rb_define_global_function("load", rb_f_load, -1);
ãã¤ããªã¼ã»ãã¡ã¤ã«load.oã¯ä¸è´ãã¾ãã
main.c:  main.c -
main.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
ãã¤ããªã¼ã»ãã¡ã¤ã«main.oã¯ä¸è´ãã¾ãã
marshal.c:  marshal.c -
marshal.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
marshal.c:#define SHORTMASK ((1<<BITSPERSHORT)-1)
marshal.c:    num = ds[len-1];
marshal.c:    return (len - 1)*sizeof(BDIGIT)/2 + offset;
marshal.c:    rb_gc_mark(p->newclass);
marshal.c:    rb_gc_mark(p->oldclass);
marshal.c:    compat->newclass = Qnil;
marshal.c:    compat->oldclass = Qnil;
marshal.c:    compat->newclass = newclass;
marshal.c:    compat->oldclass = oldclass;
marshal.c:    compat->dumper = dumper;
marshal.c:    compat->loader = loader;
marshal.c:    if (!DATA_PTR(arg->wrapper)) {
marshal.c:    rb_mark_set(p->data);
marshal.c:    rb_mark_hash(p->compat_tbl);
marshal.c:    VALUE buf = arg->str;
marshal.c:    if (arg->dest && RSTRING_LEN(buf) >= BUFSIZ) {
marshal.c:	if (arg->taint) OBJ_TAINT(buf);
marshal.c:	if (arg->untrust) OBJ_UNTRUST(buf);
marshal.c:	rb_io_write(arg->dest, buf);
marshal.c:    if (!(RSHIFT(x, 31) == 0 || RSHIFT(x, 31) == -1)) {
marshal.c:    if (-124 < x && x < 0) {
marshal.c:	w_byte((char)((x - 5)&0xff), arg);
marshal.c:	if (x == -1) {
marshal.c:	    buf[0] = -i;
marshal.c:#define DECIMAL_MANT (53-16)	/* from IEEE754 double precision */
marshal.c:	while (!buf[i - 1]) --i;
marshal.c:    if (--len > 0 && !*buf++) {	/* binary mantissa mark */
marshal.c:	    dig -= len < MANT_BITS / 8 ? 8 * (unsigned)len : MANT_BITS;
marshal.c:	} while ((len -= MANT_BITS / 8) > 0);
marshal.c:	d = ldexp(d, e - DECIMAL_MANT);
marshal.c:	if (s) d = -d;
marshal.c:	if (d < 0) strcpy(buf, "-inf");
marshal.c:	if (1.0/d < 0) strcpy(buf, "-0");
marshal.c:    if (st_lookup(arg->symbols, id, &num)) {
marshal.c:	st_add_direct(arg->symbols, id, arg->symbols->num_entries);
marshal.c:    w_object(key, arg->arg, arg->limit);
marshal.c:    w_object(value, arg->arg, arg->limit);
marshal.c:	if (RCLASS_M_TBL(klass)->num_entries ||
marshal.c:	    (RCLASS_IV_TBL(klass) && RCLASS_IV_TBL(klass)->num_entries > 1)) {
marshal.c:	path = rb_class2name(RBASIC(klass)->klass);
marshal.c:    if (st_lookup(arg->compat_tbl, (st_data_t)obj, &real_obj)) {
marshal.c:    w_symbol(id, arg->arg);
marshal.c:    w_object(value, arg->arg, arg->limit);
marshal.c:	w_long(num, arg->arg);
marshal.c:    w_long(num + 1, arg->arg);
marshal.c:    w_symbol(rb_id_encoding(), arg->arg);
marshal.c:	if (!arg->arg->encodings)
marshal.c:	    arg->arg->encodings = st_init_strcasetable();
marshal.c:	else if (st_lookup(arg->arg->encodings, (st_data_t)rb_enc_name(enc), &name))
marshal.c:	st_insert(arg->arg->encodings, (st_data_t)rb_enc_name(enc), name);
marshal.c:    w_object(name, arg->arg, arg->limit + 1);
marshal.c:    long num = tbl ? tbl->num_entries : 0;
marshal.c:    limit--;
marshal.c:    if (st_lookup(arg->data, obj, &num)) {
marshal.c:	if (RSHIFT((long)obj, 31) == 0 || RSHIFT((long)obj, 31) == -1) {
marshal.c:	if (OBJ_TAINTED(obj)) arg->taint = Qtrue;
marshal.c:	if (OBJ_UNTRUSTED(obj)) arg->untrust = Qtrue;
marshal.c:            st_add_direct(arg->data, obj, arg->data->num_entries);
marshal.c:            st_add_direct(arg->data, obj, arg->data->num_entries);
marshal.c:        st_add_direct(arg->data, obj, arg->data->num_entries);
marshal.c:            rb_alloc_func_t allocator = rb_get_alloc_func(RBASIC(obj)->klass);
marshal.c:                obj = compat->dumper(real_obj);
marshal.c:                st_insert(arg->compat_tbl, (st_data_t)obj, (st_data_t)real_obj);
marshal.c:		char sign = RBIGNUM_SIGN(obj) ? '+' : '-';
marshal.c:		while (len--) {
marshal.c:	    if (NIL_P(RHASH(obj)->ifnone)) {
marshal.c:	    if (!NIL_P(RHASH(obj)->ifnone)) {
marshal.c:		w_object(RHASH(obj)->ifnone, arg, limit);
marshal.c:    w_object(arg->obj, arg->arg, arg->limit);
marshal.c:    if (arg->arg->dest) {
marshal.c:	rb_io_write(arg->arg->dest, arg->arg->str);
marshal.c:	rb_str_resize(arg->arg->str, 0);
marshal.c:    if (!DATA_PTR(arg->wrapper)) return 0;
marshal.c:    st_free_table(arg->symbols);
marshal.c:    st_free_table(arg->data);
marshal.c:    st_free_table(arg->compat_tbl);
marshal.c:    if (arg->encodings) st_free_table(arg->encodings);
marshal.c:    DATA_PTR(arg->wrapper) = 0;
marshal.c:    arg->wrapper = 0;
marshal.c:    if (arg->taint) {
marshal.c:	OBJ_TAINT(arg->str);
marshal.c:    if (arg->untrust) {
marshal.c:	OBJ_UNTRUST(arg->str);
marshal.c: * call-seq:
marshal.c: *      dump( obj [, anIO] , limit=--1 ) => anIO
marshal.c:    int limit = -1;
marshal.c:    RBASIC(arg.str)->klass = 0;
marshal.c:    RBASIC(arg.str)->klass = rb_cString;
marshal.c:    if (!DATA_PTR(arg->wrapper)) {
marshal.c:    rb_mark_tbl(p->data);
marshal.c:    rb_mark_hash(p->compat_tbl);
marshal.c:    if (TYPE(arg->src) == T_STRING) {
marshal.c:	if (RSTRING_LEN(arg->src) > arg->offset) {
marshal.c:	    c = (unsigned char)RSTRING_PTR(arg->src)[arg->offset++];
marshal.c:	VALUE src = arg->src;
marshal.c:# define SIGN_EXTEND_CHAR(c) ((((unsigned char)(c)) ^ 128) - 128)
marshal.c:	    return c - 5;
marshal.c:	if (-129 < c && c < -4) {
marshal.c:	c = -c;
marshal.c:	x = -1;
marshal.c:    if (TYPE(arg->src) == T_STRING) {
marshal.c:	if (RSTRING_LEN(arg->src) - arg->offset >= len) {
marshal.c:	    str = rb_str_new(RSTRING_PTR(arg->src)+arg->offset, len);
marshal.c:	    arg->offset += len;
marshal.c:	VALUE src = arg->src;
marshal.c:	if (OBJ_TAINTED(str)) arg->taint = Qtrue;
marshal.c:	if (OBJ_UNTRUSTED(str)) arg->untrust = Qtrue;
marshal.c:    if (st_lookup(arg->symbols, num, &id)) {
marshal.c:    st_insert(arg->symbols, arg->symbols->num_entries, id);
marshal.c:    if (st_lookup(arg->compat_tbl, v, &real_obj)) {
marshal.c:        st_insert(arg->data, arg->data->num_entries, (st_data_t)real_obj);
marshal.c:        st_insert(arg->data, arg->data->num_entries, (st_data_t)v);
marshal.c:    if (arg->taint) {
marshal.c:    if (arg->untrust) {
marshal.c:    if (st_lookup(arg->compat_tbl, v, &data)) {
marshal.c:            compat->loader(real_obj, v);
marshal.c:        st_delete(arg->compat_tbl, &key, 0);
marshal.c:    if (arg->proc) {
marshal.c:	v = rb_funcall(arg->proc, s_call, 1, v);
marshal.c:	while (len--) {
marshal.c:        VALUE obj = rb_obj_alloc(compat->oldclass);
marshal.c:        st_insert(arg->compat_tbl, (st_data_t)obj, (st_data_t)real_obj);
marshal.c:	if (!st_lookup(arg->data, (st_data_t)id, &link)) {
marshal.c:	if (arg->proc) {
marshal.c:	    v = rb_funcall(arg->proc, s_call, 1, v);
marshal.c:	    if (TYPE(v) == T_MODULE || !RTEST(rb_class_inherited_p(c, RBASIC(v)->klass))) {
marshal.c:	    RBASIC(v)->klass = c;
marshal.c:	    else if (strcmp(ptr, "-inf") == 0) {
marshal.c:		d = -1.0 / t;
marshal.c:		d = load_mantissa(d, e, RSTRING_LEN(str) - (e - ptr));
marshal.c:		    RBIGNUM_LEN(big) * sizeof(BDIGIT) - len * 2);
marshal.c:		len--;
marshal.c:	    volatile long len = r_long(arg); /* gcc 2.7.2.3 -O2 bug?? */
marshal.c:	    while (len--) {
marshal.c:	    while (len--) {
marshal.c:		RHASH(v)->ifnone = r_object(arg);
marshal.c:	    volatile long i;	/* gcc 2.7.2.3 -O2 bug?? */
marshal.c:    if (!DATA_PTR(arg->wrapper)) return 0;
marshal.c:    st_free_table(arg->symbols);
marshal.c:    st_free_table(arg->data);
marshal.c:    st_free_table(arg->compat_tbl);
marshal.c:    DATA_PTR(arg->wrapper) = 0;
marshal.c:    arg->wrapper = 0;
marshal.c: * call-seq:
marshal.c: * (normally using -d, -v, -w, or --verbose) the major and minor
marshal.c: * parameter (a value of -1 implies that you should disable depth checking).
marshal.c:    rb_define_module_function(rb_mMarshal, "dump", marshal_dump, -1);
marshal.c:    rb_define_module_function(rb_mMarshal, "load", marshal_load, -1);
marshal.c:    rb_define_module_function(rb_mMarshal, "restore", marshal_load, -1);
ãã¤ããªã¼ã»ãã¡ã¤ã«marshal.oã¯ä¸è´ãã¾ãã
match.rb:# -*- coding: utf-8  -*
match.rb~:# -*- coding: utf-8  -*
match2.rb:# -*- coding: utf-8  -*
match2.rb~:# -*- coding: utf-8  -*
math.c:  math.c -
math.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
math.c: *  call-seq:
math.c: *  -PI..PI.
math.c: *  call-seq:
math.c: *  -1..1.
math.c: *  call-seq:
math.c: *  -1..1.
math.c: *  call-seq:
math.c: *  call-seq:
math.c: *  call-seq:
math.c: *  Computes the arc sine of <i>x</i>. Returns -{PI/2} .. {PI/2}.
math.c: *  call-seq:
math.c: *  Computes the arc tangent of <i>x</i>. Returns -{PI/2} .. {PI/2}.
math.c:    return (exp(x) + exp(-x)) / 2;
math.c: *  call-seq:
math.c:    return (exp(x) - exp(-x)) / 2;
math.c: *  call-seq:
math.c: *  call-seq:
math.c: *  call-seq:
math.c: *  call-seq:
math.c: *  call-seq:
math.c: *  call-seq:
math.c: *  call-seq:
math.c: *  call-seq:
math.c: *  call-seq:
math.c: *  call-seq:
math.c: *  Returns the non-negative square root of <i>numeric</i>.
math.c: *  call-seq:
math.c: *    -9.upto(9) {|x|
math.c: *    [-9, -2.0800838230519, -9.0]
math.c: *    [-8, -2.0, -8.0]
math.c: *    [-7, -1.91293118277239, -7.0]
math.c: *    [-6, -1.81712059283214, -6.0]
math.c: *    [-5, -1.7099759466767, -5.0]
math.c: *    [-4, -1.5874010519682, -4.0]
math.c: *    [-3, -1.44224957030741, -3.0]
math.c: *    [-2, -1.25992104989487, -2.0]
math.c: *    [-1, -1.0, -1.0]
math.c: *  call-seq:
math.c: *  Returns a two-element array containing the normalized fraction (a
math.c: *  call-seq:
math.c: *     Math.ldexp(flt, int) -> float
math.c: *  call-seq:
math.c: *  Returns sqrt(x**2 + y**2), the hypotenuse of a right-angled triangle
math.c: * call-seq:
math.c: * call-seq:
math.c: * call-seq:
math.c: *  Note that gamma(n) is same as fact(n-1) for integer n >= 0.
math.c: * call-seq:
math.c: *    Math.lgamma(x)  => [float, -1 or 1]
math.c: *   [Math.log(Math.gamma(x).abs), Math.gamma(x) < 0 ? -1 : 1]
math.c:    rb_define_module_function(rb_mMath, "log", math_log, -1);
ãã¤ããªã¼ã»ãã¡ã¤ã«math.oã¯ä¸è´ãã¾ãã
miniprelude.c:    rb_usascii_str_new(prelude_code0, sizeof(prelude_code0) - 1),
miniprelude.c:    rb_usascii_str_new(prelude_name0, sizeof(prelude_name0) - 1),
ãã¤ããªã¼ã»ãã¡ã¤ã«miniprelude.oã¯ä¸è´ãã¾ãã
mkconfig.rb:#!./miniruby -s
mkconfig.rb:# avoid warnings with -d.
mkconfig.rb:    val.gsub!(/ +(?!-)/, "=") if name == "configure_args" && /mswin32/ =~ RUBY_PLATFORM
mkconfig.rb:print "  DESTDIR = ", (drive ? "TOPDIR && TOPDIR[/\\A[a-z]:/i] || " : ""), "'' unless defined? DESTDIR\n"
mkconfig.rb:dest = drive ? /= \"(?!\$[\(\{])(?:[a-z]:)?/i : /= \"(?!\$[\(\{])/
mkconfig.rb:  if /^\s*CONFIG\["(?!abs_|old)[a-z]+(?:_prefix|dir)"\]/ === x
mkconfig.rb:Config = RbConfig # compatibility for ruby-1.8.4 and older.
newline.c:/* src="transcode-tblgen.rb", len=21189, checksum=1144 */
ãã¤ããªã¼ã»ãã¡ã¤ã«newline.oã¯ä¸è´ãã¾ãã
node.h:  node.h -
node.h:  Copyright (C) 1993-2007 Yukihiro Matsumoto
node.h:} /* satisfy cc-mode */
node.h:#define nd_type(n) ((int) (((RNODE(n))->flags & NODE_TYPEMASK)>>NODE_TYPESHIFT))
node.h:    RNODE(n)->flags=((RNODE(n)->flags&~NODE_TYPEMASK)|(((t)<<NODE_TYPESHIFT)&NODE_TYPEMASK))
node.h:#define NODE_LMASK  (((SIGNED_VALUE)1<<(sizeof(VALUE)*CHAR_BIT-NODE_LSHIFT))-1)
node.h:#define nd_line(n) ((VALUE)(((RNODE(n))->flags>>NODE_LSHIFT)&NODE_LMASK))
node.h:    RNODE(n)->flags=((RNODE(n)->flags&~(-1<<NODE_LSHIFT))|(((l)&NODE_LMASK)<<NODE_LSHIFT))
node.h:{ /* satisfy cc-mode */
node.h~:  node.h -
node.h~:  Copyright (C) 1993-2007 Yukihiro Matsumoto
node.h~:} /* satisfy cc-mode */
node.h~:#define nd_type(n) ((int) (((RNODE(n))->flags & NODE_TYPEMASK)>>NODE_TYPESHIFT))
node.h~:    RNODE(n)->flags=((RNODE(n)->flags&~NODE_TYPEMASK)|(((t)<<NODE_TYPESHIFT)&NODE_TYPEMASK))
node.h~:#define NODE_LMASK  (((SIGNED_VALUE)1<<(sizeof(VALUE)*CHAR_BIT-NODE_LSHIFT))-1)
node.h~:#define nd_line(n) ((VALUE)(((RNODE(n))->flags>>NODE_LSHIFT)&NODE_LMASK))
node.h~:    RNODE(n)->flags=((RNODE(n)->flags&~(-1<<NODE_LSHIFT))|(((l)&NODE_LMASK)<<NODE_LSHIFT))
node.h~:{ /* satisfy cc-mode */
numeric.c:  numeric.c -
numeric.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
numeric.c:#define DBL_MIN 2.2250738585072014e-308
numeric.c:#define DBL_MIN_EXP (-1021)
numeric.c:#define DBL_MIN_10_EXP (-307)
numeric.c:#define DBL_EPSILON 2.2204460492503131e-16
numeric.c:	x = f + (x - f >= 0.5);
numeric.c:	x = f - (f - x >= 0.5);
numeric.c: *  call-seq:
numeric.c: *  Ruby to handle mixed-type numeric operations: it is intended to
numeric.c:    /* ruby_frame = ruby_frame->prev; */ /* pop frame for "singleton_method_added" */
numeric.c: *  call-seq:
numeric.c: *  Unary Plus---Returns the receiver's value.
numeric.c: *  call-seq:
numeric.c: *     -num    => numeric
numeric.c: *  Unary Minus---Returns the receiver's value, negated.
numeric.c:    return rb_funcall(zero, '-', 1, num);
numeric.c: *  call-seq:
numeric.c: *  call-seq:
numeric.c: *  call-seq:
numeric.c: *  call-seq:
numeric.c: *     num.divmod( aNumeric ) -> anArray
numeric.c: *  The quotient is rounded toward -infinity, as shown in the following table:
numeric.c: *    ------+-----+---------------+---------+-------------+---------------
numeric.c: *    ------+-----+---------------+---------+-------------+---------------
numeric.c: *     13   | -4  |  -4,   -3     |  -3     |   -3        |     1
numeric.c: *    ------+-----+---------------+---------+-------------+---------------
numeric.c: *    -13   |  4  |  -4,    3     |  -4     |    3        |    -1
numeric.c: *    ------+-----+---------------+---------+-------------+---------------
numeric.c: *    -13   | -4  |   3,   -1     |   3     |   -1        |    -1
numeric.c: *    ------+-----+---------------+---------+-------------+---------------
numeric.c: *    ------+-----+---------------+---------+-------------+---------------
numeric.c: *     11.5 | -4  |  -3,   -0.5   |  -2.875 |   -0.5      |     3.5
numeric.c: *    ------+-----+---------------+---------+-------------+---------------
numeric.c: *    -11.5 |  4  |  -3,    0.5   |  -2.875 |    0.5      |    -3.5
numeric.c: *    ------+-----+---------------+---------+-------------+---------------
numeric.c: *    -11.5 | -4  |   2,   -3.5   |   2.875 |   -3.5      |    -3.5
numeric.c: *     11.divmod(-3)        #=> [-4, -1]
numeric.c: *     (-11).divmod(3.5)    #=> [-4, 3.0]
numeric.c: *  call-seq:
numeric.c: *  call-seq:
numeric.c: *  <em>mod</em>-<i>numeric</i>; otherwise, returns <em>mod</em>. In
numeric.c:	return rb_funcall(z, '-', 1, y);
numeric.c: *  call-seq:
numeric.c: *     num.real? -> true or false
numeric.c: *  call-seq:
numeric.c: *     num.integer? -> true or false
numeric.c: *  call-seq:
numeric.c: *     (-34.56).abs   #=> 34.56
numeric.c: *     -34.56.abs     #=> 34.56
numeric.c:	return rb_funcall(num, rb_intern("-@"), 0);
numeric.c: *  call-seq:
numeric.c: *  call-seq:
numeric.c: *  call-seq:
numeric.c: * Document-class: Float
numeric.c: *  architecture's double-precision floating point representation.
numeric.c:    flt->float_value = d;
numeric.c: *  call-seq:
numeric.c: *  ``<code>-Infinity</code>''.
numeric.c:	return rb_usascii_str_new2(value < 0 ? "-Infinity" : "Infinity");
numeric.c:    if (!ISDIGIT(e[-1])) { /* reformat if ended with decimal point (ex 111111111111111.) */
numeric.c:    while (p[-1]=='0' && ISDIGIT(p[-2]))
numeric.c:	p--;
numeric.c: * call-seq:
numeric.c: *    -float   => float
numeric.c:    return DBL2NUM(-RFLOAT_VALUE(flt));
numeric.c: * call-seq:
numeric.c: * call-seq:
numeric.c:	return DBL2NUM(RFLOAT_VALUE(x) - (double)FIX2LONG(y));
numeric.c:	return DBL2NUM(RFLOAT_VALUE(x) - rb_big2dbl(y));
numeric.c:	return DBL2NUM(RFLOAT_VALUE(x) - RFLOAT_VALUE(y));
numeric.c:	return rb_num_coerce_bin(x, y, '-');
numeric.c: * call-seq:
numeric.c: * call-seq:
numeric.c:	mod = x - z * y;
numeric.c:	div = (x - mod) / y;
numeric.c:	div -= 1.0;
numeric.c: *  call-seq:
numeric.c: *  call-seq:
numeric.c: * call-seq:
numeric.c: *  call-seq:
numeric.c: *  call-seq:
numeric.c: *     num <=> other -> 0 or nil
numeric.c: *  call-seq:
numeric.c: * call-seq:
numeric.c:    if (a < b) return INT2FIX(-1);
numeric.c: *  call-seq:
numeric.c: *     flt <=> numeric   => -1, 0, +1
numeric.c: *  Returns -1, 0, or +1 depending on whether <i>flt</i> is less than,
numeric.c:	    else return INT2FIX(-1);
numeric.c:	    return INT2FIX(-1);
numeric.c: * call-seq:
numeric.c: * call-seq:
numeric.c: * call-seq:
numeric.c: * call-seq:
numeric.c: *  call-seq:
numeric.c: * call-seq:
numeric.c: *  call-seq:
numeric.c: *     (-34.56).abs   #=> 34.56
numeric.c: *     -34.56.abs     #=> 34.56
numeric.c: *  call-seq:
numeric.c: *     flt.zero? -> true or false
numeric.c: *  call-seq:
numeric.c: *     flt.nan? -> true or false
numeric.c: *     a = -1.0      #=> -1.0
numeric.c: *  call-seq:
numeric.c: *     flt.infinite? -> nil, -1, +1
numeric.c: *  Returns <code>nil</code>, -1, or +1 depending on whether <i>flt</i>
numeric.c: *  is finite, -infinity, or +infinity.
numeric.c: *     (-1.0/0.0).infinite?   #=> -1
numeric.c:	return INT2FIX( value < 0 ? -1 : 1 );
numeric.c: *  call-seq:
numeric.c: *     flt.finite? -> true or false
numeric.c: *  call-seq:
numeric.c: *     (-1.2).floor   #=> -2
numeric.c: *     (-2.0).floor   #=> -2
numeric.c: *  call-seq:
numeric.c: *     (-1.2).ceil   #=> -1
numeric.c: *     (-2.0).ceil   #=> -2
numeric.c: *  call-seq:
numeric.c: *     (-1.5).round   #=> -2
numeric.c:    while  (--i >= 0)
numeric.c: *  call-seq:
numeric.c: *  call-seq:
numeric.c: *     (-1).floor   #=> -1
numeric.c: *  call-seq:
numeric.c: *     (-1.2).ceil   #=> -1
numeric.c: *     (-1.0).ceil   #=> -1
numeric.c: *  call-seq:
numeric.c: *  call-seq:
numeric.c:	double n = (end - beg)/unit;
numeric.c:	double err = (fabs(beg) + fabs(end) + fabs(end-beg)) / fabs(unit) * epsilon;
numeric.c: *  call-seq:
numeric.c: *  where <i>n = (limit - num)/step</i>. Otherwise, the loop
numeric.c:	    snprintf(buf, sizeof(buf), "%-.10g", RFLOAT_VALUE(val));
numeric.c:	    snprintf(buf, sizeof(buf), "%-.10g", RFLOAT_VALUE(val));
numeric.c: * Document-class: Integer
numeric.c: *  call-seq:
numeric.c: *  call-seq:
numeric.c: *     int.integer? -> true
numeric.c: *  call-seq:
numeric.c: *     int.odd? -> true or false
numeric.c: *  call-seq:
numeric.c: *     int.even? -> true or false
numeric.c: *  call-seq:
numeric.c: *     (-1).next   #=> 0
numeric.c: *  call-seq:
numeric.c: *     (-1).next   #=> 0
numeric.c: *  call-seq:
numeric.c: *  Returns the <code>Integer</code> equal to <i>int</i> - 1.
numeric.c: *     (-1).pred   #=> -2
numeric.c:	long i = FIX2LONG(num) - 1;
numeric.c:    return rb_funcall(num, '-', 1, INT2FIX(1));
numeric.c: *  call-seq:
numeric.c: *  call-seq:
numeric.c: * Document-class: Fixnum
numeric.c: * call-seq:
numeric.c: *   -fix   =>  integer
numeric.c:    return LONG2NUM(-FIX2LONG(num));
numeric.c:	val = -val;
numeric.c:    *--b = '\0';
numeric.c:	*--b = ruby_digitmap[(int)(val % base)];
numeric.c:	*--b = '-';
numeric.c: *  call-seq:
numeric.c: *     fix.to_s( base=10 ) -> aString
numeric.c: * call-seq:
numeric.c: * call-seq:
numeric.c: *   fix - numeric   =>  numeric_result
numeric.c:	c = a - b;
numeric.c:	return DBL2NUM((double)FIX2LONG(x) - RFLOAT_VALUE(y));
numeric.c:	return rb_num_coerce_bin(x, y, '-');
numeric.c:#define SQRT_LONG_MAX ((SIGNED_VALUE)1<<((SIZEOF_LONG*CHAR_BIT-1)/2))
numeric.c:#define FIT_SQRT_LONG(n) (((n)<SQRT_LONG_MAX)&&((n)>=-SQRT_LONG_MAX))
numeric.c: * call-seq:
numeric.c:	    div = -x / -y;
numeric.c:	    div = - (x / -y);
numeric.c:	    div = - (-x / y);
numeric.c:    mod = x - div*y;
numeric.c:	div -= 1;
numeric.c: *  call-seq:
numeric.c: * call-seq:
numeric.c: * call-seq:
numeric.c: *  call-seq:
numeric.c: *  call-seq:
numeric.c:    if (neg) x = -x;
numeric.c:		if (z != 1) v = rb_big_mul(rb_int2big(neg ? -z : z), v);
numeric.c:    } while (--y);
numeric.c:    if (neg) z = -z;
numeric.c: *  call-seq:
numeric.c: *    2 ** -1     #=> 0.5
numeric.c:	if (a == -1) {
numeric.c:		return INT2FIX(-1);
numeric.c:	if (a == -1) {
numeric.c:	    else return INT2FIX(-1);
numeric.c: * call-seq:
numeric.c: *  call-seq:
numeric.c: *     fix <=> numeric    => -1, 0, +1
numeric.c: *  Comparison---Returns -1, 0, or +1 depending on whether <i>fix</i> is
numeric.c:	return INT2FIX(-1);
numeric.c: * call-seq:
numeric.c: * call-seq:
numeric.c: * call-seq:
numeric.c: * call-seq:
numeric.c: * call-seq:
numeric.c: * call-seq:
numeric.c: * call-seq:
numeric.c: * call-seq:
numeric.c: * call-seq:
numeric.c:	return fix_rshift(val, (unsigned long)-width);
numeric.c:    if (width > (SIZEOF_LONG*CHAR_BIT-1)
numeric.c:	|| ((unsigned long)val)>>(SIZEOF_LONG*CHAR_BIT-1-width) > 0) {
numeric.c: * call-seq:
numeric.c:	return fix_lshift(val, (unsigned long)-i);
numeric.c:    if (i >= sizeof(long)*CHAR_BIT-1) {
numeric.c:	if (val < 0) return INT2FIX(-1);
numeric.c: *  call-seq:
numeric.c: *  Bit Reference---Returns the <em>n</em>th bit in the binary
numeric.c:    if (SIZEOF_LONG*CHAR_BIT-1 < i) {
numeric.c: *  call-seq:
numeric.c: *     fix.to_f -> float
numeric.c: *  call-seq:
numeric.c: *     fix.abs -> aFixnum
numeric.c: *     -12345.abs   #=> 12345
numeric.c:    if (i < 0) i = -i;
numeric.c: *  call-seq:
numeric.c: *     fix.size -> fixnum
numeric.c: *     -1.size           #=> 4
numeric.c: *  call-seq:
numeric.c: *  call-seq:
numeric.c:	for (i=FIX2LONG(from); i >= end; i--) {
numeric.c:	    i = rb_funcall(i, '-', 1, INT2FIX(1));
numeric.c: *  call-seq:
numeric.c: *  <i>int</i> - 1.
numeric.c:    ndigits = -ndigits;
numeric.c:	if (neg) x = -x;
numeric.c:	if (neg) x = -x;
numeric.c:    n = rb_funcall(num, '-', 1, r);
numeric.c: *  call-seq:
numeric.c: *  call-seq:
numeric.c: *     fix.odd? -> true or false
numeric.c: *  call-seq:
numeric.c: *     fix.even? -> true or false
numeric.c:    /* allow divide by zero -- Inf */
numeric.c:    rb_define_method(rb_cNumeric, "-@", num_uminus, 0);
numeric.c:    rb_define_method(rb_cNumeric, "round", num_round, -1);
numeric.c:    rb_define_method(rb_cNumeric, "step", num_step, -1);
numeric.c:    rb_define_method(rb_cInteger, "chr", int_chr, -1);
numeric.c:    rb_define_method(rb_cInteger, "round", int_round, -1);
numeric.c:    rb_define_method(rb_cFixnum, "to_s", fix_to_s, -1);
numeric.c:    rb_define_method(rb_cFixnum, "-@", fix_uminus, 0);
numeric.c:    rb_define_method(rb_cFixnum, "-", fix_minus, 1);
numeric.c:    rb_define_method(rb_cFloat, "-@", flo_uminus, 0);
numeric.c:    rb_define_method(rb_cFloat, "-", flo_minus, 1);
numeric.c:    rb_define_method(rb_cFloat, "round", flo_round, -1);
ãã¤ããªã¼ã»ãã¡ã¤ã«numeric.oã¯ä¸è´ãã¾ãã
object.c:  object.c -
object.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
object.c:  Copyright (C) 2000  Information-technology Promotion Agency, Japan
object.c: *  call-seq:
object.c: *  Case Equality---For class <code>Object</code>, effectively the same
object.c: *  call-seq:
object.c: *  Equality---At the <code>Object</code> level, <code>==</code> returns
object.c: *  classes to provide class-specific meaning.
object.c: *  call-seq:
object.c: *  call-seq:
object.c: *  Returns true if two objects are not-equal, otherwise false.
object.c:    while ((RBASIC(cl)->flags & FL_SINGLETON) || BUILTIN_TYPE(cl) == T_ICLASS) {
object.c: *  call-seq:
object.c:    RBASIC(dest)->flags &= ~(T_MASK|FL_EXIVAR);
object.c:    RBASIC(dest)->flags |= RBASIC(obj)->flags & (T_MASK|FL_EXIVAR|FL_TAINT|FL_UNTRUSTED);
object.c:        if (!(RBASIC(dest)->flags & ROBJECT_EMBED) && ROBJECT_IVPTR(dest)) {
object.c:            ROBJECT(dest)->as.heap.ivptr = 0;
object.c:            ROBJECT(dest)->as.heap.numiv = 0;
object.c:            ROBJECT(dest)->as.heap.iv_index_tbl = 0;
object.c:        if (RBASIC(obj)->flags & ROBJECT_EMBED) {
object.c:            MEMCPY(ROBJECT(dest)->as.ary, ROBJECT(obj)->as.ary, VALUE, ROBJECT_EMBED_LEN_MAX);
object.c:            RBASIC(dest)->flags |= ROBJECT_EMBED;
object.c:            long len = ROBJECT(obj)->as.heap.numiv;
object.c:            MEMCPY(ptr, ROBJECT(obj)->as.heap.ivptr, VALUE, len);
object.c:            ROBJECT(dest)->as.heap.ivptr = ptr;
object.c:            ROBJECT(dest)->as.heap.numiv = len;
object.c:            ROBJECT(dest)->as.heap.iv_index_tbl = ROBJECT(obj)->as.heap.iv_index_tbl;
object.c:            RBASIC(dest)->flags &= ~ROBJECT_EMBED;
object.c: *  call-seq:
object.c: *     obj.clone -> an_object
object.c: *  Produces a shallow copy of <i>obj</i>---the instance variables of
object.c: *  This method may have class-specific behavior.  If so, that
object.c:    RBASIC(clone)->klass = rb_singleton_class_clone(obj);
object.c:    RBASIC(clone)->flags = (RBASIC(obj)->flags | FL_TEST(clone, FL_TAINT) | FL_TEST(clone, FL_UNTRUSTED)) & ~(FL_FREEZE|FL_FINALIZE);
object.c:    RBASIC(clone)->flags |= RBASIC(obj)->flags & FL_FREEZE;
object.c: *  call-seq:
object.c: *     obj.dup -> an_object
object.c: *  Produces a shallow copy of <i>obj</i>---the instance variables of
object.c: *  This method may have class-specific behavior.  If so, that
object.c: *  call-seq:
object.c: *  object id. As a special case, the top-level object that is the
object.c:    if (RSTRING_PTR(str)[0] == '-') { /* first element */
object.c: *  call-seq:
object.c: *  Returns a string containing a human-readable representation of
object.c: *     Time.new.inspect                 #=> "2008-03-08 19:43:39 +0900"
object.c:            str = rb_sprintf("-<%s:%p", c, (void*)obj);
object.c: *  call-seq:
object.c: *  call-seq:
object.c: *  call-seq:
object.c: * Document-method: inherited
object.c: * call-seq:
object.c: * Document-method: singleton_method_added
object.c: *  call-seq:
object.c: * Document-method: singleton_method_removed
object.c: *  call-seq:
object.c: * Document-method: singleton_method_undefined
object.c: *  call-seq:
object.c: * Document-method: included
object.c: * call-seq:
object.c: *  call-seq:
object.c: *  call-seq:
object.c: *     obj.taint -> obj
object.c: *  Marks <i>obj</i> as tainted---if the <code>$SAFE</code> level is
object.c: *  call-seq:
object.c: *  call-seq:
object.c: *  call-seq:
object.c: *     obj.untrust -> obj
object.c: *  call-seq:
object.c: *  call-seq:
object.c: *  call-seq:
object.c: * Document-class: NilClass
object.c: *  call-seq:
object.c: *  call-seq:
object.c: *  call-seq:
object.c: * Document-method: to_a
object.c: *  call-seq:
object.c: *  call-seq:
object.c: *  Document-class: TrueClass
object.c: * call-seq:
object.c: *  call-seq:
object.c: *  And---Returns <code>false</code> if <i>obj</i> is
object.c: *  call-seq:
object.c: *  Or---Returns <code>true</code>. As <i>anObject</i> is an argument to
object.c: *  a method call, it is always evaluated; there is no short-circuit
object.c: *  call-seq:
object.c: *  Exclusive Or---Returns <code>true</code> if <i>obj</i> is
object.c: *  Document-class: FalseClass
object.c: * call-seq:
object.c: *  call-seq:
object.c: *  And---Returns <code>false</code>. <i>obj</i> is always
object.c: *  evaluated as it is the argument to a method call---there is no
object.c: *  short-circuit evaluation in this case.
object.c: *  call-seq:
object.c: *  Or---Returns <code>false</code> if <i>obj</i> is
object.c: *  call-seq:
object.c: *  Exclusive Or---If <i>obj</i> is <code>nil</code> or
object.c: *  call-seq:
object.c: *  Pattern Match---Overridden by descendents (notably
object.c: *  pattern-match semantics.
object.c: *  call-seq:
object.c: * Document-class: Module
object.c: * call-seq:
object.c: *  call-seq:
object.c: *  call-seq:
object.c: *  Case Equality---Returns <code>true</code> if <i>anObject</i> is an
object.c: * call-seq:
object.c: * call-seq:
object.c: * call-seq:
object.c: * call-seq:
object.c: *  call-seq:
object.c: *     mod <=> other_mod   => -1, 0, +1, or nil
object.c: *  Comparison---Returns -1 if <i>mod</i> includes <i>other_mod</i>, 0 if
object.c:	return INT2FIX(-1);
object.c:    RBASIC(mod)->klass = klass;
object.c: *  call-seq:
object.c: *  call-seq:
object.c:    rb_make_metaclass(klass, RBASIC(super)->klass);
object.c: *  call-seq:
object.c: *  call-seq:
object.c: *  call-seq:
object.c: *     class.superclass -> a_super_class or nil
object.c: *  call-seq:
object.c: *  call-seq:
object.c: *  call-seq:
object.c: *  call-seq:
object.c: *  call-seq:
object.c: *     Math::HIGH_SCHOOL_PI - Math::PI              #=> 0.00126448926734968
object.c: *  call-seq:
object.c: *  call-seq:
object.c: *  call-seq:
object.c: *  call-seq:
object.c: *  call-seq:
object.c: *  call-seq:
object.c: *  call-seq:
object.c: *  call-seq:
object.c: *  call-seq:
object.c: *  call-seq:
object.c: *  call-seq:
object.c: *  call-seq:
object.c:#define OutOfRange() (((w = end - p) > 20) ? (w = 20, ellipsis = "...") : (ellipsis = ""))
object.c:	char *e = buf + sizeof(buf) - 1;
object.c: *  call-seq:
object.c: *  call-seq:
object.c: *  call-seq:
object.c:    RBASIC(RBASIC(klass)->klass)->klass = metametaclass;
object.c: *  Document-class: Class
object.c: *  Classes in Ruby are first-class objects---each is an instance of
object.c: *  parentheses meta-classes. All metaclasses are instances 
object.c: *                             +-----------------+
object.c: *           BasicObject-->(BasicObject)         |
object.c: *              Object---->(Object)              |
object.c: *               |  |  +-----+  +---------+      |
object.c: *               |  +-----------+         |      |
object.c: *        +------+     |     Module--->(Module)  |
object.c: *   OtherClass-->(OtherClass)  |         |      |
object.c: *                            Class---->(Class)  |
object.c: *                              +----------------+
object.c: *  the built-in kernel functions globally accessible. Although the
object.c:    rb_define_method(rb_mKernel, "patern-match", rb_patern_match, 1);
object.c:    rb_define_method(rb_mKernel, "p-match", rb_pmatch, 1);
object.c:    rb_define_method(rb_mKernel, "methods", rb_obj_methods, -1);
object.c:    rb_define_method(rb_mKernel, "singleton_methods", rb_obj_singleton_methods, -1); /* in class.c */
object.c:    rb_define_method(rb_mKernel, "protected_methods", rb_obj_protected_methods, -1);
object.c:    rb_define_method(rb_mKernel, "private_methods", rb_obj_private_methods, -1);
object.c:    rb_define_method(rb_mKernel, "public_methods", rb_obj_public_methods, -1);
object.c:    rb_define_global_function("sprintf", rb_f_sprintf, -1); /* in sprintf.c */
object.c:    rb_define_global_function("format", rb_f_sprintf, -1);  /* in sprintf.c */
object.c:    rb_define_private_method(rb_cModule, "attr", rb_mod_attr, -1);
object.c:    rb_define_private_method(rb_cModule, "attr_reader", rb_mod_attr_reader, -1);
object.c:    rb_define_private_method(rb_cModule, "attr_writer", rb_mod_attr_writer, -1);
object.c:    rb_define_private_method(rb_cModule, "attr_accessor", rb_mod_attr_accessor, -1);
object.c:    rb_define_method(rb_cModule, "instance_methods", rb_class_instance_methods, -1); /* in class.c */
object.c:		     rb_class_public_instance_methods, -1);    /* in class.c */
object.c:		     rb_class_protected_instance_methods, -1); /* in class.c */
object.c:		     rb_class_private_instance_methods, -1);   /* in class.c */
object.c:    rb_define_method(rb_cModule, "constants", rb_mod_constants, -1); /* in variable.c */
object.c:    rb_define_method(rb_cModule, "const_get", rb_mod_const_get, -1);
object.c:    rb_define_method(rb_cModule, "const_defined?", rb_mod_const_defined, -1);
object.c:    rb_define_method(rb_cClass, "new", rb_class_new_instance, -1);
object.c:    rb_define_method(rb_cClass, "initialize", rb_class_initialize, -1);
object.c:    id_peq = rb_intern("p-match");
object.c:    id_patern_match = rb_intern("patern-match");
object.c~:  object.c -
object.c~:  Copyright (C) 1993-2007 Yukihiro Matsumoto
object.c~:  Copyright (C) 2000  Information-technology Promotion Agency, Japan
object.c~: *  call-seq:
object.c~: *  Case Equality---For class <code>Object</code>, effectively the same
object.c~: *  call-seq:
object.c~: *  Equality---At the <code>Object</code> level, <code>==</code> returns
object.c~: *  classes to provide class-specific meaning.
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: *  Returns true if two objects are not-equal, otherwise false.
object.c~:    while ((RBASIC(cl)->flags & FL_SINGLETON) || BUILTIN_TYPE(cl) == T_ICLASS) {
object.c~: *  call-seq:
object.c~:    RBASIC(dest)->flags &= ~(T_MASK|FL_EXIVAR);
object.c~:    RBASIC(dest)->flags |= RBASIC(obj)->flags & (T_MASK|FL_EXIVAR|FL_TAINT|FL_UNTRUSTED);
object.c~:        if (!(RBASIC(dest)->flags & ROBJECT_EMBED) && ROBJECT_IVPTR(dest)) {
object.c~:            ROBJECT(dest)->as.heap.ivptr = 0;
object.c~:            ROBJECT(dest)->as.heap.numiv = 0;
object.c~:            ROBJECT(dest)->as.heap.iv_index_tbl = 0;
object.c~:        if (RBASIC(obj)->flags & ROBJECT_EMBED) {
object.c~:            MEMCPY(ROBJECT(dest)->as.ary, ROBJECT(obj)->as.ary, VALUE, ROBJECT_EMBED_LEN_MAX);
object.c~:            RBASIC(dest)->flags |= ROBJECT_EMBED;
object.c~:            long len = ROBJECT(obj)->as.heap.numiv;
object.c~:            MEMCPY(ptr, ROBJECT(obj)->as.heap.ivptr, VALUE, len);
object.c~:            ROBJECT(dest)->as.heap.ivptr = ptr;
object.c~:            ROBJECT(dest)->as.heap.numiv = len;
object.c~:            ROBJECT(dest)->as.heap.iv_index_tbl = ROBJECT(obj)->as.heap.iv_index_tbl;
object.c~:            RBASIC(dest)->flags &= ~ROBJECT_EMBED;
object.c~: *  call-seq:
object.c~: *     obj.clone -> an_object
object.c~: *  Produces a shallow copy of <i>obj</i>---the instance variables of
object.c~: *  This method may have class-specific behavior.  If so, that
object.c~:    RBASIC(clone)->klass = rb_singleton_class_clone(obj);
object.c~:    RBASIC(clone)->flags = (RBASIC(obj)->flags | FL_TEST(clone, FL_TAINT) | FL_TEST(clone, FL_UNTRUSTED)) & ~(FL_FREEZE|FL_FINALIZE);
object.c~:    RBASIC(clone)->flags |= RBASIC(obj)->flags & FL_FREEZE;
object.c~: *  call-seq:
object.c~: *     obj.dup -> an_object
object.c~: *  Produces a shallow copy of <i>obj</i>---the instance variables of
object.c~: *  This method may have class-specific behavior.  If so, that
object.c~: *  call-seq:
object.c~: *  object id. As a special case, the top-level object that is the
object.c~:    if (RSTRING_PTR(str)[0] == '-') { /* first element */
object.c~: *  call-seq:
object.c~: *  Returns a string containing a human-readable representation of
object.c~: *     Time.new.inspect                 #=> "2008-03-08 19:43:39 +0900"
object.c~:            str = rb_sprintf("-<%s:%p", c, (void*)obj);
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: * Document-method: inherited
object.c~: * call-seq:
object.c~: * Document-method: singleton_method_added
object.c~: *  call-seq:
object.c~: * Document-method: singleton_method_removed
object.c~: *  call-seq:
object.c~: * Document-method: singleton_method_undefined
object.c~: *  call-seq:
object.c~: * Document-method: included
object.c~: * call-seq:
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: *     obj.taint -> obj
object.c~: *  Marks <i>obj</i> as tainted---if the <code>$SAFE</code> level is
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: *     obj.untrust -> obj
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: * Document-class: NilClass
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: * Document-method: to_a
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: *  Document-class: TrueClass
object.c~: * call-seq:
object.c~: *  call-seq:
object.c~: *  And---Returns <code>false</code> if <i>obj</i> is
object.c~: *  call-seq:
object.c~: *  Or---Returns <code>true</code>. As <i>anObject</i> is an argument to
object.c~: *  a method call, it is always evaluated; there is no short-circuit
object.c~: *  call-seq:
object.c~: *  Exclusive Or---Returns <code>true</code> if <i>obj</i> is
object.c~: *  Document-class: FalseClass
object.c~: * call-seq:
object.c~: *  call-seq:
object.c~: *  And---Returns <code>false</code>. <i>obj</i> is always
object.c~: *  evaluated as it is the argument to a method call---there is no
object.c~: *  short-circuit evaluation in this case.
object.c~: *  call-seq:
object.c~: *  Or---Returns <code>false</code> if <i>obj</i> is
object.c~: *  call-seq:
object.c~: *  Exclusive Or---If <i>obj</i> is <code>nil</code> or
object.c~: *  call-seq:
object.c~: *  Pattern Match---Overridden by descendents (notably
object.c~: *  pattern-match semantics.
object.c~: *  call-seq:
object.c~: * Document-class: Module
object.c~: * call-seq:
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: *  Case Equality---Returns <code>true</code> if <i>anObject</i> is an
object.c~: * call-seq:
object.c~: * call-seq:
object.c~: * call-seq:
object.c~: * call-seq:
object.c~: *  call-seq:
object.c~: *     mod <=> other_mod   => -1, 0, +1, or nil
object.c~: *  Comparison---Returns -1 if <i>mod</i> includes <i>other_mod</i>, 0 if
object.c~:	return INT2FIX(-1);
object.c~:    RBASIC(mod)->klass = klass;
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~:    rb_make_metaclass(klass, RBASIC(super)->klass);
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: *     class.superclass -> a_super_class or nil
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: *     Math::HIGH_SCHOOL_PI - Math::PI              #=> 0.00126448926734968
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~:#define OutOfRange() (((w = end - p) > 20) ? (w = 20, ellipsis = "...") : (ellipsis = ""))
object.c~:	char *e = buf + sizeof(buf) - 1;
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~: *  call-seq:
object.c~:    RBASIC(RBASIC(klass)->klass)->klass = metametaclass;
object.c~: *  Document-class: Class
object.c~: *  Classes in Ruby are first-class objects---each is an instance of
object.c~: *  parentheses meta-classes. All metaclasses are instances 
object.c~: *                             +-----------------+
object.c~: *           BasicObject-->(BasicObject)         |
object.c~: *              Object---->(Object)              |
object.c~: *               |  |  +-----+  +---------+      |
object.c~: *               |  +-----------+         |      |
object.c~: *        +------+     |     Module--->(Module)  |
object.c~: *   OtherClass-->(OtherClass)  |         |      |
object.c~: *                            Class---->(Class)  |
object.c~: *                              +----------------+
object.c~: *  the built-in kernel functions globally accessible. Although the
object.c~:    rb_define_method(rb_mKernel, "methods", rb_obj_methods, -1);
object.c~:    rb_define_method(rb_mKernel, "singleton_methods", rb_obj_singleton_methods, -1); /* in class.c */
object.c~:    rb_define_method(rb_mKernel, "protected_methods", rb_obj_protected_methods, -1);
object.c~:    rb_define_method(rb_mKernel, "private_methods", rb_obj_private_methods, -1);
object.c~:    rb_define_method(rb_mKernel, "public_methods", rb_obj_public_methods, -1);
object.c~:    rb_define_global_function("sprintf", rb_f_sprintf, -1); /* in sprintf.c */
object.c~:    rb_define_global_function("format", rb_f_sprintf, -1);  /* in sprintf.c */
object.c~:    rb_define_private_method(rb_cModule, "attr", rb_mod_attr, -1);
object.c~:    rb_define_private_method(rb_cModule, "attr_reader", rb_mod_attr_reader, -1);
object.c~:    rb_define_private_method(rb_cModule, "attr_writer", rb_mod_attr_writer, -1);
object.c~:    rb_define_private_method(rb_cModule, "attr_accessor", rb_mod_attr_accessor, -1);
object.c~:    rb_define_method(rb_cModule, "instance_methods", rb_class_instance_methods, -1); /* in class.c */
object.c~:		     rb_class_public_instance_methods, -1);    /* in class.c */
object.c~:		     rb_class_protected_instance_methods, -1); /* in class.c */
object.c~:		     rb_class_private_instance_methods, -1);   /* in class.c */
object.c~:    rb_define_method(rb_cModule, "constants", rb_mod_constants, -1); /* in variable.c */
object.c~:    rb_define_method(rb_cModule, "const_get", rb_mod_const_get, -1);
object.c~:    rb_define_method(rb_cModule, "const_defined?", rb_mod_const_defined, -1);
object.c~:    rb_define_method(rb_cClass, "new", rb_class_new_instance, -1);
object.c~:    rb_define_method(rb_cClass, "initialize", rb_class_initialize, -1);
ãã¤ããªã¼ã»ãã¡ã¤ã«object.oã¯ä¸è´ãã¾ãã
opt_sc.inc:/* -*-c-*- *********************************************************/
opt_sc.inc:  ----
optinsn.inc:/* -*-c-*- *********************************************************/
optinsn.inc:  ----
optinsn.inc:  switch(insnobj->insn_id){
optunifs.inc:/* -*-c-*- *********************************************************/
optunifs.inc:  ----
pack.c:  pack.c -
pack.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
pack.c:# define OFF16B(p) ((char*)(p) + (natint?0:(sizeof(short) - SIZE16)))
pack.c:# define OFF32B(p) ((char*)(p) + (natint?0:(sizeof(long) - SIZE32)))
pack.c:	t[sizeof(xtype)-i-1] = s[i];	\
pack.c:# define EXTEND32(x) do { if (!natint) {(x) = (((1L<<31)-1-(x))^~(~0L<<31));}} while(0)
pack.c:# define EXTEND16(x) do { if (!natint) {(x) = (short)(((1<<15)-1-(x))^~(~0<<15));}} while(0)
pack.c: *  call-seq:
pack.c: *     arr.pack ( aTemplateString ) -> aBinaryString
pack.c: *  platform-independent size. Spaces are ignored in the template
pack.c: *   ---------------------------------------------------------------
pack.c: *       D, d  |  Double-precision float, native format
pack.c: *       E     |  Double-precision float, little-endian byte order
pack.c: *       e     |  Single-precision float, little-endian byte order
pack.c: *       F, f  |  Single-precision float, native format
pack.c: *       G     |  Double-precision float, network (big-endian) byte order
pack.c: *       g     |  Single-precision float, network (big-endian) byte order
pack.c: *       N     |  Long, network (big-endian) byte order
pack.c: *       n     |  Short, network (big-endian) byte-order
pack.c: *       P     |  Pointer to a structure (fixed-length string)
pack.c: *       p     |  Pointer to a null-terminated string
pack.c: *       Q, q  |  64-bit number
pack.c: *       U     |  UTF-8
pack.c: *       u     |  UU-encoded string
pack.c: *       V     |  Long, little-endian byte order
pack.c: *       v     |  Short, little-endian byte order
pack.c: *       w     |  BER-compressed integer\fnm
pack.c:    int enc_info = 1;		/* 0 - BINARY, 1 - US-ASCII, 2 - UTF-8 */
pack.c:#define NEXTFROM (items-- > 0 ? RARRAY_PTR(ary)[idx++] : TOO_FEW)
pack.c:	    /* if encoding is US-ASCII, upgrade to UTF-8 */
pack.c:	    /* keep US-ASCII (do nothing) */
pack.c:	    if (p[-1] == '*')
pack.c:		    if (p[-1] == '*' && type == 'Z')
pack.c:		    len -= plen;
pack.c:			len -= 10;
pack.c:			j = (len - plen + 1)/2;
pack.c:			byte >>= 7 - (len & 7);
pack.c:			j = (len - plen + 1)/2;
pack.c:			byte <<= 7 - (len & 7);
pack.c:			j = (len + 1) / 2 - (plen + 1) / 2;
pack.c:			j = (len + 1) / 2 - (plen + 1) / 2;
pack.c:	    while (len-- > 0) {
pack.c:	    while (len-- > 0) {
pack.c:	    while (len-- > 0) {
pack.c:	    while (len-- > 0) {
pack.c:	    while (len-- > 0) {
pack.c:	  case 'n':		/* unsigned short (network byte-order)  */
pack.c:	    while (len-- > 0) {
pack.c:	  case 'N':		/* unsigned long (network byte-order) */
pack.c:	    while (len-- > 0) {
pack.c:	  case 'v':		/* unsigned short (VAX byte-order) */
pack.c:	    while (len-- > 0) {
pack.c:	  case 'V':		/* unsigned long (VAX byte-order) */
pack.c:	    while (len-- > 0) {
pack.c:	    while (len-- > 0) {
pack.c:	  case 'e':		/* single precision float in VAX byte-order */
pack.c:	    while (len-- > 0) {
pack.c:	  case 'E':		/* double precision float in VAX byte-order */
pack.c:	    while (len-- > 0) {
pack.c:	    while (len-- > 0) {
pack.c:	  case 'g':		/* single precision float in network byte-order */
pack.c:	    while (len-- > 0) {
pack.c:	  case 'G':		/* double precision float in network byte-order */
pack.c:	    while (len-- > 0) {
pack.c:		len -= 10;
pack.c:	    rb_str_set_len(res, plen - len);
pack.c:	    len -= RSTRING_LEN(res);
pack.c:	    len = -len;
pack.c:	    while (len-- > 0) {
pack.c:		plen -= todo;
pack.c:	  case 'M':		/* quoted-printable encoded string */
pack.c:	    while (len-- > 0) {
pack.c:	    while (len-- > 0) {
pack.c:		    bufe = bufs + RSTRING_LEN(buf) - 1;
pack.c:			*bufe-- = c;
pack.c:	/* do nothing, keep ASCII-8BIT */
pack.c:"`!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_";
pack.c:        while (len >= 3 && sizeof(buff)-i >= 4) {
pack.c:            len -= 3;
pack.c:        if (sizeof(buff)-i < 4) {
pack.c:	if (i > 1024 - 5) {
pack.c:        return c - '0';
pack.c:	return c - 'a' + 10;
pack.c:	return c - 'A' + 10;
pack.c:	return -1;
pack.c:    if (len > (send-s)/sz) {			\
pack.c:	    tmp = len-(send-s)/sz;		\
pack.c:	len = (send-s)/sz;			\
pack.c:#define PACK_ITEM_ADJUST() while (tmp--) rb_ary_push(ary, Qnil)
pack.c: *  call-seq:
pack.c: *  format string consists of a sequence of single-character directives,
pack.c: *  platform-independent consistent size. Spaces are ignored in the
pack.c: *     "\xfe\xff\xfe\xff".unpack('sS')     #=> [-2, 65534]
pack.c: *     -------+---------+-----------------------------------------
pack.c: *     -------+---------+-----------------------------------------
pack.c: *     -------+---------+-----------------------------------------
pack.c: *     -------+---------+-----------------------------------------
pack.c: *     -------+---------+-----------------------------------------
pack.c: *     -------+---------+-----------------------------------------
pack.c: *     -------+---------+-----------------------------------------
pack.c: *     -------+---------+-----------------------------------------
pack.c: *            |         | a double in little-endian byte order
pack.c: *     -------+---------+-----------------------------------------
pack.c: *            |         | a float in little-endian byte order
pack.c: *     -------+---------+-----------------------------------------
pack.c: *     -------+---------+-----------------------------------------
pack.c: *     -------+---------+-----------------------------------------
pack.c: *     -------+---------+-----------------------------------------
pack.c: *     -------+---------+-----------------------------------------
pack.c: *     -------+---------+-----------------------------------------
pack.c: *     -------+---------+-----------------------------------------
pack.c: *     -------+---------+-----------------------------------------
pack.c: *     -------+---------+-----------------------------------------
pack.c: *     -------+---------+-----------------------------------------
pack.c: *       M    | String  | quoted-printable
pack.c: *     -------+---------+-----------------------------------------
pack.c: *       m    | String  | base64-encoded (RFC 2045) (default)
pack.c: *            |         | base64-encoded (RFC 4648) if followed by 0
pack.c: *     -------+---------+-----------------------------------------
pack.c: *     -------+---------+-----------------------------------------
pack.c: *     -------+---------+-----------------------------------------
pack.c: *     -------+---------+-----------------------------------------
pack.c: *            |         | pointer to a  null-terminated string
pack.c: *     -------+---------+-----------------------------------------
pack.c: *     -------+---------+-----------------------------------------
pack.c: *     -------+---------+-----------------------------------------
pack.c: *     -------+---------+-----------------------------------------
pack.c: *     -------+---------+-----------------------------------------
pack.c: *       U    | Integer | UTF-8 characters as unsigned integers
pack.c: *     -------+---------+-----------------------------------------
pack.c: *       u    | String  | UU-encoded
pack.c: *     -------+---------+-----------------------------------------
pack.c: *            |         | long in little-endian byte order
pack.c: *     -------+---------+-----------------------------------------
pack.c: *            |         | short in little-endian byte order
pack.c: *     -------+---------+-----------------------------------------
pack.c: *       w    | Integer | BER-compressed integer (see Array.pack)
pack.c: *     -------+---------+-----------------------------------------
pack.c: *       X    | ---     | skip backward one character
pack.c: *     -------+---------+-----------------------------------------
pack.c: *       x    | ---     | skip forward one character
pack.c: *     -------+---------+-----------------------------------------
pack.c: *     -------+---------+-----------------------------------------
pack.c: *       @    | ---     | skip to the offset given by the
pack.c: *     -------+---------+-----------------------------------------
pack.c:	    len = send - s;
pack.c:	    if (len > send - s) len = send - s;
pack.c:		char *t = s + len - 1;
pack.c:		    t--; len--;
pack.c:		if (len > send-s) len = send-s;
pack.c:		UNPACK_PUSH(infected_str_new(s, t-s, str));
pack.c:	    if (len > send - s) len = send - s;
pack.c:		if (p[-1] == '*' || len > (send - s) * 8)
pack.c:		    len = (send - s) * 8;
pack.c:		if (p[-1] == '*' || len > (send - s) * 8)
pack.c:		    len = (send - s) * 8;
pack.c:		if (p[-1] == '*' || len > (send - s) * 2)
pack.c:		    len = (send - s) * 2;
pack.c:		if (p[-1] == '*' || len > (send - s) * 2)
pack.c:		    len = (send - s) * 2;
pack.c:	    while (len-- > 0) {
pack.c:                if (c > (char)127) c-=256;
pack.c:	    while (len-- > 0) {
pack.c:	    while (len-- > 0) {
pack.c:	    while (len-- > 0) {
pack.c:	    while (len-- > 0) {
pack.c:	    while (len-- > 0) {
pack.c:	    while (len-- > 0) {
pack.c:	    while (len-- > 0) {
pack.c:	    while (len-- > 0) {
pack.c:	    while (len-- > 0) {
pack.c:	    while (len-- > 0) {
pack.c:	    while (len-- > 0) {
pack.c:	    while (len-- > 0) {
pack.c:	    while (len-- > 0) {
pack.c:	    while (len-- > 0) {
pack.c:	    while (len-- > 0) {
pack.c:	    while (len-- > 0) {
pack.c:	    while (len-- > 0) {
pack.c:	    while (len-- > 0) {
pack.c:	    while (len-- > 0) {
pack.c:	    if (len > send - s) len = send - s;
pack.c:		long alen = send - s;
pack.c:		s += alen; len--;
pack.c:		VALUE buf = infected_str_new(0, (send - s)*3/4, str);
pack.c:		    len = (*s++ - ' ') & 077;
pack.c:			len -= total - RSTRING_LEN(buf);
pack.c:			    a = (*s++ - ' ') & 077;
pack.c:			    b = (*s++ - ' ') & 077;
pack.c:			    c = (*s++ - ' ') & 077;
pack.c:			    d = (*s++ - ' ') & 077;
pack.c:			len -= mlen;
pack.c:		VALUE buf = infected_str_new(0, (send - s)*3/4, str);
pack.c:		int a = -1,b = -1,c = 0,d = 0;
pack.c:			b64_xtable[i] = -1;
pack.c:			a = b = c = d = -1;
pack.c:			if (s >= send || a == -1) rb_raise(rb_eArgError, "invalid base64");
pack.c:			if (s >= send || b == -1) rb_raise(rb_eArgError, "invalid base64");
pack.c:			if (s >= send || c == -1) rb_raise(rb_eArgError, "invalid base64");
pack.c:			if (d == -1) rb_raise(rb_eArgError, "invalid base64");
pack.c:		    if (c == -1) {
pack.c:		    else if (d == -1) {
pack.c:			a = b = c = d = -1;
pack.c:			while ((a = b64_xtable[(unsigned char)*s]) == -1 && s < send) {s++;}
pack.c:			while ((b = b64_xtable[(unsigned char)*s]) == -1 && s < send) {s++;}
pack.c:			while ((c = b64_xtable[(unsigned char)*s]) == -1 && s < send) {if (*s == '=') break; s++;}
pack.c:			while ((d = b64_xtable[(unsigned char)*s]) == -1 && s < send) {if (*s == '=') break; s++;}
pack.c:		    if (a != -1 && b != -1) {
pack.c:			if (c == -1 && *s == '=')
pack.c:			else if (c != -1 && *s == '=') {
pack.c:		rb_str_set_len(buf, ptr - RSTRING_PTR(buf));
pack.c:		VALUE buf = infected_str_new(0, send - s, str);
pack.c:			    if ((c1 = hex2num(*s)) == -1) break;
pack.c:			    if ((c2 = hex2num(*s)) == -1) break;
pack.c:		rb_str_set_len(buf, ptr - RSTRING_PTR(buf));
pack.c:	    if (len > s - RSTRING_PTR(str))
pack.c:	    s -= len;
pack.c:	    if (len > send - s)
pack.c:	    if (sizeof(char *) <= send - s) {
pack.c:	    if (len > (send - s) / sizeof(char *))
pack.c:		len = (send - s) / sizeof(char *);
pack.c:	    while (len-- > 0) {
pack.c:		if (send - s < sizeof(char *))
pack.c:		unsigned long ulmask = 0xfeUL << ((sizeof(unsigned long) - 1) * 8);
pack.c:			len--;
pack.c:				len--;
pack.c:	rb_raise(rb_eArgError, "malformed UTF-8 character");
pack.c:	rb_raise(rb_eArgError, "malformed UTF-8 character");
pack.c:	rb_raise(rb_eArgError, "malformed UTF-8 character (expected %ld bytes, given %ld bytes)",
pack.c:    *lenp = n--;
pack.c:	while (n--) {
pack.c:		*lenp -= n + 1;
pack.c:		rb_raise(rb_eArgError, "malformed UTF-8 character");
pack.c:    n = *lenp - 1;
pack.c:	rb_raise(rb_eArgError, "redundant UTF-8 sequence");
ãã¤ããªã¼ã»ãã¡ã¤ã«pack.oã¯ä¸è´ãã¾ãã
parse.c:/* Skeleton implementation for Bison's Yacc-like parsers in C
parse.c:   Boston, MA 02110-1301, USA.  */
parse.c:   simplifying the original so-called "semantic" parser.  */
parse.c:    EXPR_BEG,			/* ignore newline, +/- is a sign. */
parse.c:    EXPR_END,			/* newline significant, +/- is an operator. */
parse.c:    EXPR_ARG,			/* newline significant, +/- is an operator. */
parse.c:    EXPR_CMDARG,		/* newline significant, +/- is an operator. */
parse.c:    EXPR_MID,			/* newline significant, +/- is an operator. */
parse.c:        return tbl->pos;
parse.c:    tbl->pos = 0;
parse.c:    tbl->capa = 8;
parse.c:    tbl->tbl = ALLOC_N(ID, tbl->capa);
parse.c:    tbl->prev = prev;
parse.c:        if (tbl->tbl) {
parse.c:            xfree(tbl->tbl);
parse.c:    if (tbl->pos == tbl->capa) {
parse.c:        tbl->capa = tbl->capa * 2;
parse.c:        REALLOC_N(tbl->tbl, ID, tbl->capa);
parse.c:    tbl->tbl[tbl->pos++] = id;
parse.c:        for (i = 0; i < tbl->pos; i++) {
parse.c:            if (tbl->tbl[i] == id) {
parse.c:    |-----------+--------------+------------|
parse.c:                |<------------>|
parse.c:#define UTF8_ENC() (parser->utf8 ? parser->utf8 : \
parse.c:		    (parser->utf8 = rb_utf8_encoding()))
parse.c:#define STR_NEW(p,n) rb_enc_str_new((p),(n),parser->enc)
parse.c:#define STR_NEW0() rb_enc_str_new(0,0,parser->enc)
parse.c:#define STR_NEW2(p) rb_enc_str_new((p),strlen(p),parser->enc)
parse.c:#define STR_NEW3(p,n,e,func) parser_str_new((p),(n),(e),(func),parser->enc)
parse.c:#define TOK_INTERN(mb) rb_intern3(tok(), toklen(), parser->enc)
parse.c:#define lex_strterm		(parser->parser_lex_strterm)
parse.c:#define lex_state		(parser->parser_lex_state)
parse.c:#define cond_stack		(parser->parser_cond_stack)
parse.c:#define cmdarg_stack		(parser->parser_cmdarg_stack)
parse.c:#define class_nest		(parser->parser_class_nest)
parse.c:#define paren_nest		(parser->parser_paren_nest)
parse.c:#define lpar_beg		(parser->parser_lpar_beg)
parse.c:#define in_single		(parser->parser_in_single)
parse.c:#define in_def			(parser->parser_in_def)
parse.c:#define compile_for_eval	(parser->parser_compile_for_eval)
parse.c:#define cur_mid			(parser->parser_cur_mid)
parse.c:#define in_defined		(parser->parser_in_defined)
parse.c:#define tokenbuf		(parser->parser_tokenbuf)
parse.c:#define tokidx			(parser->parser_tokidx)
parse.c:#define toksiz			(parser->parser_toksiz)
parse.c:#define lex_input		(parser->parser_lex_input)
parse.c:#define lex_lastline		(parser->parser_lex_lastline)
parse.c:#define lex_nextline		(parser->parser_lex_nextline)
parse.c:#define lex_pbeg		(parser->parser_lex_pbeg)
parse.c:#define lex_p			(parser->parser_lex_p)
parse.c:#define lex_pend		(parser->parser_lex_pend)
parse.c:#define heredoc_end		(parser->parser_heredoc_end)
parse.c:#define command_start		(parser->parser_command_start)
parse.c:#define deferred_nodes		(parser->parser_deferred_nodes)
parse.c:#define lex_gets_ptr		(parser->parser_lex_gets_ptr)
parse.c:#define lex_gets		(parser->parser_lex_gets)
parse.c:#define lvtbl			(parser->parser_lvtbl)
parse.c:#define ruby__end__seen		(parser->parser_ruby__end__seen)
parse.c:#define ruby_sourceline		(parser->parser_ruby_sourceline)
parse.c:#define ruby_sourcefile		(parser->parser_ruby_sourcefile)
parse.c:#define yydebug			(parser->parser_yydebug)
parse.c:#define ruby_eval_tree		(parser->parser_eval_tree)
parse.c:#define ruby_eval_tree_begin	(parser->parser_eval_tree_begin)
parse.c:#define ruby_debug_lines	(parser->debug_lines)
parse.c:#define ruby_coverage		(parser->coverage)
parse.c:#define SIGN_EXTEND(x,n) (((1<<(n)-1)^((x)&~(~0<<(n))))-(1<<(n)-1))
parse.c:#define nd_term(node) ((signed short)(node)->u2.id)
parse.c:#define nd_term(node) SIGN_EXTEND((node)->u2.id, CHAR_BIT*2)
parse.c:#define nd_paren(node) (char)((node)->u2.id >> CHAR_BIT*2)
parse.c:# define compile_error parser->nerr++,rb_compile_error
parse.c:#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
parse.c:#   define YY_(msgid) dgettext ("bison-runtime", msgid)
parse.c:/* Suppress unused-variable warnings by "using" E.  */
parse.c:   /* Pacify GCC's `empty if-body' warning.  */
parse.c:       to allow for a few compiler-allocated temporary stack slots.  */
parse.c:# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
parse.c:	YYCOPY (&yyptr->Stack, Stack, yysize);				\
parse.c:	Stack = &yyptr->Stack;						\
parse.c:/* YYFINAL -- State number of the termination state.  */
parse.c:/* YYLAST -- Last index in YYTABLE.  */
parse.c:/* YYNTOKENS -- Number of terminals.  */
parse.c:/* YYNNTS -- Number of nonterminals.  */
parse.c:/* YYNRULES -- Number of rules.  */
parse.c:/* YYNRULES -- Number of states.  */
parse.c:/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
parse.c:/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
parse.c:/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
parse.c:/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
parse.c:     151,     0,    -1,    -1,   152,   153,    -1,   154,   319,    -1,
parse.c:     326,    -1,   155,    -1,   154,   325,   155,    -1,     1,   155,
parse.c:      -1,   160,    -1,    -1,    48,   156,   138,   153,   139,    -1,
parse.c:     158,   264,   237,   267,    -1,   159,   319,    -1,   326,    -1,
parse.c:     160,    -1,   159,   325,   160,    -1,     1,   160,    -1,    -1,
parse.c:      46,   181,   161,   181,    -1,    46,    55,    55,    -1,    46,
parse.c:      55,    65,    -1,    46,    55,    64,    -1,     6,   182,    -1,
parse.c:     160,    41,   163,    -1,   160,    42,   163,    -1,   160,    43,
parse.c:     163,    -1,   160,    44,   163,    -1,   160,    45,   160,    -1,
parse.c:      49,   138,   158,   139,    -1,   176,   110,   164,    -1,   169,
parse.c:     110,   164,    -1,   291,    88,   164,    -1,   221,   140,   194,
parse.c:     322,    88,   164,    -1,   221,   141,    53,    88,   164,    -1,
parse.c:     221,   141,    57,    88,   164,    -1,   221,    86,    53,    88,
parse.c:     164,    -1,   292,    88,   164,    -1,   176,   110,   202,    -1,
parse.c:     169,   110,   190,    -1,   169,   110,   202,    -1,   162,    -1,
parse.c:     164,    -1,   162,    38,   162,    -1,   162,    39,   162,    -1,
parse.c:      40,   320,   162,    -1,   124,   164,    -1,   187,    -1,   162,
parse.c:      -1,   168,    -1,   165,    -1,    31,   195,    -1,    22,   195,
parse.c:      -1,    23,   195,    -1,   254,    -1,   254,   141,   316,   196,
parse.c:      -1,   254,    86,   316,   196,    -1,    -1,    95,   167,   243,
parse.c:     158,   139,    -1,   315,   196,    -1,   315,   196,   166,    -1,
parse.c:     221,   141,   316,   196,    -1,   221,   141,   316,   196,   166,
parse.c:      -1,   221,    86,   316,   196,    -1,   221,    86,   316,   196,
parse.c:     166,    -1,    33,   196,    -1,    32,   196,    -1,   171,    -1,
parse.c:      90,   170,   321,    -1,   171,    -1,    90,   170,   321,    -1,
parse.c:     173,    -1,   173,   172,    -1,   173,    96,   175,    -1,   173,
parse.c:      96,   175,   142,   174,    -1,   173,    96,    -1,   173,    96,
parse.c:     142,   174,    -1,    96,   175,    -1,    96,   175,   142,   174,
parse.c:      -1,    96,    -1,    96,   142,   174,    -1,   175,    -1,    90,
parse.c:     170,   321,    -1,   172,   142,    -1,   173,   172,   142,    -1,
parse.c:     172,    -1,   174,   142,   172,    -1,   289,    -1,   221,   140,
parse.c:     194,   322,    -1,   221,   141,    53,    -1,   221,    86,    53,
parse.c:      -1,   221,   141,    57,    -1,   221,    86,    57,    -1,    87,
parse.c:      57,    -1,   292,    -1,   289,    -1,   221,   140,   194,   322,
parse.c:      -1,   221,   141,    53,    -1,   221,    86,    53,    -1,   221,
parse.c:     141,    57,    -1,   221,    86,    57,    -1,    87,    57,    -1,
parse.c:     292,    -1,    53,    -1,    57,    -1,    87,   177,    -1,   177,
parse.c:      -1,   221,    86,   177,    -1,    53,    -1,    57,    -1,    54,
parse.c:      -1,   184,    -1,   185,    -1,   179,    -1,   285,    -1,   180,
parse.c:      -1,   287,    -1,   181,    -1,    -1,   182,   142,   183,   181,
parse.c:      -1,   115,    -1,   116,    -1,   117,    -1,    70,    -1,    71,
parse.c:      -1,    72,    -1,    78,    -1,    79,    -1,   113,    -1,    74,
parse.c:      -1,   114,    -1,    75,    -1,    73,    -1,    84,    -1,    85,
parse.c:      -1,   118,    -1,   119,    -1,   120,    -1,    96,    -1,   121,
parse.c:      -1,   122,    -1,    69,    -1,   124,    -1,   125,    -1,    67,
parse.c:      -1,    68,    -1,    82,    -1,    83,    -1,   143,    -1,    50,
parse.c:      -1,    51,    -1,    52,    -1,    48,    -1,    49,    -1,    46,
parse.c:      -1,    38,    -1,     7,    -1,    22,    -1,    16,    -1,    17,
parse.c:      -1,     3,    -1,     5,    -1,    47,    -1,    27,    -1,    15,
parse.c:      -1,    14,    -1,    10,    -1,     9,    -1,    37,    -1,    21,
parse.c:      -1,    26,    -1,     4,    -1,    23,    -1,    35,    -1,    40,
parse.c:      -1,    39,    -1,    24,    -1,     8,    -1,    25,    -1,    31,
parse.c:      -1,    34,    -1,    33,    -1,    13,    -1,    36,    -1,     6,
parse.c:      -1,    18,    -1,    32,    -1,    11,    -1,    12,    -1,    19,
parse.c:      -1,    20,    -1,   203,    -1,   176,   110,   187,    -1,   176,
parse.c:     110,   187,    45,   187,    -1,   291,    88,   187,    -1,   291,
parse.c:      88,   187,    45,   187,    -1,   221,   140,   194,   322,    88,
parse.c:     187,    -1,   221,   141,    53,    88,   187,    -1,   221,   141,
parse.c:      57,    88,   187,    -1,   221,    86,    53,    88,   187,    -1,
parse.c:     221,    86,    57,    88,   187,    -1,    87,    57,    88,   187,
parse.c:      -1,   292,    88,   187,    -1,   187,    80,   187,    -1,   187,
parse.c:      81,   187,    -1,   187,   118,   187,    -1,   187,   119,   187,
parse.c:      -1,   187,   120,   187,    -1,   187,   121,   187,    -1,   187,
parse.c:     122,   187,    -1,   187,    69,   187,    -1,   123,    60,    69,
parse.c:     187,    -1,   123,    61,    69,   187,    -1,    67,   187,    -1,
parse.c:      68,   187,    -1,   187,   115,   187,    -1,   187,   116,   187,
parse.c:      -1,   187,   117,   187,    -1,   187,    70,   187,    -1,   187,
parse.c:     113,   187,    -1,   187,    74,   187,    -1,   187,   114,   187,
parse.c:      -1,   187,    75,   187,    -1,   187,    71,   187,    -1,   187,
parse.c:      72,   187,    -1,   187,    73,   187,    -1,   187,    78,   187,
parse.c:      -1,   187,    79,   187,    -1,   124,   187,    -1,   125,   187,
parse.c:      -1,   187,    84,   187,    -1,   187,    85,   187,    -1,   187,
parse.c:      76,   187,    -1,   187,    77,   187,    -1,    -1,    47,   320,
parse.c:     188,   187,    -1,   187,   111,   187,   320,   112,   187,    -1,
parse.c:     204,    -1,   186,    -1,   187,    -1,   326,    -1,   201,   323,
parse.c:      -1,   201,   142,   313,   323,    -1,   313,   323,    -1,   144,
parse.c:     194,   321,    -1,   326,    -1,   192,    -1,   326,    -1,   195,
parse.c:      -1,   168,    -1,   201,   199,    -1,   313,   199,    -1,   201,
parse.c:     142,   313,   199,    -1,   198,    -1,    -1,   197,   195,    -1,
parse.c:      97,   190,    -1,   142,   198,    -1,   142,    -1,   326,    -1,
parse.c:     189,    -1,   190,    -1,    96,   190,    -1,   201,   142,   190,
parse.c:      -1,   201,   142,    96,   190,    -1,   201,   142,   190,    -1,
parse.c:     201,   142,    96,   190,    -1,    96,   190,    -1,    93,   191,
parse.c:     145,    -1,   268,    -1,   269,    -1,   272,    -1,   273,    -1,
parse.c:     274,    -1,   277,    -1,   290,    -1,   292,    -1,    54,    -1,
parse.c:      -1,   222,   205,   157,   233,    -1,    -1,    91,   162,   206,
parse.c:     321,    -1,    90,   158,   146,    -1,   221,    86,    57,    -1,
parse.c:      87,    57,    -1,    93,   191,   145,    -1,    94,   312,   139,
parse.c:      -1,    31,    -1,    32,   144,   195,   321,    -1,    32,   144,
parse.c:     321,    -1,    32,    -1,    -1,    47,   320,   144,   207,   162,
parse.c:     321,    -1,    40,   144,   162,   321,    -1,    40,   144,   321,
parse.c:      -1,   315,   256,    -1,   255,    -1,   255,   256,    -1,    98,
parse.c:     248,    -1,   223,   163,   234,   158,   236,   233,    -1,   224,
parse.c:     163,   234,   158,   237,   233,    -1,    -1,    -1,   225,   208,
parse.c:     163,   235,   209,   158,   233,    -1,    -1,    -1,   226,   210,
parse.c:     163,   235,   211,   158,   233,    -1,   228,   163,   319,   260,
parse.c:     233,    -1,   227,   163,   319,   261,   233,    -1,   227,   319,
parse.c:     261,   233,    -1,    -1,    -1,   229,   238,    26,   212,   163,
parse.c:     235,   213,   158,   233,    -1,    -1,   230,   178,   293,   214,
parse.c:     157,   233,    -1,    -1,    -1,   230,    84,   162,   215,   324,
parse.c:     216,   157,   233,    -1,    -1,   231,   178,   217,   157,   233,
parse.c:      -1,    -1,   232,   179,   218,   295,   157,   233,    -1,    -1,
parse.c:      -1,   232,   310,   318,   219,   179,   220,   295,   157,   233,
parse.c:      -1,    22,    -1,    23,    -1,    24,    -1,    25,    -1,   204,
parse.c:      -1,     7,    -1,    11,    -1,    12,    -1,    19,    -1,    20,
parse.c:      -1,    16,    -1,    17,    -1,    21,    -1,     3,    -1,     4,
parse.c:      -1,     5,    -1,    10,    -1,   324,    -1,    13,    -1,   324,
parse.c:      13,    -1,   324,    -1,    28,    -1,   237,    -1,    14,   163,
parse.c:     234,   158,   236,    -1,   326,    -1,    15,   158,    -1,   176,
parse.c:      -1,   169,    -1,   298,    -1,    90,   241,   321,    -1,   239,
parse.c:      -1,   240,   142,   239,    -1,   240,    -1,   240,   142,    96,
parse.c:     298,    -1,   240,   142,    96,   298,   142,   240,    -1,   240,
parse.c:     142,    96,    -1,   240,   142,    96,   142,   240,    -1,    96,
parse.c:     298,    -1,    96,   298,   142,   240,    -1,    96,    -1,    96,
parse.c:     142,   240,    -1,   300,   142,   303,   142,   306,   309,    -1,
parse.c:     300,   142,   303,   142,   306,   142,   300,   309,    -1,   300,
parse.c:     142,   303,   309,    -1,   300,   142,   303,   142,   300,   309,
parse.c:      -1,   300,   142,   306,   309,    -1,   300,   142,    -1,   300,
parse.c:     142,   306,   142,   300,   309,    -1,   300,   309,    -1,   303,
parse.c:     142,   306,   309,    -1,   303,   142,   306,   142,   300,   309,
parse.c:      -1,   303,   309,    -1,   303,   142,   300,   309,    -1,   306,
parse.c:     309,    -1,   306,   142,   300,   309,    -1,   308,    -1,   326,
parse.c:      -1,   244,    -1,   115,   245,   115,    -1,    77,    -1,   115,
parse.c:     242,   245,   115,    -1,   326,    -1,   147,   246,    -1,   247,
parse.c:      -1,   246,   142,   247,    -1,    53,    -1,   297,    -1,    -1,
parse.c:     249,   250,   251,    -1,   144,   296,   245,   321,    -1,   296,
parse.c:      -1,   108,   158,   139,    -1,    30,   158,    10,    -1,    -1,
parse.c:      29,   253,   243,   158,    10,    -1,   168,   252,    -1,   254,
parse.c:     141,   316,   193,    -1,   254,    86,   316,   193,    -1,   315,
parse.c:     192,    -1,   221,   141,   316,   193,    -1,   221,    86,   316,
parse.c:     192,    -1,   221,    86,   317,    -1,   221,   141,   192,    -1,
parse.c:     221,    86,   192,    -1,    33,   192,    -1,    33,    -1,   221,
parse.c:     140,   194,   322,    -1,    -1,   138,   257,   243,   158,   139,
parse.c:      -1,    -1,    27,   258,   243,   158,    10,    -1,    18,    -1,
parse.c:     259,   200,   234,   158,   263,    -1,    18,   201,   234,   158,
parse.c:     262,    -1,   237,    -1,   261,    -1,   237,    -1,   260,    -1,
parse.c:       8,   265,   266,   234,   158,   264,    -1,   326,    -1,   190,
parse.c:      -1,   202,    -1,   326,    -1,    89,   176,    -1,   326,    -1,
parse.c:       9,   158,    -1,   326,    -1,   288,    -1,   285,    -1,   287,
parse.c:      -1,   270,    -1,    63,    -1,   271,    -1,   270,   271,    -1,
parse.c:     100,   279,   107,    -1,   101,   280,   107,    -1,   102,   280,
parse.c:      66,    -1,   103,   148,   107,    -1,   103,   275,   107,    -1,
parse.c:      -1,   275,   276,   148,    -1,   281,    -1,   276,   281,    -1,
parse.c:     104,   148,   107,    -1,   104,   278,   107,    -1,    -1,   278,
parse.c:      62,   148,    -1,    -1,   279,   281,    -1,    -1,   280,   281,
parse.c:      -1,    62,    -1,    -1,   106,   282,   284,    -1,    -1,   105,
parse.c:     283,   158,   139,    -1,    55,    -1,    56,    -1,    58,    -1,
parse.c:     292,    -1,    99,   286,    -1,   179,    -1,    56,    -1,    55,
parse.c:      -1,    58,    -1,    99,   280,   107,    -1,    60,    -1,    61,
parse.c:      -1,   123,    60,    -1,   123,    61,    -1,    53,    -1,    56,
parse.c:      -1,    55,    -1,    57,    -1,    58,    -1,    35,    -1,    34,
parse.c:      -1,    36,    -1,    37,    -1,    51,    -1,    50,    -1,    52,
parse.c:      -1,   289,    -1,   289,    -1,    64,    -1,    65,    -1,   324,
parse.c:      -1,    -1,   114,   294,   163,   324,    -1,     1,   324,    -1,
parse.c:     144,   296,   321,    -1,   296,   324,    -1,   300,   142,   304,
parse.c:     142,   306,   309,    -1,   300,   142,   304,   142,   306,   142,
parse.c:     300,   309,    -1,   300,   142,   304,   309,    -1,   300,   142,
parse.c:     304,   142,   300,   309,    -1,   300,   142,   306,   309,    -1,
parse.c:     300,   142,   306,   142,   300,   309,    -1,   300,   309,    -1,
parse.c:     304,   142,   306,   309,    -1,   304,   142,   306,   142,   300,
parse.c:     309,    -1,   304,   309,    -1,   304,   142,   300,   309,    -1,
parse.c:     306,   309,    -1,   306,   142,   300,   309,    -1,   308,    -1,
parse.c:      -1,    57,    -1,    56,    -1,    55,    -1,    58,    -1,   297,
parse.c:      -1,    53,    -1,   298,    -1,    90,   241,   321,    -1,   299,
parse.c:      -1,   300,   142,   299,    -1,    53,   110,   190,    -1,    53,
parse.c:     110,   221,    -1,   302,    -1,   303,   142,   302,    -1,   301,
parse.c:      -1,   304,   142,   301,    -1,   120,    -1,    96,    -1,   305,
parse.c:      53,    -1,   305,    -1,   117,    -1,    97,    -1,   307,    53,
parse.c:      -1,   142,   308,    -1,   326,    -1,   290,    -1,    -1,   144,
parse.c:     311,   162,   321,    -1,   326,    -1,   313,   323,    -1,   314,
parse.c:      -1,   313,   142,   314,    -1,   190,    89,   190,    -1,    59,
parse.c:     190,    -1,    53,    -1,    57,    -1,    54,    -1,    53,    -1,
parse.c:      57,    -1,    54,    -1,   184,    -1,    53,    -1,    54,    -1,
parse.c:     184,    -1,   141,    -1,    86,    -1,    -1,   325,    -1,    -1,
parse.c:     149,    -1,   320,   146,    -1,   320,   145,    -1,    -1,   149,
parse.c:      -1,   142,    -1,   147,    -1,   149,    -1,   324,    -1,   325,
parse.c:     147,    -1,    -1
parse.c:/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
parse.c:/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
parse.c:  "'>'", "'<'", "'|'", "'^'", "'&'", "'+'", "'-'", "'*'", "'/'", "'%'",
parse.c:/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
parse.c:   token YYLEX-NUM.  */
parse.c:/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
parse.c:/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
parse.c:/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
parse.c:   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
parse.c:/* YYDEFGOTO[NTERM-NUM].  */
parse.c:      -1,     1,     2,    65,    66,    67,   232,   554,   555,   244,
parse.c:/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
parse.c:   STATE-NUM.  */
parse.c:#define YYPACT_NINF -780
parse.c:    -780,   110,  2360,  -780,  7005,  -780,  -780,  -780,  6513,  -780,
parse.c:    -780,  -780,  -780,  -780,  -780,  -780,  -780,  7225,  7225,  -780,
parse.c:    -780,  7225,  3808,  3379,  -780,  -780,  -780,  -780,   113,  6372,
parse.c:      -1,  -780,    75,  -780,  -780,  -780,  2664,  3522,  -780,  -780,
parse.c:    2807,  -780,  -780,  -780,  -780,  -780,  -780,  8435,  8435,   119,
parse.c:    4886,  8545,  7445,  7775,  6779,  -780,  6231,  -780,  -780,  -780,
parse.c:      85,   104,   101,  8655,  8435,  -780,   -22,  -780,   830,   409,
parse.c:    -780,  -780,   156,   206,  -780,   186,  8765,  -780,   252,  2647,
parse.c:     207,   241,  -780,  8545,  8545,  -780,  -780,  5571,  8545,  8870,
parse.c:    8975,  9080,  6089,    37,    50,  -780,  -780,   290,  -780,  -780,
parse.c:    -780,  -780,  -780,  -780,  -780,  -780,   134,  -780,   309,   341,
parse.c:      39,  -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,
parse.c:    -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,
parse.c:    -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,
parse.c:    -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,
parse.c:    -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,
parse.c:    -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,
parse.c:    -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,
parse.c:    -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,
parse.c:     228,  -780,  -780,  -780,  -780,  -780,  -780,  -780,   262,  8435,
parse.c:     363,  5033,  8435,  8435,  8435,  -780,   325,  2647,   376,  -780,
parse.c:    -780,   299,   264,    47,   379,    58,   339,  -780,  -780,  -780,
parse.c:    5461,  -780,  7225,  7225,  -780,  -780,  5705,  -780,  8545,    90,
parse.c:    -780,   332,   353,  5180,   355,   366,  -780,   269,    39,   436,
parse.c:     482,  7115,  4886,   367,   -22,   830,    -1,   397,  -780,   409,
parse.c:     384,   -11,    45,  -780,   376,   377,    45,  -780,    -1,   464,
parse.c:     434,  9185,   390,  -780,   281,   291,   393,  -780,  1265,  -780,
parse.c:    -780,  -780,  -780,   418,  -780,   596,   623,   644,   430,   635,
parse.c:     432,    62,   477,   483,  -780,  -780,  -780,  -780,  -780,  -780,
parse.c:    -780,  5815,  8545,  8545,  8545,  8545,  7115,  8545,  8545,  -780,
parse.c:    -780,  7885,  -780,  4886,  6892,   426,  7885,  8435,  8435,  8435,
parse.c:    8545,  8545,   -22,   538,   413,   -22,   505,  -780,  -780,   400,
parse.c:     549,    42,    53,   315,   344,  8545,   420,  -780,    61,   414,
parse.c:    -780,  -780,  -780,   217,   270,   274,   282,   287,   348,   356,
parse.c:     371,   374,  -780,  -780,  -780,   386, 10466, 10466,  -780,  -780,
parse.c:    -780,  -780,  8655,  8655,  -780,   484,  -780,  -780,  -780,   108,
parse.c:    -780,  -780,  8435,  8435,  7335,  -780,  -780,  9608,  7225,  9686,
parse.c:    8435,  8435,  7555,  -780,    -1,   431,  -780,  -780,    -1,  -780,
parse.c:    -780,   105,  -780,  -780,  -780,  -780,  -780,  6513,  -780,  8435,
parse.c:    4471,   444,  9608,  9686,  8435,   830,    -1,  -780,  -780,  5944,
parse.c:     443,    -1,  -780,  7665,  -780,  -780,  7775,  -780,  -780,  -780,
parse.c:     332,   417,  -780,  -780,  -780,   451,  9185,  9764,  7225,  9842,
parse.c:     486,  -780,  -780,  -780,  -780,   887,  -780,  -780,  -780,  -780,
parse.c:    1360,    66,  -780,  -780,  -780,  -780,   461,  -780,   463,   566,
parse.c:     490,   575,  -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,
parse.c:    -780,  -780,  -780,  -780,    24,  -780,  -780,   500,  -780,  8435,
parse.c:    8435,  -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,
parse.c:     237,  8435,  -780,   510,   512,  -780,    -1,  9185,   515,  -780,
parse.c:    -780,  1937,  -780,  -780,   436,  1997,  1997,  1997,  1997,   748,
parse.c:    1560,  2950,  3896,  3093,  -780,   366,  -780,    -1,   513,  -780,
parse.c:     541,  -780,  -780,  3665,   628,   664,  -780,  4190,   665,  4618,
parse.c:    -780,   409,  -780,   417,  -780,   -22,  -780,  -780,  -780, 10076,
parse.c:    7225, 10154,  4043,  8545,  1276,  -780,  -780,  -780,  -780,  -780,
parse.c:    1240,  1240,   237,   237,  -780, 10523,  -780,  2647,  -780,  -780,
parse.c:    6513, 10544,  -780,  8435,   376,  -780,   339,  2520,  3236,    -1,
parse.c:     253,   266,  -780,  -780,  -780,  -780,  -780,  -780,  8545,  2647,
parse.c:     543,  -780,   366,   366,  2647,     5,   830,  -780,    45,  9185,
parse.c:     451,   352,    12,    -1,    93,    94,  8435,  -780,   887,   492,
parse.c:    -780,   542,    -1,  -780,   547,  5327,  5180,  -780,  1360,  -780,
parse.c:    -780,  1360,  -780,  -780,  1146,  -780,  -780,  5180,   604,  -780,
parse.c:    -780,  -780,   436,   436,  -780,  1125,  5327,  -780,  -780,   548,
parse.c:    8105,  -780,   451,  9185,  8435,   583,  8655,  8435,  -780,   484,
parse.c:     562,   556,  8655,  8655,  -780,  -780,   484,  -780,  -780,  -780,
parse.c:    8215,   701,  -780,   632,  -780,   701,  -780,  -780,  -780,  -780,
parse.c:     628,    44,  -780,  -780,   624,   628,    48,   141,    -1,    64,
parse.c:      81,  8545,   -22,  -780,  8545,  4043,   352,    12,  -780,    -1,
parse.c:     628,   105,  1360,  4043,   -22,  6654,  -780,  -780,  -780,  -780,
parse.c:    5327,  5180,  8435,   237,  -780,  -780,  -780,  8435,   361,  8435,
parse.c:    8435,   105,  -780,  -780,  -780,   368,  -780,    -1,   975,   578,
parse.c:    1378,  -780,   668,    -1,  -780,   727,   606,  -780,   601,   609,
parse.c:    -780,   610,  -780,   612,   610,   607,  -780,  -780,  -780,  -780,
parse.c:    -780,   638,   547,   640,   618,  -780,   621,   622,  -780,   755,
parse.c:    8435,   626,   451,  2647,  8435,  -780,  2647,  2647,  -780,  -780,
parse.c:    8655,  -780,  2647,  -780,  2647,  -780,   510,  -780,   677,  -780,
parse.c:    4752,   769,  -780,  8545,   628,  -780,   628,  5327,  5327,  -780,
parse.c:    8325,  4337,  7445,  -780,  -780,    70,  -780,  -780,   106,    33,
parse.c:    -780,   -22,   628,  -780,  -780,  -780,    -1,   628,  -780,  -780,
parse.c:     771,   643,  2647,  5180,  8435,  -780,  -780,   641,   975,   656,
parse.c:    -780,  -780,   642,  -780,  -780,  -780,  -780,  -780,  1360,  -780,
parse.c:    1146,  -780,  1146,  -780,  1146,  -780,  -780,  -780,  9290,   671,
parse.c:    -780,  1369,  -780,  1369,  -780,  1146,  -780,  -780,   645,  2647,
parse.c:    -780,  2647,  9395,    70,  -780,  -780,  5327,  -780,  -780,    70,
parse.c:    -780,  -780,   628,   628,  -780,   357,   647,  4337,  -780,  4043,
parse.c:    -780,  -780,  -780,  -780,  1276,  -780,  -780,   649,   975,   641,
parse.c:     975,   653,   668,   610,   658,   610,   610,   744,   433,  -780,
parse.c:     663,   666,   610,  -780,   667,   610,   746,  -780,   458,   291,
parse.c:     393,  4043,  -780,  4190,  -780,  -780,  -780,  -780,  -780,  -780,
parse.c:     373,  5327,   628,  4043,  -780,   641,   975,  -780,  -780,  1146,
parse.c:    -780,  -780,  -780,  -780, 10232,  1369,  -780,  1146,  -780,  -780,
parse.c:    1146,  -780,  -780,   417, 10310,  7225, 10388,   664,   632,  -780,
parse.c:    -780,  -780,   628,  -780,   628,   641,   610,   662,   669,   610,
parse.c:     672,   610,   610,   202,    12,    -1,   128,   145,  -780,  -780,
parse.c:    -780,  -780,  -780,  -780,  1146,  -780,  -780,  -780,   166,   610,
parse.c:    -780
parse.c:/* YYPGOTO[NTERM-NUM].  */
parse.c:    -780,  -780,  -780,   396,  -780,    38,  -780,  -550,   -31,  -780,
parse.c:     102,  -780,    25,    -6,   -46,  -780,  -301,  -780,    27,   729,
parse.c:    -139,   -13,   -62,  -780,  -410,   -24,  1109,  -313,   730,   -52,
parse.c:    -780,     0,  -780,  -780,    -3,  -780,  -780,   772,  -780,  -780,
parse.c:      68,    11,   -10,    74,  -299,    84,    49,  -780,  -252,  -207,
parse.c:    -780,   -45,  -290,  -780,   -20,  -780,  -780,  -780,  -780,  -780,
parse.c:    -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,
parse.c:    -780,     4,  -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,
parse.c:    -780,  -780,  -780,   334,  -337,  -528,  -136,  -573,  -780,  -698,
parse.c:    -702,   188,  -780,  -459,  -780,  -601,  -780,   -75,  -780,  -780,
parse.c:    -780,  -780,  -780,  -780,  -780,  -780,   735,  -780,  -780,  -780,
parse.c:    -100,  -552,  -780,  -780,  -126,  -780,  -780,  -780,  -780,  -780,
parse.c:    -780,   737,  -780,  -780,  -780,  -780,  -780,  -780,  -780,  -780,
parse.c:     617,  -216,  -780,  -780,  -780,    10,  -780,    20,  -780,   934,
parse.c:     747,  1417,  1103,  -780,  -780,   -48,  -248,  -705,   212,  -588,
parse.c:     364,  -628,  -779,   -14,   201,  -780,  -537,  -780,  -253,   157,
parse.c:    -780,  -780,  -780,   -41,  -276,  1842,  -260,  -780,  -780,   -63,
parse.c:     -27,    32,  -568,  -225,   172,   -28,    -2
parse.c:/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
parse.c:#define YYTABLE_NINF -572
parse.c:     757,   696,   575,   485,   773,   745,   378,   212,   -95,   263,
parse.c:     263,   263,   225,   545,   -98,   553,   249,   378,   339,  -102,
parse.c:     264,   342,   345,   556,   913,  -101,   473,   212,   212,   191,
parse.c:     -97,   212,   212,   349,   359,   359,   645,   672,  -283,   609,
parse.c:     384,   209,   218,   426,    68,   219,    68,   -99,   337,   337,
parse.c:       3,   759,   337,   337,   763,   -68,   590,   591,   801,   -89,
parse.c:     -91,   254,   806,   376,   487,   287,   612,   288,   777,   474,
parse.c:     475,   433,   -96,   730,   731,  -488,   899,   545,   434,   553,
parse.c:     818,   -97,   605,   297,   298,   414,   401,   -82,   227,   633,
parse.c:     605,   823,  -283,  -283,   415,   416,  -550,   -95,   -99,   385,
parse.c:     612,   282,   283,   623,   506,   822,   913,  -100,  -102,   488,
parse.c:     243,   859,   659,   827,   646,   576,   240,   379,   377,   -96,
parse.c:     287,   428,   288,   223,   -87,   299,   810,   436,   379,   623,
parse.c:     -90,   287,  -549,   288,   434,   -94,   424,   844,   935,   444,
parse.c:     840,   -93,   421,   -89,   -91,    81,   -89,   472,   287,   396,
parse.c:     288,   243,   644,   233,   396,   -98,   429,   287,  -101,   288,
parse.c:     762,   410,  -488,   -91,   212,   224,   212,   212,   384,   247,
parse.c:     212,   440,   212,   278,   965,   -89,   -91,    81,   290,   -89,
parse.c:     -91,   263,   -89,   -91,   -95,    81,    81,   205,   -88,   205,
parse.c:     390,   391,   243,   757,   833,   -97,   -87,   -97,   430,   562,
parse.c:     508,   719,   565,   -92,   263,  -550,   493,   494,   495,   496,
parse.c:     247,   888,   -99,  -329,   -99,    81,   212,   212,   212,   212,
parse.c:      81,   212,   212,  -481,   404,   212,   407,    81,   264,   623,
parse.c:     212,   904,   926,   -96,   664,   -96,   301,   337,   337,   337,
parse.c:      81,   739,  -546,   425,   212,   212,  -549,  -329,  -329,   -98,
parse.c:     397,   -98,   665,   606,   740,   422,  -480,   959,  -481,   212,
parse.c:    -482,   205,   306,   -97,   811,   337,   337,   447,  -483,   503,
parse.c:     387,  -547,   800,  -485,   512,   563,   -99,  -487,   788,  -553,
parse.c:      57,   703,   628,    68,   543,  -411,   410,   382,   497,   736,
parse.c:     797,  -475,   212,   743,   398,   399,   226,   988,   970,   398,
parse.c:     423,  -480,   778,   552,   191,  -482,   290,   617,   111,   543,
parse.c:     389,   448,   449,  -483,    81,   205,   263,   193,  -485,   383,
parse.c:    -478,  -487,  -487,    81,  -484,   392,   613,   194,  -553,   552,
parse.c:     615,   394,  -486,   616,   543,   444,   410,   297,   298,   834,
parse.c:     264,  -102,   212,  -546,  -411,  -475,  -475,  -475,   625,  -546,
parse.c:    -478,   602,   604,   627,   650,   393,   650,   400,   650,   472,
parse.c:     254,   -96,   585,   572,   826,   205,   418,   573,   887,  -276,
parse.c:     473,   402,  -547,   -94,  -478,  -478,   567,   263,  -547,  -484,
parse.c:    -553,   420,  -553,  -553,   442,   443,  -549,  -486,   668,   220,
parse.c:     579,   604,   675,  -284,   254,   307,  -411,   -67,  -411,  -411,
parse.c:     223,   264,  -475,   427,   290,  -478,   438,   290,   701,   944,
parse.c:     578,   626,   446,  -276,  -276,   678,   921,   482,   671,   486,
parse.c:     454,   687,   490,   692,   580,   581,   563,  -284,  -284,   552,
parse.c:     684,   684,   680,   621,   212,   -82,    81,   212,   687,   687,
parse.c:     668,   668,  -101,   629,   679,   205,   636,   191,   955,   956,
parse.c:     194,   687,   212,   -97,   -93,   652,   765,   655,   656,   683,
parse.c:      81,   -99,  -261,   263,   670,   -89,   975,   673,   473,   766,
parse.c:     767,    81,   768,   754,   726,   728,   -96,   643,    45,    46,
parse.c:     212,   680,   742,   -91,   750,   473,   212,   212,   799,   802,
parse.c:    -262,   802,   680,   802,   752,   784,   623,   473,   -88,   830,
parse.c:     861,   650,   650,   863,   865,   867,   872,   251,  -263,   875,
parse.c:     885,   895,   896,   898,   902,   845,   909,  -264,   934,   207,
parse.c:     939,   943,   897,   953,    81,   945,  -549,   212,   947,   950,
parse.c:     253,    81,    81,  -550,   984,    81,   620,   307,   347,   236,
parse.c:    -571,   307,   458,   457,     0,   459,     0,     0,  -571,  -571,
parse.c:    -571,     0,     0,  -571,  -571,  -571,   320,   321,  -571,     0,
parse.c:       0,   662,   663,   458,     0,     0,   963,     0,  -571,     0,
parse.c:     106,     0,   752,   207,     0,     0,     0,     0,  -571,  -571,
parse.c:       0,  -571,  -571,  -571,  -571,  -571,     0,     0,     0,     0,
parse.c:     451,   452,   453,   454,     0,     0,  -571,     0,     0,   450,
parse.c:       0,     0,   456,   457,     0,   207,     0,     0,     0,  -571,
parse.c:     265,  -571,   458,     0,   223,   459,  -571,  -571,     0,  -571,
parse.c:    -553,     0,   871,   265,     0,     0,     0,     0,  -553,  -553,
parse.c:    -553,     0,     0,     0,  -553,  -553,     0,     0,  -553,   106,
parse.c:     106,     0,   207,     0,   207,     0,     0,  -553,     0,     0,
parse.c:       0,   106,     0,     0,     0,     0,     0,     0,  -553,  -553,
parse.c:     106,  -553,  -553,  -553,  -553,  -553,   871,   265,     0,     0,
parse.c:       0,     0,     0,     0,     0,     0,     0,     0,     0,  -553,
parse.c:    -553,  -553,  -553,  -553,  -553,  -553,  -553,  -553,  -553,  -553,
parse.c:    -553,  -553,     0,     0,  -553,  -553,  -553,     0,   676,   106,
parse.c:     -98,  -553,     0,  -553,  -553,  -553,  -553,  -553,  -553,  -553,
parse.c:    -553,  -553,  -553,     0,     0,   109,     0,     0,     0,     0,
parse.c:       0,    78,     0,     0,     0,     0,     0,     0,  -553,  -553,
parse.c:    -553,  -553,   -90,     0,     0,     0,  -553,  -553,   108,  -553,
parse.c:       0,     0,   108,   108,     0,     0,   307,  -572,  -572,  -572,
parse.c:    -572,   312,   313,     0,   108,  -572,  -572,     0,     0,  -239,
parse.c:    -571,     4,     0,     5,     6,     7,     8,     9,     0,     0,
parse.c:       0,     0,     0,     0,     0,     0,     0,  -571,     0,  -571,
parse.c:    -553,     0,     0,     0,     0,     0,     0,     0,  -553,  -553,
parse.c:    -553,     0,   238,  -553,  -553,  -553,     0,     0,  -553,     0,
parse.c:       0,     0,     0,     0,     0,     0,     0,  -553,  -553,  -553,
parse.c:    -553,     0,     0,     0,     0,     0,     0,     0,  -553,  -553,
parse.c:       0,  -553,  -553,  -553,  -553,  -553,     0,     0,     0,     0,
parse.c:       0,   238,   238,     0,     0,     0,     0,     0,     0,  -553,
parse.c:    -553,  -553,  -553,  -553,  -553,  -553,  -553,  -553,  -553,  -553,
parse.c:    -553,  -553,     0,     0,  -553,  -553,  -553,     0,   737,  -553,
parse.c:       0,     0,     0,     0,     0,  -553,     0,     0,     0,     0,
parse.c:       0,     0,   238,     0,     0,     0,   238,     0,  -553,     0,
parse.c:     -98,  -553,  -553,  -553,  -553,  -553,  -553,  -553,  -553,  -553,
parse.c:    -553,  -553,  -553,     0,     0,     0,     0,     0,     0,     0,
parse.c:       0,     0,   238,     0,   238,     0,     0,     0,  -553,  -553,
parse.c:    -553,  -553,  -553,     0,  -475,  -553,  -553,  -553,     0,  -553,
parse.c:       0,     0,  -475,  -475,  -475,     0,   238,  -475,  -475,  -475,
parse.c:       0,     0,  -475,     0,     0,     0,     0,     0,     0,     0,
parse.c:    -475,     0,  -475,  -475,  -475,     0,     0,     0,     0,     0,
parse.c:     238,     0,  -475,  -475,     0,  -475,  -475,  -475,  -475,  -475,
parse.c:       0,   320,   321,  -475,  -475,  -475,  -475,  -475,  -475,  -475,
parse.c:    -475,  -475,  -475,  -475,  -475,  -475,     0,     0,  -475,  -475,
parse.c:    -475,     0,  -475,  -475,     0,     0,     0,     0,   322,  -475,
parse.c:       0,     0,  -475,     0,  -475,  -475,  -475,  -475,  -475,  -475,
parse.c:    -475,  -475,  -475,  -475,  -475,  -475,  -475,     0,     0,     0,
parse.c:       0,     0,     0,  -475,  -475,  -475,  -475,  -478,     0,  -475,
parse.c:    -475,  -475,     0,  -475,     0,  -478,  -478,  -478,     0,     0,
parse.c:    -478,  -478,  -478,     0,     0,  -478,     0,     0,     0,     0,
parse.c:       0,     0,     0,  -478,     0,  -478,  -478,  -478,     0,     0,
parse.c:       0,     0,     0,     0,     0,  -478,  -478,     0,  -478,  -478,
parse.c:    -478,  -478,  -478,     0,     0,     0,     0,     0,     0,   307,
parse.c:    -572,  -572,     0,     0,   320,   321,  -478,  -478,  -478,  -478,
parse.c:    -478,  -478,  -478,  -478,  -478,  -478,  -478,  -478,  -478,     0,
parse.c:       0,  -478,  -478,  -478,     0,  -478,  -478,     0,     0,     0,
parse.c:       0,     0,  -478,   323,   324,   325,   326,   327,   328,   329,
parse.c:     330,   331,   332,     0,     0,  -478,     0,  -478,  -478,  -478,
parse.c:    -478,  -478,  -478,  -478,  -478,  -478,  -478,  -478,  -478,  -478,
parse.c:       0,     0,     0,     0,     0,     0,  -478,  -478,  -478,  -478,
parse.c:    -554,     0,  -478,  -478,  -478,     0,  -478,     0,  -554,  -554,
parse.c:    -554,     0,     0,  -554,  -554,  -554,     0,     0,  -554,     0,
parse.c:       0,     0,     0,     0,     0,     0,     0,  -554,  -554,  -554,
parse.c:    -554,     0,     0,     0,     0,     0,     0,     0,  -554,  -554,
parse.c:       0,  -554,  -554,  -554,  -554,  -554,     0,     0,     0,     0,
parse.c:       0,     0,     0,     0,     0,     0,     0,     0,     0,  -554,
parse.c:    -554,  -554,  -554,  -554,  -554,  -554,  -554,  -554,  -554,  -554,
parse.c:    -554,  -554,     0,     0,  -554,  -554,  -554,     0,     0,  -554,
parse.c:       0,     0,     0,     0,     0,  -554,     0,     0,     0,     0,
parse.c:       0,     0,     0,     0,     0,     0,     0,     0,  -554,     0,
parse.c:       0,  -554,  -554,  -554,  -554,  -554,  -554,  -554,  -554,  -554,
parse.c:    -554,  -554,  -554,     0,     0,     0,     0,     0,     0,     0,
parse.c:       0,     0,     0,     0,     0,     0,     0,     0,  -554,  -554,
parse.c:    -554,  -554,  -554,  -555,     0,  -554,  -554,  -554,     0,  -554,
parse.c:       0,  -555,  -555,  -555,     0,     0,  -555,  -555,  -555,     0,
parse.c:       0,  -555,     0,     0,     0,     0,     0,     0,     0,     0,
parse.c:    -555,  -555,  -555,  -555,     0,     0,     0,     0,     0,     0,
parse.c:       0,  -555,  -555,     0,  -555,  -555,  -555,  -555,  -555,     0,
parse.c:       0,     0,  -555,  -555,  -555,  -555,  -555,  -555,  -555,  -555,
parse.c:    -555,  -555,  -555,  -555,  -555,     0,     0,  -555,  -555,  -555,
parse.c:       0,     0,  -555,     0,     0,     0,     0,     0,  -555,     0,
parse.c:       0,  -555,     0,     0,  -555,  -555,  -555,  -555,  -555,  -555,
parse.c:    -555,  -555,  -555,  -555,  -555,  -555,     0,     0,     0,     0,
parse.c:       0,  -555,  -555,  -555,  -555,  -555,  -283,     0,  -555,  -555,
parse.c:    -555,     0,  -555,     0,  -283,  -283,  -283,     0,     0,  -283,
parse.c:    -283,  -283,     0,     0,  -283,     0,     0,     0,     0,     0,
parse.c:       0,     0,     0,     0,  -283,  -283,  -283,     0,     0,     0,
parse.c:       0,     0,     0,     0,  -283,  -283,     0,  -283,  -283,  -283,
parse.c:    -283,  -283,     0,     0,     0,     0,     0,     0,     0,     0,
parse.c:       0,     0,     0,     0,     0,  -283,  -283,  -283,  -283,  -283,
parse.c:    -283,  -283,  -283,  -283,  -283,  -283,  -283,  -283,     0,     0,
parse.c:    -283,  -283,  -283,     0,   677,  -283,     0,     0,     0,     0,
parse.c:       0,  -283,     0,     0,     0,     0,     0,     0,     0,     0,
parse.c:       0,     0,     0,     0,  -283,     0,  -100,  -283,  -283,  -283,
parse.c:    -283,  -283,  -283,  -283,  -283,  -283,  -283,  -283,  -283,     0,
parse.c:       0,     0,     0,     0,     0,  -283,  -283,  -283,  -283,  -410,
parse.c:       0,  -283,  -283,  -283,     0,  -283,     0,  -410,  -410,  -410,
parse.c:       0,     0,  -410,  -410,  -410,     0,     0,  -410,     0,     0,
parse.c:       0,     0,     0,     0,     0,     0,  -410,  -410,  -410,     0,
parse.c:       0,     0,     0,     0,     0,     0,     0,  -410,  -410,     0,
parse.c:    -410,  -410,  -410,  -410,  -410,     0,     0,     0,     0,     0,
parse.c:       0,     0,     0,     0,     0,     0,     0,     0,  -410,  -410,
parse.c:    -410,  -410,  -410,  -410,  -410,  -410,  -410,  -410,  -410,  -410,
parse.c:    -410,     0,     0,  -410,  -410,  -410,     0,     0,  -410,     0,
parse.c:       0,     0,     0,     0,  -410,     0,     0,     0,     0,     0,
parse.c:    -410,     0,  -410,  -410,  -410,  -410,  -410,  -410,  -410,  -410,
parse.c:    -410,  -410,     0,     0,     0,     0,     0,     0,     0,     0,
parse.c:       0,     0,     0,     0,     0,     0,     0,  -410,  -410,  -410,
parse.c:    -410,  -410,  -277,   223,  -410,  -410,  -410,     0,  -410,     0,
parse.c:    -277,  -277,  -277,     0,     0,  -277,  -277,  -277,     0,     0,
parse.c:    -277,     0,     0,     0,     0,     0,     0,     0,     0,     0,
parse.c:    -277,  -277,  -277,     0,     0,     0,     0,     0,     0,     0,
parse.c:    -277,  -277,     0,  -277,  -277,  -277,  -277,  -277,     0,     0,
parse.c:       0,  -277,  -277,  -277,  -277,  -277,  -277,  -277,  -277,  -277,
parse.c:    -277,  -277,  -277,  -277,     0,     0,  -277,  -277,  -277,     0,
parse.c:       0,  -277,     0,     0,     0,     0,     0,  -277,     0,     0,
parse.c:    -277,     0,     0,  -277,  -277,  -277,  -277,  -277,  -277,  -277,
parse.c:    -277,  -277,  -277,  -277,  -277,     0,     0,     0,     0,     0,
parse.c:       0,  -277,  -277,  -277,  -277,  -571,     0,  -277,  -277,  -277,
parse.c:       0,  -277,     0,  -571,  -571,  -571,     0,     0,  -571,  -571,
parse.c:    -571,     0,     0,  -571,     0,     0,     0,     0,     0,     0,
parse.c:       0,     0,  -571,  -571,  -571,     0,     0,     0,     0,     0,
parse.c:       0,     0,     0,  -571,  -571,     0,  -571,  -571,  -571,  -571,
parse.c:    -571,     0,     0,     0,     0,     0,     0,     0,     0,     0,
parse.c:       0,     0,     0,     0,  -571,  -571,  -571,  -571,  -571,  -571,
parse.c:    -571,  -571,  -571,  -571,  -571,  -571,  -571,     0,     0,  -571,
parse.c:    -571,  -571,     0,     0,  -571,     0,     0,     0,     0,     0,
parse.c:    -571,     0,     0,     0,     0,     0,     0,     0,     0,     0,
parse.c:       0,     0,     0,     0,     0,     0,  -571,     0,  -571,  -571,
parse.c:    -571,  -571,  -571,  -571,  -571,  -571,  -571,  -571,     0,     0,
parse.c:       0,     0,     0,  -571,  -571,  -571,  -571,  -571,  -290,   223,
parse.c:    -571,  -571,  -571,     0,  -571,     0,  -290,  -290,  -290,     0,
parse.c:       0,  -290,  -290,  -290,     0,     0,  -290,     0,     0,     0,
parse.c:       0,     0,     0,     0,     0,     0,  -290,  -290,     0,     0,
parse.c:       0,     0,     0,     0,     0,     0,  -290,  -290,     0,  -290,
parse.c:    -290,  -290,  -290,  -290,     0,     0,     0,     0,     0,     0,
parse.c:       0,     0,     0,     0,     0,     0,     0,  -290,  -290,  -290,
parse.c:    -290,  -290,  -290,  -290,  -290,  -290,  -290,  -290,  -290,  -290,
parse.c:       0,     0,  -290,  -290,  -290,     0,  -283,  -290,     0,     0,
parse.c:       0,     0,     0,  -290,  -283,  -283,  -283,     0,     0,     0,
parse.c:    -283,  -283,     0,     0,  -283,     0,     0,     0,     0,  -290,
parse.c:       0,  -290,  -290,  -290,  -290,  -290,  -290,  -290,  -290,  -290,
parse.c:    -290,     0,     0,     0,  -283,  -283,     0,  -283,  -283,  -283,
parse.c:    -283,  -283,     0,     0,     0,     0,     0,  -290,  -290,  -290,
parse.c:    -290,     0,   220,  -290,  -290,  -290,     0,  -290,     0,     0,
parse.c:       0,     0,     0,     0,     0,  -283,  -283,  -283,  -283,  -283,
parse.c:    -283,  -283,  -283,  -283,  -283,  -283,  -283,  -283,     0,     0,
parse.c:    -283,  -283,  -283,     0,   677,     0,     0,     0,     0,     0,
parse.c:       0,     0,     0,     0,     0,     0,  -100,  -283,     0,  -283,
parse.c:    -283,  -283,  -283,  -283,  -283,  -283,  -283,  -283,  -283,     0,
parse.c:       0,     0,     0,     0,     0,  -283,  -283,  -283,   -92,     0,
parse.c:       0,     0,  -283,  -283,   241,  -283,     5,     6,     7,     8,
parse.c:       9,  -571,  -571,  -571,    10,    11,     0,     0,  -571,    12,
parse.c:    -571,   241,  -571,     5,     6,     7,     8,     9,     0,     0,
parse.c:    -571,    10,    11,     0,  -571,  -571,    12,    13,     0,    14,
parse.c:       0,     0,     0,     0,     0,     0,     0,  -571,   241,  -571,
parse.c:       5,     6,     7,     8,     9,     0,     0,  -571,    10,    11,
parse.c:       0,     0,  -571,    12,    13,  -571,    14,    15,    16,    17,
parse.c:       0,     0,    10,    11,  -571,     0,  -571,    12,    13,     0,
parse.c:    -571,     0,     0,     0,     0,     0,     0,     0,  -571,   241,
parse.c:    -571,     5,     6,     7,     8,     9,     0,     0,  -571,    10,
parse.c:      11,     0,     0,  -571,    12,    13,     0,    14,    15,    16,
parse.c:       0,  -571,  -571,    10,    11,  -571,     0,  -571,    12,    13,
parse.c:       6,     7,     8,     9,     0,     0,     0,    10,    11,  -571,
parse.c:       0,  -571,    12,    13,     0,    14,    15,    16,    17,    18,
parse.c:       0,     0,  -571,  -571,   241,  -571,     5,     6,     7,     8,
parse.c:       0,     0,     0,     0,     0,     0,     0,     0,     0,  -571,
parse.c:    -571,   241,  -571,     5,     6,     7,     8,     9,     0,     0,
parse.c:       0,     0,     0,     0,     0,     0,     0,     0,     0,  -571,
parse.c:       0,     0,     0,     0,     0,     0,     0,  -571,   241,  -571,
parse.c:       5,     6,     7,     8,     9,     0,     0,  -571,    10,    11,
parse.c:       0,     0,    10,    11,  -571,     0,  -571,    12,    13,     0,
parse.c:     638,   639,   872,    -1,    -1,    -1,   887,    -1,   826,    -1,
parse.c:      -1,    -1,   858,   115,   116,   117,   118,   119,   120,   121,
parse.c:     122,    41,    42,    43,    44,    45,   872,    -1,   810,    -1,
parse.c:     876,    -1,    -1,   885,   712,    -1,    -1,    -1,    -1,    -1,
parse.c:     921,   887,   923,   889,    -1,    -1,   724,    -1,   564,    -1,
parse.c:     931,   903,   904,   905,   906,    -1,    -1,    -1,   910,   911,
parse.c:     912,    -1,   914,   915,    -1,   758,   759,    -1,   761,    -1,
parse.c:     763,   764,    -1,    -1,    -1,   921,    -1,   923,   930,    -1,
parse.c:      -1,   774,    -1,   776,   777,   931,     2,   933,     4,    -1,
parse.c:      53,   944,    55,    56,    57,    58,   956,    -1,   975,    -1,
parse.c:      -1,   954,    -1,   955,    -1,   957,   958,    -1,    -1,   955,
parse.c:     748,    -1,   750,    -1,   966,    -1,    -1,   969,   970,   971,
parse.c:     972,   199,    -1,    -1,   202,   203,   204,    90,    -1,    -1,
parse.c:      -1,    -1,   955,    96,    50,    -1,    -1,   989,    54,    -1,
parse.c:      -1,   819,   220,   821,   222,   223,    69,    70,    71,    72,
parse.c:      73,    74,    75,    76,    77,    78,    79,    80,    81,    -1,
parse.c:      76,    84,    85,    -1,    -1,   651,    -1,    -1,   654,    -1,
parse.c:      -1,    -1,    -1,    89,    90,    91,    92,    -1,    53,   665,
parse.c:      55,    56,    57,    58,   700,    -1,    -1,    -1,   111,   705,
parse.c:     838,   839,    -1,    -1,   720,    -1,    -1,    -1,    -1,    -1,
parse.c:     903,   904,   905,   906,    -1,    90,    -1,   910,   911,   912,
parse.c:      -1,   914,   915,   301,    -1,    -1,   149,    -1,   306,   307,
parse.c:     328,   329,   330,   331,   332,     2,   334,     4,    -1,    -1,
parse.c:     898,     2,   900,     4,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,   966,    -1,    -1,   969,   970,   971,   972,
parse.c:      -1,    -1,    -1,    -1,    -1,   201,    69,    -1,   804,    -1,
parse.c:     806,    -1,    -1,    -1,    -1,    -1,   989,    -1,   936,    -1,
parse.c:      -1,    84,    85,    50,   382,   383,   822,    54,    -1,    50,
parse.c:      -1,   827,    -1,    -1,   392,   393,   394,   233,    -1,    -1,
parse.c:     398,    -1,   400,   401,   402,   241,   242,    -1,    53,    76,
parse.c:      -1,   419,    89,    90,    91,   261,   424,    -1,    89,    53,
parse.c:      -1,    55,    56,    57,    58,   433,    -1,    -1,   436,    -1,
parse.c:      -1,    -1,   848,    -1,   850,    90,   882,   883,   854,    -1,
parse.c:     448,    96,    97,    -1,    -1,   291,    -1,   863,    -1,   865,
parse.c:     296,    -1,    -1,    -1,    -1,    -1,    90,   303,   304,    -1,
parse.c:       0,    69,   117,    97,    -1,   120,    -1,    -1,     8,     9,
parse.c:      10,    -1,    -1,    13,    14,    15,    84,    85,    18,    -1,
parse.c:      -1,   489,   490,   117,    -1,    -1,   932,    -1,    28,    -1,
parse.c:     336,    -1,   147,   501,    -1,    -1,    -1,    -1,    38,    39,
parse.c:      -1,    41,    42,    43,    44,    45,    -1,    -1,    -1,    -1,
parse.c:     118,   119,   120,   121,   122,    -1,   962,    -1,   964,    -1,
parse.c:      -1,    -1,    -1,   939,   201,    -1,    -1,    -1,    -1,   945,
parse.c:     201,   947,    -1,    -1,   950,    -1,    -1,    -1,    53,    -1,
parse.c:      55,    56,    57,    58,    -1,    -1,    86,    -1,    -1,    53,
parse.c:      -1,    55,    56,    57,    58,   563,   233,    -1,    -1,    -1,
parse.c:     568,    -1,   233,    -1,   241,   242,    -1,    -1,   984,    -1,
parse.c:     241,   242,   580,    -1,   420,    90,    -1,    -1,    -1,    -1,
parse.c:      -1,    96,    97,   429,   261,    -1,    90,    -1,    -1,    -1,
parse.c:      -1,    -1,    96,    97,    -1,   603,    -1,    -1,    -1,   139,
parse.c:     446,   141,   117,    -1,   144,   120,   146,   147,    -1,   149,
parse.c:      -1,    -1,    -1,   117,   291,    -1,   120,    -1,    -1,   296,
parse.c:     291,    -1,    -1,    -1,    -1,   296,   303,   304,   636,   144,
parse.c:      -1,    -1,   303,    53,    -1,    55,    56,    57,    58,     2,
parse.c:     144,     4,    53,    -1,    55,    56,    57,    58,    -1,    -1,
parse.c:      -1,    53,    -1,    55,    56,    57,    58,    -1,    -1,   336,
parse.c:      -1,   507,   670,    -1,    -1,   336,   674,    -1,   676,   677,
parse.c:      90,    -1,    -1,    -1,   682,   683,    96,    97,    -1,    90,
parse.c:      -1,    -1,   690,    -1,    -1,    96,    97,    50,    90,    -1,
parse.c:      -1,    -1,    -1,    -1,    96,    -1,    -1,   117,    -1,    -1,
parse.c:     120,    -1,    -1,    -1,    -1,    -1,   117,    -1,    -1,   120,
parse.c:      -1,   557,    -1,   559,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,   732,    -1,    -1,    -1,    -1,   737,
parse.c:      -1,   739,   740,    -1,    -1,    -1,   582,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,   420,    -1,    -1,    -1,    -1,    -1,   420,
parse.c:      -1,    -1,   429,    -1,    -1,    -1,    -1,    -1,   429,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   446,
parse.c:      -1,    -1,   780,    -1,    -1,    -1,   784,    -1,    -1,    -1,
parse.c:       0,    -1,   790,   629,    -1,    -1,    -1,    -1,     8,     9,
parse.c:      10,    -1,    -1,    -1,    14,    15,    -1,    -1,    18,   645,
parse.c:     646,    -1,   810,    -1,   812,    -1,    -1,    27,    -1,    -1,
parse.c:      -1,   657,    -1,    -1,    -1,    -1,    -1,    -1,    38,    39,
parse.c:     666,    41,    42,    43,    44,    45,   834,   673,    -1,    -1,
parse.c:     507,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   201,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    69,
parse.c:      80,    81,    -1,    -1,    84,    85,    86,    -1,    88,   715,
parse.c:     233,    -1,    -1,    -1,    -1,    -1,    -1,   723,   241,   242,
parse.c:     557,    -1,   559,    -1,   730,   731,   557,    -1,   559,    -1,
parse.c:     110,   111,    -1,   113,   114,   115,   116,   117,   118,   119,
parse.c:     120,   121,   122,    -1,    -1,   582,    -1,    -1,    -1,    -1,
parse.c:      -1,   582,    -1,    -1,    -1,    -1,    -1,    -1,   138,   139,
parse.c:     140,   141,   142,    -1,    -1,    -1,   146,   147,   291,   149,
parse.c:      -1,    -1,    -1,   296,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:     303,    -1,    -1,    -1,    -1,    -1,    -1,   955,    -1,    -1,
parse.c:      -1,    -1,   629,    -1,   800,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,   807,   808,    -1,    -1,   811,    -1,    -1,   645,   646,
parse.c:      -1,    -1,    -1,   336,   645,   646,    -1,    -1,    -1,    -1,
parse.c:     657,   658,    -1,    -1,    -1,    -1,   657,   833,    -1,   666,
parse.c:      -1,    -1,    -1,    -1,    -1,   666,   673,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,   858,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,   872,    -1,    -1,    -1,
parse.c:     876,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   715,    -1,
parse.c:      -1,   887,    -1,   889,   715,    -1,   723,    -1,    -1,    -1,
parse.c:      -1,    -1,   723,   730,   731,    -1,    -1,   420,    -1,   730,
parse.c:     731,    -1,    -1,    -1,    -1,    -1,   429,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,   921,    -1,   923,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,   931,    -1,   933,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    69,    70,    71,
parse.c:      72,    73,    74,    75,    76,    -1,    78,    79,    -1,    47,
parse.c:      48,    -1,    84,    85,    52,    53,    54,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,   800,    -1,    -1,    64,    -1,    -1,   800,
parse.c:     807,   808,    -1,    -1,   811,    -1,   807,   808,    76,    -1,
parse.c:     122,    89,    90,    91,    -1,    -1,   833,    -1,    -1,    -1,
parse.c:      -1,    -1,   833,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,   858,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,   557,   872,   559,    -1,    -1,   876,
parse.c:      -1,   872,    45,    -1,    -1,   876,    -1,    -1,    -1,    -1,
parse.c:     887,    -1,   889,    -1,    -1,    -1,   887,    -1,   889,   582,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    69,    70,    71,    72,
parse.c:      73,    74,    75,    76,    77,    78,    79,    80,    81,    -1,
parse.c:      -1,    84,    85,    -1,   921,    -1,   923,    -1,    -1,    -1,
parse.c:     921,    -1,   923,    -1,   931,    -1,   933,    -1,    -1,    -1,
parse.c:     931,   199,   933,    -1,   202,   203,   204,    -1,   111,    -1,
parse.c:      -1,    -1,   645,   646,    -1,    -1,    69,    70,    71,    72,
parse.c:      73,    74,    75,    -1,   657,    78,    79,    -1,    -1,   142,
parse.c:      -1,    84,    85,   666,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,   261,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,   715,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:     723,    -1,    -1,    -1,    -1,    -1,   304,   730,   731,   307,
parse.c:     328,   329,   330,   331,   332,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,   800,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,   807,   808,    -1,    -1,   811,    -1,
parse.c:      -1,    -1,    -1,    -1,   392,   393,   394,    -1,    -1,    -1,
parse.c:      -1,    -1,   400,   401,   402,    -1,    -1,    -1,    -1,    -1,
parse.c:     833,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,   419,    -1,    -1,    -1,    -1,   424,    69,    70,    71,
parse.c:      72,    73,    74,    75,    -1,   433,    78,    79,   436,    -1,
parse.c:      -1,    -1,    84,    85,    -1,    -1,    -1,    -1,   446,    -1,
parse.c:      -1,    -1,    -1,   876,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,   887,    -1,   889,    -1,    -1,    -1,
parse.c:      -1,   113,   114,   115,   116,   117,   118,   119,   120,   121,
parse.c:     122,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,   489,   490,    -1,    -1,    -1,    -1,    -1,   921,    -1,
parse.c:     923,    -1,    -1,   501,    -1,    -1,    -1,    -1,   931,   507,
parse.c:     933,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:       0,     1,    -1,     3,     4,     5,     6,     7,    -1,    -1,
parse.c:      -1,    11,    12,    -1,    -1,    -1,    16,    17,    -1,    19,
parse.c:      20,    21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,
parse.c:      -1,    31,    32,    33,    34,    35,    36,    37,    -1,    -1,
parse.c:      40,    -1,    -1,    -1,    -1,   563,    46,    47,    48,    49,
parse.c:      50,    51,    52,    53,    54,    55,    56,    57,    58,    -1,
parse.c:      60,    61,    -1,    63,    64,    65,    -1,    67,    68,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,   603,    -1,    87,    -1,    -1,
parse.c:      90,    91,    -1,    93,    94,    -1,    96,    -1,    98,    99,
parse.c:     100,   101,   102,   103,   104,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,   629,    -1,    -1,    -1,    -1,    -1,    -1,   636,    -1,
parse.c:      -1,    -1,    -1,   123,   124,   125,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,   147,    -1,   149,
parse.c:      -1,    -1,   670,    -1,    -1,   673,   674,    -1,    -1,   677,
parse.c:       0,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     8,     9,
parse.c:      10,    -1,   690,    13,    14,    15,    -1,    -1,    18,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    27,    28,    29,
parse.c:      30,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    38,    39,
parse.c:      -1,    41,    42,    43,    44,    45,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,   732,    -1,    -1,    -1,    -1,   737,
parse.c:      -1,   739,   740,    -1,    -1,    -1,    -1,    -1,    -1,    69,
parse.c:      80,    81,    -1,    -1,    84,    85,    86,    -1,    88,    89,
parse.c:      -1,    -1,    -1,    -1,    -1,    95,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,   780,    -1,    -1,    -1,   784,    -1,   108,    -1,
parse.c:     120,   121,   122,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,   810,    -1,   812,    -1,    -1,    -1,   138,   139,
parse.c:     140,   141,   142,    -1,     0,   145,   146,   147,    -1,   149,
parse.c:      -1,    -1,     8,     9,    10,    -1,   834,    13,    14,    15,
parse.c:      -1,    -1,    18,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      26,    -1,    28,    29,    30,    -1,    -1,    -1,    -1,    -1,
parse.c:     858,    -1,    38,    39,    -1,    41,    42,    43,    44,    45,
parse.c:      -1,    -1,    -1,    -1,   872,    -1,    69,    70,    71,    72,
parse.c:      73,    74,    75,    76,    77,    78,    79,    80,    81,    -1,
parse.c:      -1,    84,    85,    69,    70,    71,    72,    73,    74,    75,
parse.c:      76,    77,    78,    79,    80,    81,    -1,    -1,    84,    85,
parse.c:      86,    -1,    88,    89,    -1,    -1,    -1,    -1,   111,    95,
parse.c:      -1,    -1,   108,    -1,   110,   111,   112,   113,   114,   115,
parse.c:     116,   117,   118,   119,   120,   121,   122,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,   139,   140,   141,   142,     0,    -1,   145,
parse.c:     146,   147,    -1,   149,    -1,     8,     9,    10,    -1,    -1,
parse.c:      13,    14,    15,    -1,    -1,    18,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    26,    -1,    28,    29,    30,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    38,    39,    -1,    41,    42,
parse.c:      43,    44,    45,    -1,    -1,    -1,    -1,    -1,    -1,    69,
parse.c:      80,    81,    -1,    -1,    84,    85,    69,    70,    71,    72,
parse.c:      73,    74,    75,    76,    77,    78,    79,    80,    81,    -1,
parse.c:      -1,    84,    85,    86,    -1,    88,    89,    -1,    -1,    -1,
parse.c:      -1,    -1,    95,   113,   114,   115,   116,   117,   118,   119,
parse.c:     120,   121,   122,    -1,    -1,   108,    -1,   110,   111,   112,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,   139,   140,   141,   142,
parse.c:       0,    -1,   145,   146,   147,    -1,   149,    -1,     8,     9,
parse.c:      10,    -1,    -1,    13,    14,    15,    -1,    -1,    18,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    27,    28,    29,
parse.c:      30,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    38,    39,
parse.c:      -1,    41,    42,    43,    44,    45,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    69,
parse.c:      80,    81,    -1,    -1,    84,    85,    86,    -1,    -1,    89,
parse.c:      -1,    -1,    -1,    -1,    -1,    95,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   108,    -1,
parse.c:      -1,   111,   112,   113,   114,   115,   116,   117,   118,   119,
parse.c:     120,   121,   122,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   138,   139,
parse.c:     140,   141,   142,     0,    -1,   145,   146,   147,    -1,   149,
parse.c:      -1,     8,     9,    10,    -1,    -1,    13,    14,    15,    -1,
parse.c:      -1,    18,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      27,    28,    29,    30,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    38,    39,    -1,    41,    42,    43,    44,    45,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    69,    70,    71,    72,    73,    74,    75,    76,
parse.c:      77,    78,    79,    80,    81,    -1,    -1,    84,    85,    86,
parse.c:      -1,    -1,    89,    -1,    -1,    -1,    -1,    -1,    95,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,   108,    -1,    -1,   111,   112,   113,   114,   115,   116,
parse.c:     117,   118,   119,   120,   121,   122,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,   138,   139,   140,   141,   142,     0,    -1,   145,   146,
parse.c:     147,    -1,   149,    -1,     8,     9,    10,    -1,    -1,    13,
parse.c:      14,    15,    -1,    -1,    18,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    28,    29,    30,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    38,    39,    -1,    41,    42,    43,
parse.c:      44,    45,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    69,    70,    71,    72,    73,
parse.c:      74,    75,    76,    77,    78,    79,    80,    81,    -1,    -1,
parse.c:      84,    85,    86,    -1,    88,    89,    -1,    -1,    -1,    -1,
parse.c:      -1,    95,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,   108,    -1,   110,   111,   112,   113,
parse.c:     114,   115,   116,   117,   118,   119,   120,   121,   122,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,   139,   140,   141,   142,     0,
parse.c:      -1,   145,   146,   147,    -1,   149,    -1,     8,     9,    10,
parse.c:      -1,    -1,    13,    14,    15,    -1,    -1,    18,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    27,    28,    29,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    38,    39,    -1,
parse.c:      41,    42,    43,    44,    45,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    69,    70,
parse.c:      81,    -1,    -1,    84,    85,    86,    -1,    -1,    89,    -1,
parse.c:      -1,    -1,    -1,    -1,    95,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:     111,    -1,   113,   114,   115,   116,   117,   118,   119,   120,
parse.c:     121,   122,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,   138,   139,   140,
parse.c:     141,   142,     0,   144,   145,   146,   147,    -1,   149,    -1,
parse.c:       8,     9,    10,    -1,    -1,    13,    14,    15,    -1,    -1,
parse.c:      18,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      28,    29,    30,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      38,    39,    -1,    41,    42,    43,    44,    45,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    69,    70,    71,    72,    73,    74,    75,    76,    77,
parse.c:      78,    79,    80,    81,    -1,    -1,    84,    85,    86,    -1,
parse.c:      -1,    89,    -1,    -1,    -1,    -1,    -1,    95,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:     108,    -1,    -1,   111,   112,   113,   114,   115,   116,   117,
parse.c:     118,   119,   120,   121,   122,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,   139,   140,   141,   142,     0,    -1,   145,   146,   147,
parse.c:      -1,   149,    -1,     8,     9,    10,    -1,    -1,    13,    14,
parse.c:      15,    -1,    -1,    18,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    27,    28,    29,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    38,    39,    -1,    41,    42,    43,    44,
parse.c:      45,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    69,    70,    71,    72,    73,    74,
parse.c:      75,    76,    77,    78,    79,    80,    81,    -1,    -1,    84,
parse.c:      85,    86,    -1,    -1,    89,    -1,    -1,    -1,    -1,    -1,
parse.c:      95,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,   111,    -1,   113,   114,
parse.c:     115,   116,   117,   118,   119,   120,   121,   122,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,   138,   139,   140,   141,   142,     0,   144,
parse.c:     145,   146,   147,    -1,   149,    -1,     8,     9,    10,    -1,
parse.c:      -1,    13,    14,    15,    -1,    -1,    18,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    28,    29,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    38,    39,    -1,    41,
parse.c:      42,    43,    44,    45,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    69,    70,    71,
parse.c:      -1,    -1,    84,    85,    86,    -1,     0,    89,    -1,    -1,
parse.c:      -1,    -1,    -1,    95,     8,     9,    10,    -1,    -1,    -1,
parse.c:      14,    15,    -1,    -1,    18,    -1,    -1,    -1,    -1,   111,
parse.c:      -1,   113,   114,   115,   116,   117,   118,   119,   120,   121,
parse.c:     122,    -1,    -1,    -1,    38,    39,    -1,    41,    42,    43,
parse.c:      44,    45,    -1,    -1,    -1,    -1,    -1,   139,   140,   141,
parse.c:     142,    -1,   144,   145,   146,   147,    -1,   149,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    69,    70,    71,    72,    73,
parse.c:      74,    75,    76,    77,    78,    79,    80,    81,    -1,    -1,
parse.c:      84,    85,    86,    -1,    88,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,   110,   111,    -1,   113,
parse.c:     114,   115,   116,   117,   118,   119,   120,   121,   122,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,   139,   140,   141,   142,    -1,
parse.c:      -1,    -1,   146,   147,     1,   149,     3,     4,     5,     6,
parse.c:       7,     8,     9,    10,    11,    12,    -1,    -1,    15,    16,
parse.c:      17,    -1,    19,    20,    21,    22,    23,    24,    25,    -1,
parse.c:      -1,    -1,    -1,    -1,    31,    32,    33,    34,    35,    36,
parse.c:      37,    -1,    -1,    40,    -1,    -1,    -1,    -1,    -1,    46,
parse.c:      47,    -1,    49,    50,    51,    52,    53,    54,    55,    56,
parse.c:      57,    58,    -1,    60,    61,    -1,    63,    64,    65,    -1,
parse.c:      67,    68,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      87,    -1,    -1,    90,    91,    -1,    93,    94,    -1,    96,
parse.c:      -1,    98,    99,   100,   101,   102,   103,   104,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,   123,   124,   125,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:     147,     1,   149,     3,     4,     5,     6,     7,    -1,    -1,
parse.c:      10,    11,    12,    -1,    14,    15,    16,    17,    -1,    19,
parse.c:      20,    21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,
parse.c:      -1,    31,    32,    33,    34,    35,    36,    37,    -1,    -1,
parse.c:      40,    -1,    -1,    -1,    -1,    -1,    46,    47,    -1,    49,
parse.c:      50,    51,    52,    53,    54,    55,    56,    57,    58,    -1,
parse.c:      60,    61,    -1,    63,    64,    65,    -1,    67,    68,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,
parse.c:      90,    91,    -1,    93,    94,    -1,    96,    -1,    98,    99,
parse.c:     100,   101,   102,   103,   104,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,   123,   124,   125,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,   147,     1,   149,
parse.c:       3,     4,     5,     6,     7,    -1,    -1,    10,    11,    12,
parse.c:      -1,    -1,    15,    16,    17,    18,    19,    20,    21,    22,
parse.c:      23,    24,    25,    -1,    -1,    -1,    -1,    -1,    31,    32,
parse.c:      33,    34,    35,    36,    37,    -1,    -1,    40,    -1,    -1,
parse.c:      -1,    -1,    -1,    46,    47,    -1,    49,    50,    51,    52,
parse.c:      53,    54,    55,    56,    57,    58,    -1,    60,    61,    -1,
parse.c:      63,    64,    65,    -1,    67,    68,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    87,    -1,    -1,    90,    91,    -1,
parse.c:      93,    94,    -1,    96,    -1,    98,    99,   100,   101,   102,
parse.c:     103,   104,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:     123,   124,   125,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,     1,    -1,     3,     4,     5,     6,     7,    -1,
parse.c:      -1,    -1,    11,    12,   147,    -1,   149,    16,    17,    -1,
parse.c:      19,    20,    21,    22,    23,    24,    25,    -1,    -1,    -1,
parse.c:      -1,    -1,    31,    32,    33,    34,    35,    36,    37,    -1,
parse.c:      -1,    40,    -1,    -1,    -1,    -1,    -1,    46,    47,    48,
parse.c:      -1,    60,    61,    -1,    63,    64,    65,    -1,    67,    68,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,
parse.c:      -1,    90,    91,    -1,    93,    94,    -1,    96,    -1,    98,
parse.c:      99,   100,   101,   102,   103,   104,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,   123,   124,   125,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:     139,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   147,     1,
parse.c:     149,     3,     4,     5,     6,     7,    -1,    -1,    10,    11,
parse.c:      12,    -1,    -1,    15,    16,    17,    -1,    19,    20,    21,
parse.c:      22,    23,    24,    25,    -1,    -1,    -1,    -1,    -1,    31,
parse.c:      32,    33,    34,    35,    36,    37,    -1,    -1,    40,    -1,
parse.c:      -1,    -1,    -1,    -1,    46,    47,    -1,    49,    50,    51,
parse.c:      52,    53,    54,    55,    56,    57,    58,    -1,    60,    61,
parse.c:      -1,    63,    64,    65,    -1,    67,    68,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,    91,
parse.c:      -1,    93,    94,    -1,    96,    -1,    98,    99,   100,   101,
parse.c:     102,   103,   104,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,   123,   124,   125,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,     1,    -1,     3,     4,     5,     6,     7,
parse.c:      -1,     9,    10,    11,    12,   147,    -1,   149,    16,    17,
parse.c:      -1,    19,    20,    21,    22,    23,    24,    25,    -1,    -1,
parse.c:      -1,    -1,    -1,    31,    32,    33,    34,    35,    36,    37,
parse.c:      -1,    -1,    40,    -1,    -1,    -1,    -1,    -1,    46,    47,
parse.c:      -1,    49,    50,    51,    52,    53,    54,    55,    56,    57,
parse.c:      58,    -1,    60,    61,    -1,    63,    64,    65,    -1,    67,
parse.c:      68,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    87,
parse.c:      -1,    -1,    90,    91,    -1,    93,    94,    -1,    96,    -1,
parse.c:      98,    99,   100,   101,   102,   103,   104,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,   123,   124,   125,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,     1,    -1,     3,
parse.c:       4,     5,     6,     7,    -1,    -1,    -1,    11,    12,   147,
parse.c:      -1,   149,    16,    17,    -1,    19,    20,    21,    22,    23,
parse.c:      24,    25,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,
parse.c:      34,    35,    36,    37,    -1,    -1,    40,    -1,    -1,    -1,
parse.c:      -1,    -1,    46,    47,    -1,    49,    50,    51,    52,    53,
parse.c:      54,    55,    56,    57,    58,    -1,    60,    61,    -1,    63,
parse.c:      64,    65,    -1,    67,    68,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,
parse.c:      94,    -1,    96,    -1,    98,    99,   100,   101,   102,   103,
parse.c:     104,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   123,
parse.c:     124,   125,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,   146,   147,     1,   149,     3,     4,     5,     6,
parse.c:       7,    -1,    -1,    -1,    11,    12,    -1,    -1,    -1,    16,
parse.c:      17,    -1,    19,    20,    21,    22,    23,    24,    25,    -1,
parse.c:      -1,    -1,    -1,    -1,    31,    32,    33,    34,    35,    36,
parse.c:      37,    -1,    -1,    40,    -1,    -1,    -1,    -1,    -1,    46,
parse.c:      47,    -1,    49,    50,    51,    52,    53,    54,    55,    56,
parse.c:      57,    58,    -1,    60,    61,    -1,    63,    64,    65,    -1,
parse.c:      67,    68,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      87,    -1,    -1,    90,    91,    -1,    93,    94,    -1,    96,
parse.c:      -1,    98,    99,   100,   101,   102,   103,   104,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,   123,   124,   125,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   146,
parse.c:     147,     1,   149,     3,     4,     5,     6,     7,    -1,    -1,
parse.c:      -1,    11,    12,    -1,    -1,    -1,    16,    17,    -1,    19,
parse.c:      20,    21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,
parse.c:      -1,    31,    32,    33,    34,    35,    36,    37,    -1,    -1,
parse.c:      40,    -1,    -1,    -1,    -1,    -1,    46,    47,    -1,    49,
parse.c:      50,    51,    52,    53,    54,    55,    56,    57,    58,    -1,
parse.c:      60,    61,    -1,    63,    64,    65,    -1,    67,    68,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,
parse.c:      90,    91,    -1,    93,    94,    -1,    96,    -1,    98,    99,
parse.c:     100,   101,   102,   103,   104,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,   123,   124,   125,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   139,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,   147,     1,   149,
parse.c:       3,     4,     5,     6,     7,    -1,    -1,    10,    11,    12,
parse.c:      -1,    -1,    -1,    16,    17,    -1,    19,    20,    21,    22,
parse.c:      23,    24,    25,    -1,    -1,    -1,    -1,    -1,    31,    32,
parse.c:      33,    34,    35,    36,    37,    -1,    -1,    40,    -1,    -1,
parse.c:      -1,    -1,    -1,    46,    47,    -1,    49,    50,    51,    52,
parse.c:      53,    54,    55,    56,    57,    58,    -1,    60,    61,    -1,
parse.c:      63,    64,    65,    -1,    67,    68,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    87,    -1,    -1,    90,    91,    -1,
parse.c:      93,    94,    -1,    96,    -1,    98,    99,   100,   101,   102,
parse.c:     103,   104,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:     123,   124,   125,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,     3,     4,     5,    -1,     7,    -1,
parse.c:      -1,    -1,    11,    12,   147,    -1,   149,    16,    17,    -1,
parse.c:      19,    20,    21,    22,    23,    24,    25,    -1,    -1,    -1,
parse.c:      -1,    -1,    31,    32,    33,    34,    35,    36,    37,    -1,
parse.c:      -1,    40,    -1,    -1,    -1,    -1,    -1,    -1,    47,    -1,
parse.c:      -1,    50,    51,    52,    53,    54,    55,    56,    57,    58,
parse.c:      59,    60,    61,    -1,    63,    64,    65,    -1,    67,    68,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,
parse.c:      -1,    90,    91,    -1,    93,    94,    -1,    96,    97,    98,
parse.c:      99,   100,   101,   102,   103,   104,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,     3,     4,     5,    -1,     7,    -1,
parse.c:      -1,    -1,    11,    12,   123,   124,   125,    16,    17,    -1,
parse.c:      19,    20,    21,    22,    23,    24,    25,    -1,    -1,    -1,
parse.c:      -1,    -1,    31,    32,    33,    34,    35,    36,    37,    -1,
parse.c:     149,    40,    -1,    -1,    -1,    -1,    -1,    -1,    47,    -1,
parse.c:      -1,    50,    51,    52,    53,    54,    55,    56,    57,    58,
parse.c:      -1,    60,    61,    -1,    63,    64,    65,    -1,    67,    68,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,
parse.c:      -1,    90,    91,    -1,    93,    94,    -1,    -1,    -1,    98,
parse.c:      99,   100,   101,   102,   103,   104,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,   123,   124,   125,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,     4,
parse.c:       5,    -1,     7,    -1,    -1,    -1,    11,    12,   147,    -1,
parse.c:     149,    16,    17,    -1,    19,    20,    21,    22,    23,    24,
parse.c:      25,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,
parse.c:      35,    36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    47,    -1,    -1,    50,    51,    52,    53,    54,
parse.c:      55,    56,    57,    58,    -1,    60,    61,    -1,    63,    64,
parse.c:      65,    -1,    67,    68,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,
parse.c:      -1,    -1,    -1,    98,    99,   100,   101,   102,   103,   104,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,     4,
parse.c:       5,     6,     7,    -1,    -1,    -1,    11,    12,   123,   124,
parse.c:     125,    16,    17,    -1,    19,    20,    21,    22,    23,    24,
parse.c:      25,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,
parse.c:      35,    36,    37,    -1,   149,    40,    -1,    -1,    -1,    -1,
parse.c:      -1,    46,    47,    48,    49,    50,    51,    52,    53,    54,
parse.c:      55,    56,    57,    58,    -1,    60,    61,    -1,    63,    64,
parse.c:      65,    -1,    67,    68,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,
parse.c:      -1,    96,    -1,    98,    99,   100,   101,   102,   103,   104,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   123,   124,
parse.c:     125,    -1,    -1,    -1,    -1,    -1,    -1,     3,     4,     5,
parse.c:       6,     7,    -1,    -1,    -1,    11,    12,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,    35,
parse.c:      36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,    -1,
parse.c:      46,    47,    -1,    49,    50,    51,    52,    53,    54,    55,
parse.c:      56,    57,    58,    -1,    60,    61,    -1,    63,    64,    65,
parse.c:      -1,    67,    68,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,    -1,
parse.c:      96,    -1,    98,    99,   100,   101,   102,   103,   104,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,   123,   124,   125,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,   147,     3,     4,     5,     6,     7,     8,     9,    10,
parse.c:      21,    22,    23,    24,    25,    26,    27,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    46,    47,    48,    49,    50,
parse.c:      51,    52,    53,    54,    55,    56,    57,    58,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    67,    68,    69,    70,
parse.c:      71,    72,    73,    74,    75,    -1,    -1,    78,    79,    -1,
parse.c:      -1,    82,    83,    84,    85,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    96,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,   113,   114,   115,   116,   117,   118,   119,   120,
parse.c:     121,   122,    -1,   124,   125,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,   143,   144,     3,     4,     5,     6,     7,     8,
parse.c:      19,    20,    21,    22,    23,    24,    25,    26,    27,    -1,
parse.c:      -1,    -1,    31,    32,    33,    34,    35,    36,    37,    38,
parse.c:      39,    40,    -1,    -1,    -1,    -1,    -1,    46,    47,    48,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    67,    68,
parse.c:      69,    70,    71,    72,    73,    74,    75,    -1,    -1,    78,
parse.c:      79,    -1,    -1,    82,    83,    84,    85,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    96,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,   113,   114,   115,   116,   117,   118,
parse.c:     119,   120,   121,   122,    -1,   124,   125,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,   143,     3,     4,     5,     6,     7,
parse.c:      -1,    -1,    -1,    31,    32,    33,    34,    35,    36,    37,
parse.c:      38,    39,    40,    -1,    -1,    -1,    -1,    -1,    46,    47,
parse.c:      48,    49,    50,    51,    52,    53,    54,    55,    -1,    57,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    67,
parse.c:      68,    69,    70,    71,    72,    73,    74,    75,    -1,    -1,
parse.c:      78,    79,    -1,    -1,    82,    83,    84,    85,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    96,    -1,
parse.c:      -1,    99,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,   113,   114,   115,   116,   117,
parse.c:     118,   119,   120,   121,   122,    -1,   124,   125,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,   143,     3,     4,     5,     6,
parse.c:      27,    -1,    -1,    -1,    31,    32,    33,    34,    35,    36,
parse.c:      37,    38,    39,    40,    -1,    -1,    -1,    -1,    -1,    46,
parse.c:      47,    48,    49,    50,    51,    52,    53,    54,    -1,    -1,
parse.c:      57,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      67,    68,    69,    70,    71,    72,    73,    74,    75,    -1,
parse.c:      -1,    78,    79,    -1,    -1,    82,    83,    84,    85,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    96,
parse.c:      -1,    -1,    99,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,   113,   114,   115,   116,
parse.c:     117,   118,   119,   120,   121,   122,    -1,   124,   125,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,   143,     3,     4,     5,
parse.c:      26,    27,    -1,    -1,    -1,    31,    32,    33,    34,    35,
parse.c:      36,    37,    38,    39,    40,    -1,    -1,    -1,    -1,    -1,
parse.c:      46,    47,    48,    49,    50,    51,    52,    53,    54,    -1,
parse.c:      -1,    57,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    67,    68,    69,    70,    71,    72,    73,    74,    75,
parse.c:      -1,    -1,    78,    79,    -1,    -1,    82,    83,    84,    85,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      96,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,   113,   114,   115,
parse.c:     116,   117,   118,   119,   120,   121,   122,    -1,   124,   125,
parse.c:      -1,    -1,     3,     4,     5,    -1,     7,    -1,    -1,    -1,
parse.c:      11,    12,    -1,    -1,    -1,    16,    17,   143,    19,    20,
parse.c:      21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,    -1,
parse.c:      31,    32,    33,    34,    35,    36,    37,    -1,    -1,    40,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    47,    -1,    -1,    50,
parse.c:      51,    52,    53,    54,    55,    56,    57,    58,    -1,    60,
parse.c:      61,    -1,    63,    64,    65,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,
parse.c:      91,    -1,    93,    94,    -1,    -1,    -1,    98,    99,   100,
parse.c:     101,   102,   103,   104,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,     3,     4,     5,    -1,     7,
parse.c:      -1,    -1,   123,    11,    12,    -1,    -1,    -1,    16,    17,
parse.c:      -1,    19,    20,    21,    22,    23,    24,    25,    -1,    -1,
parse.c:      -1,   142,    -1,    31,    32,    33,    34,    35,    36,    37,
parse.c:      -1,    -1,    40,    -1,    -1,    -1,    -1,    -1,    -1,    47,
parse.c:      -1,    -1,    50,    51,    52,    53,    54,    55,    56,    57,
parse.c:      58,    -1,    60,    61,    -1,    63,    64,    65,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    87,
parse.c:      -1,    -1,    90,    91,    -1,    93,    94,    -1,    -1,    -1,
parse.c:      98,    99,   100,   101,   102,   103,   104,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,     4,
parse.c:       5,     6,     7,    -1,    -1,   123,    11,    12,    -1,    -1,
parse.c:      -1,    16,    17,    -1,    19,    20,    21,    22,    23,    24,
parse.c:      25,    -1,    -1,    -1,   142,    -1,    31,    32,    33,    34,
parse.c:      35,    36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,
parse.c:      -1,    46,    47,    48,    49,    50,    51,    52,    53,    54,
parse.c:      55,    56,    57,    58,    -1,    60,    61,    -1,    63,    64,
parse.c:      65,    -1,    67,    68,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,
parse.c:      -1,    96,    -1,    98,    99,   100,   101,   102,   103,   104,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,     4,
parse.c:       5,     6,     7,    -1,    -1,    -1,    11,    12,   123,   124,
parse.c:     125,    16,    17,    -1,    19,    20,    21,    22,    23,    24,
parse.c:      25,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,
parse.c:      35,    36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,
parse.c:      -1,    46,    47,    -1,    49,    50,    51,    52,    53,    54,
parse.c:      55,    56,    57,    58,    -1,    60,    61,    -1,    63,    64,
parse.c:      65,    -1,    67,    68,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,
parse.c:      -1,    96,    -1,    98,    99,   100,   101,   102,   103,   104,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,     4,
parse.c:       5,    -1,     7,    -1,    -1,    -1,    11,    12,   123,   124,
parse.c:     125,    16,    17,    -1,    19,    20,    21,    22,    23,    24,
parse.c:      25,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,
parse.c:      35,    36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    47,    -1,    -1,    50,    51,    52,    53,    54,
parse.c:      55,    56,    57,    58,    59,    60,    61,    -1,    63,    64,
parse.c:      65,    -1,    67,    68,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,
parse.c:      -1,    96,    97,    98,    99,   100,   101,   102,   103,   104,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,     4,
parse.c:       5,    -1,     7,    -1,    -1,    -1,    11,    12,   123,   124,
parse.c:     125,    16,    17,    -1,    19,    20,    21,    22,    23,    24,
parse.c:      25,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,
parse.c:      35,    36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    47,    -1,    -1,    50,    51,    52,    53,    54,
parse.c:      55,    56,    57,    58,    59,    60,    61,    -1,    63,    64,
parse.c:      65,    -1,    67,    68,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,
parse.c:      -1,    96,    97,    98,    99,   100,   101,   102,   103,   104,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,     4,
parse.c:       5,    -1,     7,    -1,    -1,    -1,    11,    12,   123,   124,
parse.c:     125,    16,    17,    -1,    19,    20,    21,    22,    23,    24,
parse.c:      25,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,
parse.c:      35,    36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    47,    -1,    -1,    50,    51,    52,    53,    54,
parse.c:      55,    56,    57,    58,    59,    60,    61,    -1,    63,    64,
parse.c:      65,    -1,    67,    68,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,
parse.c:      -1,    96,    -1,    98,    99,   100,   101,   102,   103,   104,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,     4,
parse.c:       5,    -1,     7,    -1,    -1,    -1,    11,    12,   123,   124,
parse.c:     125,    16,    17,    -1,    19,    20,    21,    22,    23,    24,
parse.c:      25,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,
parse.c:      35,    36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    47,    -1,    -1,    50,    51,    52,    53,    54,
parse.c:      55,    56,    57,    58,    59,    60,    61,    -1,    63,    64,
parse.c:      65,    -1,    67,    68,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,
parse.c:      -1,    -1,    97,    98,    99,   100,   101,   102,   103,   104,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,     4,
parse.c:       5,    -1,     7,    -1,    -1,    -1,    11,    12,   123,   124,
parse.c:     125,    16,    17,    -1,    19,    20,    21,    22,    23,    24,
parse.c:      25,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,
parse.c:      35,    36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    47,    -1,    -1,    50,    51,    52,    53,    54,
parse.c:      55,    56,    57,    58,    59,    60,    61,    -1,    63,    64,
parse.c:      65,    -1,    67,    68,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,
parse.c:      -1,    96,    -1,    98,    99,   100,   101,   102,   103,   104,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,     4,
parse.c:       5,    -1,     7,    -1,    -1,    -1,    11,    12,   123,   124,
parse.c:     125,    16,    17,    -1,    19,    20,    21,    22,    23,    24,
parse.c:      25,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,
parse.c:      35,    36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    47,    -1,    -1,    50,    51,    52,    53,    54,
parse.c:      55,    56,    57,    58,    59,    60,    61,    -1,    63,    64,
parse.c:      65,    -1,    67,    68,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,
parse.c:      -1,    -1,    -1,    98,    99,   100,   101,   102,   103,   104,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,     4,
parse.c:       5,    -1,     7,    -1,    -1,    -1,    11,    12,   123,   124,
parse.c:     125,    16,    17,    -1,    19,    20,    21,    22,    23,    24,
parse.c:      25,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,
parse.c:      35,    36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    47,    -1,    -1,    50,    51,    52,    53,    54,
parse.c:      55,    56,    57,    58,    -1,    60,    61,    -1,    63,    64,
parse.c:      65,    -1,    67,    68,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,
parse.c:      -1,    96,    -1,    98,    99,   100,   101,   102,   103,   104,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,     4,
parse.c:       5,    -1,     7,    -1,    -1,    -1,    11,    12,   123,   124,
parse.c:     125,    16,    17,    -1,    19,    20,    21,    22,    23,    24,
parse.c:      25,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,
parse.c:      35,    36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    47,    -1,    -1,    50,    51,    52,    53,    54,
parse.c:      55,    56,    57,    58,    -1,    60,    61,    -1,    63,    64,
parse.c:      65,    -1,    67,    68,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,
parse.c:      -1,    96,    -1,    98,    99,   100,   101,   102,   103,   104,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,     4,
parse.c:       5,    -1,     7,    -1,    -1,    -1,    11,    12,   123,   124,
parse.c:     125,    16,    17,    -1,    19,    20,    21,    22,    23,    24,
parse.c:      25,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,
parse.c:      35,    36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    47,    -1,    -1,    50,    51,    52,    53,    54,
parse.c:      55,    56,    57,    58,    -1,    60,    61,    -1,    63,    64,
parse.c:      65,    -1,    67,    68,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,
parse.c:      -1,    96,    -1,    98,    99,   100,   101,   102,   103,   104,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,     4,
parse.c:       5,    -1,     7,    -1,    -1,    -1,    11,    12,   123,   124,
parse.c:     125,    16,    17,    -1,    19,    20,    21,    22,    23,    24,
parse.c:      25,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,
parse.c:      35,    36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    47,    -1,    -1,    50,    51,    52,    53,    54,
parse.c:      55,    56,    57,    58,    -1,    60,    61,    -1,    63,    64,
parse.c:      65,    -1,    67,    68,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,
parse.c:      -1,    96,    -1,    98,    99,   100,   101,   102,   103,   104,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,     4,
parse.c:       5,    -1,     7,    -1,    -1,    -1,    11,    12,   123,   124,
parse.c:     125,    16,    17,    -1,    19,    20,    21,    22,    23,    24,
parse.c:      25,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,
parse.c:      35,    36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    47,    -1,    -1,    50,    51,    52,    53,    54,
parse.c:      55,    56,    57,    58,    -1,    60,    61,    -1,    63,    64,
parse.c:      65,    -1,    67,    68,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,
parse.c:      -1,    96,    -1,    98,    99,   100,   101,   102,   103,   104,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,     4,
parse.c:       5,    -1,     7,    -1,    -1,    -1,    11,    12,   123,   124,
parse.c:     125,    16,    17,    -1,    19,    20,    21,    22,    23,    24,
parse.c:      25,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,
parse.c:      35,    36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    47,    -1,    -1,    50,    51,    52,    53,    54,
parse.c:      55,    56,    57,    58,    -1,    60,    61,    -1,    63,    64,
parse.c:      65,    -1,    67,    68,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,
parse.c:      -1,    -1,    -1,    98,    99,   100,   101,   102,   103,   104,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,     4,
parse.c:       5,    -1,     7,    -1,    -1,    -1,    11,    12,   123,   124,
parse.c:     125,    16,    17,    -1,    19,    20,    21,    22,    23,    24,
parse.c:      25,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,
parse.c:      35,    36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    47,    -1,    -1,    50,    51,    52,    53,    54,
parse.c:      55,    56,    57,    58,    -1,    60,    61,    -1,    63,    64,
parse.c:      65,    -1,    67,    68,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,
parse.c:      -1,    -1,    -1,    98,    99,   100,   101,   102,   103,   104,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,     4,
parse.c:       5,    -1,     7,    -1,    -1,    -1,    11,    12,   123,   124,
parse.c:     125,    16,    17,    -1,    19,    20,    21,    22,    23,    24,
parse.c:      25,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,
parse.c:      35,    36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    47,    -1,    -1,    50,    51,    52,    53,    54,
parse.c:      55,    56,    57,    58,    -1,    60,    61,    -1,    63,    64,
parse.c:      65,    -1,    67,    68,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,
parse.c:      -1,    -1,    -1,    98,    99,   100,   101,   102,   103,   104,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,     4,
parse.c:       5,    -1,     7,    -1,    -1,    -1,    11,    12,   123,   124,
parse.c:     125,    16,    17,    -1,    19,    20,    21,    22,    23,    24,
parse.c:      25,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,
parse.c:      35,    36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    47,    -1,    -1,    50,    51,    52,    53,    54,
parse.c:      55,    56,    57,    58,    -1,    60,    61,    -1,    63,    64,
parse.c:      65,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,
parse.c:      -1,    96,    -1,    98,    99,   100,   101,   102,   103,   104,
parse.c:      -1,    -1,    -1,     3,     4,     5,    -1,     7,    -1,    -1,
parse.c:      -1,    11,    12,    -1,    -1,    -1,    16,    17,   123,    19,
parse.c:      20,    21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,
parse.c:      -1,    31,    32,    33,    34,    35,    36,    37,    -1,    -1,
parse.c:      40,    -1,    -1,    -1,    -1,    -1,    -1,    47,    -1,    -1,
parse.c:      50,    51,    52,    53,    54,    55,    56,    57,    58,    -1,
parse.c:      60,    61,    -1,    63,    64,    65,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,
parse.c:      90,    91,    -1,    93,    94,    -1,    96,    -1,    98,    99,
parse.c:     100,   101,   102,   103,   104,    -1,    -1,    -1,     3,     4,
parse.c:       5,    -1,     7,    -1,    -1,    -1,    11,    12,    -1,    -1,
parse.c:      -1,    16,    17,   123,    19,    20,    21,    22,    23,    24,
parse.c:      25,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,
parse.c:      35,    36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    47,    -1,    -1,    50,    51,    52,    53,    54,
parse.c:      55,    56,    57,    58,    -1,    60,    61,    -1,    63,    64,
parse.c:      65,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    84,
parse.c:      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,
parse.c:      -1,    -1,    -1,    98,    99,   100,   101,   102,   103,   104,
parse.c:      -1,    -1,    -1,     3,     4,     5,    -1,     7,    -1,    -1,
parse.c:      -1,    11,    12,    -1,    -1,    -1,    16,    17,   123,    19,
parse.c:      20,    21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,
parse.c:      -1,    31,    32,    33,    34,    35,    36,    37,    -1,    -1,
parse.c:      40,    -1,    -1,    -1,    -1,    -1,    -1,    47,    -1,    -1,
parse.c:      50,    51,    52,    53,    54,    55,    56,    57,    58,    -1,
parse.c:      60,    61,    -1,    63,    64,    65,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,
parse.c:      90,    91,    -1,    93,    94,    -1,    -1,    -1,    98,    99,
parse.c:     100,   101,   102,   103,   104,    -1,    -1,    -1,     3,     4,
parse.c:       5,    -1,     7,    -1,    -1,    -1,    11,    12,    -1,    -1,
parse.c:      -1,    16,    17,   123,    19,    20,    21,    22,    23,    24,
parse.c:      25,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,
parse.c:      35,    36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    47,    -1,    -1,    50,    51,    52,    53,    54,
parse.c:      55,    56,    57,    58,    -1,    60,    61,    -1,    63,    64,
parse.c:      65,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,
parse.c:      -1,    -1,    -1,    98,    99,   100,   101,   102,   103,   104,
parse.c:      -1,    -1,    -1,     3,     4,     5,    -1,     7,    -1,    -1,
parse.c:      -1,    11,    12,    -1,    -1,    -1,    16,    17,   123,    19,
parse.c:      20,    21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,
parse.c:      -1,    31,    32,    33,    34,    35,    36,    37,    -1,    -1,
parse.c:      40,    -1,    -1,    -1,    -1,    -1,    -1,    47,    -1,    -1,
parse.c:      50,    51,    52,    53,    54,    55,    56,    57,    58,    -1,
parse.c:      60,    61,    -1,    63,    64,    65,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,
parse.c:      90,    91,    -1,    93,    94,    -1,    -1,    -1,    98,    99,
parse.c:     100,   101,   102,   103,   104,    -1,    -1,    -1,     3,     4,
parse.c:       5,    -1,     7,    -1,    -1,    -1,    11,    12,    -1,    -1,
parse.c:      -1,    16,    17,   123,    19,    20,    21,    22,    23,    24,
parse.c:      25,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,
parse.c:      35,    36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    47,    -1,    -1,    50,    51,    52,    53,    54,
parse.c:      55,    56,    57,    58,    -1,    60,    61,    -1,    63,    64,
parse.c:      65,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,
parse.c:      -1,    -1,    -1,    98,    99,   100,   101,   102,   103,   104,
parse.c:      -1,    -1,    -1,    -1,    -1,    53,    54,    -1,    -1,    57,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   123,    67,
parse.c:      68,    69,    70,    71,    72,    73,    74,    75,    -1,    -1,
parse.c:      78,    79,    -1,    -1,    82,    83,    84,    85,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    96,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,   113,   114,   115,   116,   117,
parse.c:     118,   119,   120,   121,   122,    -1,   124,   125,    -1,    -1,
parse.c:      -1,    -1,    -1,    53,    54,    -1,    -1,    57,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,   143,   144,    67,    68,    69,
parse.c:      70,    71,    72,    73,    74,    75,    -1,    -1,    78,    79,
parse.c:      -1,    -1,    82,    83,    84,    85,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    96,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,   113,   114,   115,   116,   117,   118,   119,
parse.c:     120,   121,   122,    -1,   124,   125,    -1,    -1,    -1,    -1,
parse.c:      -1,    53,    54,    -1,    -1,    57,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,   143,   144,    67,    68,    69,    70,    71,
parse.c:      72,    73,    74,    75,    -1,    -1,    78,    79,    -1,    -1,
parse.c:      82,    83,    84,    85,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    96,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,   113,   114,   115,   116,   117,   118,   119,   120,   121,
parse.c:     122,    -1,   124,   125,    -1,    -1,    -1,    -1,    -1,    53,
parse.c:      54,    -1,    -1,    57,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,   143,   144,    67,    68,    69,    70,    71,    72,    73,
parse.c:      74,    75,    -1,    -1,    78,    79,    -1,    -1,    82,    83,
parse.c:      84,    85,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    96,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   113,
parse.c:     114,   115,   116,   117,   118,   119,   120,   121,   122,    -1,
parse.c:     124,   125,    -1,    -1,    -1,    -1,    -1,    53,    54,    -1,
parse.c:      -1,    57,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   143,
parse.c:      -1,    -1,    78,    79,    -1,    -1,    82,    83,    84,    85,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      96,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,   113,   114,   115,
parse.c:     116,   117,   118,   119,   120,   121,   122,    -1,   124,   125,
parse.c:      -1,    -1,    -1,    -1,    -1,    53,    54,    -1,    -1,    57,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,   143,   144,    67,
parse.c:      68,    69,    70,    71,    72,    73,    74,    75,    -1,    -1,
parse.c:      78,    79,    -1,    -1,    82,    83,    84,    85,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    96,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,   113,   114,   115,   116,   117,
parse.c:     118,   119,   120,   121,   122,    -1,   124,   125,    -1,    -1,
parse.c:      -1,    -1,    -1,    53,    54,    -1,    -1,    57,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,   143,   144,    67,    68,    69,
parse.c:      70,    71,    72,    73,    74,    75,    -1,    -1,    78,    79,
parse.c:      -1,    -1,    82,    83,    84,    85,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    96,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,   113,   114,   115,   116,   117,   118,   119,
parse.c:     120,   121,   122,    -1,   124,   125,    -1,    -1,    -1,    -1,
parse.c:      -1,    53,    54,    -1,    -1,    57,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,   143,   144,    67,    68,    69,    70,    71,
parse.c:      72,    73,    74,    75,    -1,    -1,    78,    79,    -1,    -1,
parse.c:      82,    83,    84,    85,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    96,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,   113,   114,   115,   116,   117,   118,   119,   120,   121,
parse.c:     122,    -1,   124,   125,    -1,    -1,    -1,    -1,    -1,    53,
parse.c:      54,    -1,    -1,    57,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,   143,   144,    67,    68,    69,    70,    71,    72,    73,
parse.c:      74,    75,    -1,    -1,    78,    79,    -1,    -1,    82,    83,
parse.c:      84,    85,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    96,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   113,
parse.c:     114,   115,   116,   117,   118,   119,   120,   121,   122,    -1,
parse.c:     124,   125,    -1,    -1,    -1,    -1,    -1,    53,    54,    -1,
parse.c:      -1,    57,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   143,
parse.c:      -1,    -1,    78,    79,    -1,    -1,    82,    83,    84,    85,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      96,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,   113,   114,   115,
parse.c:     116,   117,   118,   119,   120,   121,   122,    -1,   124,   125,
parse.c:      -1,    -1,    -1,    -1,    -1,    53,    54,    -1,    -1,    57,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,   143,   144,    67,
parse.c:      68,    69,    70,    71,    72,    73,    74,    75,    -1,    -1,
parse.c:      78,    79,    -1,    -1,    82,    83,    84,    85,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    96,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,   113,   114,   115,   116,   117,
parse.c:     118,   119,   120,   121,   122,    -1,   124,   125,    -1,    -1,
parse.c:      -1,    -1,    -1,    53,    54,    -1,    -1,    57,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,   143,   144,    67,    68,    69,
parse.c:      70,    71,    72,    73,    74,    75,    -1,    -1,    78,    79,
parse.c:      -1,    -1,    82,    83,    84,    85,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    96,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,   113,   114,   115,   116,   117,   118,   119,
parse.c:     120,   121,   122,    -1,   124,   125,    -1,    -1,    -1,    -1,
parse.c:      -1,    53,    54,    -1,    -1,    57,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,   143,   144,    67,    68,    69,    70,    71,
parse.c:      72,    73,    74,    75,    -1,    -1,    78,    79,    -1,    -1,
parse.c:      82,    83,    84,    85,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    96,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,   113,   114,   115,   116,   117,   118,   119,   120,   121,
parse.c:     122,    -1,   124,   125,    -1,    -1,    -1,    -1,    -1,    53,
parse.c:      54,    -1,    -1,    57,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,   143,   144,    67,    68,    69,    70,    71,    72,    73,
parse.c:      74,    75,    -1,    -1,    78,    79,    -1,    -1,    82,    83,
parse.c:      84,    85,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    96,    -1,    -1,    -1,    -1,    -1,    45,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   113,
parse.c:      77,    78,    79,    80,    81,    -1,    -1,    84,    85,   143,
parse.c:      -1,    -1,    -1,    69,    70,    71,    72,    73,    74,    75,
parse.c:      76,    77,    78,    79,    80,    81,    -1,    -1,    84,    85,
parse.c:      -1,    -1,    -1,    -1,   111,    -1,   113,   114,   115,   116,
parse.c:     117,   118,   119,   120,   121,   122,    -1,    -1,    -1,    -1,
parse.c:      -1,    -1,    -1,    -1,    -1,   111,    -1,   113,   114,   115,
parse.c:/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
parse.c:   symbol of state STATE-NUM.  */
parse.c:#define YYEMPTY		(-2)
parse.c:/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
parse.c:/* YY_LOCATION_PRINT -- Print the location on the stream.
parse.c:     fprintf (File, "%d.%d-%d.%d",			\
parse.c:/* YYLEX -- calling `yylex' with the right arguments.  */
parse.c:/*--------------------------------.
parse.c:`--------------------------------*/
parse.c:/*--------------------------------.
parse.c:`--------------------------------*/
parse.c:/*------------------------------------------------------------------.
parse.c:| yy_stack_print -- Print the state stack from its BOTTOM up to its |
parse.c:`------------------------------------------------------------------*/
parse.c:/*------------------------------------------------.
parse.c:`------------------------------------------------*/
parse.c:	     yyrule - 1, yylno);
parse.c:		       &(yyvsp[(yyi + 1) - (yynrhs)])
parse.c:/* YYINITDEPTH -- initial size of the parser's stacks.  */
parse.c:/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
parse.c:   if the built-in stack extension method is used).
parse.c:   evaluated with infinite-precision integer arithmetic.  */
parse.c:  return yyd - 1;
parse.c:   heuristic is that double-quoting is unnecessary unless the string
parse.c:   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
parse.c:  return yystpcpy (yyres, yystr) - yyres;
parse.c:		    + sizeof yyexpecting - 1
parse.c:		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
parse.c:		       * (sizeof yyor - 1))];
parse.c:      /* Start YYX at -YYN if negative to avoid negative indexes in
parse.c:      int yyxbegin = yyn < 0 ? -yyn : 0;
parse.c:      int yychecklim = YYLAST - yyn + 1;
parse.c:		yyformat[sizeof yyunexpected - 1] = '\0';
parse.c:/*-----------------------------------------------.
parse.c:`-----------------------------------------------*/
parse.c:/* Prevent warnings from -Wmissing-prototypes.  */
parse.c:/*----------.
parse.c:`----------*/
parse.c:  /* The look-ahead symbol.  */
parse.c:/* The semantic value of the look-ahead symbol.  */
parse.c:  /* Look-ahead token as an internal (translated) token number.  */
parse.c:#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
parse.c:/*------------------------------------------------------------.
parse.c:| yynewstate -- Push a new state, which is found in yystate.  |
parse.c:`------------------------------------------------------------*/
parse.c:  if (yyss + yystacksize - 1 <= yyssp)
parse.c:      YYSIZE_T yysize = yyssp - yyss + 1;
parse.c:      yyssp = yyss + yysize - 1;
parse.c:      yyvsp = yyvs + yysize - 1;
parse.c:      if (yyss + yystacksize - 1 <= yyssp)
parse.c:/*-----------.
parse.c:`-----------*/
parse.c:     look-ahead token if we need one and don't already have one.  */
parse.c:  /* First try to decide what to do without reference to look-ahead token.  */
parse.c:  /* Not known => get a look-ahead token if don't already have one.  */
parse.c:  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
parse.c:      yyn = -yyn;
parse.c:    yyerrstatus--;
parse.c:  /* Shift the look-ahead token.  */
parse.c:/*-----------------------------------------------------------.
parse.c:| yydefault -- do the default action for the current state.  |
parse.c:`-----------------------------------------------------------*/
parse.c:/*-----------------------------.
parse.c:| yyreduce -- Do a reduction.  |
parse.c:`-----------------------------*/
parse.c:  yyval = yyvsp[1-yylen];
parse.c:			if ((yyvsp[(2) - (2)].node) && !(yyvsp[(1) - (2)].num)) {
parse.c:			    if (nd_type((yyvsp[(2) - (2)].node)) != NODE_BLOCK) void_expr((yyvsp[(2) - (2)].node));
parse.c:				NODE *node = (yyvsp[(2) - (2)].node);
parse.c:				while (node->nd_next) {
parse.c:				    node = node->nd_next;
parse.c:				void_expr(node->nd_head);
parse.c:			ruby_eval_tree = NEW_SCOPE(0, block_append(ruby_eval_tree, (yyvsp[(2) - (2)].node)));
parse.c:			parser->result = dispatch1(program, $$);
parse.c:			void_stmts((yyvsp[(1) - (2)].node));
parse.c:			(yyval.node) = (yyvsp[(1) - (2)].node);
parse.c:			(yyval.node) = newline_node((yyvsp[(1) - (1)].node));
parse.c:			(yyval.node) = block_append((yyvsp[(1) - (3)].node), newline_node((yyvsp[(3) - (3)].node)));
parse.c:			(yyval.node) = remove_begin((yyvsp[(2) - (2)].node));
parse.c:							    (yyvsp[(4) - (5)].node));
parse.c:			(yyval.node) = (yyvsp[(1) - (4)].node);
parse.c:			if ((yyvsp[(2) - (4)].node)) {
parse.c:			    (yyval.node) = NEW_RESCUE((yyvsp[(1) - (4)].node), (yyvsp[(2) - (4)].node), (yyvsp[(3) - (4)].node));
parse.c:			else if ((yyvsp[(3) - (4)].node)) {
parse.c:			    (yyval.node) = block_append((yyval.node), (yyvsp[(3) - (4)].node));
parse.c:			if ((yyvsp[(4) - (4)].node)) {
parse.c:				(yyval.node) = NEW_ENSURE((yyval.node), (yyvsp[(4) - (4)].node));
parse.c:				(yyval.node) = block_append((yyvsp[(4) - (4)].node), NEW_NIL());
parse.c:			fixpos((yyval.node), (yyvsp[(1) - (4)].node));
parse.c:			void_stmts((yyvsp[(1) - (2)].node));
parse.c:			(yyval.node) = (yyvsp[(1) - (2)].node);
parse.c:			(yyval.node) = newline_node((yyvsp[(1) - (1)].node));
parse.c:			(yyval.node) = block_append((yyvsp[(1) - (3)].node), newline_node((yyvsp[(3) - (3)].node)));
parse.c:			(yyval.node) = remove_begin((yyvsp[(2) - (2)].node));
parse.c:			(yyval.node) = NEW_ALIAS((yyvsp[(2) - (4)].node), (yyvsp[(4) - (4)].node));
parse.c:			(yyval.node) = NEW_VALIAS((yyvsp[(2) - (3)].id), (yyvsp[(3) - (3)].id));
parse.c:			sprintf(buf, "$%c", (char)(yyvsp[(3) - (3)].node)->nd_nth);
parse.c:			(yyval.node) = NEW_VALIAS((yyvsp[(2) - (3)].id), rb_intern(buf));
parse.c:			(yyval.node) = (yyvsp[(2) - (2)].node);
parse.c:			(yyval.node) = NEW_IF(cond((yyvsp[(3) - (3)].node)), remove_begin((yyvsp[(1) - (3)].node)), 0);
parse.c:			fixpos((yyval.node), (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = NEW_UNLESS(cond((yyvsp[(3) - (3)].node)), remove_begin((yyvsp[(1) - (3)].node)), 0);
parse.c:			fixpos((yyval.node), (yyvsp[(3) - (3)].node));
parse.c:			if ((yyvsp[(1) - (3)].node) && nd_type((yyvsp[(1) - (3)].node)) == NODE_BEGIN) {
parse.c:			    (yyval.node) = NEW_WHILE(cond((yyvsp[(3) - (3)].node)), (yyvsp[(1) - (3)].node)->nd_body, 0);
parse.c:			    (yyval.node) = NEW_WHILE(cond((yyvsp[(3) - (3)].node)), (yyvsp[(1) - (3)].node), 1);
parse.c:			if ((yyvsp[(1) - (3)].node) && nd_type((yyvsp[(1) - (3)].node)) == NODE_BEGIN) {
parse.c:			    (yyval.node) = NEW_UNTIL(cond((yyvsp[(3) - (3)].node)), (yyvsp[(1) - (3)].node)->nd_body, 0);
parse.c:			    (yyval.node) = NEW_UNTIL(cond((yyvsp[(3) - (3)].node)), (yyvsp[(1) - (3)].node), 1);
parse.c:			NODE *resq = NEW_RESBODY(0, remove_begin((yyvsp[(3) - (3)].node)), 0);
parse.c:			(yyval.node) = NEW_RESCUE(remove_begin((yyvsp[(1) - (3)].node)), resq, 0);
parse.c:			    NODE_SCOPE, 0 /* tbl */, (yyvsp[(3) - (4)].node) /* body */, 0 /* args */));
parse.c:			value_expr((yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = node_assign((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c:			value_expr((yyvsp[(3) - (3)].node));
parse.c:			(yyvsp[(1) - (3)].node)->nd_value = (yyvsp[(3) - (3)].node);
parse.c:			(yyval.node) = (yyvsp[(1) - (3)].node);
parse.c:			value_expr((yyvsp[(3) - (3)].node));
parse.c:			if ((yyvsp[(1) - (3)].node)) {
parse.c:			    ID vid = (yyvsp[(1) - (3)].node)->nd_vid;
parse.c:			    if ((yyvsp[(2) - (3)].id) == tOROP) {
parse.c:				(yyvsp[(1) - (3)].node)->nd_value = (yyvsp[(3) - (3)].node);
parse.c:				(yyval.node) = NEW_OP_ASGN_OR(gettable(vid), (yyvsp[(1) - (3)].node));
parse.c:				    (yyval.node)->nd_aid = vid;
parse.c:			    else if ((yyvsp[(2) - (3)].id) == tANDOP) {
parse.c:				(yyvsp[(1) - (3)].node)->nd_value = (yyvsp[(3) - (3)].node);
parse.c:				(yyval.node) = NEW_OP_ASGN_AND(gettable(vid), (yyvsp[(1) - (3)].node));
parse.c:				(yyval.node) = (yyvsp[(1) - (3)].node);
parse.c:				(yyval.node)->nd_value = NEW_CALL(gettable(vid), (yyvsp[(2) - (3)].id), NEW_LIST((yyvsp[(3) - (3)].node)));
parse.c:			value_expr((yyvsp[(6) - (6)].node));
parse.c:			if (!(yyvsp[(3) - (6)].node)) (yyvsp[(3) - (6)].node) = NEW_ZARRAY();
parse.c:			args = arg_concat((yyvsp[(6) - (6)].node), (yyvsp[(3) - (6)].node));
parse.c:			if ((yyvsp[(5) - (6)].id) == tOROP) {
parse.c:			    (yyvsp[(5) - (6)].id) = 0;
parse.c:			else if ((yyvsp[(5) - (6)].id) == tANDOP) {
parse.c:			    (yyvsp[(5) - (6)].id) = 1;
parse.c:			(yyval.node) = NEW_OP_ASGN1((yyvsp[(1) - (6)].node), (yyvsp[(5) - (6)].id), args);
parse.c:			fixpos((yyval.node), (yyvsp[(1) - (6)].node));
parse.c:			value_expr((yyvsp[(5) - (5)].node));
parse.c:			if ((yyvsp[(4) - (5)].id) == tOROP) {
parse.c:			    (yyvsp[(4) - (5)].id) = 0;
parse.c:			else if ((yyvsp[(4) - (5)].id) == tANDOP) {
parse.c:			    (yyvsp[(4) - (5)].id) = 1;
parse.c:			(yyval.node) = NEW_OP_ASGN2((yyvsp[(1) - (5)].node), (yyvsp[(3) - (5)].id), (yyvsp[(4) - (5)].id), (yyvsp[(5) - (5)].node));
parse.c:			fixpos((yyval.node), (yyvsp[(1) - (5)].node));
parse.c:			value_expr((yyvsp[(5) - (5)].node));
parse.c:			if ((yyvsp[(4) - (5)].id) == tOROP) {
parse.c:			    (yyvsp[(4) - (5)].id) = 0;
parse.c:			else if ((yyvsp[(4) - (5)].id) == tANDOP) {
parse.c:			    (yyvsp[(4) - (5)].id) = 1;
parse.c:			(yyval.node) = NEW_OP_ASGN2((yyvsp[(1) - (5)].node), (yyvsp[(3) - (5)].id), (yyvsp[(4) - (5)].id), (yyvsp[(5) - (5)].node));
parse.c:			fixpos((yyval.node), (yyvsp[(1) - (5)].node));
parse.c:			value_expr((yyvsp[(5) - (5)].node));
parse.c:			if ((yyvsp[(4) - (5)].id) == tOROP) {
parse.c:			    (yyvsp[(4) - (5)].id) = 0;
parse.c:			else if ((yyvsp[(4) - (5)].id) == tANDOP) {
parse.c:			    (yyvsp[(4) - (5)].id) = 1;
parse.c:			(yyval.node) = NEW_OP_ASGN2((yyvsp[(1) - (5)].node), (yyvsp[(3) - (5)].id), (yyvsp[(4) - (5)].id), (yyvsp[(5) - (5)].node));
parse.c:			fixpos((yyval.node), (yyvsp[(1) - (5)].node));
parse.c:			rb_backref_error((yyvsp[(1) - (3)].node));
parse.c:			value_expr((yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = node_assign((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c:			(yyvsp[(1) - (3)].node)->nd_value = (yyvsp[(3) - (3)].node);
parse.c:			(yyval.node) = (yyvsp[(1) - (3)].node);
parse.c:			(yyvsp[(1) - (3)].node)->nd_value = (yyvsp[(3) - (3)].node);
parse.c:			(yyval.node) = (yyvsp[(1) - (3)].node);
parse.c:			(yyval.node) = logop(NODE_AND, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = logop(NODE_OR, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = call_uni_op(cond((yyvsp[(3) - (3)].node)), '!');
parse.c:			(yyval.node) = call_uni_op(cond((yyvsp[(2) - (2)].node)), '!');
parse.c:			value_expr((yyvsp[(1) - (1)].node));
parse.c:			(yyval.node) = (yyvsp[(1) - (1)].node);
parse.c:			(yyval.node) = NEW_RETURN(ret_args((yyvsp[(2) - (2)].node)));
parse.c:			(yyval.node) = NEW_BREAK(ret_args((yyvsp[(2) - (2)].node)));
parse.c:			(yyval.node) = NEW_NEXT(ret_args((yyvsp[(2) - (2)].node)));
parse.c:			(yyval.node) = NEW_CALL((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].id), (yyvsp[(4) - (4)].node));
parse.c:			(yyval.node) = NEW_CALL((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].id), (yyvsp[(4) - (4)].node));
parse.c:			(yyval.node) = NEW_ITER((yyvsp[(3) - (5)].node),(yyvsp[(4) - (5)].node));
parse.c:			nd_set_line((yyval.node), (yyvsp[(2) - (5)].num));
parse.c:			(yyval.node) = NEW_FCALL((yyvsp[(1) - (2)].id), (yyvsp[(2) - (2)].node));
parse.c:			fixpos((yyval.node), (yyvsp[(2) - (2)].node));
parse.c:			block_dup_check((yyvsp[(2) - (3)].node),(yyvsp[(3) - (3)].node));
parse.c:		        (yyvsp[(3) - (3)].node)->nd_iter = NEW_FCALL((yyvsp[(1) - (3)].id), (yyvsp[(2) - (3)].node));
parse.c:			(yyval.node) = (yyvsp[(3) - (3)].node);
parse.c:			fixpos((yyval.node), (yyvsp[(2) - (3)].node));
parse.c:			(yyval.node) = NEW_CALL((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].id), (yyvsp[(4) - (4)].node));
parse.c:			fixpos((yyval.node), (yyvsp[(1) - (4)].node));
parse.c:			block_dup_check((yyvsp[(4) - (5)].node),(yyvsp[(5) - (5)].node));
parse.c:		        (yyvsp[(5) - (5)].node)->nd_iter = NEW_CALL((yyvsp[(1) - (5)].node), (yyvsp[(3) - (5)].id), (yyvsp[(4) - (5)].node));
parse.c:			(yyval.node) = (yyvsp[(5) - (5)].node);
parse.c:			fixpos((yyval.node), (yyvsp[(1) - (5)].node));
parse.c:			(yyval.node) = NEW_CALL((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].id), (yyvsp[(4) - (4)].node));
parse.c:			fixpos((yyval.node), (yyvsp[(1) - (4)].node));
parse.c:			block_dup_check((yyvsp[(4) - (5)].node),(yyvsp[(5) - (5)].node));
parse.c:		        (yyvsp[(5) - (5)].node)->nd_iter = NEW_CALL((yyvsp[(1) - (5)].node), (yyvsp[(3) - (5)].id), (yyvsp[(4) - (5)].node));
parse.c:			(yyval.node) = (yyvsp[(5) - (5)].node);
parse.c:			fixpos((yyval.node), (yyvsp[(1) - (5)].node));
parse.c:			(yyval.node) = NEW_SUPER((yyvsp[(2) - (2)].node));
parse.c:			fixpos((yyval.node), (yyvsp[(2) - (2)].node));
parse.c:			(yyval.node) = new_yield((yyvsp[(2) - (2)].node));
parse.c:			fixpos((yyval.node), (yyvsp[(2) - (2)].node));
parse.c:			(yyval.node) = (yyvsp[(2) - (3)].node);
parse.c:			(yyval.node) = NEW_MASGN(NEW_LIST((yyvsp[(2) - (3)].node)), 0);
parse.c:			(yyval.node) = NEW_MASGN((yyvsp[(1) - (1)].node), 0);
parse.c:			(yyval.node) = NEW_MASGN(list_append((yyvsp[(1) - (2)].node),(yyvsp[(2) - (2)].node)), 0);
parse.c:			(yyval.node) = NEW_MASGN((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = NEW_MASGN((yyvsp[(1) - (5)].node), NEW_POSTARG((yyvsp[(3) - (5)].node),(yyvsp[(5) - (5)].node)));
parse.c:			(yyval.node) = NEW_MASGN((yyvsp[(1) - (2)].node), -1);
parse.c:			(yyval.node) = NEW_MASGN((yyvsp[(1) - (4)].node), NEW_POSTARG(-1, (yyvsp[(4) - (4)].node)));
parse.c:			(yyval.node) = NEW_MASGN(0, (yyvsp[(2) - (2)].node));
parse.c:			(yyval.node) = NEW_MASGN(0, NEW_POSTARG((yyvsp[(2) - (4)].node),(yyvsp[(4) - (4)].node)));
parse.c:			(yyval.node) = NEW_MASGN(0, -1);
parse.c:			(yyval.node) = NEW_MASGN(0, NEW_POSTARG(-1, (yyvsp[(3) - (3)].node)));
parse.c:			(yyval.node) = (yyvsp[(2) - (3)].node);
parse.c:			(yyval.node) = NEW_LIST((yyvsp[(1) - (2)].node));
parse.c:			(yyval.node) = list_append((yyvsp[(1) - (3)].node), (yyvsp[(2) - (3)].node));
parse.c:			(yyval.node) = NEW_LIST((yyvsp[(1) - (1)].node));
parse.c:			(yyval.node) = list_append((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = assignable((yyvsp[(1) - (1)].id), 0);
parse.c:			(yyval.node) = aryset((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].node));
parse.c:			(yyval.node) = attrset((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].id));
parse.c:			(yyval.node) = attrset((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].id));
parse.c:			(yyval.node) = attrset((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].id));
parse.c:			(yyval.node) = NEW_CDECL(0, 0, NEW_COLON2((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].id)));
parse.c:			(yyval.node) = NEW_CDECL(0, 0, NEW_COLON3((yyvsp[(2) - (2)].id)));
parse.c:			rb_backref_error((yyvsp[(1) - (1)].node));
parse.c:			if (!((yyval.node) = assignable((yyvsp[(1) - (1)].id), 0))) (yyval.node) = NEW_BEGIN(0);
parse.c:			(yyval.node) = aryset((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].node));
parse.c:			(yyval.node) = attrset((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].id));
parse.c:			(yyval.node) = attrset((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].id));
parse.c:			(yyval.node) = attrset((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].id));
parse.c:			(yyval.node) = NEW_CDECL(0, 0, NEW_COLON2((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].id)));
parse.c:			(yyval.node) = NEW_CDECL(0, 0, NEW_COLON3((yyvsp[(2) - (2)].id)));
parse.c:			rb_backref_error((yyvsp[(1) - (1)].node));
parse.c:			(yyval.node) = NEW_COLON3((yyvsp[(2) - (2)].id));
parse.c:			(yyval.node) = NEW_COLON2((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].id));
parse.c:			(yyval.id) = (yyvsp[(1) - (1)].id);
parse.c:			(yyval.id) = (yyvsp[(1) - (1)].id);
parse.c:			(yyval.node) = NEW_LIT(ID2SYM((yyvsp[(1) - (1)].id)));
parse.c:			(yyval.node) = NEW_UNDEF((yyvsp[(1) - (1)].node));
parse.c:			(yyval.node) = block_append((yyvsp[(1) - (4)].node), NEW_UNDEF((yyvsp[(4) - (4)].node)));
parse.c:    { ifndef_ripper((yyval.id) = '-'); ;}
parse.c:			(yyval.node) = (yyvsp[(1) - (1)].node);
parse.c:			value_expr((yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = node_assign((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c:			value_expr((yyvsp[(3) - (5)].node));
parse.c:		        (yyvsp[(3) - (5)].node) = NEW_RESCUE((yyvsp[(3) - (5)].node), NEW_RESBODY(0,(yyvsp[(5) - (5)].node),0), 0);
parse.c:			(yyval.node) = node_assign((yyvsp[(1) - (5)].node), (yyvsp[(3) - (5)].node));
parse.c:			value_expr((yyvsp[(3) - (3)].node));
parse.c:			if ((yyvsp[(1) - (3)].node)) {
parse.c:			    ID vid = (yyvsp[(1) - (3)].node)->nd_vid;
parse.c:			    if ((yyvsp[(2) - (3)].id) == tOROP) {
parse.c:				(yyvsp[(1) - (3)].node)->nd_value = (yyvsp[(3) - (3)].node);
parse.c:				(yyval.node) = NEW_OP_ASGN_OR(gettable(vid), (yyvsp[(1) - (3)].node));
parse.c:				    (yyval.node)->nd_aid = vid;
parse.c:			    else if ((yyvsp[(2) - (3)].id) == tANDOP) {
parse.c:				(yyvsp[(1) - (3)].node)->nd_value = (yyvsp[(3) - (3)].node);
parse.c:				(yyval.node) = NEW_OP_ASGN_AND(gettable(vid), (yyvsp[(1) - (3)].node));
parse.c:				(yyval.node) = (yyvsp[(1) - (3)].node);
parse.c:				(yyval.node)->nd_value = NEW_CALL(gettable(vid), (yyvsp[(2) - (3)].id), NEW_LIST((yyvsp[(3) - (3)].node)));
parse.c:			value_expr((yyvsp[(3) - (5)].node));
parse.c:		        (yyvsp[(3) - (5)].node) = NEW_RESCUE((yyvsp[(3) - (5)].node), NEW_RESBODY(0,(yyvsp[(5) - (5)].node),0), 0);
parse.c:			if ((yyvsp[(1) - (5)].node)) {
parse.c:			    ID vid = (yyvsp[(1) - (5)].node)->nd_vid;
parse.c:			    if ((yyvsp[(2) - (5)].id) == tOROP) {
parse.c:				(yyvsp[(1) - (5)].node)->nd_value = (yyvsp[(3) - (5)].node);
parse.c:				(yyval.node) = NEW_OP_ASGN_OR(gettable(vid), (yyvsp[(1) - (5)].node));
parse.c:				    (yyval.node)->nd_aid = vid;
parse.c:			    else if ((yyvsp[(2) - (5)].id) == tANDOP) {
parse.c:				(yyvsp[(1) - (5)].node)->nd_value = (yyvsp[(3) - (5)].node);
parse.c:				(yyval.node) = NEW_OP_ASGN_AND(gettable(vid), (yyvsp[(1) - (5)].node));
parse.c:				(yyval.node) = (yyvsp[(1) - (5)].node);
parse.c:				(yyval.node)->nd_value = NEW_CALL(gettable(vid), (yyvsp[(2) - (5)].id), NEW_LIST((yyvsp[(3) - (5)].node)));
parse.c:			value_expr((yyvsp[(6) - (6)].node));
parse.c:			if (!(yyvsp[(3) - (6)].node)) (yyvsp[(3) - (6)].node) = NEW_ZARRAY();
parse.c:			args = arg_concat((yyvsp[(6) - (6)].node), (yyvsp[(3) - (6)].node));
parse.c:			if ((yyvsp[(5) - (6)].id) == tOROP) {
parse.c:			    (yyvsp[(5) - (6)].id) = 0;
parse.c:			else if ((yyvsp[(5) - (6)].id) == tANDOP) {
parse.c:			    (yyvsp[(5) - (6)].id) = 1;
parse.c:			(yyval.node) = NEW_OP_ASGN1((yyvsp[(1) - (6)].node), (yyvsp[(5) - (6)].id), args);
parse.c:			fixpos((yyval.node), (yyvsp[(1) - (6)].node));
parse.c:			value_expr((yyvsp[(5) - (5)].node));
parse.c:			if ((yyvsp[(4) - (5)].id) == tOROP) {
parse.c:			    (yyvsp[(4) - (5)].id) = 0;
parse.c:			else if ((yyvsp[(4) - (5)].id) == tANDOP) {
parse.c:			    (yyvsp[(4) - (5)].id) = 1;
parse.c:			(yyval.node) = NEW_OP_ASGN2((yyvsp[(1) - (5)].node), (yyvsp[(3) - (5)].id), (yyvsp[(4) - (5)].id), (yyvsp[(5) - (5)].node));
parse.c:			fixpos((yyval.node), (yyvsp[(1) - (5)].node));
parse.c:			value_expr((yyvsp[(5) - (5)].node));
parse.c:			if ((yyvsp[(4) - (5)].id) == tOROP) {
parse.c:			    (yyvsp[(4) - (5)].id) = 0;
parse.c:			else if ((yyvsp[(4) - (5)].id) == tANDOP) {
parse.c:			    (yyvsp[(4) - (5)].id) = 1;
parse.c:			(yyval.node) = NEW_OP_ASGN2((yyvsp[(1) - (5)].node), (yyvsp[(3) - (5)].id), (yyvsp[(4) - (5)].id), (yyvsp[(5) - (5)].node));
parse.c:			fixpos((yyval.node), (yyvsp[(1) - (5)].node));
parse.c:			value_expr((yyvsp[(5) - (5)].node));
parse.c:			if ((yyvsp[(4) - (5)].id) == tOROP) {
parse.c:			    (yyvsp[(4) - (5)].id) = 0;
parse.c:			else if ((yyvsp[(4) - (5)].id) == tANDOP) {
parse.c:			    (yyvsp[(4) - (5)].id) = 1;
parse.c:			(yyval.node) = NEW_OP_ASGN2((yyvsp[(1) - (5)].node), (yyvsp[(3) - (5)].id), (yyvsp[(4) - (5)].id), (yyvsp[(5) - (5)].node));
parse.c:			fixpos((yyval.node), (yyvsp[(1) - (5)].node));
parse.c:			yyerror("constant re-assignment");
parse.c:			yyerror("constant re-assignment");
parse.c:			rb_backref_error((yyvsp[(1) - (3)].node));
parse.c:			value_expr((yyvsp[(1) - (3)].node));
parse.c:			value_expr((yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = NEW_DOT2((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c:			if (nd_type((yyvsp[(1) - (3)].node)) == NODE_LIT && FIXNUM_P((yyvsp[(1) - (3)].node)->nd_lit) &&
parse.c:			    nd_type((yyvsp[(3) - (3)].node)) == NODE_LIT && FIXNUM_P((yyvsp[(3) - (3)].node)->nd_lit)) {
parse.c:			value_expr((yyvsp[(1) - (3)].node));
parse.c:			value_expr((yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = NEW_DOT3((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c:			if (nd_type((yyvsp[(1) - (3)].node)) == NODE_LIT && FIXNUM_P((yyvsp[(1) - (3)].node)->nd_lit) &&
parse.c:			    nd_type((yyvsp[(3) - (3)].node)) == NODE_LIT && FIXNUM_P((yyvsp[(3) - (3)].node)->nd_lit)) {
parse.c:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), '+', (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), '-', (yyvsp[(3) - (3)].node));
parse.c:			$$ = dispatch3(binary, $1, ID2SYM('-'), $3);
parse.c:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), '*', (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), '/', (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), '%', (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), tPOW, (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = NEW_CALL(call_bin_op((yyvsp[(2) - (4)].node), tPOW, (yyvsp[(4) - (4)].node)), tUMINUS, 0);
parse.c:			$$ = dispatch2(unary, ripper_intern("-@"), $$);
parse.c:			(yyval.node) = NEW_CALL(call_bin_op((yyvsp[(2) - (4)].node), tPOW, (yyvsp[(4) - (4)].node)), tUMINUS, 0);
parse.c:			$$ = dispatch2(unary, ripper_intern("-@"), $$);
parse.c:			(yyval.node) = call_uni_op((yyvsp[(2) - (2)].node), tUPLUS);
parse.c:			(yyval.node) = call_uni_op((yyvsp[(2) - (2)].node), tUMINUS);
parse.c:			$$ = dispatch2(unary, ripper_intern("-@"), $2);
parse.c:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), '|', (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), '^', (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), '&', (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), tCMP, (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), '>', (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), tGEQ, (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), '<', (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), tLEQ, (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), tEQ, (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), tEQQ, (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), tNEQ, (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = match_op((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c:                        if (nd_type((yyvsp[(1) - (3)].node)) == NODE_LIT && TYPE((yyvsp[(1) - (3)].node)->nd_lit) == T_REGEXP) {
parse.c:                            (yyval.node) = reg_named_capture_assign((yyvsp[(1) - (3)].node)->nd_lit, (yyval.node));
parse.c:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), tNMATCH, (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = call_uni_op(cond((yyvsp[(2) - (2)].node)), '!');
parse.c:			(yyval.node) = call_uni_op((yyvsp[(2) - (2)].node), '~');
parse.c:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), tLSHFT, (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), tRSHFT, (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = logop(NODE_AND, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = logop(NODE_OR, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = NEW_DEFINED((yyvsp[(4) - (4)].node));
parse.c:			value_expr((yyvsp[(1) - (6)].node));
parse.c:			(yyval.node) = NEW_IF(cond((yyvsp[(1) - (6)].node)), (yyvsp[(3) - (6)].node), (yyvsp[(6) - (6)].node));
parse.c:			fixpos((yyval.node), (yyvsp[(1) - (6)].node));
parse.c:			(yyval.node) = (yyvsp[(1) - (1)].node);
parse.c:			value_expr((yyvsp[(1) - (1)].node));
parse.c:			(yyval.node) = (yyvsp[(1) - (1)].node);
parse.c:			value_expr((yyvsp[(1) - (1)].node));
parse.c:			(yyval.node) = (yyvsp[(1) - (1)].node);
parse.c:			(yyval.node) = (yyvsp[(1) - (2)].node);
parse.c:			(yyval.node) = arg_append((yyvsp[(1) - (4)].node), NEW_HASH((yyvsp[(3) - (4)].node)));
parse.c:			(yyval.node) = NEW_LIST(NEW_HASH((yyvsp[(1) - (2)].node)));
parse.c:			(yyval.node) = (yyvsp[(2) - (3)].node);
parse.c:			(yyval.node) = NEW_LIST((yyvsp[(1) - (1)].node));
parse.c:			(yyval.node) = arg_blk_pass((yyvsp[(1) - (2)].node), (yyvsp[(2) - (2)].node));
parse.c:			(yyval.node) = NEW_LIST(NEW_HASH((yyvsp[(1) - (2)].node)));
parse.c:			(yyval.node) = arg_blk_pass((yyval.node), (yyvsp[(2) - (2)].node));
parse.c:			(yyval.node) = arg_append((yyvsp[(1) - (4)].node), NEW_HASH((yyvsp[(3) - (4)].node)));
parse.c:			(yyval.node) = arg_blk_pass((yyval.node), (yyvsp[(4) - (4)].node));
parse.c:			cmdarg_stack = (yyvsp[(1) - (2)].num);
parse.c:			(yyval.node) = (yyvsp[(2) - (2)].node);
parse.c:			(yyval.node) = NEW_BLOCK_PASS((yyvsp[(2) - (2)].node));
parse.c:			(yyval.node) = (yyvsp[(2) - (2)].node);
parse.c:			(yyval.node) = NEW_LIST((yyvsp[(1) - (1)].node));
parse.c:			(yyval.node) = NEW_LIST((yyvsp[(1) - (1)].node));
parse.c:			(yyval.node) = NEW_SPLAT((yyvsp[(2) - (2)].node));
parse.c:			if ((n1 = splat_array((yyvsp[(1) - (3)].node))) != 0) {
parse.c:			    (yyval.node) = list_append(n1, (yyvsp[(3) - (3)].node));
parse.c:			    (yyval.node) = arg_append((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c:			if ((nd_type((yyvsp[(4) - (4)].node)) == NODE_ARRAY) && (n1 = splat_array((yyvsp[(1) - (4)].node))) != 0) {
parse.c:			    (yyval.node) = list_concat(n1, (yyvsp[(4) - (4)].node));
parse.c:			    (yyval.node) = arg_concat((yyvsp[(1) - (4)].node), (yyvsp[(4) - (4)].node));
parse.c:			if ((n1 = splat_array((yyvsp[(1) - (3)].node))) != 0) {
parse.c:			    (yyval.node) = list_append(n1, (yyvsp[(3) - (3)].node));
parse.c:			    (yyval.node) = arg_append((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c:			if (nd_type((yyvsp[(4) - (4)].node)) == NODE_ARRAY &&
parse.c:			    (n1 = splat_array((yyvsp[(1) - (4)].node))) != 0) {
parse.c:			    (yyval.node) = list_concat(n1, (yyvsp[(4) - (4)].node));
parse.c:			    (yyval.node) = arg_concat((yyvsp[(1) - (4)].node), (yyvsp[(4) - (4)].node));
parse.c:			(yyval.node) = NEW_SPLAT((yyvsp[(2) - (2)].node));
parse.c:			if ((yyvsp[(2) - (3)].node) == 0) {
parse.c:			    (yyval.node) = (yyvsp[(2) - (3)].node);
parse.c:			(yyval.node) = NEW_FCALL((yyvsp[(1) - (1)].id), 0);
parse.c:			if ((yyvsp[(3) - (4)].node) == NULL) {
parse.c:			    if (nd_type((yyvsp[(3) - (4)].node)) == NODE_RESCUE ||
parse.c:				nd_type((yyvsp[(3) - (4)].node)) == NODE_ENSURE)
parse.c:				nd_set_line((yyvsp[(3) - (4)].node), (yyvsp[(2) - (4)].num));
parse.c:			    (yyval.node) = NEW_BEGIN((yyvsp[(3) - (4)].node));
parse.c:			nd_set_line((yyval.node), (yyvsp[(2) - (4)].num));
parse.c:			(yyval.node) = (yyvsp[(2) - (4)].node);
parse.c:			(yyval.node) = (yyvsp[(2) - (3)].node);
parse.c:			(yyval.node) = NEW_COLON2((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].id));
parse.c:			(yyval.node) = NEW_COLON3((yyvsp[(2) - (2)].id));
parse.c:			if ((yyvsp[(2) - (3)].node) == 0) {
parse.c:			    (yyval.node) = (yyvsp[(2) - (3)].node);
parse.c:			(yyval.node) = NEW_HASH((yyvsp[(2) - (3)].node));
parse.c:			(yyval.node) = new_yield((yyvsp[(3) - (4)].node));
parse.c:			(yyval.node) = NEW_DEFINED((yyvsp[(5) - (6)].node));
parse.c:			(yyval.node) = call_uni_op(cond((yyvsp[(3) - (4)].node)), '!');
parse.c:			(yyvsp[(2) - (2)].node)->nd_iter = NEW_FCALL((yyvsp[(1) - (2)].id), 0);
parse.c:			(yyval.node) = (yyvsp[(2) - (2)].node);
parse.c:			fixpos((yyvsp[(2) - (2)].node)->nd_iter, (yyvsp[(2) - (2)].node));
parse.c:			block_dup_check((yyvsp[(1) - (2)].node)->nd_args, (yyvsp[(2) - (2)].node));
parse.c:			(yyvsp[(2) - (2)].node)->nd_iter = (yyvsp[(1) - (2)].node);
parse.c:			(yyval.node) = (yyvsp[(2) - (2)].node);
parse.c:			fixpos((yyval.node), (yyvsp[(1) - (2)].node));
parse.c:			(yyval.node) = (yyvsp[(2) - (2)].node);
parse.c:			(yyval.node) = NEW_IF(cond((yyvsp[(2) - (6)].node)), (yyvsp[(4) - (6)].node), (yyvsp[(5) - (6)].node));
parse.c:			fixpos((yyval.node), (yyvsp[(2) - (6)].node));
parse.c:			(yyval.node) = NEW_UNLESS(cond((yyvsp[(2) - (6)].node)), (yyvsp[(4) - (6)].node), (yyvsp[(5) - (6)].node));
parse.c:			fixpos((yyval.node), (yyvsp[(2) - (6)].node));
parse.c:			(yyval.node) = NEW_WHILE(cond((yyvsp[(3) - (7)].node)), (yyvsp[(6) - (7)].node), 1);
parse.c:			fixpos((yyval.node), (yyvsp[(3) - (7)].node));
parse.c:			(yyval.node) = NEW_UNTIL(cond((yyvsp[(3) - (7)].node)), (yyvsp[(6) - (7)].node), 1);
parse.c:			fixpos((yyval.node), (yyvsp[(3) - (7)].node));
parse.c:			(yyval.node) = NEW_PATERN((yyvsp[(2) - (5)].node), (yyvsp[(4) - (5)].node));
parse.c:			fixpos((yyval.node), (yyvsp[(2) - (5)].node));
parse.c:			(yyval.node) = NEW_CASE((yyvsp[(2) - (5)].node), (yyvsp[(4) - (5)].node));
parse.c:			fixpos((yyval.node), (yyvsp[(2) - (5)].node));
parse.c:			(yyval.node) = NEW_CASE(0, (yyvsp[(3) - (4)].node));
parse.c:			if (nd_type((yyvsp[(2) - (9)].node)) == NODE_MASGN) {
parse.c:			    m->nd_next = block_append(
parse.c:				node_assign((yyvsp[(2) - (9)].node), NEW_DVAR(id)));
parse.c:			    if (nd_type((yyvsp[(2) - (9)].node)) == NODE_LASGN ||
parse.c:				nd_type((yyvsp[(2) - (9)].node)) == NODE_DASGN ||
parse.c:				nd_type((yyvsp[(2) - (9)].node)) == NODE_DASGN_CURR) {
parse.c:				(yyvsp[(2) - (9)].node)->nd_value = NEW_DVAR(id);
parse.c:				m->nd_plen = 1;
parse.c:				m->nd_next = (yyvsp[(2) - (9)].node);
parse.c:				m->nd_next = node_assign(NEW_MASGN(NEW_LIST((yyvsp[(2) - (9)].node)), 0), NEW_DVAR(id));
parse.c:			scope = NEW_NODE(NODE_SCOPE, tbl, (yyvsp[(8) - (9)].node), args);
parse.c:			(yyval.node) = NEW_FOR(0, (yyvsp[(5) - (9)].node), scope);
parse.c:			fixpos((yyval.node), (yyvsp[(2) - (9)].node));
parse.c:			(yyval.node) = NEW_CLASS((yyvsp[(2) - (6)].node), (yyvsp[(5) - (6)].node), (yyvsp[(3) - (6)].node));
parse.c:			nd_set_line((yyval.node), (yyvsp[(4) - (6)].num));
parse.c:			(yyval.node) = NEW_SCLASS((yyvsp[(3) - (8)].node), (yyvsp[(7) - (8)].node));
parse.c:			fixpos((yyval.node), (yyvsp[(3) - (8)].node));
parse.c:			in_def = (yyvsp[(4) - (8)].num);
parse.c:			in_single = (yyvsp[(6) - (8)].num);
parse.c:			(yyval.node) = NEW_MODULE((yyvsp[(2) - (5)].node), (yyvsp[(4) - (5)].node));
parse.c:			nd_set_line((yyval.node), (yyvsp[(3) - (5)].num));
parse.c:			cur_mid = (yyvsp[(2) - (2)].id);
parse.c:			NODE *body = remove_begin((yyvsp[(5) - (6)].node));
parse.c:			(yyval.node) = NEW_DEFN((yyvsp[(2) - (6)].id), (yyvsp[(4) - (6)].node), body, NOEX_PRIVATE);
parse.c:			fixpos((yyval.node), (yyvsp[(4) - (6)].node));
parse.c:			fixpos((yyval.node)->nd_defn, (yyvsp[(4) - (6)].node));
parse.c:			in_def--;
parse.c:			cur_mid = (yyvsp[(3) - (6)].id);
parse.c:			NODE *body = remove_begin((yyvsp[(8) - (9)].node));
parse.c:			(yyval.node) = NEW_DEFS((yyvsp[(2) - (9)].node), (yyvsp[(5) - (9)].id), (yyvsp[(7) - (9)].node), body);
parse.c:			fixpos((yyval.node), (yyvsp[(2) - (9)].node));
parse.c:			fixpos((yyval.node)->nd_defn, (yyvsp[(2) - (9)].node));
parse.c:			in_single--;
parse.c:			value_expr((yyvsp[(1) - (1)].node));
parse.c:			(yyval.node) = (yyvsp[(1) - (1)].node);
parse.c:			(yyval.node) = NEW_IF(cond((yyvsp[(2) - (5)].node)), (yyvsp[(4) - (5)].node), (yyvsp[(5) - (5)].node));
parse.c:			fixpos((yyval.node), (yyvsp[(2) - (5)].node));
parse.c:			(yyval.node) = (yyvsp[(2) - (2)].node);
parse.c:			(yyval.node) = assignable((yyvsp[(1) - (1)].id), 0);
parse.c:			(yyval.node) = (yyvsp[(2) - (3)].node);
parse.c:			(yyval.node) = NEW_LIST((yyvsp[(1) - (1)].node));
parse.c:			(yyval.node) = list_append((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = NEW_MASGN((yyvsp[(1) - (1)].node), 0);
parse.c:			(yyval.node) = NEW_MASGN((yyvsp[(1) - (4)].node), assignable((yyvsp[(4) - (4)].id), 0));
parse.c:			(yyval.node) = NEW_MASGN((yyvsp[(1) - (6)].node), NEW_POSTARG(assignable((yyvsp[(4) - (6)].id), 0), (yyvsp[(6) - (6)].node)));
parse.c:			(yyval.node) = NEW_MASGN((yyvsp[(1) - (3)].node), -1);
parse.c:			(yyval.node) = NEW_MASGN((yyvsp[(1) - (5)].node), NEW_POSTARG(-1, (yyvsp[(5) - (5)].node)));
parse.c:			(yyval.node) = NEW_MASGN(0, assignable((yyvsp[(2) - (2)].id), 0));
parse.c:			(yyval.node) = NEW_MASGN(0, NEW_POSTARG(assignable((yyvsp[(2) - (4)].id), 0), (yyvsp[(4) - (4)].node)));
parse.c:			(yyval.node) = NEW_MASGN(0, -1);
parse.c:			(yyval.node) = NEW_MASGN(0, NEW_POSTARG(-1, (yyvsp[(3) - (3)].node)));
parse.c:			(yyval.node) = new_args((yyvsp[(1) - (6)].node), (yyvsp[(3) - (6)].node), (yyvsp[(5) - (6)].id), 0, (yyvsp[(6) - (6)].id));
parse.c:			(yyval.node) = new_args((yyvsp[(1) - (8)].node), (yyvsp[(3) - (8)].node), (yyvsp[(5) - (8)].id), (yyvsp[(7) - (8)].node), (yyvsp[(8) - (8)].id));
parse.c:			(yyval.node) = new_args((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].node), 0, 0, (yyvsp[(4) - (4)].id));
parse.c:			(yyval.node) = new_args((yyvsp[(1) - (6)].node), (yyvsp[(3) - (6)].node), 0, (yyvsp[(5) - (6)].node), (yyvsp[(6) - (6)].id));
parse.c:			(yyval.node) = new_args((yyvsp[(1) - (4)].node), 0, (yyvsp[(3) - (4)].id), 0, (yyvsp[(4) - (4)].id));
parse.c:			(yyval.node) = new_args((yyvsp[(1) - (2)].node), 0, 1, 0, 0);
parse.c:			(yyval.node) = new_args((yyvsp[(1) - (6)].node), 0, (yyvsp[(3) - (6)].id), (yyvsp[(5) - (6)].node), (yyvsp[(6) - (6)].id));
parse.c:			(yyval.node) = new_args((yyvsp[(1) - (2)].node), 0, 0, 0, (yyvsp[(2) - (2)].id));
parse.c:			(yyval.node) = new_args(0, (yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].id), 0, (yyvsp[(4) - (4)].id));
parse.c:			(yyval.node) = new_args(0, (yyvsp[(1) - (6)].node), (yyvsp[(3) - (6)].id), (yyvsp[(5) - (6)].node), (yyvsp[(6) - (6)].id));
parse.c:			(yyval.node) = new_args(0, (yyvsp[(1) - (2)].node), 0, 0, (yyvsp[(2) - (2)].id));
parse.c:			(yyval.node) = new_args(0, (yyvsp[(1) - (4)].node), 0, (yyvsp[(3) - (4)].node), (yyvsp[(4) - (4)].id));
parse.c:			(yyval.node) = new_args(0, 0, (yyvsp[(1) - (2)].id), 0, (yyvsp[(2) - (2)].id));
parse.c:			(yyval.node) = new_args(0, 0, (yyvsp[(1) - (4)].id), (yyvsp[(3) - (4)].node), (yyvsp[(4) - (4)].id));
parse.c:			(yyval.node) = new_args(0, 0, 0, 0, (yyvsp[(1) - (1)].id));
parse.c:			(yyval.node) = (yyvsp[(2) - (4)].node);
parse.c:			new_bv((yyvsp[(1) - (1)].id));
parse.c:			lpar_beg = (yyvsp[(1) - (3)].num);
parse.c:			(yyval.node) = (yyvsp[(2) - (3)].node);
parse.c:			(yyval.node)->nd_body = NEW_SCOPE((yyvsp[(2) - (3)].node)->nd_head, (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = NEW_LAMBDA((yyvsp[(2) - (4)].node));
parse.c:			(yyval.node) = NEW_LAMBDA((yyvsp[(1) - (1)].node));
parse.c:			(yyval.node) = (yyvsp[(2) - (3)].node);
parse.c:			(yyval.node) = (yyvsp[(2) - (3)].node);
parse.c:			(yyval.node) = NEW_ITER((yyvsp[(3) - (5)].node),(yyvsp[(4) - (5)].node));
parse.c:			nd_set_line((yyval.node), (yyvsp[(2) - (5)].num));
parse.c:			if (nd_type((yyvsp[(1) - (2)].node)) == NODE_YIELD) {
parse.c:			    block_dup_check((yyvsp[(1) - (2)].node)->nd_args, (yyvsp[(2) - (2)].node));
parse.c:			(yyvsp[(2) - (2)].node)->nd_iter = (yyvsp[(1) - (2)].node);
parse.c:			(yyval.node) = (yyvsp[(2) - (2)].node);
parse.c:			fixpos((yyval.node), (yyvsp[(1) - (2)].node));
parse.c:			(yyval.node) = NEW_CALL((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].id), (yyvsp[(4) - (4)].node));
parse.c:			(yyval.node) = NEW_CALL((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].id), (yyvsp[(4) - (4)].node));
parse.c:			(yyval.node) = NEW_FCALL((yyvsp[(1) - (2)].id), (yyvsp[(2) - (2)].node));
parse.c:			fixpos((yyval.node), (yyvsp[(2) - (2)].node));
parse.c:			(yyval.node) = NEW_CALL((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].id), (yyvsp[(4) - (4)].node));
parse.c:			fixpos((yyval.node), (yyvsp[(1) - (4)].node));
parse.c:			(yyval.node) = NEW_CALL((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].id), (yyvsp[(4) - (4)].node));
parse.c:			fixpos((yyval.node), (yyvsp[(1) - (4)].node));
parse.c:			(yyval.node) = NEW_CALL((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].id), 0);
parse.c:			(yyval.node) = NEW_CALL((yyvsp[(1) - (3)].node), rb_intern("call"), (yyvsp[(3) - (3)].node));
parse.c:			fixpos((yyval.node), (yyvsp[(1) - (3)].node));
parse.c:			(yyval.node) = NEW_CALL((yyvsp[(1) - (3)].node), rb_intern("call"), (yyvsp[(3) - (3)].node));
parse.c:			fixpos((yyval.node), (yyvsp[(1) - (3)].node));
parse.c:			(yyval.node) = NEW_SUPER((yyvsp[(2) - (2)].node));
parse.c:		      if ((yyvsp[(1) - (4)].node) && nd_type((yyvsp[(1) - (4)].node)) == NODE_SELF)
parse.c:			    (yyval.node) = NEW_FCALL(tAREF, (yyvsp[(3) - (4)].node));
parse.c:			    (yyval.node) = NEW_CALL((yyvsp[(1) - (4)].node), tAREF, (yyvsp[(3) - (4)].node));
parse.c:			fixpos((yyval.node), (yyvsp[(1) - (4)].node));
parse.c:			(yyval.node) = NEW_ITER((yyvsp[(3) - (5)].node),(yyvsp[(4) - (5)].node));
parse.c:			nd_set_line((yyval.node), (yyvsp[(2) - (5)].num));
parse.c:			nd_set_line((yyval.node)->nd_body, (yyvsp[(2) - (5)].num));
parse.c:			nd_set_line((yyval.node)->nd_body->nd_body, (yyvsp[(2) - (5)].num));
parse.c:			(yyval.node) = NEW_ITER((yyvsp[(3) - (5)].node),(yyvsp[(4) - (5)].node));
parse.c:			nd_set_line((yyval.node), (yyvsp[(2) - (5)].num));
parse.c:			(yyval.node) = NEW_WHEN((yyvsp[(2) - (5)].node), (yyvsp[(4) - (5)].node), (yyvsp[(5) - (5)].node));
parse.c:			(yyval.node) = NEW_WHEN((yyvsp[(2) - (5)].node), (yyvsp[(4) - (5)].node), (yyvsp[(5) - (5)].node));
parse.c:			if ((yyvsp[(3) - (6)].node)) {
parse.c:			    (yyvsp[(3) - (6)].node) = node_assign((yyvsp[(3) - (6)].node), NEW_ERRINFO());
parse.c:			    (yyvsp[(5) - (6)].node) = block_append((yyvsp[(3) - (6)].node), (yyvsp[(5) - (6)].node));
parse.c:			(yyval.node) = NEW_RESBODY((yyvsp[(2) - (6)].node), (yyvsp[(5) - (6)].node), (yyvsp[(6) - (6)].node));
parse.c:			fixpos((yyval.node), (yyvsp[(2) - (6)].node)?(yyvsp[(2) - (6)].node):(yyvsp[(5) - (6)].node));
parse.c:			(yyval.node) = NEW_LIST((yyvsp[(1) - (1)].node));
parse.c:			if (!((yyval.node) = splat_array((yyvsp[(1) - (1)].node)))) (yyval.node) = (yyvsp[(1) - (1)].node);
parse.c:			(yyval.node) = (yyvsp[(2) - (2)].node);
parse.c:			(yyval.node) = (yyvsp[(2) - (2)].node);
parse.c:			(yyval.node) = NEW_LIT(ID2SYM((yyvsp[(1) - (1)].id)));
parse.c:			NODE *node = (yyvsp[(1) - (1)].node);
parse.c:			(yyval.node) = literal_concat((yyvsp[(1) - (2)].node), (yyvsp[(2) - (2)].node));
parse.c:			(yyval.node) = (yyvsp[(2) - (3)].node);
parse.c:			NODE *node = (yyvsp[(2) - (3)].node);
parse.c:			int options = (yyvsp[(3) - (3)].num);
parse.c:			NODE *node = (yyvsp[(2) - (3)].node);
parse.c:				VALUE src = node->nd_lit;
parse.c:				node->nd_lit = reg_compile(src, options);
parse.c:			    node->nd_cflag = options & RE_OPTION_MASK;
parse.c:                            reg_fragment_check(node->nd_lit, options);
parse.c:                            for (list = node->nd_next; list; list = list->nd_next) {
parse.c:                                if (nd_type(list->nd_head) == NODE_STR) {
parse.c:                                    reg_fragment_check(list->nd_head->nd_lit, options);
parse.c:			(yyval.node) = (yyvsp[(2) - (3)].node);
parse.c:			(yyval.node) = list_append((yyvsp[(1) - (3)].node), evstr2dstr((yyvsp[(2) - (3)].node)));
parse.c:			(yyval.node) = literal_concat((yyvsp[(1) - (2)].node), (yyvsp[(2) - (2)].node));
parse.c:			(yyval.node) = (yyvsp[(2) - (3)].node);
parse.c:			(yyval.node) = list_append((yyvsp[(1) - (3)].node), (yyvsp[(2) - (3)].node));
parse.c:			(yyval.node) = literal_concat((yyvsp[(1) - (2)].node), (yyvsp[(2) - (2)].node));
parse.c:			(yyval.node) = literal_concat((yyvsp[(1) - (2)].node), (yyvsp[(2) - (2)].node));
parse.c:			lex_strterm = (yyvsp[(2) - (3)].node);
parse.c:			(yyval.node) = NEW_EVSTR((yyvsp[(3) - (3)].node));
parse.c:			lex_strterm = (yyvsp[(2) - (4)].node);
parse.c:			if ((yyvsp[(3) - (4)].node)) (yyvsp[(3) - (4)].node)->flags &= ~NODE_FL_NEWLINE;
parse.c:			(yyval.node) = new_evstr((yyvsp[(3) - (4)].node));
parse.c:			(yyval.node) = NEW_GVAR((yyvsp[(1) - (1)].id));
parse.c:			(yyval.node) = NEW_IVAR((yyvsp[(1) - (1)].id));
parse.c:			(yyval.node) = NEW_CVAR((yyvsp[(1) - (1)].id));
parse.c:			(yyval.id) = (yyvsp[(2) - (2)].id);
parse.c:			if (!((yyval.node) = (yyvsp[(2) - (3)].node))) {
parse.c:				lit = (yyval.node)->nd_lit;
parse.c:				(yyval.node)->nd_lit = ID2SYM(rb_intern_str(lit));
parse.c:			(yyval.node) = negate_lit((yyvsp[(2) - (2)].node));
parse.c:			$$ = dispatch2(unary, ripper_intern("-@"), $2);
parse.c:			(yyval.node) = negate_lit((yyvsp[(2) - (2)].node));
parse.c:			$$ = dispatch2(unary, ripper_intern("-@"), $2);
parse.c:			if (!((yyval.node) = gettable((yyvsp[(1) - (1)].id)))) (yyval.node) = NEW_BEGIN(0);
parse.c:			(yyval.node) = assignable((yyvsp[(1) - (1)].id), 0);
parse.c:			(yyval.node) = (yyvsp[(3) - (4)].node);
parse.c:			(yyval.node) = (yyvsp[(2) - (3)].node);
parse.c:			(yyval.node) = (yyvsp[(1) - (2)].node);
parse.c:			(yyval.node) = new_args((yyvsp[(1) - (6)].node), (yyvsp[(3) - (6)].node), (yyvsp[(5) - (6)].id), 0, (yyvsp[(6) - (6)].id));
parse.c:			(yyval.node) = new_args((yyvsp[(1) - (8)].node), (yyvsp[(3) - (8)].node), (yyvsp[(5) - (8)].id), (yyvsp[(7) - (8)].node), (yyvsp[(8) - (8)].id));
parse.c:			(yyval.node) = new_args((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].node), 0, 0, (yyvsp[(4) - (4)].id));
parse.c:			(yyval.node) = new_args((yyvsp[(1) - (6)].node), (yyvsp[(3) - (6)].node), 0, (yyvsp[(5) - (6)].node), (yyvsp[(6) - (6)].id));
parse.c:			(yyval.node) = new_args((yyvsp[(1) - (4)].node), 0, (yyvsp[(3) - (4)].id), 0, (yyvsp[(4) - (4)].id));
parse.c:			(yyval.node) = new_args((yyvsp[(1) - (6)].node), 0, (yyvsp[(3) - (6)].id), (yyvsp[(5) - (6)].node), (yyvsp[(6) - (6)].id));
parse.c:			(yyval.node) = new_args((yyvsp[(1) - (2)].node), 0, 0, 0, (yyvsp[(2) - (2)].id));
parse.c:			(yyval.node) = new_args(0, (yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].id), 0, (yyvsp[(4) - (4)].id));
parse.c:			(yyval.node) = new_args(0, (yyvsp[(1) - (6)].node), (yyvsp[(3) - (6)].id), (yyvsp[(5) - (6)].node), (yyvsp[(6) - (6)].id));
parse.c:			(yyval.node) = new_args(0, (yyvsp[(1) - (2)].node), 0, 0, (yyvsp[(2) - (2)].id));
parse.c:			(yyval.node) = new_args(0, (yyvsp[(1) - (4)].node), 0, (yyvsp[(3) - (4)].node), (yyvsp[(4) - (4)].id));
parse.c:			(yyval.node) = new_args(0, 0, (yyvsp[(1) - (2)].id), 0, (yyvsp[(2) - (2)].id));
parse.c:			(yyval.node) = new_args(0, 0, (yyvsp[(1) - (4)].id), (yyvsp[(3) - (4)].node), (yyvsp[(4) - (4)].id));
parse.c:			(yyval.node) = new_args(0, 0, 0, 0, (yyvsp[(1) - (1)].id));
parse.c:			if (!is_local_id((yyvsp[(1) - (1)].id)))
parse.c:			shadowing_lvar((yyvsp[(1) - (1)].id));
parse.c:			(yyval.id) = (yyvsp[(1) - (1)].id);
parse.c:			arg_var((yyvsp[(1) - (1)].id));
parse.c:			(yyval.node) = NEW_ARGS_AUX((yyvsp[(1) - (1)].id), 1);
parse.c:			    (yyvsp[(2) - (3)].node)->nd_value = NEW_DVAR(tid);
parse.c:			    (yyvsp[(2) - (3)].node)->nd_value = NEW_LVAR(tid);
parse.c:			(yyval.node)->nd_next = (yyvsp[(2) - (3)].node);
parse.c:			(yyval.node) = (yyvsp[(1) - (3)].node);
parse.c:			(yyval.node)->nd_plen++;
parse.c:			(yyval.node)->nd_next = block_append((yyval.node)->nd_next, (yyvsp[(3) - (3)].node)->nd_next);
parse.c:			rb_gc_force_recycle((VALUE)(yyvsp[(3) - (3)].node));
parse.c:			if (!is_local_id((yyvsp[(1) - (3)].id)))
parse.c:			shadowing_lvar((yyvsp[(1) - (3)].id));
parse.c:			arg_var((yyvsp[(1) - (3)].id));
parse.c:			(yyval.node) = NEW_OPT_ARG(0, assignable((yyvsp[(1) - (3)].id), (yyvsp[(3) - (3)].node)));
parse.c:			if (!is_local_id((yyvsp[(1) - (3)].id)))
parse.c:			shadowing_lvar((yyvsp[(1) - (3)].id));
parse.c:			arg_var((yyvsp[(1) - (3)].id));
parse.c:			(yyval.node) = NEW_OPT_ARG(0, assignable((yyvsp[(1) - (3)].id), (yyvsp[(3) - (3)].node)));
parse.c:			(yyval.node) = (yyvsp[(1) - (1)].node);
parse.c:			NODE *opts = (yyvsp[(1) - (3)].node);
parse.c:			while (opts->nd_next) {
parse.c:			    opts = opts->nd_next;
parse.c:			opts->nd_next = (yyvsp[(3) - (3)].node);
parse.c:			(yyval.node) = (yyvsp[(1) - (3)].node);
parse.c:			(yyval.node) = (yyvsp[(1) - (1)].node);
parse.c:			NODE *opts = (yyvsp[(1) - (3)].node);
parse.c:			while (opts->nd_next) {
parse.c:			    opts = opts->nd_next;
parse.c:			opts->nd_next = (yyvsp[(3) - (3)].node);
parse.c:			(yyval.node) = (yyvsp[(1) - (3)].node);
parse.c:			if (!is_local_id((yyvsp[(2) - (2)].id)))
parse.c:			shadowing_lvar((yyvsp[(2) - (2)].id));
parse.c:			arg_var((yyvsp[(2) - (2)].id));
parse.c:			(yyval.id) = (yyvsp[(2) - (2)].id);
parse.c:			if (!is_local_id((yyvsp[(2) - (2)].id)))
parse.c:			else if (!dyna_in_block() && local_id((yyvsp[(2) - (2)].id)))
parse.c:			shadowing_lvar((yyvsp[(2) - (2)].id));
parse.c:			arg_var((yyvsp[(2) - (2)].id));
parse.c:			(yyval.id) = (yyvsp[(2) - (2)].id);
parse.c:			(yyval.id) = (yyvsp[(2) - (2)].id);
parse.c:			value_expr((yyvsp[(1) - (1)].node));
parse.c:			(yyval.node) = (yyvsp[(1) - (1)].node);
parse.c:			if ((yyvsp[(3) - (4)].node) == 0) {
parse.c:			    switch (nd_type((yyvsp[(3) - (4)].node))) {
parse.c:				value_expr((yyvsp[(3) - (4)].node));
parse.c:			(yyval.node) = (yyvsp[(3) - (4)].node);
parse.c:			(yyval.node) = (yyvsp[(1) - (2)].node);
parse.c:			(yyval.node) = list_concat((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = list_append(NEW_LIST((yyvsp[(1) - (3)].node)), (yyvsp[(3) - (3)].node));
parse.c:			(yyval.node) = list_append(NEW_LIST(NEW_LIT(ID2SYM((yyvsp[(1) - (2)].id)))), (yyvsp[(2) - (2)].node));
parse.c:  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
parse.c:  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
parse.c:    yystate = yydefgoto[yyn - YYNTOKENS];
parse.c:/*------------------------------------.
parse.c:| yyerrlab -- here on detecting error |
parse.c:`------------------------------------*/
parse.c:      /* If just tried and failed to reuse look-ahead token after an
parse.c:  /* Else will try to reuse look-ahead token after shifting the error
parse.c:/*---------------------------------------------------.
parse.c:| yyerrorlab -- error raised explicitly by YYERROR.  |
parse.c:`---------------------------------------------------*/
parse.c:/*-------------------------------------------------------------.
parse.c:| yyerrlab1 -- common code for both syntax error and YYERROR.  |
parse.c:`-------------------------------------------------------------*/
parse.c:/*-------------------------------------.
parse.c:| yyacceptlab -- YYACCEPT comes here.  |
parse.c:`-------------------------------------*/
parse.c:/*-----------------------------------.
parse.c:| yyabortlab -- YYABORT comes here.  |
parse.c:`-----------------------------------*/
parse.c:/*-------------------------------------------------.
parse.c:| yyexhaustedlab -- memory exhaustion comes here.  |
parse.c:`-------------------------------------------------*/
parse.c:# define yylval  (*((YYSTYPE*)(parser->parser_yylval)))
parse.c:#define ripper_flush(p) (p->tokp = p->parser_lex_p)
parse.c:    if (lex_p < parser->tokp) rb_raise(rb_eRuntimeError, "lex_p < tokp");
parse.c:    if (lex_p == parser->tokp) return;
parse.c:    str = STR_NEW(parser->tokp, lex_p - parser->tokp);
parse.c:    const char *saved_tokp = parser->tokp;
parse.c:    ruby_sourceline = parser->delayed_line;
parse.c:    parser->tokp = lex_pbeg + parser->delayed_col;
parse.c:    yylval.val = ripper_dispatch1(parser, ripper_token2eventid(t), parser->delayed);
parse.c:    parser->delayed = Qnil;
parse.c:    parser->tokp = saved_tokp;
parse.c:# define SIGN_EXTEND_CHAR(c) ((((unsigned char)(c)) ^ 128) - 128)
parse.c:#define parser_encoding_name()  (parser->enc->name)
parse.c:#define parser_mbclen()  mbclen((lex_p-1),lex_pend,parser->enc)
parse.c:#define parser_precise_mbclen()  rb_enc_precise_mbclen((lex_p-1),lex_pend,parser->enc)
parse.c:#define parser_is_identchar() (!parser->eofp && is_identchar((lex_p-1),lex_pend,parser->enc))
parse.c:#define parser_isascii() ISASCII(*(lex_p-1))
parse.c:    const char *p, *pend = lex_p - strlen(token);
parse.c:	    column = (((column - 1) / 8) + 1) * 8;
parse.c:    const char *p, *pend = lex_p - strlen(token);
parse.c:    ptinfo->token = token;
parse.c:    ptinfo->linenum = ruby_sourceline;
parse.c:    ptinfo->column = token_info_get_column(parser, token);
parse.c:    ptinfo->nonspc = token_info_has_nonspaces(parser, token);
parse.c:    ptinfo->next = parser->parser_token_info;
parse.c:    parser->parser_token_info = ptinfo;
parse.c:    token_info *ptinfo = parser->parser_token_info;
parse.c:    parser->parser_token_info = ptinfo->next;
parse.c:    if (token_info_get_column(parser, token) == ptinfo->column) { /* OK */
parse.c:    if (linenum == ptinfo->linenum) { /* SKIP */
parse.c:    if (token_info_has_nonspaces(parser, token) || ptinfo->nonspc) { /* SKIP */
parse.c:	       token, ptinfo->token, ptinfo->linenum);
parse.c:	p--;
parse.c:    len = pe - p;
parse.c:	    if (lex_p - p > max_line_margin) {
parse.c:		p = rb_enc_prev_char(p, lex_p - max_line_margin, pe, rb_enc_get(lex_lastline));
parse.c:	    if (pe - lex_p > max_line_margin) {
parse.c:	    len = pe - p;
parse.c:	i = lex_p - p;
parse.c:    if (RTEST(coverages) && RBASIC(coverages)->klass == 0) {
parse.c:	RBASIC(lines)->klass = 0;
parse.c:	RARRAY(lines)->as.heap.len = n;
parse.c:    if (strcmp(ruby_sourcefile, "-e") == 0)
parse.c:	    } while (--n);
parse.c:    if (parser->nerr) {
parse.c:	    scope->nd_body = NEW_PRELUDE(ruby_eval_tree_begin, scope->nd_body);
parse.c:    ruby_sourceline = line - 1;
parse.c:    lex_gets_ptr = end - RSTRING_PTR(s);
parse.c:    return rb_enc_str_new(beg, end - beg, rb_enc_get(s));
parse.c:    VALUE line = (*parser->parser_lex_gets)(parser, parser->parser_lex_input);
parse.c:#define lex_goto_eol(parser) (parser->parser_lex_p = parser->parser_lex_pend)
parse.c:	    if (parser->eofp)
parse.c:		return -1;
parse.c:		parser->eofp = Qtrue;
parse.c:		return -1;
parse.c:	    if (parser->tokp < lex_pend) {
parse.c:		if (NIL_P(parser->delayed)) {
parse.c:		    parser->delayed = rb_str_buf_new(1024);
parse.c:		    rb_str_buf_cat(parser->delayed,
parse.c:				   parser->tokp, lex_pend - parser->tokp);
parse.c:		    parser->delayed_line = ruby_sourceline;
parse.c:		    parser->delayed_col = parser->tokp - lex_pbeg;
parse.c:		    rb_str_buf_cat(parser->delayed,
parse.c:				   parser->tokp, lex_pend - parser->tokp);
parse.c:	    parser->line_count++;
parse.c:    if (c == -1) return;
parse.c:    lex_p--;
parse.c:    if (lex_p > lex_pbeg && lex_p[0] == '\n' && lex_p[-1] == '\r') {
parse.c:	lex_p--;
parse.c:#define toklast() (tokidx>0?tokenbuf[tokidx-1]:0)
parse.c:    return &tokenbuf[tokidx-n];
parse.c:#define tokcopy(n) memcpy(tokspace(n), lex_p - (n), (n))
parse.c:      case 'r':	/* carriage-return */
parse.c:      case 'f':	/* form-feed */
parse.c:	if ((c = nextc()) != '-') {
parse.c:	else if (c == -1 || !ISASCII(c)) goto eof;
parse.c:	if ((c = nextc()) != '-') {
parse.c:	else if (c == -1 || !ISASCII(c)) goto eof;
parse.c:      case -1:
parse.c:	    oct = scan_oct(--lex_p, 3, &numlen);
parse.c:	if ((c = nextc()) != '-') {
parse.c:	if ((c = nextc()) != '-') {
parse.c:	else if (c == -1) goto eof;
parse.c:      case -1:
parse.c:	return -1;
parse.c:	compile_error(PARSER_ARG "unknown regexp option%s - %s",
parse.c:    if (RBASIC(str)->flags & RSTRING_NOEMBED)
parse.c:	return -1;
parse.c:    lex_p += --len;
parse.c:	int len = sizeof(mixed_msg) - 4;	\
parse.c:    while ((c = nextc()) != -1) {
parse.c:	    --*nest;
parse.c:	    const char *beg = lex_p - 1;
parse.c:			return -1;
parse.c:	    if (tokadd_mbchar(c) == -1) return -1;
parse.c:    int func = quote->nd_func;
parse.c:    rb_encoding *enc = parser->enc;
parse.c:    if (func == -1) return tSTRING_END;
parse.c:    if (c == term && !quote->nd_nest) {
parse.c:	    quote->nd_func = -1;
parse.c:    if (tokadd_string(func, term, paren, &quote->nd_nest,
parse.c:		      &enc) == -1) {
parse.c:	    if (parser->eofp)
parse.c:	    if (parser->eofp)
parse.c:    if (c == '-') {
parse.c:	while ((c = nextc()) != -1 && c != term) {
parse.c:	    if (tokadd_mbchar(c) == -1) return 0;
parse.c:	if (c == -1) {
parse.c:		pushback('-');
parse.c:	    if (tokadd_mbchar(c) == -1) return 0;
parse.c:	} while ((c = nextc()) != -1 && parser_is_identchar());
parse.c:    len = lex_p - lex_pbeg;
parse.c:    if (!NIL_P(parser->delayed))
parse.c:    line = here->nd_orig;
parse.c:    lex_p = lex_pbeg + here->nd_nth;
parse.c:    dispose_string(here->nd_lit);
parse.c:    n= lex_pend - (p + len);
parse.c:    eos = RSTRING_PTR(here->nd_lit);
parse.c:    len = RSTRING_LEN(here->nd_lit) - 1;
parse.c:    if ((c = nextc()) == -1) {
parse.c:		switch (pend[-1]) {
parse.c:		    if (--pend == p || pend[-1] != '\r') {
parse.c:		    --pend;
parse.c:		rb_str_cat(str, p, pend - p);
parse.c:		str = STR_NEW(p, pend - p);
parse.c:	    if (nextc() == -1) {
parse.c:	rb_encoding *enc = parser->enc;
parse.c:	    if ((c = tokadd_string(func, '\n', 0, NULL, &enc)) == -1) {
parse.c:		if (parser->eofp) goto error;
parse.c:	    if ((c = nextc()) == -1) goto error;
parse.c:    lex_strterm = NEW_STRTERM(-1, 0, 0);
parse.c:/* emacsen -*- hack */
parse.c:    if (len > 5 && name[nlen = len - 5] == '-') {
parse.c:    if (len > 4 && name[nlen = len - 5] == '-') {
parse.c:    parser->enc = enc;
parse.c:    const char *p = lex_pbeg, *pend = lex_p - 1;
parse.c:    if (parser->line_count != (parser->has_shebang ? 2 : 1)) return 0;
parse.c:	  case '-':
parse.c:	    if (str[i-1] == '*' && str[i-2] == '-') {
parse.c:	    if (str[i+1] != '-') {
parse.c:	    else if (str[i-1] != '-') {
parse.c:    if (!(end = magic_comment_marker(beg, str + len - beg))) return Qfalse;
parse.c:    len = end - beg - 3;
parse.c:	for (; len > 0 && *str; str++, --len) {
parse.c:	for (beg = str; len > 0; str++, --len) {
parse.c:	for (end = str; len > 0 && ISSPACE(*str); str++, --len);
parse.c:	do str++; while (--len > 0 && ISSPACE(*str));
parse.c:	    for (vbeg = ++str; --len > 0 && *str != '"'; str++) {
parse.c:		    --len;
parse.c:		--len;
parse.c:	    for (vbeg = str; len > 0 && *str != '"' && *str != ';' && !ISSPACE(*str); --len, str++);
parse.c:	while (len > 0 && (*str == ';' || ISSPACE(*str))) --len, str++;
parse.c:	n = end - beg;
parse.c:	    if (*s == '-') *s = '_';
parse.c:	    if (STRNCASECMP(p->name, s, n) == 0) {
parse.c:		n = vend - vbeg;
parse.c:		if (p->length) {
parse.c:		    n = (*p->length)(parser, vbeg, n);
parse.c:		(*p->func)(parser, s, RSTRING_PTR(val));
parse.c:	if (send - str <= 6) return;
parse.c:	if (STRNCASECMP(str-6, "coding", 6) == 0) break;
parse.c:    while ((*str == '-' || *str == '_' || ISALNUM(*str)) && ++str < send);
parse.c:    s = rb_str_new(beg, parser_encode_length(parser, beg, str - beg));
parse.c:	if (peek('!')) parser->has_shebang = 1;
parse.c:      case 0xef:		/* UTF-8 BOM marker */
parse.c:	if (lex_pend - lex_p >= 2 &&
parse.c:	    parser->enc = rb_utf8_encoding();
parse.c:    parser->enc = rb_enc_get(lex_lastline);
parse.c:      case -1:			/* end of script. */
parse.c:	if (!parser_magic_comment(parser, lex_p, lex_pend - lex_p)) {
parse.c:		--ruby_sourceline;
parse.c:	      case -1:		/* EOF no decrement*/
parse.c:		if (c != -1) {
parse.c:		    parser->tokp = lex_p;
parse.c:		    if (c == -1) {
parse.c:	if (c == -1) {
parse.c:	if (rb_enc_isspace(c, parser->enc)) {
parse.c:	enc = parser->enc;
parse.c:	    if (tokadd_mbchar(c) == -1) return 0;
parse.c:	else if ((rb_enc_isalnum(c, parser->enc) || c == '_') &&
parse.c:		 lex_p < lex_pend && is_identchar(lex_p, lex_pend, parser->enc)) {
parse.c:	    if (c != -1 && ISDIGIT(c)) {
parse.c:      case '-':
parse.c:	    return '-';
parse.c:            set_yylval_id('-');
parse.c:	    if (c != -1 && ISDIGIT(c)) {
parse.c:	return '-';
parse.c:	if (c != -1 && ISDIGIT(c)) {
parse.c:	    if (c == '-' || c == '+') {
parse.c:		    if (c != -1 && ISXDIGIT(c)) {
parse.c:			} while ((c = nextc()) != -1);
parse.c:			} while ((c = nextc()) != -1);
parse.c:		    if (c != -1 && ISDIGIT(c)) {
parse.c:			} while ((c = nextc()) != -1);
parse.c:		    if (c == -1 || c == '_' || !ISDIGIT(c)) {
parse.c:		    } while ((c = nextc()) != -1);
parse.c:			if (c0 == -1 || !ISDIGIT(c0)) {
parse.c:		    if (c != '-' && c != '+') continue;
parse.c:	paren_nest--;
parse.c:	if (lex_state == EXPR_END || lex_state == EXPR_ENDARG || (c != -1 && ISSPACE(c))) {
parse.c:	    --paren_nest;
parse.c:	    if (c == -1 || !ISALNUM(c)) {
parse.c:		if (rb_enc_isalnum(term, parser->enc) || !parser_isascii()) {
parse.c:	    if (c == -1 || term == -1) {
parse.c:	  case '~':		/* $~: match-data */
parse.c:	  case '-':
parse.c:		if (tokadd_mbchar(c) == -1) return 0;
parse.c:	    } while (c != -1 && ISDIGIT(c));
parse.c:	if (c != -1 && ISDIGIT(c)) {
parse.c:	    parser->eofp = Qtrue;
parse.c:	    return -1;
parse.c:	if (tokadd_mbchar(c) == -1) return 0;
parse.c:		    lex_state = kw->state;
parse.c:                        set_yylval_id(rb_intern(kw->name));
parse.c:			return kw->id[0];
parse.c:		    if (kw->id[0] == keyword_do) {
parse.c:			    --paren_nest;
parse.c:			return kw->id[0];
parse.c:			if (kw->id[0] != kw->id[1])
parse.c:			return kw->id[1];
parse.c:    parser->parser_yylval = lval;
parse.c:    parser->parser_yylval->val = Qundef;
parse.c:    if (!NIL_P(parser->delayed)) {
parse.c:	node->flags |= NODE_FL_NEWLINE;
parse.c:	end->nd_end = end;
parse.c:	end = h->nd_end;
parse.c:    nd = end->nd_head;
parse.c:	tail->nd_end = tail;
parse.c:    end->nd_next = tail;
parse.c:    h->nd_end = tail->nd_end;
parse.c:    if (list->nd_next) {
parse.c:	last = list->nd_next->nd_end;
parse.c:    list->nd_alen += 1;
parse.c:    last->nd_next = NEW_LIST(item);
parse.c:    list->nd_next->nd_end = last->nd_next;
parse.c:    if (head->nd_next) {
parse.c:	last = head->nd_next->nd_end;
parse.c:    head->nd_alen += tail->nd_alen;
parse.c:    last->nd_next = tail;
parse.c:    if (tail->nd_next) {
parse.c:	head->nd_next->nd_end = tail->nd_next->nd_end;
parse.c:	head->nd_next->nd_end = tail;
parse.c:	    if (!literal_concat0(parser, head->nd_lit, tail->nd_lit)) {
parse.c:	    if (!literal_concat0(parser, head->nd_lit, tail->nd_lit))
parse.c:	    tail->nd_lit = head->nd_lit;
parse.c:	    tail->nd_head = NEW_STR(tail->nd_lit);
parse.c:	    head->nd_alen = 1;
parse.c:	    if (TYPE(node1->nd_lit) == T_REGEXP) {
parse.c:	    if (TYPE(node2->nd_lit) == T_REGEXP) {
parse.c:	return NEW_LIT(rb_enc_from_encoding(parser->enc));
parse.c:	    rb_warningS("shadowing outer local variable - %s", rb_id2name(name));
parse.c:	    vtable_add(lvtbl->vars, name);
parse.c:	compile_error(PARSER_ARG "invalid local variable - %s",
parse.c:	compile_error(PARSER_ARG "Can't set variable $%ld", node->nd_nth);
parse.c:	compile_error(PARSER_ARG "Can't set variable $%c", (int)node->nd_nth);
parse.c:	node1->nd_iter = arg_concat(node1->nd_iter, node2);
parse.c:	node1->nd_body = list_concat(NEW_LIST(node1->nd_body), node2);
parse.c:	    nd_type(node1->nd_body) != NODE_ARRAY) break;
parse.c:	node1->nd_body = list_concat(node1->nd_body, node2);
parse.c:	node1->nd_head = arg_append(node1->nd_head, node2);
parse.c:	node1->nd_body = list_append(NEW_LIST(node1->nd_body), node2);
parse.c:    if (nd_type(node) == NODE_SPLAT) node = node->nd_head;
parse.c:	lhs->nd_value = rhs;
parse.c:	lhs->nd_args = arg_append(lhs->nd_args, rhs);
parse.c:	    while (node->nd_next) {
parse.c:		node = node->nd_next;
parse.c:	    node = node->nd_head;
parse.c:	    node = node->nd_body;
parse.c:	    if (!node->nd_body) {
parse.c:		node = node->nd_else;
parse.c:	    else if (!node->nd_else) {
parse.c:		node = node->nd_body;
parse.c:	    if (!value_expr(node->nd_body)) return Qfalse;
parse.c:	    node = node->nd_else;
parse.c:	    node = node->nd_2nd;
parse.c:	switch (node->nd_mid) {
parse.c:	  case '-':
parse.c:	    useless = rb_id2name(node->nd_mid);
parse.c:	if (!node->nd_next) return;
parse.c:	void_expr0(node->nd_head);
parse.c:	node = node->nd_next;
parse.c:    while (n1 && nd_type(n1) == NODE_BEGIN && n1->nd_body) {
parse.c:	*n = n1 = n1->nd_body;
parse.c:    ((!node->n1) ? (node->n2 ? (body = &node->n2, 1) : 0) : \
parse.c:     (!node->n2) ? (body = &node->n1, 1) : \
parse.c:     (reduce_nodes(&node->n1), body = &node->n2, 1))
parse.c:	    *body = node = node->nd_stts;
parse.c:	    *body = node = node->nd_body;
parse.c:	    body = &node->nd_end->nd_head;
parse.c:	    body = &node->nd_body;
parse.c:    switch (nd_type(node->nd_value)) {
parse.c:	parser_warn(node->nd_value, "found = in conditional, should be ==");
parse.c:	next = node->nd_next;
parse.c:	head = node->nd_head;
parse.c:	    val = rb_range_new(head->nd_beg->nd_lit, head->nd_end->nd_lit,
parse.c:	    rb_gc_force_recycle((VALUE)head->nd_beg);
parse.c:	    rb_gc_force_recycle((VALUE)head->nd_end);
parse.c:	    head->nd_lit = val;
parse.c:    if (type == NODE_LIT && FIXNUM_P(node->nd_lit)) {
parse.c:	node->nd_1st = cond0(parser, node->nd_1st);
parse.c:	node->nd_2nd = cond0(parser, node->nd_2nd);
parse.c:	node->nd_beg = range_op(parser, node->nd_beg);
parse.c:	node->nd_end = range_op(parser, node->nd_end);
parse.c:	    int b = literal_node(node->nd_beg);
parse.c:	    int e = literal_node(node->nd_end);
parse.c:	if (TYPE(node->nd_lit) == T_REGEXP) {
parse.c:	while ((second = node->nd_2nd) != 0 && nd_type(second) == type) {
parse.c:	node->nd_2nd = NEW_NODE(type, second, right, 0);
parse.c:	    if (node->nd_next == 0) {
parse.c:		node = node->nd_head;
parse.c:    switch (TYPE(node->nd_lit)) {
parse.c:	node->nd_lit = LONG2FIX(-FIX2LONG(node->nd_lit));
parse.c:	node->nd_lit = rb_funcall(node->nd_lit,tUMINUS,0,0);
parse.c:	RFLOAT(node->nd_lit)->float_value = -RFLOAT_VALUE(node->nd_lit);
parse.c:	node2->nd_head = node1;
parse.c:    node = NEW_ARGS(m ? m->nd_plen : 0, o);
parse.c:    i1 = m ? m->nd_next : 0;
parse.c:    node->nd_next = NEW_ARGS_AUX(r, b);
parse.c:	i2 = p->nd_next;
parse.c:	node->nd_next->nd_next = NEW_ARGS_AUX(p->nd_pid, p->nd_plen);
parse.c:	node->nd_next->nd_next = NEW_ARGS_AUX(0, 0);
parse.c:	node->nd_next->nd_next->nd_next = NEW_NODE(NODE_AND, i1, i2, 0);
parse.c:    local->prev = lvtbl;
parse.c:    local->args = vtable_alloc(0);
parse.c:    local->vars = vtable_alloc(inherit_dvars ? DVARS_INHERIT : DVARS_TOPSCOPE);
parse.c:    struct local_vars *local = lvtbl->prev;
parse.c:    vtable_free(lvtbl->args);
parse.c:    vtable_free(lvtbl->vars);
parse.c:            buf[i] = src->tbl[i];
parse.c:    int cnt = vtable_size(lvtbl->args) + vtable_size(lvtbl->vars);
parse.c:    vtable_tblcpy(buf+1, lvtbl->args);
parse.c:    vtable_tblcpy(buf+vtable_size(lvtbl->args)+1, lvtbl->vars);
parse.c:    vtable_add(lvtbl->args, id);
parse.c:    return vtable_size(lvtbl->args) - 1;
parse.c:    vtable_add(lvtbl->vars, id);
parse.c:    return vtable_size(lvtbl->vars) - 1;
parse.c:    vars = lvtbl->vars;
parse.c:    args = lvtbl->args;
parse.c:    while (vars && POINTER_P(vars->prev)) {
parse.c:	vars = vars->prev;
parse.c:	args = args->prev;
parse.c:    if (vars && vars->prev == DVARS_INHERIT) {
parse.c:    lvtbl->args = vtable_alloc(lvtbl->args);
parse.c:    lvtbl->vars = vtable_alloc(lvtbl->vars);
parse.c:    tmp = lvtbl->args;
parse.c:    lvtbl->args = lvtbl->args->prev;
parse.c:    tmp = lvtbl->vars;
parse.c:    lvtbl->vars = lvtbl->vars->prev;
parse.c:    return POINTER_P(lvtbl->vars) && lvtbl->vars->prev != DVARS_TOPSCOPE;
parse.c:    args = lvtbl->args;
parse.c:    vars = lvtbl->vars;
parse.c:	args = args->prev;
parse.c:	vars = vars->prev;
parse.c:    return (vtable_included(lvtbl->args, id) ||
parse.c:	    vtable_included(lvtbl->vars, id));
parse.c:    else if (parser->enc == rb_usascii_encoding()) {
parse.c:    struct parser_params* parser = arg->parser;
parse.c:    rb_encoding *enc = arg->enc;
parse.c:    int len = name_end - name;
parse.c:    arg->num++;
parse.c:    if (arg->succ_block == 0) {
parse.c:        arg->succ_block = NEW_BEGIN(0);
parse.c:        arg->fail_block = NEW_BEGIN(0);
parse.c:        rb_warningS("named capture conflicts a local variable - %s",
parse.c:    arg->succ_block = block_append(arg->succ_block,
parse.c:    arg->fail_block = block_append(arg->fail_block,
parse.c:    onig_foreach_name(RREGEXP(regexp)->ptr, reg_named_capture_assign_iter, (void*)&arg);
parse.c:    node = node->nd_body;
parse.c:	node = node->nd_body;
parse.c:	prelude->nd_body = node;
parse.c:	scope->nd_body = prelude;
parse.c:	scope->nd_body = node;
parse.c:    node = node->nd_body;
parse.c:	node = node->nd_body;
parse.c:	prelude->nd_body = node;
parse.c:	scope->nd_body = prelude;
parse.c:	scope->nd_body = node;
parse.c:    {'-',	"-(binary)"},
parse.c:    {tUMINUS,	"-@"},
parse.c:    if (key1->id == key2->id && key1->klass == key2->klass) {
parse.c:    return (key->id << 8) ^ (key->klass >> 2);
parse.c:    ID id = (ID)vtable_size(lvtbl->args) + (ID)vtable_size(lvtbl->vars);
parse.c:    id += ((tLAST_TOKEN - ID_INTERNAL) >> ID_SCOPE_SHIFT) + 1;
parse.c:      case '-':
parse.c:      case '+': case '-':
parse.c:    last = len-1;
parse.c:	    if (!--mb) enc = rb_ascii8bit_encoding();
parse.c:    if (m - name < len) id = ID_JUNK;
parse.c:	 * rb_intern_str() taking care of code-range.
parse.c:        if (RBASIC(str)->klass == 0)
parse.c:            RBASIC(str)->klass = rb_cString;
parse.c:            if (RBASIC(str)->klass == 0)
parse.c:                RBASIC(str)->klass = rb_cString;
parse.c: *  call-seq:
parse.c:    VALUE ary = rb_ary_new2(global_symbols.sym_id->num_entries);
parse.c:    parser->eofp = Qfalse;
parse.c:    parser->parser_lex_strterm = 0;
parse.c:    parser->parser_cond_stack = 0;
parse.c:    parser->parser_cmdarg_stack = 0;
parse.c:    parser->parser_class_nest = 0;
parse.c:    parser->parser_paren_nest = 0;
parse.c:    parser->parser_lpar_beg = 0;
parse.c:    parser->parser_in_single = 0;
parse.c:    parser->parser_in_def = 0;
parse.c:    parser->parser_in_defined = 0;
parse.c:    parser->parser_compile_for_eval = 0;
parse.c:    parser->parser_cur_mid = 0;
parse.c:    parser->parser_tokenbuf = NULL;
parse.c:    parser->parser_tokidx = 0;
parse.c:    parser->parser_toksiz = 0;
parse.c:    parser->parser_heredoc_end = 0;
parse.c:    parser->parser_command_start = Qtrue;
parse.c:    parser->parser_deferred_nodes = 0;
parse.c:    parser->parser_lex_pbeg = 0;
parse.c:    parser->parser_lex_p = 0;
parse.c:    parser->parser_lex_pend = 0;
parse.c:    parser->parser_lvtbl = 0;
parse.c:    parser->parser_ruby__end__seen = 0;
parse.c:    parser->parser_ruby_sourcefile = 0;
parse.c:    parser->is_ripper = 0;
parse.c:    parser->parser_eval_tree_begin = 0;
parse.c:    parser->parser_eval_tree = 0;
parse.c:    parser->is_ripper = 1;
parse.c:    parser->parser_ruby_sourcefile_string = Qnil;
parse.c:    parser->delayed = Qnil;
parse.c:    parser->result = Qnil;
parse.c:    parser->parsing_thread = Qnil;
parse.c:    parser->toplevel_p = Qtrue;
parse.c:    parser->heap = NULL;
parse.c:    parser->enc = rb_usascii_encoding();
parse.c:    rb_gc_mark((VALUE)p->parser_lex_strterm);
parse.c:    rb_gc_mark((VALUE)p->parser_deferred_nodes);
parse.c:    rb_gc_mark(p->parser_lex_input);
parse.c:    rb_gc_mark(p->parser_lex_lastline);
parse.c:    rb_gc_mark(p->parser_lex_nextline);
parse.c:    rb_gc_mark((VALUE)p->parser_eval_tree_begin) ;
parse.c:    rb_gc_mark((VALUE)p->parser_eval_tree) ;
parse.c:    rb_gc_mark(p->debug_lines);
parse.c:    rb_gc_mark(p->parser_ruby_sourcefile_string);
parse.c:    rb_gc_mark(p->delayed);
parse.c:    rb_gc_mark(p->value);
parse.c:    rb_gc_mark(p->result);
parse.c:    rb_gc_mark(p->parsing_thread);
parse.c:    rb_gc_mark((VALUE)p->heap);
parse.c:    if (p->parser_tokenbuf) {
parse.c:        xfree(p->parser_tokenbuf);
parse.c:    for (local = p->parser_lvtbl; local; local = prev) {
parse.c:	if (local->vars) xfree(local->vars);
parse.c:	prev = local->prev;
parse.c:    xfree(p->parser_ruby_sourcefile);
parse.c: *  call-seq:
parse.c: *    ripper#end_seen?   -> Boolean
parse.c: *  call-seq:
parse.c: *    ripper#encoding   -> encoding
parse.c:    return rb_enc_from_encoding(parser->enc);
parse.c: *  call-seq:
parse.c: *    ripper.yydebug   -> true or false
parse.c: *  call-seq:
parse.c:#define NEWHEAP() rb_node_newnode(NODE_ALLOCA, 0, (VALUE)parser->heap, 0)
parse.c:#define ADD2HEAP(n, c, p) ((parser->heap = (n))->u1.node = (p), \
parse.c:			   (n)->u3.cnt = (c), (p))
parse.c:    if (ptr && (n = parser->heap) != NULL) {
parse.c:	    if (n->u1.node == ptr) {
parse.c:		n->u1.node = ptr = xrealloc(ptr, size);
parse.c:		if (n->u3.cnt) n->u3.cnt = cnt;
parse.c:	} while ((n = n->u2.node) != NULL);
parse.c:    NODE **prev = &parser->heap, *n;
parse.c:	if (n->u1.node == ptr) {
parse.c:	    *prev = n->u2.node;
parse.c:	prev = &n->u2.node;
parse.c:    return rb_funcall(parser->value, mid, 0);
parse.c:    return rb_funcall(parser->value, mid, 1, a);
parse.c:    return rb_funcall(parser->value, mid, 2, a, b);
parse.c:    return rb_funcall(parser->value, mid, 3, a, b, c);
parse.c:    return rb_funcall(parser->value, mid, 4, a, b, c, d);
parse.c:    return rb_funcall(parser->value, mid, 5, a, b, c, d, e);
parse.c:    for (a = keyword_to_name; a->id; a++) {
parse.c:        if (a->id == id)
parse.c:            return a->name;
parse.c:    rb_funcall(parser->value, rb_intern("compile_error"), 1, str);
parse.c:    rb_funcall(parser->value, rb_intern("warn"), 1, STR_NEW2(fmt));
parse.c:    rb_funcall(parser->value, rb_intern("warn"), 2,
parse.c:    rb_funcall(parser->value, rb_intern("warn"), 2,
parse.c:    rb_funcall(parser->value, rb_intern("warning"), 1, STR_NEW2(fmt));
parse.c:    rb_funcall(parser->value, rb_intern("warning"), 2,
parse.c:    p->value = self;
parse.c:#define ripper_initialized_p(r) ((r)->parser_lex_input != 0)
parse.c: *  call-seq:
parse.c: *    Ripper.new(src, filename="(ripper)", lineno=1) -> ripper
parse.c:        parser->parser_lex_gets = ripper_lex_get_generic;
parse.c:        parser->parser_lex_gets = lex_get_str;
parse.c:    parser->parser_lex_input = src;
parse.c:    parser->eofp = Qfalse;
parse.c:    parser->parser_ruby_sourcefile_string = fname;
parse.c:    parser->parser_ruby_sourcefile = RSTRING_PTR(fname);
parse.c:    parser->parser_ruby_sourceline = NIL_P(lineno) ? 0 : NUM2INT(lineno) - 1;
parse.c:    return parser->result;
parse.c:    parser->parsing_thread = Qnil;
parse.c: *  call-seq:
parse.c:    if (!NIL_P(parser->parsing_thread)) {
parse.c:        if (parser->parsing_thread == rb_thread_current())
parse.c:            rb_raise(rb_eArgError, "Ripper#parse is not multithread-safe");
parse.c:    parser->parsing_thread = rb_thread_current();
parse.c:    return parser->result;
parse.c: *  call-seq:
parse.c: *    ripper#column   -> Integer
parse.c:    if (NIL_P(parser->parsing_thread)) return Qnil;
parse.c:    col = parser->tokp - parser->parser_lex_pbeg;
parse.c: *  call-seq:
parse.c: *    ripper#lineno   -> Integer
parse.c:    if (NIL_P(parser->parsing_thread)) return Qnil;
parse.c:    return INT2NUM(parser->parser_ruby_sourceline);
parse.c:    rb_define_method(Ripper, "initialize", ripper_initialize, -1);
parse.c~:/* Skeleton implementation for Bison's Yacc-like parsers in C
parse.c~:   Boston, MA 02110-1301, USA.  */
parse.c~:   simplifying the original so-called "semantic" parser.  */
parse.c~:    EXPR_BEG,			/* ignore newline, +/- is a sign. */
parse.c~:    EXPR_END,			/* newline significant, +/- is an operator. */
parse.c~:    EXPR_ARG,			/* newline significant, +/- is an operator. */
parse.c~:    EXPR_CMDARG,		/* newline significant, +/- is an operator. */
parse.c~:    EXPR_MID,			/* newline significant, +/- is an operator. */
parse.c~:        return tbl->pos;
parse.c~:    tbl->pos = 0;
parse.c~:    tbl->capa = 8;
parse.c~:    tbl->tbl = ALLOC_N(ID, tbl->capa);
parse.c~:    tbl->prev = prev;
parse.c~:        if (tbl->tbl) {
parse.c~:            xfree(tbl->tbl);
parse.c~:    if (tbl->pos == tbl->capa) {
parse.c~:        tbl->capa = tbl->capa * 2;
parse.c~:        REALLOC_N(tbl->tbl, ID, tbl->capa);
parse.c~:    tbl->tbl[tbl->pos++] = id;
parse.c~:        for (i = 0; i < tbl->pos; i++) {
parse.c~:            if (tbl->tbl[i] == id) {
parse.c~:    |-----------+--------------+------------|
parse.c~:                |<------------>|
parse.c~:#define UTF8_ENC() (parser->utf8 ? parser->utf8 : \
parse.c~:		    (parser->utf8 = rb_utf8_encoding()))
parse.c~:#define STR_NEW(p,n) rb_enc_str_new((p),(n),parser->enc)
parse.c~:#define STR_NEW0() rb_enc_str_new(0,0,parser->enc)
parse.c~:#define STR_NEW2(p) rb_enc_str_new((p),strlen(p),parser->enc)
parse.c~:#define STR_NEW3(p,n,e,func) parser_str_new((p),(n),(e),(func),parser->enc)
parse.c~:#define TOK_INTERN(mb) rb_intern3(tok(), toklen(), parser->enc)
parse.c~:#define lex_strterm		(parser->parser_lex_strterm)
parse.c~:#define lex_state		(parser->parser_lex_state)
parse.c~:#define cond_stack		(parser->parser_cond_stack)
parse.c~:#define cmdarg_stack		(parser->parser_cmdarg_stack)
parse.c~:#define class_nest		(parser->parser_class_nest)
parse.c~:#define paren_nest		(parser->parser_paren_nest)
parse.c~:#define lpar_beg		(parser->parser_lpar_beg)
parse.c~:#define in_single		(parser->parser_in_single)
parse.c~:#define in_def			(parser->parser_in_def)
parse.c~:#define compile_for_eval	(parser->parser_compile_for_eval)
parse.c~:#define cur_mid			(parser->parser_cur_mid)
parse.c~:#define in_defined		(parser->parser_in_defined)
parse.c~:#define tokenbuf		(parser->parser_tokenbuf)
parse.c~:#define tokidx			(parser->parser_tokidx)
parse.c~:#define toksiz			(parser->parser_toksiz)
parse.c~:#define lex_input		(parser->parser_lex_input)
parse.c~:#define lex_lastline		(parser->parser_lex_lastline)
parse.c~:#define lex_nextline		(parser->parser_lex_nextline)
parse.c~:#define lex_pbeg		(parser->parser_lex_pbeg)
parse.c~:#define lex_p			(parser->parser_lex_p)
parse.c~:#define lex_pend		(parser->parser_lex_pend)
parse.c~:#define heredoc_end		(parser->parser_heredoc_end)
parse.c~:#define command_start		(parser->parser_command_start)
parse.c~:#define deferred_nodes		(parser->parser_deferred_nodes)
parse.c~:#define lex_gets_ptr		(parser->parser_lex_gets_ptr)
parse.c~:#define lex_gets		(parser->parser_lex_gets)
parse.c~:#define lvtbl			(parser->parser_lvtbl)
parse.c~:#define ruby__end__seen		(parser->parser_ruby__end__seen)
parse.c~:#define ruby_sourceline		(parser->parser_ruby_sourceline)
parse.c~:#define ruby_sourcefile		(parser->parser_ruby_sourcefile)
parse.c~:#define yydebug			(parser->parser_yydebug)
parse.c~:#define ruby_eval_tree		(parser->parser_eval_tree)
parse.c~:#define ruby_eval_tree_begin	(parser->parser_eval_tree_begin)
parse.c~:#define ruby_debug_lines	(parser->debug_lines)
parse.c~:#define ruby_coverage		(parser->coverage)
parse.c~:#define SIGN_EXTEND(x,n) (((1<<(n)-1)^((x)&~(~0<<(n))))-(1<<(n)-1))
parse.c~:#define nd_term(node) ((signed short)(node)->u2.id)
parse.c~:#define nd_term(node) SIGN_EXTEND((node)->u2.id, CHAR_BIT*2)
parse.c~:#define nd_paren(node) (char)((node)->u2.id >> CHAR_BIT*2)
parse.c~:# define compile_error parser->nerr++,rb_compile_error
parse.c~:#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
parse.c~:#   define YY_(msgid) dgettext ("bison-runtime", msgid)
parse.c~:/* Suppress unused-variable warnings by "using" E.  */
parse.c~:   /* Pacify GCC's `empty if-body' warning.  */
parse.c~:       to allow for a few compiler-allocated temporary stack slots.  */
parse.c~:# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
parse.c~:	YYCOPY (&yyptr->Stack, Stack, yysize);				\
parse.c~:	Stack = &yyptr->Stack;						\
parse.c~:/* YYFINAL -- State number of the termination state.  */
parse.c~:/* YYLAST -- Last index in YYTABLE.  */
parse.c~:/* YYNTOKENS -- Number of terminals.  */
parse.c~:/* YYNNTS -- Number of nonterminals.  */
parse.c~:/* YYNRULES -- Number of rules.  */
parse.c~:/* YYNRULES -- Number of states.  */
parse.c~:/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
parse.c~:/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
parse.c~:/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
parse.c~:/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
parse.c~:     151,     0,    -1,    -1,   152,   153,    -1,   154,   312,    -1,
parse.c~:     319,    -1,   155,    -1,   154,   318,   155,    -1,     1,   155,
parse.c~:      -1,   160,    -1,    -1,    48,   156,   138,   153,   139,    -1,
parse.c~:     158,   257,   233,   260,    -1,   159,   312,    -1,   319,    -1,
parse.c~:     160,    -1,   159,   318,   160,    -1,     1,   160,    -1,    -1,
parse.c~:      46,   181,   161,   181,    -1,    46,    55,    55,    -1,    46,
parse.c~:      55,    65,    -1,    46,    55,    64,    -1,     6,   182,    -1,
parse.c~:     160,    41,   163,    -1,   160,    42,   163,    -1,   160,    43,
parse.c~:     163,    -1,   160,    44,   163,    -1,   160,    45,   160,    -1,
parse.c~:      49,   138,   158,   139,    -1,   176,   110,   164,    -1,   169,
parse.c~:     110,   164,    -1,   284,    88,   164,    -1,   217,   140,   192,
parse.c~:     315,    88,   164,    -1,   217,   141,    53,    88,   164,    -1,
parse.c~:     217,   141,    57,    88,   164,    -1,   217,    86,    53,    88,
parse.c~:     164,    -1,   285,    88,   164,    -1,   176,   110,   199,    -1,
parse.c~:     169,   110,   188,    -1,   169,   110,   199,    -1,   162,    -1,
parse.c~:     164,    -1,   162,    38,   162,    -1,   162,    39,   162,    -1,
parse.c~:      40,   313,   162,    -1,   124,   164,    -1,   186,    -1,   162,
parse.c~:      -1,   168,    -1,   165,    -1,    31,   193,    -1,    22,   193,
parse.c~:      -1,    23,   193,    -1,   250,    -1,   250,   141,   309,   194,
parse.c~:      -1,   250,    86,   309,   194,    -1,    -1,    95,   167,   239,
parse.c~:     158,   139,    -1,   308,   194,    -1,   308,   194,   166,    -1,
parse.c~:     217,   141,   309,   194,    -1,   217,   141,   309,   194,   166,
parse.c~:      -1,   217,    86,   309,   194,    -1,   217,    86,   309,   194,
parse.c~:     166,    -1,    33,   194,    -1,    32,   194,    -1,   171,    -1,
parse.c~:      90,   170,   314,    -1,   171,    -1,    90,   170,   314,    -1,
parse.c~:     173,    -1,   173,   172,    -1,   173,    96,   175,    -1,   173,
parse.c~:      96,   175,   142,   174,    -1,   173,    96,    -1,   173,    96,
parse.c~:     142,   174,    -1,    96,   175,    -1,    96,   175,   142,   174,
parse.c~:      -1,    96,    -1,    96,   142,   174,    -1,   175,    -1,    90,
parse.c~:     170,   314,    -1,   172,   142,    -1,   173,   172,   142,    -1,
parse.c~:     172,    -1,   174,   142,   172,    -1,   282,    -1,   217,   140,
parse.c~:     192,   315,    -1,   217,   141,    53,    -1,   217,    86,    53,
parse.c~:      -1,   217,   141,    57,    -1,   217,    86,    57,    -1,    87,
parse.c~:      57,    -1,   285,    -1,   282,    -1,   217,   140,   192,   315,
parse.c~:      -1,   217,   141,    53,    -1,   217,    86,    53,    -1,   217,
parse.c~:     141,    57,    -1,   217,    86,    57,    -1,    87,    57,    -1,
parse.c~:     285,    -1,    53,    -1,    57,    -1,    87,   177,    -1,   177,
parse.c~:      -1,   217,    86,   177,    -1,    53,    -1,    57,    -1,    54,
parse.c~:      -1,   184,    -1,   185,    -1,   179,    -1,   278,    -1,   180,
parse.c~:      -1,   280,    -1,   181,    -1,    -1,   182,   142,   183,   181,
parse.c~:      -1,   115,    -1,   116,    -1,   117,    -1,    70,    -1,    71,
parse.c~:      -1,    72,    -1,    78,    -1,    79,    -1,   113,    -1,    74,
parse.c~:      -1,   114,    -1,    75,    -1,    73,    -1,    84,    -1,    85,
parse.c~:      -1,   118,    -1,   119,    -1,   120,    -1,    96,    -1,   121,
parse.c~:      -1,   122,    -1,    69,    -1,   124,    -1,   125,    -1,    67,
parse.c~:      -1,    68,    -1,    82,    -1,    83,    -1,   143,    -1,    50,
parse.c~:      -1,    51,    -1,    52,    -1,    48,    -1,    49,    -1,    46,
parse.c~:      -1,    38,    -1,     7,    -1,    22,    -1,    16,    -1,    17,
parse.c~:      -1,     3,    -1,     5,    -1,    47,    -1,    27,    -1,    15,
parse.c~:      -1,    14,    -1,    10,    -1,     9,    -1,    37,    -1,    21,
parse.c~:      -1,    26,    -1,     4,    -1,    23,    -1,    35,    -1,    40,
parse.c~:      -1,    39,    -1,    24,    -1,     8,    -1,    25,    -1,    31,
parse.c~:      -1,    34,    -1,    33,    -1,    13,    -1,    36,    -1,     6,
parse.c~:      -1,    18,    -1,    32,    -1,    11,    -1,    12,    -1,    19,
parse.c~:      -1,    20,    -1,   176,   110,   186,    -1,   176,   110,   186,
parse.c~:      45,   186,    -1,   284,    88,   186,    -1,   284,    88,   186,
parse.c~:      45,   186,    -1,   217,   140,   192,   315,    88,   186,    -1,
parse.c~:     217,   141,    53,    88,   186,    -1,   217,   141,    57,    88,
parse.c~:     186,    -1,   217,    86,    53,    88,   186,    -1,   217,    86,
parse.c~:      57,    88,   186,    -1,    87,    57,    88,   186,    -1,   285,
parse.c~:      88,   186,    -1,   186,    80,   186,    -1,   186,    81,   186,
parse.c~:      -1,   186,   118,   186,    -1,   186,   119,   186,    -1,   186,
parse.c~:     120,   186,    -1,   186,   121,   186,    -1,   186,   122,   186,
parse.c~:      -1,   186,    69,   186,    -1,   123,    60,    69,   186,    -1,
parse.c~:     123,    61,    69,   186,    -1,    67,   186,    -1,    68,   186,
parse.c~:      -1,   186,   115,   186,    -1,   186,   116,   186,    -1,   186,
parse.c~:     117,   186,    -1,   186,    70,   186,    -1,   186,   113,   186,
parse.c~:      -1,   186,    74,   186,    -1,   186,   114,   186,    -1,   186,
parse.c~:      75,   186,    -1,   186,    71,   186,    -1,   186,    72,   186,
parse.c~:      -1,   186,    73,   186,    -1,   186,    78,   186,    -1,   186,
parse.c~:      79,   186,    -1,   124,   186,    -1,   125,   186,    -1,   186,
parse.c~:      84,   186,    -1,   186,    85,   186,    -1,   186,    76,   186,
parse.c~:      -1,   186,    77,   186,    -1,    -1,    47,   313,   187,   186,
parse.c~:      -1,   186,   111,   186,   313,   112,   186,    -1,   200,    -1,
parse.c~:     186,    -1,   319,    -1,   198,   316,    -1,   198,   142,   306,
parse.c~:     316,    -1,   306,   316,    -1,   144,   192,   314,    -1,   319,
parse.c~:      -1,   190,    -1,   319,    -1,   193,    -1,   168,    -1,   198,
parse.c~:     197,    -1,   306,   197,    -1,   198,   142,   306,   197,    -1,
parse.c~:     196,    -1,    -1,   195,   193,    -1,    97,   188,    -1,   142,
parse.c~:     196,    -1,   142,    -1,   319,    -1,   188,    -1,    96,   188,
parse.c~:      -1,   198,   142,   188,    -1,   198,   142,    96,   188,    -1,
parse.c~:     198,   142,   188,    -1,   198,   142,    96,   188,    -1,    96,
parse.c~:     188,    -1,   261,    -1,   262,    -1,   265,    -1,   266,    -1,
parse.c~:     267,    -1,   270,    -1,   283,    -1,   285,    -1,    54,    -1,
parse.c~:      -1,   218,   201,   157,   229,    -1,    -1,    91,   162,   202,
parse.c~:     314,    -1,    90,   158,   145,    -1,   217,    86,    57,    -1,
parse.c~:      87,    57,    -1,    93,   189,   146,    -1,    94,   305,   139,
parse.c~:      -1,    31,    -1,    32,   144,   193,   314,    -1,    32,   144,
parse.c~:     314,    -1,    32,    -1,    -1,    47,   313,   144,   203,   162,
parse.c~:     314,    -1,    40,   144,   162,   314,    -1,    40,   144,   314,
parse.c~:      -1,   308,   252,    -1,   251,    -1,   251,   252,    -1,    98,
parse.c~:     244,    -1,   219,   163,   230,   158,   232,   229,    -1,   220,
parse.c~:     163,   230,   158,   233,   229,    -1,    -1,    -1,   221,   204,
parse.c~:     163,   231,   205,   158,   229,    -1,    -1,    -1,   222,   206,
parse.c~:     163,   231,   207,   158,   229,    -1,   224,   163,   312,   255,
parse.c~:     229,    -1,   223,   163,   312,   255,   229,    -1,   223,   312,
parse.c~:     255,   229,    -1,    -1,    -1,   225,   234,    26,   208,   163,
parse.c~:     231,   209,   158,   229,    -1,    -1,   226,   178,   286,   210,
parse.c~:     157,   229,    -1,    -1,    -1,   226,    84,   162,   211,   317,
parse.c~:     212,   157,   229,    -1,    -1,   227,   178,   213,   157,   229,
parse.c~:      -1,    -1,   228,   179,   214,   288,   157,   229,    -1,    -1,
parse.c~:      -1,   228,   303,   311,   215,   179,   216,   288,   157,   229,
parse.c~:      -1,    22,    -1,    23,    -1,    24,    -1,    25,    -1,   200,
parse.c~:      -1,     7,    -1,    11,    -1,    12,    -1,    19,    -1,    20,
parse.c~:      -1,    16,    -1,    17,    -1,    21,    -1,     3,    -1,     4,
parse.c~:      -1,     5,    -1,    10,    -1,   317,    -1,    13,    -1,   317,
parse.c~:      13,    -1,   317,    -1,    28,    -1,   233,    -1,    14,   163,
parse.c~:     230,   158,   232,    -1,   319,    -1,    15,   158,    -1,   176,
parse.c~:      -1,   169,    -1,   291,    -1,    90,   237,   314,    -1,   235,
parse.c~:      -1,   236,   142,   235,    -1,   236,    -1,   236,   142,    96,
parse.c~:     291,    -1,   236,   142,    96,   291,   142,   236,    -1,   236,
parse.c~:     142,    96,    -1,   236,   142,    96,   142,   236,    -1,    96,
parse.c~:     291,    -1,    96,   291,   142,   236,    -1,    96,    -1,    96,
parse.c~:     142,   236,    -1,   293,   142,   296,   142,   299,   302,    -1,
parse.c~:     293,   142,   296,   142,   299,   142,   293,   302,    -1,   293,
parse.c~:     142,   296,   302,    -1,   293,   142,   296,   142,   293,   302,
parse.c~:      -1,   293,   142,   299,   302,    -1,   293,   142,    -1,   293,
parse.c~:     142,   299,   142,   293,   302,    -1,   293,   302,    -1,   296,
parse.c~:     142,   299,   302,    -1,   296,   142,   299,   142,   293,   302,
parse.c~:      -1,   296,   302,    -1,   296,   142,   293,   302,    -1,   299,
parse.c~:     302,    -1,   299,   142,   293,   302,    -1,   301,    -1,   319,
parse.c~:      -1,   240,    -1,   115,   241,   115,    -1,    77,    -1,   115,
parse.c~:     238,   241,   115,    -1,   319,    -1,   147,   242,    -1,   243,
parse.c~:      -1,   242,   142,   243,    -1,    53,    -1,   290,    -1,    -1,
parse.c~:     245,   246,   247,    -1,   144,   289,   241,   314,    -1,   289,
parse.c~:      -1,   108,   158,   139,    -1,    30,   158,    10,    -1,    -1,
parse.c~:      29,   249,   239,   158,    10,    -1,   168,   248,    -1,   250,
parse.c~:     141,   309,   191,    -1,   250,    86,   309,   191,    -1,   308,
parse.c~:     190,    -1,   217,   141,   309,   191,    -1,   217,    86,   309,
parse.c~:     190,    -1,   217,    86,   310,    -1,   217,   141,   190,    -1,
parse.c~:     217,    86,   190,    -1,    33,   190,    -1,    33,    -1,   217,
parse.c~:     140,   192,   315,    -1,    -1,   138,   253,   239,   158,   139,
parse.c~:      -1,    -1,    27,   254,   239,   158,    10,    -1,    18,   198,
parse.c~:     230,   158,   256,    -1,   233,    -1,   255,    -1,     8,   258,
parse.c~:     259,   230,   158,   257,    -1,   319,    -1,   188,    -1,   199,
parse.c~:      -1,   319,    -1,    89,   176,    -1,   319,    -1,     9,   158,
parse.c~:      -1,   319,    -1,   281,    -1,   278,    -1,   280,    -1,   263,
parse.c~:      -1,    63,    -1,   264,    -1,   263,   264,    -1,   100,   272,
parse.c~:     107,    -1,   101,   273,   107,    -1,   102,   273,    66,    -1,
parse.c~:     103,   148,   107,    -1,   103,   268,   107,    -1,    -1,   268,
parse.c~:     269,   148,    -1,   274,    -1,   269,   274,    -1,   104,   148,
parse.c~:     107,    -1,   104,   271,   107,    -1,    -1,   271,    62,   148,
parse.c~:      -1,    -1,   272,   274,    -1,    -1,   273,   274,    -1,    62,
parse.c~:      -1,    -1,   106,   275,   277,    -1,    -1,   105,   276,   158,
parse.c~:     139,    -1,    55,    -1,    56,    -1,    58,    -1,   285,    -1,
parse.c~:      99,   279,    -1,   179,    -1,    56,    -1,    55,    -1,    58,
parse.c~:      -1,    99,   273,   107,    -1,    60,    -1,    61,    -1,   123,
parse.c~:      60,    -1,   123,    61,    -1,    53,    -1,    56,    -1,    55,
parse.c~:      -1,    57,    -1,    58,    -1,    35,    -1,    34,    -1,    36,
parse.c~:      -1,    37,    -1,    51,    -1,    50,    -1,    52,    -1,   282,
parse.c~:      -1,   282,    -1,    64,    -1,    65,    -1,   317,    -1,    -1,
parse.c~:     114,   287,   163,   317,    -1,     1,   317,    -1,   144,   289,
parse.c~:     314,    -1,   289,   317,    -1,   293,   142,   297,   142,   299,
parse.c~:     302,    -1,   293,   142,   297,   142,   299,   142,   293,   302,
parse.c~:      -1,   293,   142,   297,   302,    -1,   293,   142,   297,   142,
parse.c~:     293,   302,    -1,   293,   142,   299,   302,    -1,   293,   142,
parse.c~:     299,   142,   293,   302,    -1,   293,   302,    -1,   297,   142,
parse.c~:     299,   302,    -1,   297,   142,   299,   142,   293,   302,    -1,
parse.c~:     297,   302,    -1,   297,   142,   293,   302,    -1,   299,   302,
parse.c~:      -1,   299,   142,   293,   302,    -1,   301,    -1,    -1,    57,
parse.c~:      -1,    56,    -1,    55,    -1,    58,    -1,   290,    -1,    53,
parse.c~:      -1,   291,    -1,    90,   237,   314,    -1,   292,    -1,   293,
parse.c~:     142,   292,    -1,    53,   110,   188,    -1,    53,   110,   217,
parse.c~:      -1,   295,    -1,   296,   142,   295,    -1,   294,    -1,   297,
parse.c~:     142,   294,    -1,   120,    -1,    96,    -1,   298,    53,    -1,
parse.c~:     298,    -1,   117,    -1,    97,    -1,   300,    53,    -1,   142,
parse.c~:     301,    -1,   319,    -1,   283,    -1,    -1,   144,   304,   162,
parse.c~:     314,    -1,   319,    -1,   306,   316,    -1,   307,    -1,   306,
parse.c~:     142,   307,    -1,   188,    89,   188,    -1,    59,   188,    -1,
parse.c~:      53,    -1,    57,    -1,    54,    -1,    53,    -1,    57,    -1,
parse.c~:      54,    -1,   184,    -1,    53,    -1,    54,    -1,   184,    -1,
parse.c~:     141,    -1,    86,    -1,    -1,   318,    -1,    -1,   149,    -1,
parse.c~:     313,   145,    -1,   313,   146,    -1,    -1,   149,    -1,   142,
parse.c~:      -1,   147,    -1,   149,    -1,   317,    -1,   318,   147,    -1,
parse.c~:      -1
parse.c~:/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
parse.c~:/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
parse.c~:  "'>'", "'<'", "'|'", "'^'", "'&'", "'+'", "'-'", "'*'", "'/'", "'%'",
parse.c~:/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
parse.c~:   token YYLEX-NUM.  */
parse.c~:/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
parse.c~:/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
parse.c~:/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
parse.c~:   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
parse.c~:/* YYDEFGOTO[NTERM-NUM].  */
parse.c~:      -1,     1,     2,    65,    66,    67,   232,   554,   555,   244,
parse.c~:/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
parse.c~:   STATE-NUM.  */
parse.c~:#define YYPACT_NINF -757
parse.c~:    -757,   113,  2352,  -757,  7029,  -757,  -757,  -757,  6537,  -757,
parse.c~:    -757,  -757,  -757,  -757,  -757,  -757,  -757,  7249,  7249,  -757,
parse.c~:    -757,  7249,  3690,  3261,  -757,  -757,  -757,  -757,   313,  6396,
parse.c~:      36,  -757,     0,  -757,  -757,  -757,  2539,  3404,  -757,  -757,
parse.c~:    2689,  -757,  -757,  -757,  -757,  -757,  -757,  8459,  8459,   108,
parse.c~:    4910,  8569,  7469,  7799,  6803,  -757,  6255,  -757,  -757,  -757,
parse.c~:      43,    64,    63,  8679,  8459,  -757,   250,  -757,   739,   457,
parse.c~:    -757,  -757,   212,   203,  -757,   204,  8789,  -757,   242,  2815,
parse.c~:      23,   215,  -757,  8569,  8569,  -757,  -757,  5595,  8569,  8894,
parse.c~:    8999,  9104,  6113,    20,    70,  -757,  -757,   261,  -757,  -757,
parse.c~:    -757,  -757,  -757,  -757,  -757,  -757,    44,  -757,   276,   371,
parse.c~:      61,  -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,
parse.c~:    -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,
parse.c~:    -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,
parse.c~:    -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,
parse.c~:    -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,
parse.c~:    -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,
parse.c~:    -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,
parse.c~:    -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,
parse.c~:     230,  -757,  -757,  -757,  -757,  -757,  -757,  -757,   247,  8459,
parse.c~:     366,  5057,  8459,  8459,  8459,  -757,   350,  2815,   380,  -757,
parse.c~:    -757,   360,   249,    31,   398,    52,   373,  -757,  -757,  -757,
parse.c~:    5485,  -757,  7249,  7249,  -757,  -757,  5729,  -757,  8569,   485,
parse.c~:    -757,   375,   391,  5204,   404,   410,  -757,   262,    61,   466,
parse.c~:     435,  7139,  4910,   397,   250,   739,    36,   446,  -757,   457,
parse.c~:     412,   191,   238,  -757,   380,   434,   238,  -757,    36,   503,
parse.c~:     461,  9209,   469,  -757,   267,   279,   315,  -757,   976,  -757,
parse.c~:    -757,  -757,  -757,   555,  -757,   560,   575,   709,   479,   614,
parse.c~:     492,    50,   507,   546,  -757,  -757,  -757,  -757,  -757,  -757,
parse.c~:    -757,  5839,  8569,  8569,  8569,  8569,  7139,  8569,  8569,  -757,
parse.c~:    -757,  7909,  -757,  4910,  6916,   477,  7909,  8459,  8459,  8459,
parse.c~:    8569,  8569,   250,   620,   496,   250,   587,  -757,  -757,   330,
parse.c~:     628,    53,    73,   431,   512,  8569,   444,  -757,   109,   353,
parse.c~:    -757,  -757,  -757,    39,    47,    59,   228,   268,   280,   312,
parse.c~:     342,   351,  -757,  -757,  -757,   363, 10412, 10412,  -757,  -757,
parse.c~:    -757,  -757,  8679,  8679,  -757,   562,  -757,  -757,  -757,    67,
parse.c~:    -757,  -757,  8459,  8459,  7359,  -757,  -757,  9554,  7249,  9632,
parse.c~:    8459,  8459,  7579,  -757,    36,   526,  -757,  -757,    36,  -757,
parse.c~:    -757,   121,  -757,  -757,  -757,  -757,  -757,  6537,  -757,  8459,
parse.c~:    4495,   534,  9554,  9632,  8459,   739,    36,  -757,  -757,  5968,
parse.c~:     535,    36,  -757,  7689,  -757,  -757,  7799,  -757,  -757,  -757,
parse.c~:     375,   365,  -757,  -757,  -757,   537,  9209,  9710,  7249,  9788,
parse.c~:     573,  -757,  -757,  -757,  -757,   784,  -757,  -757,  -757,  -757,
parse.c~:    1044,    74,  -757,  -757,  -757,  -757,   544,  -757,   545,   637,
parse.c~:     557,   647,  -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,
parse.c~:    -757,  -757,  -757,  -757,   245,  -757,  -757,   556,  -757,  8459,
parse.c~:    8459,  -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,
parse.c~:     206,  8459,  -757,   559,   565,  -757,    36,  9209,   566,  -757,
parse.c~:    -757,  1074,  -757,  -757,   466,  2014,  2014,  2014,  2014,   846,
parse.c~:    3833,  2832,  3920,  2975,  -757,   410,  -757,    36,   486,  -757,
parse.c~:     504,  -757,  -757,  3547,   699,   702,  -757,  4214,   700,  4642,
parse.c~:    -757,   457,  -757,   365,  -757,   250,  -757,  -757,  -757, 10022,
parse.c~:    7249, 10100,  4067,  8569,  1110,  -757,  -757,  -757,  -757,  -757,
parse.c~:    1956,  1956,   206,   206,  -757, 10469,  -757,  2815,  -757,  -757,
parse.c~:    6537, 10490,  -757,  8459,   380,  -757,   373,  2197,  3118,    36,
parse.c~:     253,   324,  -757,  -757,  -757,  -757,  -757,  -757,  8569,  2815,
parse.c~:     578,  -757,   410,   410,  2815,   218,   739,  -757,   238,  9209,
parse.c~:     537,   612,   234,    36,    34,    48,  8459,  -757,   784,    94,
parse.c~:    -757,   576,    36,  -757,   577,  5351,  5204,  -757,  1044,  -757,
parse.c~:    -757,  1044,  -757,  -757,   421,  -757,  -757,  5204,   737,  -757,
parse.c~:    -757,  -757,   466,   466,  -757,   689,  5351,  -757,  -757,   580,
parse.c~:    8129,  -757,   537,  9209,  8459,   622,  8679,  8459,  -757,   562,
parse.c~:     590,   530,  8679,  8679,  -757,  -757,   562,  -757,  -757,  -757,
parse.c~:    8239,   711,  -757,   610,  -757,   711,  -757,  -757,  -757,  -757,
parse.c~:     699,   168,  -757,   699,    45,   145,    36,    90,   100,  8569,
parse.c~:     250,  -757,  8569,  4067,   612,   234,  -757,    36,   699,   121,
parse.c~:    1044,  4067,   250,  6678,  -757,  -757,  -757,  -757,  5351,  5204,
parse.c~:    8459,   206,  -757,  -757,  -757,  8459,   402,  8459,  8459,   121,
parse.c~:    -757,  -757,  -757,   344,  -757,    36,   808,   598,  1162,  -757,
parse.c~:     639,    36,  -757,   733,   619,  -757,   609,   624,  -757,   625,
parse.c~:    -757,   627,   625,   638,  -757,  -757,  -757,  -757,  -757,   666,
parse.c~:     577,   663,   645,  -757,   646,   649,  -757,   779,  8459,   654,
parse.c~:     537,  2815,  8459,  -757,  2815,  2815,  -757,  -757,  8679,  -757,
parse.c~:    2815,  -757,  2815,  -757,   559,  -757,   710,  -757,  4776,   789,
parse.c~:    -757,  8569,   699,  -757,   699,  5351,  5351,  -757,  8349,  4361,
parse.c~:    -757,   103,    49,  -757,   250,   699,  -757,  -757,  -757,    36,
parse.c~:     699,  -757,  -757,   794,   671,  2815,  5204,  8459,  -757,  -757,
parse.c~:     670,   808,   117,  -757,  -757,   674,  -757,  -757,  -757,  -757,
parse.c~:    -757,  1044,  -757,   421,  -757,   421,  -757,   421,  -757,  -757,
parse.c~:    -757,  9314,   690,  -757,  1243,  -757,  1243,  -757,   421,  -757,
parse.c~:    -757,   675,  2815,  -757,  2815,  9419,   105,  -757,  -757,  5351,
parse.c~:    -757,  -757,   105,  -757,  -757,   699,   699,  -757,    96,  -757,
parse.c~:    4067,  -757,  -757,  -757,  -757,  1110,  -757,  -757,   681,   808,
parse.c~:    -757,   688,   692,   625,  -757,   693,   625,   774,  -757,   403,
parse.c~:     279,   315,  4067,  -757,  4214,  -757,  -757,  -757,  -757,  -757,
parse.c~:    5351,   699,  4067,  -757,   670,   808,  -757,  -757,   421,  -757,
parse.c~:    -757,  -757,  -757, 10178,  1243,  -757,   421,  -757,  -757,   421,
parse.c~:    -757,  -757,   365, 10256,  7249, 10334,   702,   610,   699,  -757,
parse.c~:     234,    36,   129,   133,  -757,  -757,  -757,  -757,  -757,  -757,
parse.c~:     421,  -757,  -757,  -757,   155,   625,  -757
parse.c~:/* YYPGOTO[NTERM-NUM].  */
parse.c~:    -757,  -757,  -757,   426,  -757,    28,  -757,  -475,  1003,  -757,
parse.c~:      71,  -757,   239,   -76,   -53,  -757,  -250,  -757,   -16,   743,
parse.c~:    -137,    13,   -67,  -757,  -405,   -12,   937,  -308,   758,   -49,
parse.c~:    -757,   -13,  -757,  -757,    16,  -757,   685,  -757,  1120,  -757,
parse.c~:      12,   -23,  -331,    66,    10,  -757,  -210,  -191,   -39,  -280,
parse.c~:     -32,  -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,
parse.c~:    -757,  -757,  -757,  -757,  -757,  -757,  -757,     2,  -757,  -757,
parse.c~:    -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,  -757,  -434,
parse.c~:    -325,  -521,   -93,  -597,  -757,  -679,  -664,   217,  -757,  -497,
parse.c~:    -757,  -544,  -757,   -37,  -757,  -757,  -757,  -757,  -757,  -757,
parse.c~:    -757,  -757,   764,  -757,  -757,  -501,  -757,   -87,  -757,  -757,
parse.c~:    -757,  -757,  -757,  -757,   771,  -757,  -757,  -757,  -757,  -757,
parse.c~:    -757,  -757,  -757,   568,  -209,  -757,  -757,  -757,     7,  -757,
parse.c~:       9,  -757,   968,   777,  1239,  1041,  -757,  -757,   -15,  -247,
parse.c~:    -682,  -437,  -594,     4,  -602,  -756,    18,   225,  -757,  -517,
parse.c~:    -757,  -240,   553,  -757,  -757,  -757,    -6,  -267,  1860,  -296,
parse.c~:    -757,  -757,   -11,    -1,    99,  -578,  -222,  -202,    -4,    -2
parse.c~:/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
parse.c~:#define YYTABLE_NINF -564
parse.c~:     -89,   700,   291,   247,   703,   212,   479,   609,   837,   833,
parse.c~:     485,   -98,   191,    68,   -91,    68,   343,   696,   264,   -95,
parse.c~:     212,   349,   359,   359,   799,   728,   729,   378,   804,  -102,
parse.c~:     904,   545,   672,   553,   645,   426,   376,   718,   191,  -325,
parse.c~:     575,   798,   487,     3,   563,  -101,   -97,   633,   556,  -480,
parse.c~:     385,   771,   384,   282,   283,  -473,   -99,   623,   811,   -96,
parse.c~:     702,   757,  -480,  -472,   761,   612,   558,   558,   233,   816,
parse.c~:     401,   -95,   -97,   -98,   -89,  -474,   -99,   637,   775,   451,
parse.c~:     452,   453,   454,   623,   -95,   424,   578,   488,   -91,   297,
parse.c~:     298,   377,  -102,  -325,  -325,   240,   506,   890,   -96,   612,
parse.c~:     637,  -100,   451,   452,   453,   454,   -89,  -101,   904,   -89,
parse.c~:    -473,   556,   646,   -89,   605,   227,   -87,   -90,  -472,  -541,
parse.c~:     -91,   278,   605,   -91,   444,   -87,   287,   -91,   288,   379,
parse.c~:    -474,   643,   747,    81,   205,   223,   205,   205,   379,   396,
parse.c~:     833,   837,   280,   644,   396,   -94,   493,   494,   495,   496,
parse.c~:     212,   -93,   -89,   428,   826,    81,   746,   706,   815,   760,
parse.c~:     429,   299,   -91,    81,    81,   -88,   820,   224,   502,   717,
parse.c~:     227,   716,   263,   623,  -541,   660,   -97,   -98,   -97,   -98,
parse.c~:     -99,   917,   -99,   664,   817,   623,   404,   -92,   407,  -542,
parse.c~:     212,   333,   -96,   212,   -96,    81,   264,   473,   212,   643,
parse.c~:     808,   643,   425,   301,  -475,   287,   247,   288,   205,   492,
parse.c~:    -279,   665,   337,   337,   895,   412,   337,   337,   -68,   594,
parse.c~:     474,   475,   306,   447,  -477,   334,   335,   212,   698,   698,
parse.c~:     -82,    57,    68,   -97,   382,  -479,  -476,   497,   873,  -475,
parse.c~:     874,  -407,   387,   711,  -279,  -279,   809,   918,  -542,   444,
parse.c~:     399,   226,   307,   659,   643,   892,   410,   287,  -478,   288,
parse.c~:     212,  -272,   398,   423,   617,   921,   741,   448,   449,  -477,
parse.c~:     795,   552,   738,   543,   263,   734,   567,   956,   111,  -479,
parse.c~:    -479,  -476,    81,   389,   193,   776,   194,   628,  -467,   786,
parse.c~:    -407,    81,   205,   191,   -99,   552,   793,  -470,   543,   579,
parse.c~:     212,  -280,   643,  -478,   643,  -272,  -272,   226,  -538,   383,
parse.c~:     472,  -102,  -407,  -467,  -407,  -407,   400,   949,   643,   943,
parse.c~:     827,    68,  -470,   580,   581,   297,   298,   572,   668,   558,
parse.c~:     626,   573,   394,   613,   586,  -280,  -280,   615,   813,   264,
parse.c~:     616,   455,   -96,   -94,   966,   402,   967,  -467,   457,   418,
parse.c~:     627,   337,   337,   337,   337,   307,   498,   499,   458,  -539,
parse.c~:     414,   912,   427,   944,   945,  -101,   680,   914,   220,   415,
parse.c~:     416,   687,   205,   692,   223,   679,   -67,   678,   432,    81,
parse.c~:     441,    81,   742,   686,   205,   684,   410,   724,   726,  -538,
parse.c~:     212,  -467,  -467,   438,   682,  -538,   489,   -93,   410,   337,
parse.c~:     668,   668,   683,   552,   571,   543,   -97,   263,  -470,   486,
parse.c~:     698,   446,   881,   961,   -99,   490,   191,   473,   788,   509,
parse.c~:     212,   687,   473,   783,   801,   798,   276,   277,   -89,   789,
parse.c~:     791,   264,   680,   812,   678,   684,   814,   473,   563,  -545,
parse.c~:     -96,   263,   752,   491,   566,   472,   -91,    81,    81,   623,
parse.c~:    -539,   504,  -470,  -470,   570,   759,  -539,   598,   762,    81,
parse.c~:     558,   614,   -88,   621,   822,   264,   473,   -82,   212,   629,
parse.c~:     653,   800,   834,   800,   451,   452,   453,   454,  -545,   654,
parse.c~:     656,  -258,   207,   207,   661,   680,   207,   670,   673,   688,
parse.c~:     475,   483,  -259,    81,   750,   872,   798,   320,   321,   668,
parse.c~:    -545,   841,  -545,  -545,   650,   650,  -541,   650,   840,   650,
parse.c~:     212,   858,   764,   765,   867,   766,  -260,   871,   869,   865,
parse.c~:     887,    81,   889,   932,   474,   475,   893,  -261,   818,   263,
parse.c~:     452,   453,   454,   970,   829,   894,   620,   896,  -541,   362,
parse.c~:     838,   897,  -542,   899,   965,   745,   926,   739,   380,   964,
parse.c~:     106,     0,     0,     0,     0,   637,  -237,   451,   452,   453,
parse.c~:     238,   238,   108,   109,     0,   109,  -563,     0,     0,     0,
parse.c~:     108,   109,     0,   109,  -563,  -563,  -563,   108,   108,  -563,
parse.c~:    -563,  -563,     0,     0,  -563,     0,     0,     0,     0,     0,
parse.c~:       0,     0,     0,     0,  -563,     0,     0,     0,     0,   540,
parse.c~:     541,     0,     0,   542,  -563,  -563,     0,  -563,  -563,  -563,
parse.c~:    -563,  -563,     0,   158,   159,   160,   161,   162,   163,   164,
parse.c~:     321,     0,  -563,     0,   108,   108,     0,     0,   108,   174,
parse.c~:     223,     0,     0,   307,  -564,  -564,  -564,  -564,   312,   313,
parse.c~:       0,     0,  -564,  -564,     0,  -563,     0,  -563,   320,   321,
parse.c~:     223,  -563,     0,  -563,     0,  -563,     0,     0,   108,     0,
parse.c~:     238,   238,   238,     0,     0,     0,     0,  -545,     0,     0,
parse.c~:       0,     0,     0,     0,     0,  -545,  -545,  -545,     0,     0,
parse.c~:    -545,  -545,  -545,     0,     0,  -545,     0,     0,     0,     0,
parse.c~:       0,     0,     0,     0,  -545,  -545,  -545,  -545,     0,     0,
parse.c~:       0,     0,     0,     0,     0,  -545,  -545,     0,  -545,  -545,
parse.c~:    -545,  -545,  -545,     0,     0,     0,     0,     0,     0,     0,
parse.c~:     238,   238,   238,     0,     0,     0,  -545,  -545,  -545,  -545,
parse.c~:    -545,  -545,  -545,  -545,  -545,  -545,  -545,  -545,  -545,   238,
parse.c~:       0,  -545,  -545,  -545,   238,   735,  -545,     0,     0,     0,
parse.c~:       0,     0,  -545,   238,     0,     0,   238,     0,     0,     0,
parse.c~:       0,     0,     0,     0,     0,  -545,   238,   -98,  -545,  -545,
parse.c~:    -545,  -545,  -545,  -545,  -545,  -545,  -545,  -545,  -545,  -545,
parse.c~:       0,     0,     0,     0,     0,  -545,  -545,  -545,  -545,  -545,
parse.c~:       0,     0,  -545,  -545,  -545,     0,  -545,     0,     0,   238,
parse.c~:     238,     0,  -563,     4,     0,     5,     6,     7,     8,     9,
parse.c~:       0,     0,     0,     0,     0,     0,   238,     0,     0,  -563,
parse.c~:       0,  -563,     0,     0,     0,     0,     0,     0,   323,   324,
parse.c~:     238,     0,     0,   238,   238,     0,     0,   238,     0,  -467,
parse.c~:       0,     0,     0,     0,     0,     0,     0,  -467,  -467,  -467,
parse.c~:     238,     0,  -467,  -467,  -467,     0,     0,  -467,     0,     0,
parse.c~:       0,     0,     0,     0,     0,  -467,     0,  -467,  -467,  -467,
parse.c~:       0,     0,     0,     0,     0,     0,     0,  -467,  -467,     0,
parse.c~:    -467,  -467,  -467,  -467,  -467,     0,     0,     0,     0,     0,
parse.c~:       0,     0,     0,     0,     0,     0,     0,     0,  -467,  -467,
parse.c~:    -467,  -467,  -467,  -467,  -467,  -467,  -467,  -467,  -467,  -467,
parse.c~:    -467,     0,     0,  -467,  -467,  -467,     0,  -467,  -467,     0,
parse.c~:       0,     0,     0,     0,  -467,     0,     0,     0,   238,     0,
parse.c~:       0,     0,   238,     0,     0,     0,     0,  -467,     0,  -467,
parse.c~:    -467,  -467,  -467,  -467,  -467,  -467,  -467,  -467,  -467,  -467,
parse.c~:    -467,  -467,     0,     0,     0,     0,     0,     0,   238,     0,
parse.c~:       0,     0,     0,     0,     0,     0,     0,     0,  -467,  -467,
parse.c~:    -467,  -467,     0,     0,  -467,  -467,  -467,   238,  -467,  -470,
parse.c~:       0,     0,     0,     0,     0,     0,     0,  -470,  -470,  -470,
parse.c~:       0,     0,  -470,  -470,  -470,     0,     0,  -470,     0,     0,
parse.c~:       0,   238,     0,     0,     0,  -470,     0,  -470,  -470,  -470,
parse.c~:       0,     0,     0,     0,     0,   238,     0,  -470,  -470,     0,
parse.c~:    -470,  -470,  -470,  -470,  -470,     0,     0,     0,     0,     0,
parse.c~:     316,   317,   318,   319,     0,     0,   320,   321,  -470,  -470,
parse.c~:    -470,  -470,  -470,  -470,  -470,  -470,  -470,  -470,  -470,  -470,
parse.c~:    -470,     0,     0,  -470,  -470,  -470,     0,  -470,  -470,     0,
parse.c~:       0,     0,     0,   322,  -470,   323,   324,   325,   326,   327,
parse.c~:     328,   329,   330,   331,   332,     0,     0,  -470,     0,  -470,
parse.c~:    -470,  -470,  -470,  -470,  -470,  -470,  -470,  -470,  -470,  -470,
parse.c~:    -470,  -470,     0,     0,     0,     0,     0,     0,     0,     0,
parse.c~:       0,   227,     0,     0,     0,     0,     0,     0,  -470,  -470,
parse.c~:    -470,  -470,  -546,     0,  -470,  -470,  -470,     0,  -470,     0,
parse.c~:    -546,  -546,  -546,     0,     0,  -546,  -546,  -546,     0,     0,
parse.c~:    -546,     0,     0,     0,     0,     0,     0,     0,     0,  -546,
parse.c~:    -546,  -546,  -546,     0,     0,     0,     0,     0,     0,     0,
parse.c~:    -546,  -546,     0,  -546,  -546,  -546,  -546,  -546,     0,     0,
parse.c~:     321,  -546,  -546,  -546,  -546,  -546,  -546,  -546,  -546,  -546,
parse.c~:    -546,  -546,  -546,  -546,     0,     0,  -546,  -546,  -546,     0,
parse.c~:       0,  -546,     0,     0,     0,     0,   322,  -546,   323,   324,
parse.c~:    -546,     0,     0,  -546,  -546,  -546,  -546,  -546,  -546,  -546,
parse.c~:    -546,  -546,  -546,  -546,  -546,     0,     0,     0,     0,     0,
parse.c~:    -546,  -546,  -546,  -546,  -546,  -547,     0,  -546,  -546,  -546,
parse.c~:       0,  -546,     0,  -547,  -547,  -547,     0,     0,  -547,  -547,
parse.c~:    -547,     0,     0,  -547,     0,     0,     0,     0,     0,     0,
parse.c~:       0,     0,  -547,  -547,  -547,  -547,     0,     0,     0,     0,
parse.c~:       0,     0,     0,  -547,  -547,     0,  -547,  -547,  -547,  -547,
parse.c~:    -547,     0,     0,     0,     0,     0,     0,   307,   308,   309,
parse.c~:     310,   311,   312,   313,   314,   315,   316,   317,  -564,  -564,
parse.c~:       0,     0,   320,   321,  -547,  -547,  -547,  -547,  -547,  -547,
parse.c~:    -547,  -547,  -547,  -547,  -547,  -547,  -547,     0,     0,  -547,
parse.c~:    -547,  -547,     0,     0,  -547,     0,     0,     0,     0,     0,
parse.c~:    -547,   323,   324,   325,   326,   327,   328,   329,   330,   331,
parse.c~:     332,     0,     0,  -547,     0,     0,  -547,  -547,  -547,  -547,
parse.c~:    -547,  -547,  -547,  -547,  -547,  -547,  -547,  -547,     0,     0,
parse.c~:       0,     0,     0,  -547,  -547,  -547,  -547,  -547,  -279,     0,
parse.c~:    -547,  -547,  -547,     0,  -547,     0,  -279,  -279,  -279,     0,
parse.c~:       0,  -279,  -279,  -279,     0,     0,  -279,     0,     0,     0,
parse.c~:       0,     0,     0,     0,     0,     0,  -279,  -279,  -279,     0,
parse.c~:       0,     0,     0,     0,     0,     0,  -279,  -279,     0,  -279,
parse.c~:    -279,  -279,  -279,  -279,     0,     0,     0,     0,     0,     0,
parse.c~:       0,     0,     0,     0,     0,     0,     0,  -279,  -279,  -279,
parse.c~:    -279,  -279,  -279,  -279,  -279,  -279,  -279,  -279,  -279,  -279,
parse.c~:       0,     0,  -279,  -279,  -279,     0,   677,  -279,     0,     0,
parse.c~:       0,     0,     0,  -279,     0,     0,     0,     0,     0,     0,
parse.c~:       0,     0,     0,     0,     0,     0,  -279,     0,  -100,  -279,
parse.c~:    -279,  -279,  -279,  -279,  -279,  -279,  -279,  -279,  -279,  -279,
parse.c~:    -279,     0,     0,     0,     0,     0,     0,     0,     0,     0,
parse.c~:       0,     0,     0,     0,     0,     0,     0,  -279,  -279,  -279,
parse.c~:    -279,  -406,     0,  -279,  -279,  -279,     0,  -279,     0,  -406,
parse.c~:    -406,  -406,     0,     0,  -406,  -406,  -406,     0,     0,  -406,
parse.c~:       0,     0,     0,     0,     0,     0,     0,     0,  -406,  -406,
parse.c~:    -406,     0,     0,     0,     0,     0,     0,     0,     0,  -406,
parse.c~:    -406,     0,  -406,  -406,  -406,  -406,  -406,     0,     0,     0,
parse.c~:    -406,  -406,  -406,  -406,  -406,  -406,  -406,  -406,  -406,  -406,
parse.c~:    -406,  -406,  -406,     0,     0,  -406,  -406,  -406,     0,     0,
parse.c~:    -406,     0,     0,     0,     0,     0,  -406,     0,     0,     0,
parse.c~:       0,     0,  -406,     0,  -406,  -406,  -406,  -406,  -406,  -406,
parse.c~:    -406,  -406,  -406,  -406,     0,     0,     0,     0,     0,     0,
parse.c~:       0,     0,     0,     0,     0,     0,     0,     0,     0,  -406,
parse.c~:    -406,  -406,  -406,  -406,  -273,   223,  -406,  -406,  -406,     0,
parse.c~:    -406,     0,  -273,  -273,  -273,     0,     0,  -273,  -273,  -273,
parse.c~:       0,     0,  -273,     0,     0,     0,     0,     0,     0,     0,
parse.c~:       0,     0,  -273,  -273,  -273,     0,     0,     0,     0,     0,
parse.c~:       0,     0,  -273,  -273,     0,  -273,  -273,  -273,  -273,  -273,
parse.c~:       0,     0,     0,  -273,  -273,  -273,  -273,  -273,  -273,  -273,
parse.c~:    -273,  -273,  -273,  -273,  -273,  -273,     0,     0,  -273,  -273,
parse.c~:    -273,     0,     0,  -273,     0,     0,     0,     0,     0,  -273,
parse.c~:       0,     0,  -273,     0,     0,  -273,  -273,  -273,  -273,  -273,
parse.c~:    -273,  -273,  -273,  -273,  -273,  -273,  -273,     0,     0,     0,
parse.c~:       0,     0,     0,  -273,  -273,  -273,  -273,  -563,     0,  -273,
parse.c~:    -273,  -273,     0,  -273,     0,  -563,  -563,  -563,     0,     0,
parse.c~:    -563,  -563,  -563,     0,     0,  -563,     0,     0,     0,     0,
parse.c~:       0,     0,     0,     0,  -563,  -563,  -563,     0,     0,     0,
parse.c~:       0,     0,     0,     0,     0,  -563,  -563,     0,  -563,  -563,
parse.c~:    -563,  -563,  -563,     0,     0,     0,     0,     0,     0,     0,
parse.c~:       0,     0,     0,     0,     0,     0,  -563,  -563,  -563,  -563,
parse.c~:    -563,  -563,  -563,  -563,  -563,  -563,  -563,  -563,  -563,     0,
parse.c~:       0,  -563,  -563,  -563,     0,     0,  -563,     0,     0,     0,
parse.c~:       0,     0,  -563,     0,     0,     0,     0,     0,     0,     0,
parse.c~:       0,     0,     0,     0,     0,     0,     0,     0,  -563,     0,
parse.c~:    -563,  -563,  -563,  -563,  -563,  -563,  -563,  -563,  -563,  -563,
parse.c~:       0,     0,     0,     0,     0,  -563,  -563,  -563,  -563,  -563,
parse.c~:    -286,   223,  -563,  -563,  -563,     0,  -563,     0,  -286,  -286,
parse.c~:    -286,     0,     0,  -286,  -286,  -286,     0,     0,  -286,     0,
parse.c~:       0,     0,     0,     0,     0,     0,     0,     0,  -286,  -286,
parse.c~:       0,     0,     0,     0,     0,     0,     0,     0,  -286,  -286,
parse.c~:       0,  -286,  -286,  -286,  -286,  -286,     0,     0,     0,     0,
parse.c~:       0,     0,     0,     0,     0,     0,     0,     0,     0,  -286,
parse.c~:    -286,  -286,  -286,  -286,  -286,  -286,  -286,  -286,  -286,  -286,
parse.c~:    -286,  -286,     0,     0,  -286,  -286,  -286,     0,     0,  -286,
parse.c~:       0,     0,     0,     0,     0,  -286,     0,     0,     0,     0,
parse.c~:       0,  -286,     0,  -286,  -286,  -286,  -286,  -286,  -286,  -286,
parse.c~:    -286,  -286,  -286,     0,     0,     0,     0,     0,     0,     0,
parse.c~:       0,     0,     0,     0,     0,     0,     0,     0,     0,  -286,
parse.c~:    -286,  -286,  -286,  -545,   220,  -286,  -286,  -286,     0,  -286,
parse.c~:       0,  -545,  -545,  -545,     0,     0,     0,  -545,  -545,     0,
parse.c~:       0,  -545,     0,     0,     0,     0,     0,     0,     0,     0,
parse.c~:    -545,     0,     0,     0,     0,     0,     0,     0,     0,     0,
parse.c~:       0,  -545,  -545,     0,  -545,  -545,  -545,  -545,  -545,     0,
parse.c~:       0,     0,  -545,  -545,  -545,  -545,  -545,  -545,  -545,  -545,
parse.c~:    -545,  -545,  -545,  -545,  -545,     0,     0,  -545,  -545,  -545,
parse.c~:    -279,   676,     0,     0,     0,     0,     0,     0,  -279,  -279,
parse.c~:    -279,     0,     0,     0,  -279,  -279,     0,     0,  -279,     0,
parse.c~:       0,     0,     0,   -98,  -545,     0,  -545,  -545,  -545,  -545,
parse.c~:    -545,  -545,  -545,  -545,  -545,  -545,     0,     0,  -279,  -279,
parse.c~:       0,  -279,  -279,  -279,  -279,  -279,     0,     0,     0,     0,
parse.c~:       0,  -545,  -545,  -545,  -545,   -90,     0,     0,  -545,     0,
parse.c~:    -545,     0,  -545,     0,     0,     0,     0,     0,     0,  -279,
parse.c~:    -279,  -279,  -279,  -279,  -279,  -279,  -279,  -279,  -279,  -279,
parse.c~:    -279,  -279,     0,     0,  -279,  -279,  -279,     0,   677,     0,
parse.c~:    -100,  -279,     0,  -279,  -279,  -279,  -279,  -279,  -279,  -279,
parse.c~:    -279,  -279,  -279,     0,     0,     0,     0,     0,     0,     0,
parse.c~:       0,     0,     0,     0,     0,     0,     0,     0,     0,  -279,
parse.c~:    -279,  -279,   -92,     0,     0,  -279,     0,  -279,   241,  -279,
parse.c~:       5,     6,     7,     8,     9,  -563,  -563,  -563,    10,    11,
parse.c~:       0,     0,  -563,    12,    13,     0,    14,    15,    16,    17,
parse.c~:       0,     0,     0,     0,  -563,   241,  -563,     5,     6,     7,
parse.c~:       8,     9,     0,     0,  -563,    10,    11,     0,  -563,  -563,
parse.c~:       0,  -563,   241,  -563,     5,     6,     7,     8,     9,     0,
parse.c~:       0,  -563,    10,    11,     0,     0,  -563,    12,    13,  -563,
parse.c~:       7,     8,     9,     0,     0,     0,    10,    11,  -563,     0,
parse.c~:    -563,    12,    13,     0,    14,    15,    16,    17,    18,    19,
parse.c~:       0,     0,     0,     0,  -563,     0,     0,     0,     0,     0,
parse.c~:       0,     0,  -563,   241,  -563,     5,     6,     7,     8,     9,
parse.c~:       0,     0,  -563,    10,    11,     0,     0,  -563,    12,    13,
parse.c~:       6,     7,     8,     9,     0,  -563,  -563,    10,    11,  -563,
parse.c~:       0,  -563,    12,    13,     0,    14,    15,    16,    17,    18,
parse.c~:       0,    10,    11,  -563,     0,  -563,    12,    13,     0,    14,
parse.c~:       0,     0,     0,     0,     0,  -563,     0,  -563,   241,  -563,
parse.c~:       0,     0,  -563,     0,  -563,   241,  -563,     5,     6,     7,
parse.c~:       0,     0,     0,  -563,     0,     0,     0,     0,     0,     0,
parse.c~:       0,  -563,   241,  -563,     5,     6,     7,     8,     9,     0,
parse.c~:       0,  -563,    10,    11,     0,     0,     0,    12,    13,     0,
parse.c~:       7,     0,     9,     0,     0,     0,    10,    11,  -563,     0,
parse.c~:    -563,    12,    13,     0,    14,    15,    16,   195,   196,    19,
parse.c~:     885,   869,   854,   648,    90,    -1,   878,    -1,    -1,    -1,
parse.c~:      96,    -1,   880,    -1,   199,    -1,    -1,   202,   203,   204,
parse.c~:      -1,    -1,   894,   895,   896,   897,    -1,    -1,    90,   901,
parse.c~:     902,   903,    -1,   905,   906,   220,    -1,   222,   223,    -1,
parse.c~:      -1,    -1,    -1,    -1,   912,    69,   914,    -1,   819,    -1,
parse.c~:      -1,    -1,   920,    -1,   922,    -1,    -1,    -1,   944,    -1,
parse.c~:      84,    85,   928,    -1,    -1,    -1,    -1,    -1,   934,     2,
parse.c~:     936,     4,   944,   939,   946,   947,   944,    -1,   709,   933,
parse.c~:     952,   712,    -1,   955,   956,   957,   958,   945,    -1,   943,
parse.c~:     961,   115,   116,   117,   118,   119,   120,   121,   122,    -1,
parse.c~:       2,    -1,     4,   975,   970,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,   301,    50,    -1,    -1,
parse.c~:      -1,   306,   307,   308,   309,   310,   311,   312,   313,   314,
parse.c~:      -1,   468,    54,   470,    -1,    -1,    89,    -1,    -1,    53,
parse.c~:      -1,    55,    56,    57,    58,    -1,    -1,    -1,    -1,    -1,
parse.c~:     801,    -1,    -1,     2,    76,     4,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    50,    -1,    -1,    -1,    89,    90,    91,
parse.c~:      92,    -1,    -1,    -1,    -1,    -1,    90,   382,   383,    -1,
parse.c~:      -1,    -1,    96,    97,    69,    -1,    -1,   392,   393,   394,
parse.c~:      -1,    -1,    -1,   398,    -1,   400,   401,   402,    -1,    84,
parse.c~:      85,    50,    -1,   117,    -1,    54,   120,    53,    -1,    55,
parse.c~:      56,    57,    58,    -1,   419,    -1,    -1,    -1,    -1,   424,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    76,   433,    45,
parse.c~:     144,   436,   117,   118,   119,   120,   121,   122,    -1,    -1,
parse.c~:      89,    90,    91,   448,    90,    -1,    -1,    -1,   201,    -1,
parse.c~:      96,    97,    -1,    69,    70,    71,    72,    73,    74,    75,
parse.c~:      76,    77,    78,    79,    80,    81,    -1,    -1,    84,    85,
parse.c~:      -1,   117,    -1,    53,   120,    55,    56,    57,    58,   201,
parse.c~:     233,    -1,    -1,    53,   489,   490,    -1,    -1,   241,   242,
parse.c~:      -1,    -1,    -1,    -1,    -1,   111,   501,   113,   114,   115,
parse.c~:     116,   117,   118,   119,   120,   121,   122,    -1,    -1,    -1,
parse.c~:      90,   233,    -1,    -1,   201,    -1,    96,    97,    -1,   241,
parse.c~:     242,    -1,    -1,    -1,    -1,    53,   142,    55,    56,    57,
parse.c~:      58,    -1,    -1,    -1,    -1,    -1,    -1,   117,   291,   261,
parse.c~:     120,    -1,    -1,   296,    -1,    -1,   233,    -1,    -1,    -1,
parse.c~:     303,     2,   201,     4,    -1,   242,    -1,    -1,   563,    -1,
parse.c~:      -1,    -1,    90,   568,   144,    -1,    -1,    -1,    96,   291,
parse.c~:      -1,    -1,    -1,    -1,   296,   580,    -1,    -1,    -1,    -1,
parse.c~:      -1,   303,   304,   336,   233,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,   241,   242,    -1,    -1,    -1,    -1,   603,    50,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    53,    -1,    55,    56,
parse.c~:      57,    58,   261,    -1,   336,    -1,   303,    -1,    -1,   756,
parse.c~:     757,    -1,   759,    -1,   761,   762,    -1,    -1,    -1,   199,
parse.c~:      -1,   636,   202,   203,    -1,   772,    -1,   774,   775,    -1,
parse.c~:      -1,    -1,   291,    90,    -1,    -1,    -1,   296,    -1,    96,
parse.c~:      97,    -1,    -1,    -1,   303,   304,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,   670,    -1,   420,    -1,   674,
parse.c~:     117,   676,   677,   120,    -1,    -1,   429,   682,   683,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,   690,    -1,   336,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   420,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,   429,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,   446,   730,    -1,    -1,    -1,    -1,
parse.c~:     735,   301,   737,   738,    -1,    -1,   306,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:     201,    -1,    -1,    -1,    -1,    -1,    -1,   894,   895,   896,
parse.c~:     897,    -1,    -1,    -1,   901,   902,   903,    -1,   905,   906,
parse.c~:      -1,   420,    -1,   778,    -1,    -1,    -1,   782,    -1,    -1,
parse.c~:     429,    -1,   233,   788,    -1,   507,    -1,    -1,    -1,    -1,
parse.c~:     241,   242,    -1,    -1,    -1,    -1,    -1,   446,    -1,    -1,
parse.c~:      -1,    -1,    -1,   808,   557,    -1,   559,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,   952,    -1,    -1,   955,   956,
parse.c~:     957,   958,   827,   393,   394,    -1,    -1,    -1,    -1,   582,
parse.c~:      -1,    -1,   402,    -1,    -1,   557,    -1,   559,   975,    -1,
parse.c~:     291,    -1,    -1,    -1,    -1,   296,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,   303,    -1,    -1,    -1,    -1,    -1,   507,    -1,
parse.c~:     582,    -1,    -1,   433,    -1,    -1,   436,    -1,    -1,    -1,
parse.c~:     557,    -1,   559,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,   336,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,   645,   646,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,   657,    -1,    -1,   629,   557,    -1,
parse.c~:     559,    -1,    -1,   666,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,   645,   646,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,   501,    -1,   582,    -1,   657,    -1,    -1,    -1,   944,
parse.c~:      -1,    -1,    -1,    -1,   666,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,   673,    -1,    -1,    -1,    -1,    -1,    -1,   645,   646,
parse.c~:     713,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   721,   420,
parse.c~:     657,    -1,    -1,    -1,    -1,   728,   729,    -1,   429,   666,
parse.c~:     629,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,   713,    -1,   563,    -1,    -1,   645,   646,    -1,   721,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,   728,   729,   657,   658,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,   666,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,   673,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,   603,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,   728,   729,    -1,    -1,   798,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,   805,   806,    -1,    -1,   809,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,   713,    -1,   636,    -1,    -1,    -1,
parse.c~:      -1,    -1,   721,   826,    -1,    -1,   798,    -1,    -1,   728,
parse.c~:     729,    -1,    -1,   805,   806,    -1,    -1,   809,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:     670,    -1,    -1,    -1,   826,    -1,   557,    -1,   559,    -1,
parse.c~:      -1,   798,   865,    -1,    -1,    -1,   869,    -1,   805,   806,
parse.c~:     690,    -1,   809,    -1,    -1,    -1,    -1,   880,    -1,   851,
parse.c~:      -1,   582,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   826,
parse.c~:      -1,    -1,    -1,   865,    -1,    -1,    -1,   869,    -1,   798,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,   805,   806,   880,   912,
parse.c~:     809,   914,    -1,    -1,    -1,    -1,    -1,   920,    -1,   922,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,   826,    -1,    -1,
parse.c~:      -1,    -1,   869,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:     912,    -1,   914,    -1,   645,   646,    -1,    -1,   920,    -1,
parse.c~:     922,    -1,   851,    -1,    -1,    -1,   657,    -1,   778,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,   666,   865,    47,    48,    -1,
parse.c~:     869,    -1,    52,    53,    54,   912,    -1,   914,    -1,    -1,
parse.c~:      -1,   880,    -1,   920,    64,    -1,    -1,    -1,   808,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    76,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    89,
parse.c~:      90,    91,   713,   912,    -1,   914,     0,    -1,    -1,    -1,
parse.c~:     721,   920,    -1,   922,     8,     9,    10,   728,   729,    13,
parse.c~:      14,    15,    -1,    -1,    18,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    28,    -1,    -1,    -1,    -1,    53,
parse.c~:      54,    -1,    -1,    57,    38,    39,    -1,    41,    42,    43,
parse.c~:      44,    45,    -1,    67,    68,    69,    70,    71,    72,    73,
parse.c~:      74,    75,    -1,    -1,    78,    79,    -1,    -1,    82,    83,
parse.c~:      84,    85,    -1,    -1,    69,    70,    71,    72,    73,    74,
parse.c~:      75,    76,    96,    78,    79,    -1,    -1,   798,    -1,    84,
parse.c~:      85,    -1,    86,    -1,   805,   806,    -1,    -1,   809,   113,
parse.c~:     124,   125,   202,   203,   204,   826,    -1,    -1,   113,   114,
parse.c~:     115,   116,   117,   118,   119,   120,   121,   122,    -1,   143,
parse.c~:     144,    -1,    -1,    69,    70,    71,    72,    73,    74,    75,
parse.c~:      -1,    -1,    78,    79,    -1,   139,    -1,   141,    84,    85,
parse.c~:     144,   145,    -1,   147,    -1,   149,    -1,    -1,   869,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   880,
parse.c~:      -1,   261,    -1,    -1,    -1,    -1,    -1,   113,   114,   115,
parse.c~:     116,   117,   118,   119,   120,   121,   122,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,   912,    -1,   914,    -1,    -1,    -1,    -1,    -1,   920,
parse.c~:      -1,   922,    -1,    -1,   304,    -1,    -1,   307,   308,   309,
parse.c~:     330,   331,   332,    -1,    -1,    -1,    -1,     0,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,     8,     9,    10,    -1,    -1,
parse.c~:      13,    14,    15,    -1,    -1,    18,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    27,    28,    29,    30,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    38,    39,    -1,    41,    42,
parse.c~:      43,    44,    45,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,   392,   393,   394,    -1,    -1,    -1,    -1,    -1,
parse.c~:     400,   401,   402,    -1,    -1,    -1,    69,    70,    71,    72,
parse.c~:      -1,    84,    85,    86,   424,    88,    89,    -1,    -1,    -1,
parse.c~:      -1,    -1,    95,   433,    -1,    -1,   436,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,   108,   446,   110,   111,   112,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,   138,   139,   140,   141,   142,
parse.c~:      -1,    -1,   145,   146,   147,    -1,   149,    -1,    -1,   489,
parse.c~:     490,    -1,     0,     1,    -1,     3,     4,     5,     6,     7,
parse.c~:      -1,   501,    -1,    11,    12,    -1,    -1,   507,    16,    17,
parse.c~:      -1,    19,    20,    21,    22,    23,    24,    25,    -1,    -1,
parse.c~:      -1,    -1,    -1,    31,    32,    33,    34,    35,    36,    37,
parse.c~:      -1,    -1,    40,    -1,    -1,    -1,    -1,    -1,    46,    47,
parse.c~:      58,    -1,    60,    61,    -1,    63,    64,    65,    -1,    67,
parse.c~:      68,    -1,    -1,   563,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    87,
parse.c~:      -1,    -1,    90,    91,    -1,    93,    94,    -1,    96,    -1,
parse.c~:      98,    99,   100,   101,   102,   103,   104,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,   603,    69,    70,    71,    72,    73,    74,
parse.c~:      75,    -1,    -1,    78,    79,   123,   124,   125,    -1,    84,
parse.c~:      85,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   629,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,   636,    -1,    -1,   147,
parse.c~:      -1,   149,    -1,    -1,    -1,    -1,    -1,    -1,   113,   114,
parse.c~:     115,   116,   117,   118,   119,   120,   121,   122,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:     670,    -1,    -1,   673,   674,    -1,    -1,   677,    -1,     0,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,     8,     9,    10,
parse.c~:     690,    -1,    13,    14,    15,    -1,    -1,    18,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    26,    -1,    28,    29,    30,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    38,    39,    -1,
parse.c~:      41,    42,    43,    44,    45,    -1,    -1,    -1,    -1,    -1,
parse.c~:     730,    -1,    -1,    -1,    -1,   735,    -1,   737,   738,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    69,    70,
parse.c~:      81,    -1,    -1,    84,    85,    86,    -1,    88,    89,    -1,
parse.c~:      -1,    -1,    -1,    -1,    95,    -1,    -1,    -1,   778,    -1,
parse.c~:      -1,    -1,   782,    -1,    -1,    -1,    -1,   108,    -1,   110,
parse.c~:     121,   122,    -1,    -1,    -1,    -1,    -1,    -1,   808,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   139,   140,
parse.c~:     141,   142,    -1,    -1,   145,   146,   147,   827,   149,     0,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,     8,     9,    10,
parse.c~:      -1,    -1,    13,    14,    15,    -1,    -1,    18,    -1,    -1,
parse.c~:      -1,   851,    -1,    -1,    -1,    26,    -1,    28,    29,    30,
parse.c~:      -1,    -1,    -1,    -1,    -1,   865,    -1,    38,    39,    -1,
parse.c~:      41,    42,    43,    44,    45,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    69,    70,    71,    72,    73,    74,    75,    76,    77,
parse.c~:      78,    79,    80,    81,    -1,    -1,    84,    85,    69,    70,
parse.c~:      81,    -1,    -1,    84,    85,    86,    -1,    88,    89,    -1,
parse.c~:      -1,    -1,    -1,   111,    95,   113,   114,   115,   116,   117,
parse.c~:     118,   119,   120,   121,   122,    -1,    -1,   108,    -1,   110,
parse.c~:     121,   122,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,   149,    -1,    -1,    -1,    -1,    -1,    -1,   139,   140,
parse.c~:     141,   142,     0,    -1,   145,   146,   147,    -1,   149,    -1,
parse.c~:       8,     9,    10,    -1,    -1,    13,    14,    15,    -1,    -1,
parse.c~:      18,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    27,
parse.c~:      28,    29,    30,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      38,    39,    -1,    41,    42,    43,    44,    45,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    69,    70,    71,    72,    73,    74,
parse.c~:      75,    76,    77,    78,    79,    80,    81,    -1,    -1,    84,
parse.c~:      78,    79,    80,    81,    -1,    -1,    84,    85,    86,    -1,
parse.c~:      -1,    89,    -1,    -1,    -1,    -1,   111,    95,   113,   114,
parse.c~:     115,   116,   117,   118,   119,   120,   121,   122,    -1,    -1,
parse.c~:     108,    -1,    -1,   111,   112,   113,   114,   115,   116,   117,
parse.c~:     118,   119,   120,   121,   122,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:     138,   139,   140,   141,   142,     0,    -1,   145,   146,   147,
parse.c~:      -1,   149,    -1,     8,     9,    10,    -1,    -1,    13,    14,
parse.c~:      15,    -1,    -1,    18,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    27,    28,    29,    30,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    38,    39,    -1,    41,    42,    43,    44,
parse.c~:      45,    -1,    -1,    -1,    -1,    -1,    -1,    69,    70,    71,
parse.c~:      -1,    -1,    84,    85,    69,    70,    71,    72,    73,    74,
parse.c~:      75,    76,    77,    78,    79,    80,    81,    -1,    -1,    84,
parse.c~:      85,    86,    -1,    -1,    89,    -1,    -1,    -1,    -1,    -1,
parse.c~:     122,    -1,    -1,   108,    -1,    -1,   111,   112,   113,   114,
parse.c~:     115,   116,   117,   118,   119,   120,   121,   122,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,   138,   139,   140,   141,   142,     0,    -1,
parse.c~:     145,   146,   147,    -1,   149,    -1,     8,     9,    10,    -1,
parse.c~:      -1,    13,    14,    15,    -1,    -1,    18,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    28,    29,    30,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    38,    39,    -1,    41,
parse.c~:      42,    43,    44,    45,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    69,    70,    71,
parse.c~:      -1,    -1,    84,    85,    86,    -1,    88,    89,    -1,    -1,
parse.c~:      -1,    -1,    -1,    95,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,   108,    -1,   110,   111,
parse.c~:     122,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,   139,   140,   141,
parse.c~:     142,     0,    -1,   145,   146,   147,    -1,   149,    -1,     8,
parse.c~:       9,    10,    -1,    -1,    13,    14,    15,    -1,    -1,    18,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    27,    28,
parse.c~:      29,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    38,
parse.c~:      39,    -1,    41,    42,    43,    44,    45,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      79,    80,    81,    -1,    -1,    84,    85,    86,    -1,    -1,
parse.c~:      89,    -1,    -1,    -1,    -1,    -1,    95,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,   111,    -1,   113,   114,   115,   116,   117,   118,
parse.c~:     119,   120,   121,   122,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   138,
parse.c~:     139,   140,   141,   142,     0,   144,   145,   146,   147,    -1,
parse.c~:     149,    -1,     8,     9,    10,    -1,    -1,    13,    14,    15,
parse.c~:      -1,    -1,    18,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    28,    29,    30,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    38,    39,    -1,    41,    42,    43,    44,    45,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    69,    70,    71,    72,    73,    74,    75,
parse.c~:      76,    77,    78,    79,    80,    81,    -1,    -1,    84,    85,
parse.c~:      86,    -1,    -1,    89,    -1,    -1,    -1,    -1,    -1,    95,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,   108,    -1,    -1,   111,   112,   113,   114,   115,
parse.c~:     116,   117,   118,   119,   120,   121,   122,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,   139,   140,   141,   142,     0,    -1,   145,
parse.c~:     146,   147,    -1,   149,    -1,     8,     9,    10,    -1,    -1,
parse.c~:      13,    14,    15,    -1,    -1,    18,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    27,    28,    29,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    38,    39,    -1,    41,    42,
parse.c~:      43,    44,    45,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    69,    70,    71,    72,
parse.c~:      73,    74,    75,    76,    77,    78,    79,    80,    81,    -1,
parse.c~:      -1,    84,    85,    86,    -1,    -1,    89,    -1,    -1,    -1,
parse.c~:      -1,    -1,    95,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   111,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,   138,   139,   140,   141,   142,
parse.c~:       0,   144,   145,   146,   147,    -1,   149,    -1,     8,     9,
parse.c~:      10,    -1,    -1,    13,    14,    15,    -1,    -1,    18,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    28,    29,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    38,    39,
parse.c~:      -1,    41,    42,    43,    44,    45,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    69,
parse.c~:      80,    81,    -1,    -1,    84,    85,    86,    -1,    -1,    89,
parse.c~:      -1,    -1,    -1,    -1,    -1,    95,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,   111,    -1,   113,   114,   115,   116,   117,   118,   119,
parse.c~:     120,   121,   122,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   139,
parse.c~:     140,   141,   142,     0,   144,   145,   146,   147,    -1,   149,
parse.c~:      -1,     8,     9,    10,    -1,    -1,    -1,    14,    15,    -1,
parse.c~:      -1,    18,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      27,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    38,    39,    -1,    41,    42,    43,    44,    45,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    69,    70,    71,    72,    73,    74,    75,    76,
parse.c~:      77,    78,    79,    80,    81,    -1,    -1,    84,    85,    86,
parse.c~:       0,    88,    -1,    -1,    -1,    -1,    -1,    -1,     8,     9,
parse.c~:      10,    -1,    -1,    -1,    14,    15,    -1,    -1,    18,    -1,
parse.c~:      -1,    -1,    -1,   110,   111,    -1,   113,   114,   115,   116,
parse.c~:     117,   118,   119,   120,   121,   122,    -1,    -1,    38,    39,
parse.c~:      -1,    41,    42,    43,    44,    45,    -1,    -1,    -1,    -1,
parse.c~:      -1,   138,   139,   140,   141,   142,    -1,    -1,   145,    -1,
parse.c~:     147,    -1,   149,    -1,    -1,    -1,    -1,    -1,    -1,    69,
parse.c~:      80,    81,    -1,    -1,    84,    85,    86,    -1,    88,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:     110,   111,    -1,   113,   114,   115,   116,   117,   118,   119,
parse.c~:     120,   121,   122,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   139,
parse.c~:     140,   141,   142,    -1,    -1,   145,    -1,   147,     1,   149,
parse.c~:      -1,    -1,    15,    16,    17,    -1,    19,    20,    21,    22,
parse.c~:      23,    24,    25,    -1,    -1,    -1,    -1,    -1,    31,    32,
parse.c~:      33,    34,    35,    36,    37,    -1,    -1,    40,    -1,    -1,
parse.c~:      -1,    -1,    -1,    46,    47,    -1,    49,    50,    51,    52,
parse.c~:      53,    54,    55,    56,    57,    58,    -1,    60,    61,    -1,
parse.c~:      63,    64,    65,    -1,    67,    68,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    87,    -1,    -1,    90,    91,    -1,
parse.c~:      93,    94,    -1,    96,    -1,    98,    99,   100,   101,   102,
parse.c~:     103,   104,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:     123,   124,   125,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,   147,     1,   149,     3,     4,     5,
parse.c~:       6,     7,    -1,    -1,    10,    11,    12,    -1,    14,    15,
parse.c~:      16,    17,    -1,    19,    20,    21,    22,    23,    24,    25,
parse.c~:      -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,    35,
parse.c~:      36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,    -1,
parse.c~:      46,    47,    -1,    49,    50,    51,    52,    53,    54,    55,
parse.c~:      56,    57,    58,    -1,    60,    61,    -1,    63,    64,    65,
parse.c~:      -1,    67,    68,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,    -1,
parse.c~:      96,    -1,    98,    99,   100,   101,   102,   103,   104,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,   123,   124,   125,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,   147,     1,   149,     3,     4,     5,     6,     7,    -1,
parse.c~:      -1,    10,    11,    12,    -1,    -1,    15,    16,    17,    18,
parse.c~:      19,    20,    21,    22,    23,    24,    25,    -1,    -1,    -1,
parse.c~:      -1,    -1,    31,    32,    33,    34,    35,    36,    37,    -1,
parse.c~:      -1,    40,    -1,    -1,    -1,    -1,    -1,    46,    47,    -1,
parse.c~:      -1,    60,    61,    -1,    63,    64,    65,    -1,    67,    68,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,
parse.c~:      -1,    90,    91,    -1,    93,    94,    -1,    96,    -1,    98,
parse.c~:      99,   100,   101,   102,   103,   104,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,   123,   124,   125,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,     1,    -1,     3,     4,
parse.c~:       5,     6,     7,    -1,    -1,    -1,    11,    12,   147,    -1,
parse.c~:     149,    16,    17,    -1,    19,    20,    21,    22,    23,    24,
parse.c~:      25,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,
parse.c~:      35,    36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,
parse.c~:      -1,    46,    47,    48,    49,    50,    51,    52,    53,    54,
parse.c~:      55,    56,    57,    58,    -1,    60,    61,    -1,    63,    64,
parse.c~:      65,    -1,    67,    68,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,
parse.c~:      -1,    96,    -1,    98,    99,   100,   101,   102,   103,   104,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   123,   124,
parse.c~:     125,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,   139,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,   147,     1,   149,     3,     4,     5,     6,     7,
parse.c~:      -1,    -1,    10,    11,    12,    -1,    -1,    15,    16,    17,
parse.c~:      -1,    19,    20,    21,    22,    23,    24,    25,    -1,    -1,
parse.c~:      -1,    -1,    -1,    31,    32,    33,    34,    35,    36,    37,
parse.c~:      -1,    -1,    40,    -1,    -1,    -1,    -1,    -1,    46,    47,
parse.c~:      -1,    49,    50,    51,    52,    53,    54,    55,    56,    57,
parse.c~:      58,    -1,    60,    61,    -1,    63,    64,    65,    -1,    67,
parse.c~:      68,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    87,
parse.c~:      -1,    -1,    90,    91,    -1,    93,    94,    -1,    96,    -1,
parse.c~:      98,    99,   100,   101,   102,   103,   104,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,   123,   124,   125,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,     1,    -1,     3,
parse.c~:       4,     5,     6,     7,    -1,     9,    10,    11,    12,   147,
parse.c~:      -1,   149,    16,    17,    -1,    19,    20,    21,    22,    23,
parse.c~:      24,    25,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,
parse.c~:      34,    35,    36,    37,    -1,    -1,    40,    -1,    -1,    -1,
parse.c~:      -1,    -1,    46,    47,    -1,    49,    50,    51,    52,    53,
parse.c~:      54,    55,    56,    57,    58,    -1,    60,    61,    -1,    63,
parse.c~:      64,    65,    -1,    67,    68,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,
parse.c~:      94,    -1,    96,    -1,    98,    99,   100,   101,   102,   103,
parse.c~:     104,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   123,
parse.c~:     124,   125,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,     1,    -1,     3,     4,     5,     6,     7,    -1,    -1,
parse.c~:      -1,    11,    12,   147,    -1,   149,    16,    17,    -1,    19,
parse.c~:      20,    21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,
parse.c~:      -1,    31,    32,    33,    34,    35,    36,    37,    -1,    -1,
parse.c~:      40,    -1,    -1,    -1,    -1,    -1,    46,    47,    -1,    49,
parse.c~:      50,    51,    52,    53,    54,    55,    56,    57,    58,    -1,
parse.c~:      60,    61,    -1,    63,    64,    65,    -1,    67,    68,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,
parse.c~:      90,    91,    -1,    93,    94,    -1,    96,    -1,    98,    99,
parse.c~:     100,   101,   102,   103,   104,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,   123,   124,   125,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,   145,    -1,   147,     1,   149,
parse.c~:       3,     4,     5,     6,     7,    -1,    -1,    -1,    11,    12,
parse.c~:      -1,    -1,    -1,    16,    17,    -1,    19,    20,    21,    22,
parse.c~:      23,    24,    25,    -1,    -1,    -1,    -1,    -1,    31,    32,
parse.c~:      33,    34,    35,    36,    37,    -1,    -1,    40,    -1,    -1,
parse.c~:      -1,    -1,    -1,    46,    47,    -1,    49,    50,    51,    52,
parse.c~:      53,    54,    55,    56,    57,    58,    -1,    60,    61,    -1,
parse.c~:      63,    64,    65,    -1,    67,    68,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    87,    -1,    -1,    90,    91,    -1,
parse.c~:      93,    94,    -1,    96,    -1,    98,    99,   100,   101,   102,
parse.c~:     103,   104,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:     123,   124,   125,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,   145,    -1,   147,     1,   149,     3,     4,     5,
parse.c~:       6,     7,    -1,    -1,    -1,    11,    12,    -1,    -1,    -1,
parse.c~:      16,    17,    -1,    19,    20,    21,    22,    23,    24,    25,
parse.c~:      -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,    35,
parse.c~:      36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,    -1,
parse.c~:      46,    47,    -1,    49,    50,    51,    52,    53,    54,    55,
parse.c~:      56,    57,    58,    -1,    60,    61,    -1,    63,    64,    65,
parse.c~:      -1,    67,    68,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,    -1,
parse.c~:      96,    -1,    98,    99,   100,   101,   102,   103,   104,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,   123,   124,   125,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,   139,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,   147,     1,   149,     3,     4,     5,     6,     7,    -1,
parse.c~:      -1,    10,    11,    12,    -1,    -1,    -1,    16,    17,    -1,
parse.c~:      19,    20,    21,    22,    23,    24,    25,    -1,    -1,    -1,
parse.c~:      -1,    -1,    31,    32,    33,    34,    35,    36,    37,    -1,
parse.c~:      -1,    40,    -1,    -1,    -1,    -1,    -1,    46,    47,    -1,
parse.c~:      -1,    60,    61,    -1,    63,    64,    65,    -1,    67,    68,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,
parse.c~:      -1,    90,    91,    -1,    93,    94,    -1,    96,    -1,    98,
parse.c~:      99,   100,   101,   102,   103,   104,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,   123,   124,   125,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,     4,
parse.c~:       5,    -1,     7,    -1,    -1,    -1,    11,    12,   147,    -1,
parse.c~:     149,    16,    17,    -1,    19,    20,    21,    22,    23,    24,
parse.c~:      25,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,
parse.c~:      35,    36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    47,    -1,    -1,    50,    51,    52,    53,    54,
parse.c~:      55,    56,    57,    58,    59,    60,    61,    -1,    63,    64,
parse.c~:      65,    -1,    67,    68,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,
parse.c~:      -1,    96,    97,    98,    99,   100,   101,   102,   103,   104,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,     4,
parse.c~:       5,    -1,     7,    -1,    -1,    -1,    11,    12,   123,   124,
parse.c~:     125,    16,    17,    -1,    19,    20,    21,    22,    23,    24,
parse.c~:      25,    -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,
parse.c~:      35,    36,    37,    -1,   149,    40,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    47,    -1,    -1,    50,    51,    52,    53,    54,
parse.c~:      55,    56,    57,    58,    -1,    60,    61,    -1,    63,    64,
parse.c~:      65,    -1,    67,    68,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,
parse.c~:      -1,    -1,    -1,    98,    99,   100,   101,   102,   103,   104,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   123,   124,
parse.c~:     125,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,     3,     4,     5,    -1,     7,    -1,    -1,    -1,
parse.c~:      11,    12,   147,    -1,   149,    16,    17,    -1,    19,    20,
parse.c~:      21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,    -1,
parse.c~:      31,    32,    33,    34,    35,    36,    37,    -1,    -1,    40,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    47,    -1,    -1,    50,
parse.c~:      51,    52,    53,    54,    55,    56,    57,    58,    -1,    60,
parse.c~:      61,    -1,    63,    64,    65,    -1,    67,    68,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,
parse.c~:      91,    -1,    93,    94,    -1,    -1,    -1,    98,    99,   100,
parse.c~:     101,   102,   103,   104,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,     3,     4,     5,     6,     7,    -1,    -1,    -1,
parse.c~:      11,    12,   123,   124,   125,    16,    17,    -1,    19,    20,
parse.c~:      21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,    -1,
parse.c~:      31,    32,    33,    34,    35,    36,    37,    -1,   149,    40,
parse.c~:      -1,    -1,    -1,    -1,    -1,    46,    47,    48,    49,    50,
parse.c~:      51,    52,    53,    54,    55,    56,    57,    58,    -1,    60,
parse.c~:      61,    -1,    63,    64,    65,    -1,    67,    68,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,
parse.c~:      91,    -1,    93,    94,    -1,    96,    -1,    98,    99,   100,
parse.c~:     101,   102,   103,   104,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,   123,   124,   125,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,     3,     4,     5,     6,     7,    -1,    -1,    -1,    11,
parse.c~:      12,    -1,    -1,    -1,    16,    17,   147,    19,    20,    21,
parse.c~:      22,    23,    24,    25,    -1,    -1,    -1,    -1,    -1,    31,
parse.c~:      32,    33,    34,    35,    36,    37,    -1,    -1,    40,    -1,
parse.c~:      -1,    -1,    -1,    -1,    46,    47,    -1,    49,    50,    51,
parse.c~:      52,    53,    54,    55,    56,    57,    58,    -1,    60,    61,
parse.c~:      -1,    63,    64,    65,    -1,    67,    68,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,    91,
parse.c~:      -1,    93,    94,    -1,    96,    -1,    98,    99,   100,   101,
parse.c~:     102,   103,   104,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,   123,   124,   125,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,   147,     3,     4,     5,     6,
parse.c~:      27,    -1,    -1,    -1,    31,    32,    33,    34,    35,    36,
parse.c~:      37,    38,    39,    40,    -1,    -1,    -1,    -1,    -1,    46,
parse.c~:      57,    58,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      67,    68,    69,    70,    71,    72,    73,    74,    75,    -1,
parse.c~:      -1,    78,    79,    -1,    -1,    82,    83,    84,    85,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    96,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,   113,   114,   115,   116,
parse.c~:     117,   118,   119,   120,   121,   122,    -1,   124,   125,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,   143,   144,     3,     4,
parse.c~:      25,    26,    27,    -1,    -1,    -1,    31,    32,    33,    34,
parse.c~:      35,    36,    37,    38,    39,    40,    -1,    -1,    -1,    -1,
parse.c~:      -1,    46,    47,    48,    49,    50,    51,    52,    53,    54,
parse.c~:      55,    56,    57,    58,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    67,    68,    69,    70,    71,    72,    73,    74,
parse.c~:      75,    -1,    -1,    78,    79,    -1,    -1,    82,    83,    84,
parse.c~:      85,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    96,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   113,   114,
parse.c~:     115,   116,   117,   118,   119,   120,   121,   122,    -1,   124,
parse.c~:     125,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   143,     3,
parse.c~:      24,    25,    26,    27,    -1,    -1,    -1,    31,    32,    33,
parse.c~:      34,    35,    36,    37,    38,    39,    40,    -1,    -1,    -1,
parse.c~:      -1,    -1,    46,    47,    48,    49,    50,    51,    52,    53,
parse.c~:      54,    55,    -1,    57,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    67,    68,    69,    70,    71,    72,    73,
parse.c~:      74,    75,    -1,    -1,    78,    79,    -1,    -1,    82,    83,
parse.c~:      84,    85,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    96,    -1,    -1,    99,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   113,
parse.c~:     114,   115,   116,   117,   118,   119,   120,   121,   122,    -1,
parse.c~:     124,   125,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   143,
parse.c~:      23,    24,    25,    26,    27,    -1,    -1,    -1,    31,    32,
parse.c~:      33,    34,    35,    36,    37,    38,    39,    40,    -1,    -1,
parse.c~:      -1,    -1,    -1,    46,    47,    48,    49,    50,    51,    52,
parse.c~:      53,    54,    -1,    -1,    57,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    67,    68,    69,    70,    71,    72,
parse.c~:      73,    74,    75,    -1,    -1,    78,    79,    -1,    -1,    82,
parse.c~:      83,    84,    85,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    96,    -1,    -1,    99,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,   124,   125,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      22,    23,    24,    25,    26,    27,    -1,    -1,    -1,    31,
parse.c~:      32,    33,    34,    35,    36,    37,    38,    39,    40,    -1,
parse.c~:      -1,    -1,    -1,    -1,    46,    47,    48,    49,    50,    51,
parse.c~:      52,    53,    54,    -1,    -1,    57,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    67,    68,    69,    70,    71,
parse.c~:      72,    73,    74,    75,    -1,    -1,    78,    79,    -1,    -1,
parse.c~:      82,    83,    84,    85,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    96,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,   113,   114,   115,   116,   117,   118,   119,   120,   121,
parse.c~:     122,    -1,   124,   125,    -1,    -1,     3,     4,     5,    -1,
parse.c~:       7,    -1,    -1,    -1,    11,    12,    -1,    -1,    -1,    16,
parse.c~:      17,   143,    19,    20,    21,    22,    23,    24,    25,    -1,
parse.c~:      -1,    -1,    -1,    -1,    31,    32,    33,    34,    35,    36,
parse.c~:      37,    -1,    -1,    40,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      47,    -1,    -1,    50,    51,    52,    53,    54,    55,    56,
parse.c~:      57,    58,    -1,    60,    61,    -1,    63,    64,    65,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      87,    -1,    -1,    90,    91,    -1,    93,    94,    -1,    -1,
parse.c~:      -1,    98,    99,   100,   101,   102,   103,   104,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,
parse.c~:       4,     5,    -1,     7,    -1,    -1,   123,    11,    12,    -1,
parse.c~:      -1,    -1,    16,    17,    -1,    19,    20,    21,    22,    23,
parse.c~:      24,    25,    -1,    -1,    -1,   142,    -1,    31,    32,    33,
parse.c~:      34,    35,    36,    37,    -1,    -1,    40,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    47,    -1,    -1,    50,    51,    52,    53,
parse.c~:      54,    55,    56,    57,    58,    -1,    60,    61,    -1,    63,
parse.c~:      64,    65,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    87,    -1,    -1,    90,    91,    -1,    93,
parse.c~:      94,    -1,    -1,    -1,    98,    99,   100,   101,   102,   103,
parse.c~:     104,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,     3,     4,     5,     6,     7,    -1,    -1,   123,
parse.c~:      11,    12,    -1,    -1,    -1,    16,    17,    -1,    19,    20,
parse.c~:      21,    22,    23,    24,    25,    -1,    -1,    -1,   142,    -1,
parse.c~:      31,    32,    33,    34,    35,    36,    37,    -1,    -1,    40,
parse.c~:      -1,    -1,    -1,    -1,    -1,    46,    47,    48,    49,    50,
parse.c~:      51,    52,    53,    54,    55,    56,    57,    58,    -1,    60,
parse.c~:      61,    -1,    63,    64,    65,    -1,    67,    68,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,
parse.c~:      91,    -1,    93,    94,    -1,    96,    -1,    98,    99,   100,
parse.c~:     101,   102,   103,   104,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,     3,     4,     5,     6,     7,    -1,    -1,    -1,
parse.c~:      11,    12,   123,   124,   125,    16,    17,    -1,    19,    20,
parse.c~:      21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,    -1,
parse.c~:      31,    32,    33,    34,    35,    36,    37,    -1,    -1,    40,
parse.c~:      -1,    -1,    -1,    -1,    -1,    46,    47,    -1,    49,    50,
parse.c~:      51,    52,    53,    54,    55,    56,    57,    58,    -1,    60,
parse.c~:      61,    -1,    63,    64,    65,    -1,    67,    68,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,
parse.c~:      91,    -1,    93,    94,    -1,    96,    -1,    98,    99,   100,
parse.c~:     101,   102,   103,   104,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,     3,     4,     5,    -1,     7,    -1,    -1,    -1,
parse.c~:      11,    12,   123,   124,   125,    16,    17,    -1,    19,    20,
parse.c~:      21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,    -1,
parse.c~:      31,    32,    33,    34,    35,    36,    37,    -1,    -1,    40,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    47,    -1,    -1,    50,
parse.c~:      61,    -1,    63,    64,    65,    -1,    67,    68,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,
parse.c~:      91,    -1,    93,    94,    -1,    96,    97,    98,    99,   100,
parse.c~:     101,   102,   103,   104,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,     3,     4,     5,    -1,     7,    -1,    -1,    -1,
parse.c~:      11,    12,   123,   124,   125,    16,    17,    -1,    19,    20,
parse.c~:      21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,    -1,
parse.c~:      31,    32,    33,    34,    35,    36,    37,    -1,    -1,    40,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    47,    -1,    -1,    50,
parse.c~:      61,    -1,    63,    64,    65,    -1,    67,    68,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,
parse.c~:      91,    -1,    93,    94,    -1,    96,    97,    98,    99,   100,
parse.c~:     101,   102,   103,   104,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,     3,     4,     5,    -1,     7,    -1,    -1,    -1,
parse.c~:      11,    12,   123,   124,   125,    16,    17,    -1,    19,    20,
parse.c~:      21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,    -1,
parse.c~:      31,    32,    33,    34,    35,    36,    37,    -1,    -1,    40,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    47,    -1,    -1,    50,
parse.c~:      61,    -1,    63,    64,    65,    -1,    67,    68,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,
parse.c~:      91,    -1,    93,    94,    -1,    96,    -1,    98,    99,   100,
parse.c~:     101,   102,   103,   104,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,     3,     4,     5,    -1,     7,    -1,    -1,    -1,
parse.c~:      11,    12,   123,   124,   125,    16,    17,    -1,    19,    20,
parse.c~:      21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,    -1,
parse.c~:      31,    32,    33,    34,    35,    36,    37,    -1,    -1,    40,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    47,    -1,    -1,    50,
parse.c~:      61,    -1,    63,    64,    65,    -1,    67,    68,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,
parse.c~:      91,    -1,    93,    94,    -1,    -1,    97,    98,    99,   100,
parse.c~:     101,   102,   103,   104,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,     3,     4,     5,    -1,     7,    -1,    -1,    -1,
parse.c~:      11,    12,   123,   124,   125,    16,    17,    -1,    19,    20,
parse.c~:      21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,    -1,
parse.c~:      31,    32,    33,    34,    35,    36,    37,    -1,    -1,    40,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    47,    -1,    -1,    50,
parse.c~:      61,    -1,    63,    64,    65,    -1,    67,    68,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,
parse.c~:      91,    -1,    93,    94,    -1,    96,    -1,    98,    99,   100,
parse.c~:     101,   102,   103,   104,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,     3,     4,     5,    -1,     7,    -1,    -1,    -1,
parse.c~:      11,    12,   123,   124,   125,    16,    17,    -1,    19,    20,
parse.c~:      21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,    -1,
parse.c~:      31,    32,    33,    34,    35,    36,    37,    -1,    -1,    40,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    47,    -1,    -1,    50,
parse.c~:      61,    -1,    63,    64,    65,    -1,    67,    68,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,
parse.c~:      91,    -1,    93,    94,    -1,    -1,    -1,    98,    99,   100,
parse.c~:     101,   102,   103,   104,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,     3,     4,     5,    -1,     7,    -1,    -1,    -1,
parse.c~:      11,    12,   123,   124,   125,    16,    17,    -1,    19,    20,
parse.c~:      21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,    -1,
parse.c~:      31,    32,    33,    34,    35,    36,    37,    -1,    -1,    40,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    47,    -1,    -1,    50,
parse.c~:      51,    52,    53,    54,    55,    56,    57,    58,    -1,    60,
parse.c~:      61,    -1,    63,    64,    65,    -1,    67,    68,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,
parse.c~:      91,    -1,    93,    94,    -1,    96,    -1,    98,    99,   100,
parse.c~:     101,   102,   103,   104,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,     3,     4,     5,    -1,     7,    -1,    -1,    -1,
parse.c~:      11,    12,   123,   124,   125,    16,    17,    -1,    19,    20,
parse.c~:      21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,    -1,
parse.c~:      31,    32,    33,    34,    35,    36,    37,    -1,    -1,    40,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    47,    -1,    -1,    50,
parse.c~:      51,    52,    53,    54,    55,    56,    57,    58,    -1,    60,
parse.c~:      61,    -1,    63,    64,    65,    -1,    67,    68,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,
parse.c~:      91,    -1,    93,    94,    -1,    96,    -1,    98,    99,   100,
parse.c~:     101,   102,   103,   104,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,     3,     4,     5,    -1,     7,    -1,    -1,    -1,
parse.c~:      11,    12,   123,   124,   125,    16,    17,    -1,    19,    20,
parse.c~:      21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,    -1,
parse.c~:      31,    32,    33,    34,    35,    36,    37,    -1,    -1,    40,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    47,    -1,    -1,    50,
parse.c~:      51,    52,    53,    54,    55,    56,    57,    58,    -1,    60,
parse.c~:      61,    -1,    63,    64,    65,    -1,    67,    68,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,
parse.c~:      91,    -1,    93,    94,    -1,    96,    -1,    98,    99,   100,
parse.c~:     101,   102,   103,   104,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,     3,     4,     5,    -1,     7,    -1,    -1,    -1,
parse.c~:      11,    12,   123,   124,   125,    16,    17,    -1,    19,    20,
parse.c~:      21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,    -1,
parse.c~:      31,    32,    33,    34,    35,    36,    37,    -1,    -1,    40,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    47,    -1,    -1,    50,
parse.c~:      51,    52,    53,    54,    55,    56,    57,    58,    -1,    60,
parse.c~:      61,    -1,    63,    64,    65,    -1,    67,    68,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,
parse.c~:      91,    -1,    93,    94,    -1,    96,    -1,    98,    99,   100,
parse.c~:     101,   102,   103,   104,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,     3,     4,     5,    -1,     7,    -1,    -1,    -1,
parse.c~:      11,    12,   123,   124,   125,    16,    17,    -1,    19,    20,
parse.c~:      21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,    -1,
parse.c~:      31,    32,    33,    34,    35,    36,    37,    -1,    -1,    40,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    47,    -1,    -1,    50,
parse.c~:      51,    52,    53,    54,    55,    56,    57,    58,    -1,    60,
parse.c~:      61,    -1,    63,    64,    65,    -1,    67,    68,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,
parse.c~:      91,    -1,    93,    94,    -1,    96,    -1,    98,    99,   100,
parse.c~:     101,   102,   103,   104,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,     3,     4,     5,    -1,     7,    -1,    -1,    -1,
parse.c~:      11,    12,   123,   124,   125,    16,    17,    -1,    19,    20,
parse.c~:      21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,    -1,
parse.c~:      31,    32,    33,    34,    35,    36,    37,    -1,    -1,    40,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    47,    -1,    -1,    50,
parse.c~:      51,    52,    53,    54,    55,    56,    57,    58,    -1,    60,
parse.c~:      61,    -1,    63,    64,    65,    -1,    67,    68,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,
parse.c~:      91,    -1,    93,    94,    -1,    -1,    -1,    98,    99,   100,
parse.c~:     101,   102,   103,   104,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,     3,     4,     5,    -1,     7,    -1,    -1,    -1,
parse.c~:      11,    12,   123,   124,   125,    16,    17,    -1,    19,    20,
parse.c~:      21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,    -1,
parse.c~:      31,    32,    33,    34,    35,    36,    37,    -1,    -1,    40,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    47,    -1,    -1,    50,
parse.c~:      51,    52,    53,    54,    55,    56,    57,    58,    -1,    60,
parse.c~:      61,    -1,    63,    64,    65,    -1,    67,    68,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,
parse.c~:      91,    -1,    93,    94,    -1,    -1,    -1,    98,    99,   100,
parse.c~:     101,   102,   103,   104,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,     3,     4,     5,    -1,     7,    -1,    -1,    -1,
parse.c~:      11,    12,   123,   124,   125,    16,    17,    -1,    19,    20,
parse.c~:      21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,    -1,
parse.c~:      31,    32,    33,    34,    35,    36,    37,    -1,    -1,    40,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    47,    -1,    -1,    50,
parse.c~:      51,    52,    53,    54,    55,    56,    57,    58,    -1,    60,
parse.c~:      61,    -1,    63,    64,    65,    -1,    67,    68,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,
parse.c~:      91,    -1,    93,    94,    -1,    -1,    -1,    98,    99,   100,
parse.c~:     101,   102,   103,   104,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,     3,     4,     5,    -1,     7,    -1,    -1,    -1,
parse.c~:      11,    12,   123,   124,   125,    16,    17,    -1,    19,    20,
parse.c~:      21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,    -1,
parse.c~:      31,    32,    33,    34,    35,    36,    37,    -1,    -1,    40,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    47,    -1,    -1,    50,
parse.c~:      51,    52,    53,    54,    55,    56,    57,    58,    -1,    60,
parse.c~:      61,    -1,    63,    64,    65,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,
parse.c~:      91,    -1,    93,    94,    -1,    96,    -1,    98,    99,   100,
parse.c~:     101,   102,   103,   104,    -1,    -1,    -1,     3,     4,     5,
parse.c~:      -1,     7,    -1,    -1,    -1,    11,    12,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,    35,
parse.c~:      36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    47,    -1,    -1,    50,    51,    52,    53,    54,    55,
parse.c~:      56,    57,    58,    -1,    60,    61,    -1,    63,    64,    65,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,    -1,
parse.c~:      96,    -1,    98,    99,   100,   101,   102,   103,   104,    -1,
parse.c~:      -1,    -1,     3,     4,     5,    -1,     7,    -1,    -1,    -1,
parse.c~:      11,    12,    -1,    -1,    -1,    16,    17,   123,    19,    20,
parse.c~:      21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,    -1,
parse.c~:      31,    32,    33,    34,    35,    36,    37,    -1,    -1,    40,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    47,    -1,    -1,    50,
parse.c~:      51,    52,    53,    54,    55,    56,    57,    58,    -1,    60,
parse.c~:      61,    -1,    63,    64,    65,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    84,    -1,    -1,    87,    -1,    -1,    90,
parse.c~:      91,    -1,    93,    94,    -1,    -1,    -1,    98,    99,   100,
parse.c~:     101,   102,   103,   104,    -1,    -1,    -1,     3,     4,     5,
parse.c~:      -1,     7,    -1,    -1,    -1,    11,    12,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,    35,
parse.c~:      36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    47,    -1,    -1,    50,    51,    52,    53,    54,    55,
parse.c~:      56,    57,    58,    -1,    60,    61,    -1,    63,    64,    65,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,    -1,
parse.c~:      -1,    -1,    98,    99,   100,   101,   102,   103,   104,    -1,
parse.c~:      -1,    -1,     3,     4,     5,    -1,     7,    -1,    -1,    -1,
parse.c~:      11,    12,    -1,    -1,    -1,    16,    17,   123,    19,    20,
parse.c~:      21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,    -1,
parse.c~:      31,    32,    33,    34,    35,    36,    37,    -1,    -1,    40,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    47,    -1,    -1,    50,
parse.c~:      51,    52,    53,    54,    55,    56,    57,    58,    -1,    60,
parse.c~:      61,    -1,    63,    64,    65,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,
parse.c~:      91,    -1,    93,    94,    -1,    -1,    -1,    98,    99,   100,
parse.c~:     101,   102,   103,   104,    -1,    -1,    -1,     3,     4,     5,
parse.c~:      -1,     7,    -1,    -1,    -1,    11,    12,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    31,    32,    33,    34,    35,
parse.c~:      36,    37,    -1,    -1,    40,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    47,    -1,    -1,    50,    51,    52,    53,    54,    55,
parse.c~:      56,    57,    58,    -1,    60,    61,    -1,    63,    64,    65,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    87,    -1,    -1,    90,    91,    -1,    93,    94,    -1,
parse.c~:      -1,    -1,    98,    99,   100,   101,   102,   103,   104,    -1,
parse.c~:      -1,    -1,     3,     4,     5,    -1,     7,    -1,    -1,    -1,
parse.c~:      11,    12,    -1,    -1,    -1,    16,    17,   123,    19,    20,
parse.c~:      21,    22,    23,    24,    25,    -1,    -1,    -1,    -1,    -1,
parse.c~:      31,    32,    33,    34,    35,    36,    37,    -1,    -1,    40,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    47,    -1,    -1,    50,
parse.c~:      51,    52,    53,    54,    55,    56,    57,    58,    -1,    60,
parse.c~:      61,    -1,    63,    64,    65,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    87,    -1,    -1,    90,
parse.c~:      91,    -1,    93,    94,    -1,    -1,    -1,    98,    99,   100,
parse.c~:     101,   102,   103,   104,    -1,    -1,    -1,    -1,    -1,    53,
parse.c~:      54,    -1,    -1,    57,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,   123,    67,    68,    69,    70,    71,    72,    73,
parse.c~:      74,    75,    -1,    -1,    78,    79,    -1,    -1,    82,    83,
parse.c~:      84,    85,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    96,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   113,
parse.c~:     114,   115,   116,   117,   118,   119,   120,   121,   122,    -1,
parse.c~:     124,   125,    -1,    -1,    -1,    -1,    -1,    53,    54,    -1,
parse.c~:      -1,    57,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   143,
parse.c~:      -1,    -1,    78,    79,    -1,    -1,    82,    83,    84,    85,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      96,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,   113,   114,   115,
parse.c~:     116,   117,   118,   119,   120,   121,   122,    -1,   124,   125,
parse.c~:      -1,    -1,    -1,    -1,    -1,    53,    54,    -1,    -1,    57,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,   143,   144,    67,
parse.c~:      68,    69,    70,    71,    72,    73,    74,    75,    -1,    -1,
parse.c~:      78,    79,    -1,    -1,    82,    83,    84,    85,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    96,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,   113,   114,   115,   116,   117,
parse.c~:     118,   119,   120,   121,   122,    -1,   124,   125,    -1,    -1,
parse.c~:      -1,    -1,    -1,    53,    54,    -1,    -1,    57,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,   143,   144,    67,    68,    69,
parse.c~:      70,    71,    72,    73,    74,    75,    -1,    -1,    78,    79,
parse.c~:      -1,    -1,    82,    83,    84,    85,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    96,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,   113,   114,   115,   116,   117,   118,   119,
parse.c~:     120,   121,   122,    -1,   124,   125,    -1,    -1,    -1,    -1,
parse.c~:      -1,    53,    54,    -1,    -1,    57,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,   143,   144,    67,    68,    69,    70,    71,
parse.c~:      72,    73,    74,    75,    -1,    -1,    78,    79,    -1,    -1,
parse.c~:      82,    83,    84,    85,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    96,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,   113,   114,   115,   116,   117,   118,   119,   120,   121,
parse.c~:     122,    -1,   124,   125,    -1,    -1,    -1,    -1,    -1,    53,
parse.c~:      54,    -1,    -1,    57,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,   143,   144,    67,    68,    69,    70,    71,    72,    73,
parse.c~:      74,    75,    -1,    -1,    78,    79,    -1,    -1,    82,    83,
parse.c~:      84,    85,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    96,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   113,
parse.c~:     114,   115,   116,   117,   118,   119,   120,   121,   122,    -1,
parse.c~:     124,   125,    -1,    -1,    -1,    -1,    -1,    53,    54,    -1,
parse.c~:      -1,    57,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   143,
parse.c~:      -1,    -1,    78,    79,    -1,    -1,    82,    83,    84,    85,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      96,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,   113,   114,   115,
parse.c~:     116,   117,   118,   119,   120,   121,   122,    -1,   124,   125,
parse.c~:      -1,    -1,    -1,    -1,    -1,    53,    54,    -1,    -1,    57,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,   143,   144,    67,
parse.c~:      68,    69,    70,    71,    72,    73,    74,    75,    -1,    -1,
parse.c~:      78,    79,    -1,    -1,    82,    83,    84,    85,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    96,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,   113,   114,   115,   116,   117,
parse.c~:     118,   119,   120,   121,   122,    -1,   124,   125,    -1,    -1,
parse.c~:      -1,    -1,    -1,    53,    54,    -1,    -1,    57,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,   143,   144,    67,    68,    69,
parse.c~:      70,    71,    72,    73,    74,    75,    -1,    -1,    78,    79,
parse.c~:      -1,    -1,    82,    83,    84,    85,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    96,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,   113,   114,   115,   116,   117,   118,   119,
parse.c~:     120,   121,   122,    -1,   124,   125,    -1,    -1,    -1,    -1,
parse.c~:      -1,    53,    54,    -1,    -1,    57,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,   143,   144,    67,    68,    69,    70,    71,
parse.c~:      72,    73,    74,    75,    -1,    -1,    78,    79,    -1,    -1,
parse.c~:      82,    83,    84,    85,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    96,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,   113,   114,   115,   116,   117,   118,   119,   120,   121,
parse.c~:     122,    -1,   124,   125,    -1,    -1,    -1,    -1,    -1,    53,
parse.c~:      54,    -1,    -1,    57,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,   143,   144,    67,    68,    69,    70,    71,    72,    73,
parse.c~:      74,    75,    -1,    -1,    78,    79,    -1,    -1,    82,    83,
parse.c~:      84,    85,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    96,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   113,
parse.c~:     114,   115,   116,   117,   118,   119,   120,   121,   122,    -1,
parse.c~:     124,   125,    -1,    -1,    -1,    -1,    -1,    53,    54,    -1,
parse.c~:      -1,    57,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   143,
parse.c~:      -1,    -1,    78,    79,    -1,    -1,    82,    83,    84,    85,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      96,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,   113,   114,   115,
parse.c~:     116,   117,   118,   119,   120,   121,   122,    -1,   124,   125,
parse.c~:      -1,    -1,    -1,    -1,    -1,    53,    54,    -1,    -1,    57,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,   143,   144,    67,
parse.c~:      68,    69,    70,    71,    72,    73,    74,    75,    -1,    -1,
parse.c~:      78,    79,    -1,    -1,    82,    83,    84,    85,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    96,    -1,
parse.c~:      -1,    -1,    -1,    -1,    45,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,    -1,    -1,    -1,    -1,   113,   114,   115,   116,   117,
parse.c~:      81,    -1,    -1,    84,    85,   143,    -1,    -1,    -1,    69,
parse.c~:      80,    81,    -1,    -1,    84,    85,    -1,    -1,    -1,    -1,
parse.c~:     111,    -1,   113,   114,   115,   116,   117,   118,   119,   120,
parse.c~:     121,   122,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
parse.c~:      -1,   111,    -1,   113,   114,   115,   116,   117,   118,   119,
parse.c~:/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
parse.c~:   symbol of state STATE-NUM.  */
parse.c~:#define YYEMPTY		(-2)
parse.c~:/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
parse.c~:/* YY_LOCATION_PRINT -- Print the location on the stream.
parse.c~:     fprintf (File, "%d.%d-%d.%d",			\
parse.c~:/* YYLEX -- calling `yylex' with the right arguments.  */
parse.c~:/*--------------------------------.
parse.c~:`--------------------------------*/
parse.c~:/*--------------------------------.
parse.c~:`--------------------------------*/
parse.c~:/*------------------------------------------------------------------.
parse.c~:| yy_stack_print -- Print the state stack from its BOTTOM up to its |
parse.c~:`------------------------------------------------------------------*/
parse.c~:/*------------------------------------------------.
parse.c~:`------------------------------------------------*/
parse.c~:	     yyrule - 1, yylno);
parse.c~:		       &(yyvsp[(yyi + 1) - (yynrhs)])
parse.c~:/* YYINITDEPTH -- initial size of the parser's stacks.  */
parse.c~:/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
parse.c~:   if the built-in stack extension method is used).
parse.c~:   evaluated with infinite-precision integer arithmetic.  */
parse.c~:  return yyd - 1;
parse.c~:   heuristic is that double-quoting is unnecessary unless the string
parse.c~:   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
parse.c~:  return yystpcpy (yyres, yystr) - yyres;
parse.c~:		    + sizeof yyexpecting - 1
parse.c~:		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
parse.c~:		       * (sizeof yyor - 1))];
parse.c~:      /* Start YYX at -YYN if negative to avoid negative indexes in
parse.c~:      int yyxbegin = yyn < 0 ? -yyn : 0;
parse.c~:      int yychecklim = YYLAST - yyn + 1;
parse.c~:		yyformat[sizeof yyunexpected - 1] = '\0';
parse.c~:/*-----------------------------------------------.
parse.c~:`-----------------------------------------------*/
parse.c~:/* Prevent warnings from -Wmissing-prototypes.  */
parse.c~:/*----------.
parse.c~:`----------*/
parse.c~:  /* The look-ahead symbol.  */
parse.c~:/* The semantic value of the look-ahead symbol.  */
parse.c~:  /* Look-ahead token as an internal (translated) token number.  */
parse.c~:#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
parse.c~:/*------------------------------------------------------------.
parse.c~:| yynewstate -- Push a new state, which is found in yystate.  |
parse.c~:`------------------------------------------------------------*/
parse.c~:  if (yyss + yystacksize - 1 <= yyssp)
parse.c~:      YYSIZE_T yysize = yyssp - yyss + 1;
parse.c~:      yyssp = yyss + yysize - 1;
parse.c~:      yyvsp = yyvs + yysize - 1;
parse.c~:      if (yyss + yystacksize - 1 <= yyssp)
parse.c~:/*-----------.
parse.c~:`-----------*/
parse.c~:     look-ahead token if we need one and don't already have one.  */
parse.c~:  /* First try to decide what to do without reference to look-ahead token.  */
parse.c~:  /* Not known => get a look-ahead token if don't already have one.  */
parse.c~:  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
parse.c~:      yyn = -yyn;
parse.c~:    yyerrstatus--;
parse.c~:  /* Shift the look-ahead token.  */
parse.c~:/*-----------------------------------------------------------.
parse.c~:| yydefault -- do the default action for the current state.  |
parse.c~:`-----------------------------------------------------------*/
parse.c~:/*-----------------------------.
parse.c~:| yyreduce -- Do a reduction.  |
parse.c~:`-----------------------------*/
parse.c~:  yyval = yyvsp[1-yylen];
parse.c~:			if ((yyvsp[(2) - (2)].node) && !(yyvsp[(1) - (2)].num)) {
parse.c~:			    if (nd_type((yyvsp[(2) - (2)].node)) != NODE_BLOCK) void_expr((yyvsp[(2) - (2)].node));
parse.c~:				NODE *node = (yyvsp[(2) - (2)].node);
parse.c~:				while (node->nd_next) {
parse.c~:				    node = node->nd_next;
parse.c~:				void_expr(node->nd_head);
parse.c~:			ruby_eval_tree = NEW_SCOPE(0, block_append(ruby_eval_tree, (yyvsp[(2) - (2)].node)));
parse.c~:			parser->result = dispatch1(program, $$);
parse.c~:			void_stmts((yyvsp[(1) - (2)].node));
parse.c~:			(yyval.node) = (yyvsp[(1) - (2)].node);
parse.c~:			(yyval.node) = newline_node((yyvsp[(1) - (1)].node));
parse.c~:			(yyval.node) = block_append((yyvsp[(1) - (3)].node), newline_node((yyvsp[(3) - (3)].node)));
parse.c~:			(yyval.node) = remove_begin((yyvsp[(2) - (2)].node));
parse.c~:							    (yyvsp[(4) - (5)].node));
parse.c~:			(yyval.node) = (yyvsp[(1) - (4)].node);
parse.c~:			if ((yyvsp[(2) - (4)].node)) {
parse.c~:			    (yyval.node) = NEW_RESCUE((yyvsp[(1) - (4)].node), (yyvsp[(2) - (4)].node), (yyvsp[(3) - (4)].node));
parse.c~:			else if ((yyvsp[(3) - (4)].node)) {
parse.c~:			    (yyval.node) = block_append((yyval.node), (yyvsp[(3) - (4)].node));
parse.c~:			if ((yyvsp[(4) - (4)].node)) {
parse.c~:				(yyval.node) = NEW_ENSURE((yyval.node), (yyvsp[(4) - (4)].node));
parse.c~:				(yyval.node) = block_append((yyvsp[(4) - (4)].node), NEW_NIL());
parse.c~:			fixpos((yyval.node), (yyvsp[(1) - (4)].node));
parse.c~:			void_stmts((yyvsp[(1) - (2)].node));
parse.c~:			(yyval.node) = (yyvsp[(1) - (2)].node);
parse.c~:			(yyval.node) = newline_node((yyvsp[(1) - (1)].node));
parse.c~:			(yyval.node) = block_append((yyvsp[(1) - (3)].node), newline_node((yyvsp[(3) - (3)].node)));
parse.c~:			(yyval.node) = remove_begin((yyvsp[(2) - (2)].node));
parse.c~:			(yyval.node) = NEW_ALIAS((yyvsp[(2) - (4)].node), (yyvsp[(4) - (4)].node));
parse.c~:			(yyval.node) = NEW_VALIAS((yyvsp[(2) - (3)].id), (yyvsp[(3) - (3)].id));
parse.c~:			sprintf(buf, "$%c", (char)(yyvsp[(3) - (3)].node)->nd_nth);
parse.c~:			(yyval.node) = NEW_VALIAS((yyvsp[(2) - (3)].id), rb_intern(buf));
parse.c~:			(yyval.node) = (yyvsp[(2) - (2)].node);
parse.c~:			(yyval.node) = NEW_IF(cond((yyvsp[(3) - (3)].node)), remove_begin((yyvsp[(1) - (3)].node)), 0);
parse.c~:			fixpos((yyval.node), (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = NEW_UNLESS(cond((yyvsp[(3) - (3)].node)), remove_begin((yyvsp[(1) - (3)].node)), 0);
parse.c~:			fixpos((yyval.node), (yyvsp[(3) - (3)].node));
parse.c~:			if ((yyvsp[(1) - (3)].node) && nd_type((yyvsp[(1) - (3)].node)) == NODE_BEGIN) {
parse.c~:			    (yyval.node) = NEW_WHILE(cond((yyvsp[(3) - (3)].node)), (yyvsp[(1) - (3)].node)->nd_body, 0);
parse.c~:			    (yyval.node) = NEW_WHILE(cond((yyvsp[(3) - (3)].node)), (yyvsp[(1) - (3)].node), 1);
parse.c~:			if ((yyvsp[(1) - (3)].node) && nd_type((yyvsp[(1) - (3)].node)) == NODE_BEGIN) {
parse.c~:			    (yyval.node) = NEW_UNTIL(cond((yyvsp[(3) - (3)].node)), (yyvsp[(1) - (3)].node)->nd_body, 0);
parse.c~:			    (yyval.node) = NEW_UNTIL(cond((yyvsp[(3) - (3)].node)), (yyvsp[(1) - (3)].node), 1);
parse.c~:			NODE *resq = NEW_RESBODY(0, remove_begin((yyvsp[(3) - (3)].node)), 0);
parse.c~:			(yyval.node) = NEW_RESCUE(remove_begin((yyvsp[(1) - (3)].node)), resq, 0);
parse.c~:			    NODE_SCOPE, 0 /* tbl */, (yyvsp[(3) - (4)].node) /* body */, 0 /* args */));
parse.c~:			value_expr((yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = node_assign((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c~:			value_expr((yyvsp[(3) - (3)].node));
parse.c~:			(yyvsp[(1) - (3)].node)->nd_value = (yyvsp[(3) - (3)].node);
parse.c~:			(yyval.node) = (yyvsp[(1) - (3)].node);
parse.c~:			value_expr((yyvsp[(3) - (3)].node));
parse.c~:			if ((yyvsp[(1) - (3)].node)) {
parse.c~:			    ID vid = (yyvsp[(1) - (3)].node)->nd_vid;
parse.c~:			    if ((yyvsp[(2) - (3)].id) == tOROP) {
parse.c~:				(yyvsp[(1) - (3)].node)->nd_value = (yyvsp[(3) - (3)].node);
parse.c~:				(yyval.node) = NEW_OP_ASGN_OR(gettable(vid), (yyvsp[(1) - (3)].node));
parse.c~:				    (yyval.node)->nd_aid = vid;
parse.c~:			    else if ((yyvsp[(2) - (3)].id) == tANDOP) {
parse.c~:				(yyvsp[(1) - (3)].node)->nd_value = (yyvsp[(3) - (3)].node);
parse.c~:				(yyval.node) = NEW_OP_ASGN_AND(gettable(vid), (yyvsp[(1) - (3)].node));
parse.c~:				(yyval.node) = (yyvsp[(1) - (3)].node);
parse.c~:				(yyval.node)->nd_value = NEW_CALL(gettable(vid), (yyvsp[(2) - (3)].id), NEW_LIST((yyvsp[(3) - (3)].node)));
parse.c~:			value_expr((yyvsp[(6) - (6)].node));
parse.c~:			if (!(yyvsp[(3) - (6)].node)) (yyvsp[(3) - (6)].node) = NEW_ZARRAY();
parse.c~:			args = arg_concat((yyvsp[(6) - (6)].node), (yyvsp[(3) - (6)].node));
parse.c~:			if ((yyvsp[(5) - (6)].id) == tOROP) {
parse.c~:			    (yyvsp[(5) - (6)].id) = 0;
parse.c~:			else if ((yyvsp[(5) - (6)].id) == tANDOP) {
parse.c~:			    (yyvsp[(5) - (6)].id) = 1;
parse.c~:			(yyval.node) = NEW_OP_ASGN1((yyvsp[(1) - (6)].node), (yyvsp[(5) - (6)].id), args);
parse.c~:			fixpos((yyval.node), (yyvsp[(1) - (6)].node));
parse.c~:			value_expr((yyvsp[(5) - (5)].node));
parse.c~:			if ((yyvsp[(4) - (5)].id) == tOROP) {
parse.c~:			    (yyvsp[(4) - (5)].id) = 0;
parse.c~:			else if ((yyvsp[(4) - (5)].id) == tANDOP) {
parse.c~:			    (yyvsp[(4) - (5)].id) = 1;
parse.c~:			(yyval.node) = NEW_OP_ASGN2((yyvsp[(1) - (5)].node), (yyvsp[(3) - (5)].id), (yyvsp[(4) - (5)].id), (yyvsp[(5) - (5)].node));
parse.c~:			fixpos((yyval.node), (yyvsp[(1) - (5)].node));
parse.c~:			value_expr((yyvsp[(5) - (5)].node));
parse.c~:			if ((yyvsp[(4) - (5)].id) == tOROP) {
parse.c~:			    (yyvsp[(4) - (5)].id) = 0;
parse.c~:			else if ((yyvsp[(4) - (5)].id) == tANDOP) {
parse.c~:			    (yyvsp[(4) - (5)].id) = 1;
parse.c~:			(yyval.node) = NEW_OP_ASGN2((yyvsp[(1) - (5)].node), (yyvsp[(3) - (5)].id), (yyvsp[(4) - (5)].id), (yyvsp[(5) - (5)].node));
parse.c~:			fixpos((yyval.node), (yyvsp[(1) - (5)].node));
parse.c~:			value_expr((yyvsp[(5) - (5)].node));
parse.c~:			if ((yyvsp[(4) - (5)].id) == tOROP) {
parse.c~:			    (yyvsp[(4) - (5)].id) = 0;
parse.c~:			else if ((yyvsp[(4) - (5)].id) == tANDOP) {
parse.c~:			    (yyvsp[(4) - (5)].id) = 1;
parse.c~:			(yyval.node) = NEW_OP_ASGN2((yyvsp[(1) - (5)].node), (yyvsp[(3) - (5)].id), (yyvsp[(4) - (5)].id), (yyvsp[(5) - (5)].node));
parse.c~:			fixpos((yyval.node), (yyvsp[(1) - (5)].node));
parse.c~:			rb_backref_error((yyvsp[(1) - (3)].node));
parse.c~:			value_expr((yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = node_assign((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c~:			(yyvsp[(1) - (3)].node)->nd_value = (yyvsp[(3) - (3)].node);
parse.c~:			(yyval.node) = (yyvsp[(1) - (3)].node);
parse.c~:			(yyvsp[(1) - (3)].node)->nd_value = (yyvsp[(3) - (3)].node);
parse.c~:			(yyval.node) = (yyvsp[(1) - (3)].node);
parse.c~:			(yyval.node) = logop(NODE_AND, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = logop(NODE_OR, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = call_uni_op(cond((yyvsp[(3) - (3)].node)), '!');
parse.c~:			(yyval.node) = call_uni_op(cond((yyvsp[(2) - (2)].node)), '!');
parse.c~:			value_expr((yyvsp[(1) - (1)].node));
parse.c~:			(yyval.node) = (yyvsp[(1) - (1)].node);
parse.c~:			(yyval.node) = NEW_RETURN(ret_args((yyvsp[(2) - (2)].node)));
parse.c~:			(yyval.node) = NEW_BREAK(ret_args((yyvsp[(2) - (2)].node)));
parse.c~:			(yyval.node) = NEW_NEXT(ret_args((yyvsp[(2) - (2)].node)));
parse.c~:			(yyval.node) = NEW_CALL((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].id), (yyvsp[(4) - (4)].node));
parse.c~:			(yyval.node) = NEW_CALL((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].id), (yyvsp[(4) - (4)].node));
parse.c~:			(yyval.node) = NEW_ITER((yyvsp[(3) - (5)].node),(yyvsp[(4) - (5)].node));
parse.c~:			nd_set_line((yyval.node), (yyvsp[(2) - (5)].num));
parse.c~:			(yyval.node) = NEW_FCALL((yyvsp[(1) - (2)].id), (yyvsp[(2) - (2)].node));
parse.c~:			fixpos((yyval.node), (yyvsp[(2) - (2)].node));
parse.c~:			block_dup_check((yyvsp[(2) - (3)].node),(yyvsp[(3) - (3)].node));
parse.c~:		        (yyvsp[(3) - (3)].node)->nd_iter = NEW_FCALL((yyvsp[(1) - (3)].id), (yyvsp[(2) - (3)].node));
parse.c~:			(yyval.node) = (yyvsp[(3) - (3)].node);
parse.c~:			fixpos((yyval.node), (yyvsp[(2) - (3)].node));
parse.c~:			(yyval.node) = NEW_CALL((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].id), (yyvsp[(4) - (4)].node));
parse.c~:			fixpos((yyval.node), (yyvsp[(1) - (4)].node));
parse.c~:			block_dup_check((yyvsp[(4) - (5)].node),(yyvsp[(5) - (5)].node));
parse.c~:		        (yyvsp[(5) - (5)].node)->nd_iter = NEW_CALL((yyvsp[(1) - (5)].node), (yyvsp[(3) - (5)].id), (yyvsp[(4) - (5)].node));
parse.c~:			(yyval.node) = (yyvsp[(5) - (5)].node);
parse.c~:			fixpos((yyval.node), (yyvsp[(1) - (5)].node));
parse.c~:			(yyval.node) = NEW_CALL((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].id), (yyvsp[(4) - (4)].node));
parse.c~:			fixpos((yyval.node), (yyvsp[(1) - (4)].node));
parse.c~:			block_dup_check((yyvsp[(4) - (5)].node),(yyvsp[(5) - (5)].node));
parse.c~:		        (yyvsp[(5) - (5)].node)->nd_iter = NEW_CALL((yyvsp[(1) - (5)].node), (yyvsp[(3) - (5)].id), (yyvsp[(4) - (5)].node));
parse.c~:			(yyval.node) = (yyvsp[(5) - (5)].node);
parse.c~:			fixpos((yyval.node), (yyvsp[(1) - (5)].node));
parse.c~:			(yyval.node) = NEW_SUPER((yyvsp[(2) - (2)].node));
parse.c~:			fixpos((yyval.node), (yyvsp[(2) - (2)].node));
parse.c~:			(yyval.node) = new_yield((yyvsp[(2) - (2)].node));
parse.c~:			fixpos((yyval.node), (yyvsp[(2) - (2)].node));
parse.c~:			(yyval.node) = (yyvsp[(2) - (3)].node);
parse.c~:			(yyval.node) = NEW_MASGN(NEW_LIST((yyvsp[(2) - (3)].node)), 0);
parse.c~:			(yyval.node) = NEW_MASGN((yyvsp[(1) - (1)].node), 0);
parse.c~:			(yyval.node) = NEW_MASGN(list_append((yyvsp[(1) - (2)].node),(yyvsp[(2) - (2)].node)), 0);
parse.c~:			(yyval.node) = NEW_MASGN((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = NEW_MASGN((yyvsp[(1) - (5)].node), NEW_POSTARG((yyvsp[(3) - (5)].node),(yyvsp[(5) - (5)].node)));
parse.c~:			(yyval.node) = NEW_MASGN((yyvsp[(1) - (2)].node), -1);
parse.c~:			(yyval.node) = NEW_MASGN((yyvsp[(1) - (4)].node), NEW_POSTARG(-1, (yyvsp[(4) - (4)].node)));
parse.c~:			(yyval.node) = NEW_MASGN(0, (yyvsp[(2) - (2)].node));
parse.c~:			(yyval.node) = NEW_MASGN(0, NEW_POSTARG((yyvsp[(2) - (4)].node),(yyvsp[(4) - (4)].node)));
parse.c~:			(yyval.node) = NEW_MASGN(0, -1);
parse.c~:			(yyval.node) = NEW_MASGN(0, NEW_POSTARG(-1, (yyvsp[(3) - (3)].node)));
parse.c~:			(yyval.node) = (yyvsp[(2) - (3)].node);
parse.c~:			(yyval.node) = NEW_LIST((yyvsp[(1) - (2)].node));
parse.c~:			(yyval.node) = list_append((yyvsp[(1) - (3)].node), (yyvsp[(2) - (3)].node));
parse.c~:			(yyval.node) = NEW_LIST((yyvsp[(1) - (1)].node));
parse.c~:			(yyval.node) = list_append((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = assignable((yyvsp[(1) - (1)].id), 0);
parse.c~:			(yyval.node) = aryset((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].node));
parse.c~:			(yyval.node) = attrset((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].id));
parse.c~:			(yyval.node) = attrset((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].id));
parse.c~:			(yyval.node) = attrset((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].id));
parse.c~:			(yyval.node) = NEW_CDECL(0, 0, NEW_COLON2((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].id)));
parse.c~:			(yyval.node) = NEW_CDECL(0, 0, NEW_COLON3((yyvsp[(2) - (2)].id)));
parse.c~:			rb_backref_error((yyvsp[(1) - (1)].node));
parse.c~:			if (!((yyval.node) = assignable((yyvsp[(1) - (1)].id), 0))) (yyval.node) = NEW_BEGIN(0);
parse.c~:			(yyval.node) = aryset((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].node));
parse.c~:			(yyval.node) = attrset((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].id));
parse.c~:			(yyval.node) = attrset((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].id));
parse.c~:			(yyval.node) = attrset((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].id));
parse.c~:			(yyval.node) = NEW_CDECL(0, 0, NEW_COLON2((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].id)));
parse.c~:			(yyval.node) = NEW_CDECL(0, 0, NEW_COLON3((yyvsp[(2) - (2)].id)));
parse.c~:			rb_backref_error((yyvsp[(1) - (1)].node));
parse.c~:			(yyval.node) = NEW_COLON3((yyvsp[(2) - (2)].id));
parse.c~:			(yyval.node) = NEW_COLON2((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].id));
parse.c~:			(yyval.id) = (yyvsp[(1) - (1)].id);
parse.c~:			(yyval.id) = (yyvsp[(1) - (1)].id);
parse.c~:			(yyval.node) = NEW_LIT(ID2SYM((yyvsp[(1) - (1)].id)));
parse.c~:			(yyval.node) = NEW_UNDEF((yyvsp[(1) - (1)].node));
parse.c~:			(yyval.node) = block_append((yyvsp[(1) - (4)].node), NEW_UNDEF((yyvsp[(4) - (4)].node)));
parse.c~:    { ifndef_ripper((yyval.id) = '-'); ;}
parse.c~:			value_expr((yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = node_assign((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c~:			value_expr((yyvsp[(3) - (5)].node));
parse.c~:		        (yyvsp[(3) - (5)].node) = NEW_RESCUE((yyvsp[(3) - (5)].node), NEW_RESBODY(0,(yyvsp[(5) - (5)].node),0), 0);
parse.c~:			(yyval.node) = node_assign((yyvsp[(1) - (5)].node), (yyvsp[(3) - (5)].node));
parse.c~:			value_expr((yyvsp[(3) - (3)].node));
parse.c~:			if ((yyvsp[(1) - (3)].node)) {
parse.c~:			    ID vid = (yyvsp[(1) - (3)].node)->nd_vid;
parse.c~:			    if ((yyvsp[(2) - (3)].id) == tOROP) {
parse.c~:				(yyvsp[(1) - (3)].node)->nd_value = (yyvsp[(3) - (3)].node);
parse.c~:				(yyval.node) = NEW_OP_ASGN_OR(gettable(vid), (yyvsp[(1) - (3)].node));
parse.c~:				    (yyval.node)->nd_aid = vid;
parse.c~:			    else if ((yyvsp[(2) - (3)].id) == tANDOP) {
parse.c~:				(yyvsp[(1) - (3)].node)->nd_value = (yyvsp[(3) - (3)].node);
parse.c~:				(yyval.node) = NEW_OP_ASGN_AND(gettable(vid), (yyvsp[(1) - (3)].node));
parse.c~:				(yyval.node) = (yyvsp[(1) - (3)].node);
parse.c~:				(yyval.node)->nd_value = NEW_CALL(gettable(vid), (yyvsp[(2) - (3)].id), NEW_LIST((yyvsp[(3) - (3)].node)));
parse.c~:			value_expr((yyvsp[(3) - (5)].node));
parse.c~:		        (yyvsp[(3) - (5)].node) = NEW_RESCUE((yyvsp[(3) - (5)].node), NEW_RESBODY(0,(yyvsp[(5) - (5)].node),0), 0);
parse.c~:			if ((yyvsp[(1) - (5)].node)) {
parse.c~:			    ID vid = (yyvsp[(1) - (5)].node)->nd_vid;
parse.c~:			    if ((yyvsp[(2) - (5)].id) == tOROP) {
parse.c~:				(yyvsp[(1) - (5)].node)->nd_value = (yyvsp[(3) - (5)].node);
parse.c~:				(yyval.node) = NEW_OP_ASGN_OR(gettable(vid), (yyvsp[(1) - (5)].node));
parse.c~:				    (yyval.node)->nd_aid = vid;
parse.c~:			    else if ((yyvsp[(2) - (5)].id) == tANDOP) {
parse.c~:				(yyvsp[(1) - (5)].node)->nd_value = (yyvsp[(3) - (5)].node);
parse.c~:				(yyval.node) = NEW_OP_ASGN_AND(gettable(vid), (yyvsp[(1) - (5)].node));
parse.c~:				(yyval.node) = (yyvsp[(1) - (5)].node);
parse.c~:				(yyval.node)->nd_value = NEW_CALL(gettable(vid), (yyvsp[(2) - (5)].id), NEW_LIST((yyvsp[(3) - (5)].node)));
parse.c~:			value_expr((yyvsp[(6) - (6)].node));
parse.c~:			if (!(yyvsp[(3) - (6)].node)) (yyvsp[(3) - (6)].node) = NEW_ZARRAY();
parse.c~:			args = arg_concat((yyvsp[(6) - (6)].node), (yyvsp[(3) - (6)].node));
parse.c~:			if ((yyvsp[(5) - (6)].id) == tOROP) {
parse.c~:			    (yyvsp[(5) - (6)].id) = 0;
parse.c~:			else if ((yyvsp[(5) - (6)].id) == tANDOP) {
parse.c~:			    (yyvsp[(5) - (6)].id) = 1;
parse.c~:			(yyval.node) = NEW_OP_ASGN1((yyvsp[(1) - (6)].node), (yyvsp[(5) - (6)].id), args);
parse.c~:			fixpos((yyval.node), (yyvsp[(1) - (6)].node));
parse.c~:			value_expr((yyvsp[(5) - (5)].node));
parse.c~:			if ((yyvsp[(4) - (5)].id) == tOROP) {
parse.c~:			    (yyvsp[(4) - (5)].id) = 0;
parse.c~:			else if ((yyvsp[(4) - (5)].id) == tANDOP) {
parse.c~:			    (yyvsp[(4) - (5)].id) = 1;
parse.c~:			(yyval.node) = NEW_OP_ASGN2((yyvsp[(1) - (5)].node), (yyvsp[(3) - (5)].id), (yyvsp[(4) - (5)].id), (yyvsp[(5) - (5)].node));
parse.c~:			fixpos((yyval.node), (yyvsp[(1) - (5)].node));
parse.c~:			value_expr((yyvsp[(5) - (5)].node));
parse.c~:			if ((yyvsp[(4) - (5)].id) == tOROP) {
parse.c~:			    (yyvsp[(4) - (5)].id) = 0;
parse.c~:			else if ((yyvsp[(4) - (5)].id) == tANDOP) {
parse.c~:			    (yyvsp[(4) - (5)].id) = 1;
parse.c~:			(yyval.node) = NEW_OP_ASGN2((yyvsp[(1) - (5)].node), (yyvsp[(3) - (5)].id), (yyvsp[(4) - (5)].id), (yyvsp[(5) - (5)].node));
parse.c~:			fixpos((yyval.node), (yyvsp[(1) - (5)].node));
parse.c~:			value_expr((yyvsp[(5) - (5)].node));
parse.c~:			if ((yyvsp[(4) - (5)].id) == tOROP) {
parse.c~:			    (yyvsp[(4) - (5)].id) = 0;
parse.c~:			else if ((yyvsp[(4) - (5)].id) == tANDOP) {
parse.c~:			    (yyvsp[(4) - (5)].id) = 1;
parse.c~:			(yyval.node) = NEW_OP_ASGN2((yyvsp[(1) - (5)].node), (yyvsp[(3) - (5)].id), (yyvsp[(4) - (5)].id), (yyvsp[(5) - (5)].node));
parse.c~:			fixpos((yyval.node), (yyvsp[(1) - (5)].node));
parse.c~:			yyerror("constant re-assignment");
parse.c~:			yyerror("constant re-assignment");
parse.c~:			rb_backref_error((yyvsp[(1) - (3)].node));
parse.c~:			value_expr((yyvsp[(1) - (3)].node));
parse.c~:			value_expr((yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = NEW_DOT2((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c~:			if (nd_type((yyvsp[(1) - (3)].node)) == NODE_LIT && FIXNUM_P((yyvsp[(1) - (3)].node)->nd_lit) &&
parse.c~:			    nd_type((yyvsp[(3) - (3)].node)) == NODE_LIT && FIXNUM_P((yyvsp[(3) - (3)].node)->nd_lit)) {
parse.c~:			value_expr((yyvsp[(1) - (3)].node));
parse.c~:			value_expr((yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = NEW_DOT3((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c~:			if (nd_type((yyvsp[(1) - (3)].node)) == NODE_LIT && FIXNUM_P((yyvsp[(1) - (3)].node)->nd_lit) &&
parse.c~:			    nd_type((yyvsp[(3) - (3)].node)) == NODE_LIT && FIXNUM_P((yyvsp[(3) - (3)].node)->nd_lit)) {
parse.c~:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), '+', (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), '-', (yyvsp[(3) - (3)].node));
parse.c~:			$$ = dispatch3(binary, $1, ID2SYM('-'), $3);
parse.c~:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), '*', (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), '/', (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), '%', (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), tPOW, (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = NEW_CALL(call_bin_op((yyvsp[(2) - (4)].node), tPOW, (yyvsp[(4) - (4)].node)), tUMINUS, 0);
parse.c~:			$$ = dispatch2(unary, ripper_intern("-@"), $$);
parse.c~:			(yyval.node) = NEW_CALL(call_bin_op((yyvsp[(2) - (4)].node), tPOW, (yyvsp[(4) - (4)].node)), tUMINUS, 0);
parse.c~:			$$ = dispatch2(unary, ripper_intern("-@"), $$);
parse.c~:			(yyval.node) = call_uni_op((yyvsp[(2) - (2)].node), tUPLUS);
parse.c~:			(yyval.node) = call_uni_op((yyvsp[(2) - (2)].node), tUMINUS);
parse.c~:			$$ = dispatch2(unary, ripper_intern("-@"), $2);
parse.c~:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), '|', (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), '^', (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), '&', (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), tCMP, (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), '>', (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), tGEQ, (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), '<', (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), tLEQ, (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), tEQ, (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), tEQQ, (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), tNEQ, (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = match_op((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c~:                        if (nd_type((yyvsp[(1) - (3)].node)) == NODE_LIT && TYPE((yyvsp[(1) - (3)].node)->nd_lit) == T_REGEXP) {
parse.c~:                            (yyval.node) = reg_named_capture_assign((yyvsp[(1) - (3)].node)->nd_lit, (yyval.node));
parse.c~:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), tNMATCH, (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = call_uni_op(cond((yyvsp[(2) - (2)].node)), '!');
parse.c~:			(yyval.node) = call_uni_op((yyvsp[(2) - (2)].node), '~');
parse.c~:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), tLSHFT, (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = call_bin_op((yyvsp[(1) - (3)].node), tRSHFT, (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = logop(NODE_AND, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = logop(NODE_OR, (yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = NEW_DEFINED((yyvsp[(4) - (4)].node));
parse.c~:			value_expr((yyvsp[(1) - (6)].node));
parse.c~:			(yyval.node) = NEW_IF(cond((yyvsp[(1) - (6)].node)), (yyvsp[(3) - (6)].node), (yyvsp[(6) - (6)].node));
parse.c~:			fixpos((yyval.node), (yyvsp[(1) - (6)].node));
parse.c~:			(yyval.node) = (yyvsp[(1) - (1)].node);
parse.c~:			value_expr((yyvsp[(1) - (1)].node));
parse.c~:			(yyval.node) = (yyvsp[(1) - (1)].node);
parse.c~:			(yyval.node) = (yyvsp[(1) - (2)].node);
parse.c~:			(yyval.node) = arg_append((yyvsp[(1) - (4)].node), NEW_HASH((yyvsp[(3) - (4)].node)));
parse.c~:			(yyval.node) = NEW_LIST(NEW_HASH((yyvsp[(1) - (2)].node)));
parse.c~:			(yyval.node) = (yyvsp[(2) - (3)].node);
parse.c~:			(yyval.node) = NEW_LIST((yyvsp[(1) - (1)].node));
parse.c~:			(yyval.node) = arg_blk_pass((yyvsp[(1) - (2)].node), (yyvsp[(2) - (2)].node));
parse.c~:			(yyval.node) = NEW_LIST(NEW_HASH((yyvsp[(1) - (2)].node)));
parse.c~:			(yyval.node) = arg_blk_pass((yyval.node), (yyvsp[(2) - (2)].node));
parse.c~:			(yyval.node) = arg_append((yyvsp[(1) - (4)].node), NEW_HASH((yyvsp[(3) - (4)].node)));
parse.c~:			(yyval.node) = arg_blk_pass((yyval.node), (yyvsp[(4) - (4)].node));
parse.c~:			cmdarg_stack = (yyvsp[(1) - (2)].num);
parse.c~:			(yyval.node) = (yyvsp[(2) - (2)].node);
parse.c~:			(yyval.node) = NEW_BLOCK_PASS((yyvsp[(2) - (2)].node));
parse.c~:			(yyval.node) = (yyvsp[(2) - (2)].node);
parse.c~:			(yyval.node) = NEW_LIST((yyvsp[(1) - (1)].node));
parse.c~:			(yyval.node) = NEW_SPLAT((yyvsp[(2) - (2)].node));
parse.c~:			if ((n1 = splat_array((yyvsp[(1) - (3)].node))) != 0) {
parse.c~:			    (yyval.node) = list_append(n1, (yyvsp[(3) - (3)].node));
parse.c~:			    (yyval.node) = arg_append((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c~:			if ((nd_type((yyvsp[(4) - (4)].node)) == NODE_ARRAY) && (n1 = splat_array((yyvsp[(1) - (4)].node))) != 0) {
parse.c~:			    (yyval.node) = list_concat(n1, (yyvsp[(4) - (4)].node));
parse.c~:			    (yyval.node) = arg_concat((yyvsp[(1) - (4)].node), (yyvsp[(4) - (4)].node));
parse.c~:			if ((n1 = splat_array((yyvsp[(1) - (3)].node))) != 0) {
parse.c~:			    (yyval.node) = list_append(n1, (yyvsp[(3) - (3)].node));
parse.c~:			    (yyval.node) = arg_append((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c~:			if (nd_type((yyvsp[(4) - (4)].node)) == NODE_ARRAY &&
parse.c~:			    (n1 = splat_array((yyvsp[(1) - (4)].node))) != 0) {
parse.c~:			    (yyval.node) = list_concat(n1, (yyvsp[(4) - (4)].node));
parse.c~:			    (yyval.node) = arg_concat((yyvsp[(1) - (4)].node), (yyvsp[(4) - (4)].node));
parse.c~:			(yyval.node) = NEW_SPLAT((yyvsp[(2) - (2)].node));
parse.c~:			(yyval.node) = NEW_FCALL((yyvsp[(1) - (1)].id), 0);
parse.c~:			if ((yyvsp[(3) - (4)].node) == NULL) {
parse.c~:			    if (nd_type((yyvsp[(3) - (4)].node)) == NODE_RESCUE ||
parse.c~:				nd_type((yyvsp[(3) - (4)].node)) == NODE_ENSURE)
parse.c~:				nd_set_line((yyvsp[(3) - (4)].node), (yyvsp[(2) - (4)].num));
parse.c~:			    (yyval.node) = NEW_BEGIN((yyvsp[(3) - (4)].node));
parse.c~:			nd_set_line((yyval.node), (yyvsp[(2) - (4)].num));
parse.c~:			(yyval.node) = (yyvsp[(2) - (4)].node);
parse.c~:			(yyval.node) = (yyvsp[(2) - (3)].node);
parse.c~:			(yyval.node) = NEW_COLON2((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].id));
parse.c~:			(yyval.node) = NEW_COLON3((yyvsp[(2) - (2)].id));
parse.c~:			if ((yyvsp[(2) - (3)].node) == 0) {
parse.c~:			    (yyval.node) = (yyvsp[(2) - (3)].node);
parse.c~:			(yyval.node) = NEW_HASH((yyvsp[(2) - (3)].node));
parse.c~:			(yyval.node) = new_yield((yyvsp[(3) - (4)].node));
parse.c~:			(yyval.node) = NEW_DEFINED((yyvsp[(5) - (6)].node));
parse.c~:			(yyval.node) = call_uni_op(cond((yyvsp[(3) - (4)].node)), '!');
parse.c~:			(yyvsp[(2) - (2)].node)->nd_iter = NEW_FCALL((yyvsp[(1) - (2)].id), 0);
parse.c~:			(yyval.node) = (yyvsp[(2) - (2)].node);
parse.c~:			fixpos((yyvsp[(2) - (2)].node)->nd_iter, (yyvsp[(2) - (2)].node));
parse.c~:			block_dup_check((yyvsp[(1) - (2)].node)->nd_args, (yyvsp[(2) - (2)].node));
parse.c~:			(yyvsp[(2) - (2)].node)->nd_iter = (yyvsp[(1) - (2)].node);
parse.c~:			(yyval.node) = (yyvsp[(2) - (2)].node);
parse.c~:			fixpos((yyval.node), (yyvsp[(1) - (2)].node));
parse.c~:			(yyval.node) = (yyvsp[(2) - (2)].node);
parse.c~:			(yyval.node) = NEW_IF(cond((yyvsp[(2) - (6)].node)), (yyvsp[(4) - (6)].node), (yyvsp[(5) - (6)].node));
parse.c~:			fixpos((yyval.node), (yyvsp[(2) - (6)].node));
parse.c~:			(yyval.node) = NEW_UNLESS(cond((yyvsp[(2) - (6)].node)), (yyvsp[(4) - (6)].node), (yyvsp[(5) - (6)].node));
parse.c~:			fixpos((yyval.node), (yyvsp[(2) - (6)].node));
parse.c~:			(yyval.node) = NEW_WHILE(cond((yyvsp[(3) - (7)].node)), (yyvsp[(6) - (7)].node), 1);
parse.c~:			fixpos((yyval.node), (yyvsp[(3) - (7)].node));
parse.c~:			(yyval.node) = NEW_UNTIL(cond((yyvsp[(3) - (7)].node)), (yyvsp[(6) - (7)].node), 1);
parse.c~:			fixpos((yyval.node), (yyvsp[(3) - (7)].node));
parse.c~:			(yyval.node) = NEW_CASE((yyvsp[(2) - (5)].node), (yyvsp[(4) - (5)].node));
parse.c~:			fixpos((yyval.node), (yyvsp[(2) - (5)].node));
parse.c~:			(yyval.node) = NEW_CASE((yyvsp[(2) - (5)].node), (yyvsp[(4) - (5)].node));
parse.c~:			fixpos((yyval.node), (yyvsp[(2) - (5)].node));
parse.c~:			(yyval.node) = NEW_CASE(0, (yyvsp[(3) - (4)].node));
parse.c~:			if (nd_type((yyvsp[(2) - (9)].node)) == NODE_MASGN) {
parse.c~:			    m->nd_next = block_append(
parse.c~:				node_assign((yyvsp[(2) - (9)].node), NEW_DVAR(id)));
parse.c~:			    if (nd_type((yyvsp[(2) - (9)].node)) == NODE_LASGN ||
parse.c~:				nd_type((yyvsp[(2) - (9)].node)) == NODE_DASGN ||
parse.c~:				nd_type((yyvsp[(2) - (9)].node)) == NODE_DASGN_CURR) {
parse.c~:				(yyvsp[(2) - (9)].node)->nd_value = NEW_DVAR(id);
parse.c~:				m->nd_plen = 1;
parse.c~:				m->nd_next = (yyvsp[(2) - (9)].node);
parse.c~:				m->nd_next = node_assign(NEW_MASGN(NEW_LIST((yyvsp[(2) - (9)].node)), 0), NEW_DVAR(id));
parse.c~:			scope = NEW_NODE(NODE_SCOPE, tbl, (yyvsp[(8) - (9)].node), args);
parse.c~:			(yyval.node) = NEW_FOR(0, (yyvsp[(5) - (9)].node), scope);
parse.c~:			fixpos((yyval.node), (yyvsp[(2) - (9)].node));
parse.c~:			(yyval.node) = NEW_CLASS((yyvsp[(2) - (6)].node), (yyvsp[(5) - (6)].node), (yyvsp[(3) - (6)].node));
parse.c~:			nd_set_line((yyval.node), (yyvsp[(4) - (6)].num));
parse.c~:			(yyval.node) = NEW_SCLASS((yyvsp[(3) - (8)].node), (yyvsp[(7) - (8)].node));
parse.c~:			fixpos((yyval.node), (yyvsp[(3) - (8)].node));
parse.c~:			in_def = (yyvsp[(4) - (8)].num);
parse.c~:			in_single = (yyvsp[(6) - (8)].num);
parse.c~:			(yyval.node) = NEW_MODULE((yyvsp[(2) - (5)].node), (yyvsp[(4) - (5)].node));
parse.c~:			nd_set_line((yyval.node), (yyvsp[(3) - (5)].num));
parse.c~:			cur_mid = (yyvsp[(2) - (2)].id);
parse.c~:			NODE *body = remove_begin((yyvsp[(5) - (6)].node));
parse.c~:			(yyval.node) = NEW_DEFN((yyvsp[(2) - (6)].id), (yyvsp[(4) - (6)].node), body, NOEX_PRIVATE);
parse.c~:			fixpos((yyval.node), (yyvsp[(4) - (6)].node));
parse.c~:			fixpos((yyval.node)->nd_defn, (yyvsp[(4) - (6)].node));
parse.c~:			in_def--;
parse.c~:			cur_mid = (yyvsp[(3) - (6)].id);
parse.c~:			NODE *body = remove_begin((yyvsp[(8) - (9)].node));
parse.c~:			(yyval.node) = NEW_DEFS((yyvsp[(2) - (9)].node), (yyvsp[(5) - (9)].id), (yyvsp[(7) - (9)].node), body);
parse.c~:			fixpos((yyval.node), (yyvsp[(2) - (9)].node));
parse.c~:			fixpos((yyval.node)->nd_defn, (yyvsp[(2) - (9)].node));
parse.c~:			in_single--;
parse.c~:			value_expr((yyvsp[(1) - (1)].node));
parse.c~:			(yyval.node) = (yyvsp[(1) - (1)].node);
parse.c~:			(yyval.node) = NEW_IF(cond((yyvsp[(2) - (5)].node)), (yyvsp[(4) - (5)].node), (yyvsp[(5) - (5)].node));
parse.c~:			fixpos((yyval.node), (yyvsp[(2) - (5)].node));
parse.c~:			(yyval.node) = (yyvsp[(2) - (2)].node);
parse.c~:			(yyval.node) = assignable((yyvsp[(1) - (1)].id), 0);
parse.c~:			(yyval.node) = (yyvsp[(2) - (3)].node);
parse.c~:			(yyval.node) = NEW_LIST((yyvsp[(1) - (1)].node));
parse.c~:			(yyval.node) = list_append((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = NEW_MASGN((yyvsp[(1) - (1)].node), 0);
parse.c~:			(yyval.node) = NEW_MASGN((yyvsp[(1) - (4)].node), assignable((yyvsp[(4) - (4)].id), 0));
parse.c~:			(yyval.node) = NEW_MASGN((yyvsp[(1) - (6)].node), NEW_POSTARG(assignable((yyvsp[(4) - (6)].id), 0), (yyvsp[(6) - (6)].node)));
parse.c~:			(yyval.node) = NEW_MASGN((yyvsp[(1) - (3)].node), -1);
parse.c~:			(yyval.node) = NEW_MASGN((yyvsp[(1) - (5)].node), NEW_POSTARG(-1, (yyvsp[(5) - (5)].node)));
parse.c~:			(yyval.node) = NEW_MASGN(0, assignable((yyvsp[(2) - (2)].id), 0));
parse.c~:			(yyval.node) = NEW_MASGN(0, NEW_POSTARG(assignable((yyvsp[(2) - (4)].id), 0), (yyvsp[(4) - (4)].node)));
parse.c~:			(yyval.node) = NEW_MASGN(0, -1);
parse.c~:			(yyval.node) = NEW_MASGN(0, NEW_POSTARG(-1, (yyvsp[(3) - (3)].node)));
parse.c~:			(yyval.node) = new_args((yyvsp[(1) - (6)].node), (yyvsp[(3) - (6)].node), (yyvsp[(5) - (6)].id), 0, (yyvsp[(6) - (6)].id));
parse.c~:			(yyval.node) = new_args((yyvsp[(1) - (8)].node), (yyvsp[(3) - (8)].node), (yyvsp[(5) - (8)].id), (yyvsp[(7) - (8)].node), (yyvsp[(8) - (8)].id));
parse.c~:			(yyval.node) = new_args((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].node), 0, 0, (yyvsp[(4) - (4)].id));
parse.c~:			(yyval.node) = new_args((yyvsp[(1) - (6)].node), (yyvsp[(3) - (6)].node), 0, (yyvsp[(5) - (6)].node), (yyvsp[(6) - (6)].id));
parse.c~:			(yyval.node) = new_args((yyvsp[(1) - (4)].node), 0, (yyvsp[(3) - (4)].id), 0, (yyvsp[(4) - (4)].id));
parse.c~:			(yyval.node) = new_args((yyvsp[(1) - (2)].node), 0, 1, 0, 0);
parse.c~:			(yyval.node) = new_args((yyvsp[(1) - (6)].node), 0, (yyvsp[(3) - (6)].id), (yyvsp[(5) - (6)].node), (yyvsp[(6) - (6)].id));
parse.c~:			(yyval.node) = new_args((yyvsp[(1) - (2)].node), 0, 0, 0, (yyvsp[(2) - (2)].id));
parse.c~:			(yyval.node) = new_args(0, (yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].id), 0, (yyvsp[(4) - (4)].id));
parse.c~:			(yyval.node) = new_args(0, (yyvsp[(1) - (6)].node), (yyvsp[(3) - (6)].id), (yyvsp[(5) - (6)].node), (yyvsp[(6) - (6)].id));
parse.c~:			(yyval.node) = new_args(0, (yyvsp[(1) - (2)].node), 0, 0, (yyvsp[(2) - (2)].id));
parse.c~:			(yyval.node) = new_args(0, (yyvsp[(1) - (4)].node), 0, (yyvsp[(3) - (4)].node), (yyvsp[(4) - (4)].id));
parse.c~:			(yyval.node) = new_args(0, 0, (yyvsp[(1) - (2)].id), 0, (yyvsp[(2) - (2)].id));
parse.c~:			(yyval.node) = new_args(0, 0, (yyvsp[(1) - (4)].id), (yyvsp[(3) - (4)].node), (yyvsp[(4) - (4)].id));
parse.c~:			(yyval.node) = new_args(0, 0, 0, 0, (yyvsp[(1) - (1)].id));
parse.c~:			(yyval.node) = (yyvsp[(2) - (4)].node);
parse.c~:			new_bv((yyvsp[(1) - (1)].id));
parse.c~:			lpar_beg = (yyvsp[(1) - (3)].num);
parse.c~:			(yyval.node) = (yyvsp[(2) - (3)].node);
parse.c~:			(yyval.node)->nd_body = NEW_SCOPE((yyvsp[(2) - (3)].node)->nd_head, (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = NEW_LAMBDA((yyvsp[(2) - (4)].node));
parse.c~:			(yyval.node) = NEW_LAMBDA((yyvsp[(1) - (1)].node));
parse.c~:			(yyval.node) = (yyvsp[(2) - (3)].node);
parse.c~:			(yyval.node) = (yyvsp[(2) - (3)].node);
parse.c~:			(yyval.node) = NEW_ITER((yyvsp[(3) - (5)].node),(yyvsp[(4) - (5)].node));
parse.c~:			nd_set_line((yyval.node), (yyvsp[(2) - (5)].num));
parse.c~:			if (nd_type((yyvsp[(1) - (2)].node)) == NODE_YIELD) {
parse.c~:			    block_dup_check((yyvsp[(1) - (2)].node)->nd_args, (yyvsp[(2) - (2)].node));
parse.c~:			(yyvsp[(2) - (2)].node)->nd_iter = (yyvsp[(1) - (2)].node);
parse.c~:			(yyval.node) = (yyvsp[(2) - (2)].node);
parse.c~:			fixpos((yyval.node), (yyvsp[(1) - (2)].node));
parse.c~:			(yyval.node) = NEW_CALL((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].id), (yyvsp[(4) - (4)].node));
parse.c~:			(yyval.node) = NEW_CALL((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].id), (yyvsp[(4) - (4)].node));
parse.c~:			(yyval.node) = NEW_FCALL((yyvsp[(1) - (2)].id), (yyvsp[(2) - (2)].node));
parse.c~:			fixpos((yyval.node), (yyvsp[(2) - (2)].node));
parse.c~:			(yyval.node) = NEW_CALL((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].id), (yyvsp[(4) - (4)].node));
parse.c~:			fixpos((yyval.node), (yyvsp[(1) - (4)].node));
parse.c~:			(yyval.node) = NEW_CALL((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].id), (yyvsp[(4) - (4)].node));
parse.c~:			fixpos((yyval.node), (yyvsp[(1) - (4)].node));
parse.c~:			(yyval.node) = NEW_CALL((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].id), 0);
parse.c~:			(yyval.node) = NEW_CALL((yyvsp[(1) - (3)].node), rb_intern("call"), (yyvsp[(3) - (3)].node));
parse.c~:			fixpos((yyval.node), (yyvsp[(1) - (3)].node));
parse.c~:			(yyval.node) = NEW_CALL((yyvsp[(1) - (3)].node), rb_intern("call"), (yyvsp[(3) - (3)].node));
parse.c~:			fixpos((yyval.node), (yyvsp[(1) - (3)].node));
parse.c~:			(yyval.node) = NEW_SUPER((yyvsp[(2) - (2)].node));
parse.c~:			if ((yyvsp[(1) - (4)].node) && nd_type((yyvsp[(1) - (4)].node)) == NODE_SELF)
parse.c~:			    (yyval.node) = NEW_FCALL(tAREF, (yyvsp[(3) - (4)].node));
parse.c~:			    (yyval.node) = NEW_CALL((yyvsp[(1) - (4)].node), tAREF, (yyvsp[(3) - (4)].node));
parse.c~:			fixpos((yyval.node), (yyvsp[(1) - (4)].node));
parse.c~:			(yyval.node) = NEW_ITER((yyvsp[(3) - (5)].node),(yyvsp[(4) - (5)].node));
parse.c~:			nd_set_line((yyval.node), (yyvsp[(2) - (5)].num));
parse.c~:			nd_set_line((yyval.node)->nd_body, (yyvsp[(2) - (5)].num));
parse.c~:			nd_set_line((yyval.node)->nd_body->nd_body, (yyvsp[(2) - (5)].num));
parse.c~:			(yyval.node) = NEW_ITER((yyvsp[(3) - (5)].node),(yyvsp[(4) - (5)].node));
parse.c~:			nd_set_line((yyval.node), (yyvsp[(2) - (5)].num));
parse.c~:			(yyval.node) = NEW_WHEN((yyvsp[(2) - (5)].node), (yyvsp[(4) - (5)].node), (yyvsp[(5) - (5)].node));
parse.c~:			if ((yyvsp[(3) - (6)].node)) {
parse.c~:			    (yyvsp[(3) - (6)].node) = node_assign((yyvsp[(3) - (6)].node), NEW_ERRINFO());
parse.c~:			    (yyvsp[(5) - (6)].node) = block_append((yyvsp[(3) - (6)].node), (yyvsp[(5) - (6)].node));
parse.c~:			(yyval.node) = NEW_RESBODY((yyvsp[(2) - (6)].node), (yyvsp[(5) - (6)].node), (yyvsp[(6) - (6)].node));
parse.c~:			fixpos((yyval.node), (yyvsp[(2) - (6)].node)?(yyvsp[(2) - (6)].node):(yyvsp[(5) - (6)].node));
parse.c~:			(yyval.node) = NEW_LIST((yyvsp[(1) - (1)].node));
parse.c~:			if (!((yyval.node) = splat_array((yyvsp[(1) - (1)].node)))) (yyval.node) = (yyvsp[(1) - (1)].node);
parse.c~:			(yyval.node) = (yyvsp[(2) - (2)].node);
parse.c~:			(yyval.node) = (yyvsp[(2) - (2)].node);
parse.c~:			(yyval.node) = NEW_LIT(ID2SYM((yyvsp[(1) - (1)].id)));
parse.c~:			NODE *node = (yyvsp[(1) - (1)].node);
parse.c~:			(yyval.node) = literal_concat((yyvsp[(1) - (2)].node), (yyvsp[(2) - (2)].node));
parse.c~:			(yyval.node) = (yyvsp[(2) - (3)].node);
parse.c~:			NODE *node = (yyvsp[(2) - (3)].node);
parse.c~:			int options = (yyvsp[(3) - (3)].num);
parse.c~:			NODE *node = (yyvsp[(2) - (3)].node);
parse.c~:				VALUE src = node->nd_lit;
parse.c~:				node->nd_lit = reg_compile(src, options);
parse.c~:			    node->nd_cflag = options & RE_OPTION_MASK;
parse.c~:                            reg_fragment_check(node->nd_lit, options);
parse.c~:                            for (list = node->nd_next; list; list = list->nd_next) {
parse.c~:                                if (nd_type(list->nd_head) == NODE_STR) {
parse.c~:                                    reg_fragment_check(list->nd_head->nd_lit, options);
parse.c~:			(yyval.node) = (yyvsp[(2) - (3)].node);
parse.c~:			(yyval.node) = list_append((yyvsp[(1) - (3)].node), evstr2dstr((yyvsp[(2) - (3)].node)));
parse.c~:			(yyval.node) = literal_concat((yyvsp[(1) - (2)].node), (yyvsp[(2) - (2)].node));
parse.c~:			(yyval.node) = (yyvsp[(2) - (3)].node);
parse.c~:			(yyval.node) = list_append((yyvsp[(1) - (3)].node), (yyvsp[(2) - (3)].node));
parse.c~:			(yyval.node) = literal_concat((yyvsp[(1) - (2)].node), (yyvsp[(2) - (2)].node));
parse.c~:			(yyval.node) = literal_concat((yyvsp[(1) - (2)].node), (yyvsp[(2) - (2)].node));
parse.c~:			lex_strterm = (yyvsp[(2) - (3)].node);
parse.c~:			(yyval.node) = NEW_EVSTR((yyvsp[(3) - (3)].node));
parse.c~:			lex_strterm = (yyvsp[(2) - (4)].node);
parse.c~:			if ((yyvsp[(3) - (4)].node)) (yyvsp[(3) - (4)].node)->flags &= ~NODE_FL_NEWLINE;
parse.c~:			(yyval.node) = new_evstr((yyvsp[(3) - (4)].node));
parse.c~:			(yyval.node) = NEW_GVAR((yyvsp[(1) - (1)].id));
parse.c~:			(yyval.node) = NEW_IVAR((yyvsp[(1) - (1)].id));
parse.c~:			(yyval.node) = NEW_CVAR((yyvsp[(1) - (1)].id));
parse.c~:			(yyval.id) = (yyvsp[(2) - (2)].id);
parse.c~:			if (!((yyval.node) = (yyvsp[(2) - (3)].node))) {
parse.c~:				lit = (yyval.node)->nd_lit;
parse.c~:				(yyval.node)->nd_lit = ID2SYM(rb_intern_str(lit));
parse.c~:			(yyval.node) = negate_lit((yyvsp[(2) - (2)].node));
parse.c~:			$$ = dispatch2(unary, ripper_intern("-@"), $2);
parse.c~:			(yyval.node) = negate_lit((yyvsp[(2) - (2)].node));
parse.c~:			$$ = dispatch2(unary, ripper_intern("-@"), $2);
parse.c~:			if (!((yyval.node) = gettable((yyvsp[(1) - (1)].id)))) (yyval.node) = NEW_BEGIN(0);
parse.c~:			(yyval.node) = assignable((yyvsp[(1) - (1)].id), 0);
parse.c~:			(yyval.node) = (yyvsp[(3) - (4)].node);
parse.c~:			(yyval.node) = (yyvsp[(2) - (3)].node);
parse.c~:			(yyval.node) = (yyvsp[(1) - (2)].node);
parse.c~:			(yyval.node) = new_args((yyvsp[(1) - (6)].node), (yyvsp[(3) - (6)].node), (yyvsp[(5) - (6)].id), 0, (yyvsp[(6) - (6)].id));
parse.c~:			(yyval.node) = new_args((yyvsp[(1) - (8)].node), (yyvsp[(3) - (8)].node), (yyvsp[(5) - (8)].id), (yyvsp[(7) - (8)].node), (yyvsp[(8) - (8)].id));
parse.c~:			(yyval.node) = new_args((yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].node), 0, 0, (yyvsp[(4) - (4)].id));
parse.c~:			(yyval.node) = new_args((yyvsp[(1) - (6)].node), (yyvsp[(3) - (6)].node), 0, (yyvsp[(5) - (6)].node), (yyvsp[(6) - (6)].id));
parse.c~:			(yyval.node) = new_args((yyvsp[(1) - (4)].node), 0, (yyvsp[(3) - (4)].id), 0, (yyvsp[(4) - (4)].id));
parse.c~:			(yyval.node) = new_args((yyvsp[(1) - (6)].node), 0, (yyvsp[(3) - (6)].id), (yyvsp[(5) - (6)].node), (yyvsp[(6) - (6)].id));
parse.c~:			(yyval.node) = new_args((yyvsp[(1) - (2)].node), 0, 0, 0, (yyvsp[(2) - (2)].id));
parse.c~:			(yyval.node) = new_args(0, (yyvsp[(1) - (4)].node), (yyvsp[(3) - (4)].id), 0, (yyvsp[(4) - (4)].id));
parse.c~:			(yyval.node) = new_args(0, (yyvsp[(1) - (6)].node), (yyvsp[(3) - (6)].id), (yyvsp[(5) - (6)].node), (yyvsp[(6) - (6)].id));
parse.c~:			(yyval.node) = new_args(0, (yyvsp[(1) - (2)].node), 0, 0, (yyvsp[(2) - (2)].id));
parse.c~:			(yyval.node) = new_args(0, (yyvsp[(1) - (4)].node), 0, (yyvsp[(3) - (4)].node), (yyvsp[(4) - (4)].id));
parse.c~:			(yyval.node) = new_args(0, 0, (yyvsp[(1) - (2)].id), 0, (yyvsp[(2) - (2)].id));
parse.c~:			(yyval.node) = new_args(0, 0, (yyvsp[(1) - (4)].id), (yyvsp[(3) - (4)].node), (yyvsp[(4) - (4)].id));
parse.c~:			(yyval.node) = new_args(0, 0, 0, 0, (yyvsp[(1) - (1)].id));
parse.c~:			if (!is_local_id((yyvsp[(1) - (1)].id)))
parse.c~:			shadowing_lvar((yyvsp[(1) - (1)].id));
parse.c~:			(yyval.id) = (yyvsp[(1) - (1)].id);
parse.c~:			arg_var((yyvsp[(1) - (1)].id));
parse.c~:			(yyval.node) = NEW_ARGS_AUX((yyvsp[(1) - (1)].id), 1);
parse.c~:			    (yyvsp[(2) - (3)].node)->nd_value = NEW_DVAR(tid);
parse.c~:			    (yyvsp[(2) - (3)].node)->nd_value = NEW_LVAR(tid);
parse.c~:			(yyval.node)->nd_next = (yyvsp[(2) - (3)].node);
parse.c~:			(yyval.node) = (yyvsp[(1) - (3)].node);
parse.c~:			(yyval.node)->nd_plen++;
parse.c~:			(yyval.node)->nd_next = block_append((yyval.node)->nd_next, (yyvsp[(3) - (3)].node)->nd_next);
parse.c~:			rb_gc_force_recycle((VALUE)(yyvsp[(3) - (3)].node));
parse.c~:			if (!is_local_id((yyvsp[(1) - (3)].id)))
parse.c~:			shadowing_lvar((yyvsp[(1) - (3)].id));
parse.c~:			arg_var((yyvsp[(1) - (3)].id));
parse.c~:			(yyval.node) = NEW_OPT_ARG(0, assignable((yyvsp[(1) - (3)].id), (yyvsp[(3) - (3)].node)));
parse.c~:			if (!is_local_id((yyvsp[(1) - (3)].id)))
parse.c~:			shadowing_lvar((yyvsp[(1) - (3)].id));
parse.c~:			arg_var((yyvsp[(1) - (3)].id));
parse.c~:			(yyval.node) = NEW_OPT_ARG(0, assignable((yyvsp[(1) - (3)].id), (yyvsp[(3) - (3)].node)));
parse.c~:			(yyval.node) = (yyvsp[(1) - (1)].node);
parse.c~:			NODE *opts = (yyvsp[(1) - (3)].node);
parse.c~:			while (opts->nd_next) {
parse.c~:			    opts = opts->nd_next;
parse.c~:			opts->nd_next = (yyvsp[(3) - (3)].node);
parse.c~:			(yyval.node) = (yyvsp[(1) - (3)].node);
parse.c~:			(yyval.node) = (yyvsp[(1) - (1)].node);
parse.c~:			NODE *opts = (yyvsp[(1) - (3)].node);
parse.c~:			while (opts->nd_next) {
parse.c~:			    opts = opts->nd_next;
parse.c~:			opts->nd_next = (yyvsp[(3) - (3)].node);
parse.c~:			(yyval.node) = (yyvsp[(1) - (3)].node);
parse.c~:			if (!is_local_id((yyvsp[(2) - (2)].id)))
parse.c~:			shadowing_lvar((yyvsp[(2) - (2)].id));
parse.c~:			arg_var((yyvsp[(2) - (2)].id));
parse.c~:			(yyval.id) = (yyvsp[(2) - (2)].id);
parse.c~:			if (!is_local_id((yyvsp[(2) - (2)].id)))
parse.c~:			else if (!dyna_in_block() && local_id((yyvsp[(2) - (2)].id)))
parse.c~:			shadowing_lvar((yyvsp[(2) - (2)].id));
parse.c~:			arg_var((yyvsp[(2) - (2)].id));
parse.c~:			(yyval.id) = (yyvsp[(2) - (2)].id);
parse.c~:			(yyval.id) = (yyvsp[(2) - (2)].id);
parse.c~:			value_expr((yyvsp[(1) - (1)].node));
parse.c~:			(yyval.node) = (yyvsp[(1) - (1)].node);
parse.c~:			if ((yyvsp[(3) - (4)].node) == 0) {
parse.c~:			    switch (nd_type((yyvsp[(3) - (4)].node))) {
parse.c~:				value_expr((yyvsp[(3) - (4)].node));
parse.c~:			(yyval.node) = (yyvsp[(3) - (4)].node);
parse.c~:			(yyval.node) = (yyvsp[(1) - (2)].node);
parse.c~:			(yyval.node) = list_concat((yyvsp[(1) - (3)].node), (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = list_append(NEW_LIST((yyvsp[(1) - (3)].node)), (yyvsp[(3) - (3)].node));
parse.c~:			(yyval.node) = list_append(NEW_LIST(NEW_LIT(ID2SYM((yyvsp[(1) - (2)].id)))), (yyvsp[(2) - (2)].node));
parse.c~:  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
parse.c~:  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
parse.c~:    yystate = yydefgoto[yyn - YYNTOKENS];
parse.c~:/*------------------------------------.
parse.c~:| yyerrlab -- here on detecting error |
parse.c~:`------------------------------------*/
parse.c~:      /* If just tried and failed to reuse look-ahead token after an
parse.c~:  /* Else will try to reuse look-ahead token after shifting the error
parse.c~:/*---------------------------------------------------.
parse.c~:| yyerrorlab -- error raised explicitly by YYERROR.  |
parse.c~:`---------------------------------------------------*/
parse.c~:/*-------------------------------------------------------------.
parse.c~:| yyerrlab1 -- common code for both syntax error and YYERROR.  |
parse.c~:`-------------------------------------------------------------*/
parse.c~:/*-------------------------------------.
parse.c~:| yyacceptlab -- YYACCEPT comes here.  |
parse.c~:`-------------------------------------*/
parse.c~:/*-----------------------------------.
parse.c~:| yyabortlab -- YYABORT comes here.  |
parse.c~:`-----------------------------------*/
parse.c~:/*-------------------------------------------------.
parse.c~:| yyexhaustedlab -- memory exhaustion comes here.  |
parse.c~:`-------------------------------------------------*/
parse.c~:# define yylval  (*((YYSTYPE*)(parser->parser_yylval)))
parse.c~:#define ripper_flush(p) (p->tokp = p->parser_lex_p)
parse.c~:    if (lex_p < parser->tokp) rb_raise(rb_eRuntimeError, "lex_p < tokp");
parse.c~:    if (lex_p == parser->tokp) return;
parse.c~:    str = STR_NEW(parser->tokp, lex_p - parser->tokp);
parse.c~:    const char *saved_tokp = parser->tokp;
parse.c~:    ruby_sourceline = parser->delayed_line;
parse.c~:    parser->tokp = lex_pbeg + parser->delayed_col;
parse.c~:    yylval.val = ripper_dispatch1(parser, ripper_token2eventid(t), parser->delayed);
parse.c~:    parser->delayed = Qnil;
parse.c~:    parser->tokp = saved_tokp;
parse.c~:# define SIGN_EXTEND_CHAR(c) ((((unsigned char)(c)) ^ 128) - 128)
parse.c~:#define parser_encoding_name()  (parser->enc->name)
parse.c~:#define parser_mbclen()  mbclen((lex_p-1),lex_pend,parser->enc)
parse.c~:#define parser_precise_mbclen()  rb_enc_precise_mbclen((lex_p-1),lex_pend,parser->enc)
parse.c~:#define parser_is_identchar() (!parser->eofp && is_identchar((lex_p-1),lex_pend,parser->enc))
parse.c~:#define parser_isascii() ISASCII(*(lex_p-1))
parse.c~:    const char *p, *pend = lex_p - strlen(token);
parse.c~:	    column = (((column - 1) / 8) + 1) * 8;
parse.c~:    const char *p, *pend = lex_p - strlen(token);
parse.c~:    ptinfo->token = token;
parse.c~:    ptinfo->linenum = ruby_sourceline;
parse.c~:    ptinfo->column = token_info_get_column(parser, token);
parse.c~:    ptinfo->nonspc = token_info_has_nonspaces(parser, token);
parse.c~:    ptinfo->next = parser->parser_token_info;
parse.c~:    parser->parser_token_info = ptinfo;
parse.c~:    token_info *ptinfo = parser->parser_token_info;
parse.c~:    parser->parser_token_info = ptinfo->next;
parse.c~:    if (token_info_get_column(parser, token) == ptinfo->column) { /* OK */
parse.c~:    if (linenum == ptinfo->linenum) { /* SKIP */
parse.c~:    if (token_info_has_nonspaces(parser, token) || ptinfo->nonspc) { /* SKIP */
parse.c~:	       token, ptinfo->token, ptinfo->linenum);
parse.c~:	p--;
parse.c~:    len = pe - p;
parse.c~:	    if (lex_p - p > max_line_margin) {
parse.c~:		p = rb_enc_prev_char(p, lex_p - max_line_margin, pe, rb_enc_get(lex_lastline));
parse.c~:	    if (pe - lex_p > max_line_margin) {
parse.c~:	    len = pe - p;
parse.c~:	i = lex_p - p;
parse.c~:    if (RTEST(coverages) && RBASIC(coverages)->klass == 0) {
parse.c~:	RBASIC(lines)->klass = 0;
parse.c~:	RARRAY(lines)->as.heap.len = n;
parse.c~:    if (strcmp(ruby_sourcefile, "-e") == 0)
parse.c~:	    } while (--n);
parse.c~:    if (parser->nerr) {
parse.c~:	    scope->nd_body = NEW_PRELUDE(ruby_eval_tree_begin, scope->nd_body);
parse.c~:    ruby_sourceline = line - 1;
parse.c~:    lex_gets_ptr = end - RSTRING_PTR(s);
parse.c~:    return rb_enc_str_new(beg, end - beg, rb_enc_get(s));
parse.c~:    VALUE line = (*parser->parser_lex_gets)(parser, parser->parser_lex_input);
parse.c~:#define lex_goto_eol(parser) (parser->parser_lex_p = parser->parser_lex_pend)
parse.c~:	    if (parser->eofp)
parse.c~:		return -1;
parse.c~:		parser->eofp = Qtrue;
parse.c~:		return -1;
parse.c~:	    if (parser->tokp < lex_pend) {
parse.c~:		if (NIL_P(parser->delayed)) {
parse.c~:		    parser->delayed = rb_str_buf_new(1024);
parse.c~:		    rb_str_buf_cat(parser->delayed,
parse.c~:				   parser->tokp, lex_pend - parser->tokp);
parse.c~:		    parser->delayed_line = ruby_sourceline;
parse.c~:		    parser->delayed_col = parser->tokp - lex_pbeg;
parse.c~:		    rb_str_buf_cat(parser->delayed,
parse.c~:				   parser->tokp, lex_pend - parser->tokp);
parse.c~:	    parser->line_count++;
parse.c~:    if (c == -1) return;
parse.c~:    lex_p--;
parse.c~:    if (lex_p > lex_pbeg && lex_p[0] == '\n' && lex_p[-1] == '\r') {
parse.c~:	lex_p--;
parse.c~:#define toklast() (tokidx>0?tokenbuf[tokidx-1]:0)
parse.c~:    return &tokenbuf[tokidx-n];
parse.c~:#define tokcopy(n) memcpy(tokspace(n), lex_p - (n), (n))
parse.c~:      case 'r':	/* carriage-return */
parse.c~:      case 'f':	/* form-feed */
parse.c~:	if ((c = nextc()) != '-') {
parse.c~:	else if (c == -1 || !ISASCII(c)) goto eof;
parse.c~:	if ((c = nextc()) != '-') {
parse.c~:	else if (c == -1 || !ISASCII(c)) goto eof;
parse.c~:      case -1:
parse.c~:	    oct = scan_oct(--lex_p, 3, &numlen);
parse.c~:	if ((c = nextc()) != '-') {
parse.c~:	if ((c = nextc()) != '-') {
parse.c~:	else if (c == -1) goto eof;
parse.c~:      case -1:
parse.c~:	return -1;
parse.c~:	compile_error(PARSER_ARG "unknown regexp option%s - %s",
parse.c~:    if (RBASIC(str)->flags & RSTRING_NOEMBED)
parse.c~:	return -1;
parse.c~:    lex_p += --len;
parse.c~:	int len = sizeof(mixed_msg) - 4;	\
parse.c~:    while ((c = nextc()) != -1) {
parse.c~:	    --*nest;
parse.c~:	    const char *beg = lex_p - 1;
parse.c~:			return -1;
parse.c~:	    if (tokadd_mbchar(c) == -1) return -1;
parse.c~:    int func = quote->nd_func;
parse.c~:    rb_encoding *enc = parser->enc;
parse.c~:    if (func == -1) return tSTRING_END;
parse.c~:    if (c == term && !quote->nd_nest) {
parse.c~:	    quote->nd_func = -1;
parse.c~:    if (tokadd_string(func, term, paren, &quote->nd_nest,
parse.c~:		      &enc) == -1) {
parse.c~:	    if (parser->eofp)
parse.c~:	    if (parser->eofp)
parse.c~:    if (c == '-') {
parse.c~:	while ((c = nextc()) != -1 && c != term) {
parse.c~:	    if (tokadd_mbchar(c) == -1) return 0;
parse.c~:	if (c == -1) {
parse.c~:		pushback('-');
parse.c~:	    if (tokadd_mbchar(c) == -1) return 0;
parse.c~:	} while ((c = nextc()) != -1 && parser_is_identchar());
parse.c~:    len = lex_p - lex_pbeg;
parse.c~:    if (!NIL_P(parser->delayed))
parse.c~:    line = here->nd_orig;
parse.c~:    lex_p = lex_pbeg + here->nd_nth;
parse.c~:    dispose_string(here->nd_lit);
parse.c~:    n= lex_pend - (p + len);
parse.c~:    eos = RSTRING_PTR(here->nd_lit);
parse.c~:    len = RSTRING_LEN(here->nd_lit) - 1;
parse.c~:    if ((c = nextc()) == -1) {
parse.c~:		switch (pend[-1]) {
parse.c~:		    if (--pend == p || pend[-1] != '\r') {
parse.c~:		    --pend;
parse.c~:		rb_str_cat(str, p, pend - p);
parse.c~:		str = STR_NEW(p, pend - p);
parse.c~:	    if (nextc() == -1) {
parse.c~:	rb_encoding *enc = parser->enc;
parse.c~:	    if ((c = tokadd_string(func, '\n', 0, NULL, &enc)) == -1) {
parse.c~:		if (parser->eofp) goto error;
parse.c~:	    if ((c = nextc()) == -1) goto error;
parse.c~:    lex_strterm = NEW_STRTERM(-1, 0, 0);
parse.c~:/* emacsen -*- hack */
parse.c~:    if (len > 5 && name[nlen = len - 5] == '-') {
parse.c~:    if (len > 4 && name[nlen = len - 5] == '-') {
parse.c~:    parser->enc = enc;
parse.c~:    const char *p = lex_pbeg, *pend = lex_p - 1;
parse.c~:    if (parser->line_count != (parser->has_shebang ? 2 : 1)) return 0;
parse.c~:	  case '-':
parse.c~:	    if (str[i-1] == '*' && str[i-2] == '-') {
parse.c~:	    if (str[i+1] != '-') {
parse.c~:	    else if (str[i-1] != '-') {
parse.c~:    if (!(end = magic_comment_marker(beg, str + len - beg))) return Qfalse;
parse.c~:    len = end - beg - 3;
parse.c~:	for (; len > 0 && *str; str++, --len) {
parse.c~:	for (beg = str; len > 0; str++, --len) {
parse.c~:	for (end = str; len > 0 && ISSPACE(*str); str++, --len);
parse.c~:	do str++; while (--len > 0 && ISSPACE(*str));
parse.c~:	    for (vbeg = ++str; --len > 0 && *str != '"'; str++) {
parse.c~:		    --len;
parse.c~:		--len;
parse.c~:	    for (vbeg = str; len > 0 && *str != '"' && *str != ';' && !ISSPACE(*str); --len, str++);
parse.c~:	while (len > 0 && (*str == ';' || ISSPACE(*str))) --len, str++;
parse.c~:	n = end - beg;
parse.c~:	    if (*s == '-') *s = '_';
parse.c~:	    if (STRNCASECMP(p->name, s, n) == 0) {
parse.c~:		n = vend - vbeg;
parse.c~:		if (p->length) {
parse.c~:		    n = (*p->length)(parser, vbeg, n);
parse.c~:		(*p->func)(parser, s, RSTRING_PTR(val));
parse.c~:	if (send - str <= 6) return;
parse.c~:	if (STRNCASECMP(str-6, "coding", 6) == 0) break;
parse.c~:    while ((*str == '-' || *str == '_' || ISALNUM(*str)) && ++str < send);
parse.c~:    s = rb_str_new(beg, parser_encode_length(parser, beg, str - beg));
parse.c~:	if (peek('!')) parser->has_shebang = 1;
parse.c~:      case 0xef:		/* UTF-8 BOM marker */
parse.c~:	if (lex_pend - lex_p >= 2 &&
parse.c~:	    parser->enc = rb_utf8_encoding();
parse.c~:    parser->enc = rb_enc_get(lex_lastline);
parse.c~:      case -1:			/* end of script. */
parse.c~:	if (!parser_magic_comment(parser, lex_p, lex_pend - lex_p)) {
parse.c~:		--ruby_sourceline;
parse.c~:	      case -1:		/* EOF no decrement*/
parse.c~:		if (c != -1) {
parse.c~:		    parser->tokp = lex_p;
parse.c~:		    if (c == -1) {
parse.c~:	if (c == -1) {
parse.c~:	if (rb_enc_isspace(c, parser->enc)) {
parse.c~:	enc = parser->enc;
parse.c~:	    if (tokadd_mbchar(c) == -1) return 0;
parse.c~:	else if ((rb_enc_isalnum(c, parser->enc) || c == '_') &&
parse.c~:		 lex_p < lex_pend && is_identchar(lex_p, lex_pend, parser->enc)) {
parse.c~:	    if (c != -1 && ISDIGIT(c)) {
parse.c~:      case '-':
parse.c~:	    return '-';
parse.c~:            set_yylval_id('-');
parse.c~:	    if (c != -1 && ISDIGIT(c)) {
parse.c~:	return '-';
parse.c~:	if (c != -1 && ISDIGIT(c)) {
parse.c~:	    if (c == '-' || c == '+') {
parse.c~:		    if (c != -1 && ISXDIGIT(c)) {
parse.c~:			} while ((c = nextc()) != -1);
parse.c~:			} while ((c = nextc()) != -1);
parse.c~:		    if (c != -1 && ISDIGIT(c)) {
parse.c~:			} while ((c = nextc()) != -1);
parse.c~:		    if (c == -1 || c == '_' || !ISDIGIT(c)) {
parse.c~:		    } while ((c = nextc()) != -1);
parse.c~:			if (c0 == -1 || !ISDIGIT(c0)) {
parse.c~:		    if (c != '-' && c != '+') continue;
parse.c~:	paren_nest--;
parse.c~:	if (lex_state == EXPR_END || lex_state == EXPR_ENDARG || (c != -1 && ISSPACE(c))) {
parse.c~:	    --paren_nest;
parse.c~:	    if (c == -1 || !ISALNUM(c)) {
parse.c~:		if (rb_enc_isalnum(term, parser->enc) || !parser_isascii()) {
parse.c~:	    if (c == -1 || term == -1) {
parse.c~:	  case '~':		/* $~: match-data */
parse.c~:	  case '-':
parse.c~:		if (tokadd_mbchar(c) == -1) return 0;
parse.c~:	    } while (c != -1 && ISDIGIT(c));
parse.c~:	if (c != -1 && ISDIGIT(c)) {
parse.c~:	    parser->eofp = Qtrue;
parse.c~:	    return -1;
parse.c~:	if (tokadd_mbchar(c) == -1) return 0;
parse.c~:		    lex_state = kw->state;
parse.c~:                        set_yylval_id(rb_intern(kw->name));
parse.c~:			return kw->id[0];
parse.c~:		    if (kw->id[0] == keyword_do) {
parse.c~:			    --paren_nest;
parse.c~:			return kw->id[0];
parse.c~:			if (kw->id[0] != kw->id[1])
parse.c~:			return kw->id[1];
parse.c~:    parser->parser_yylval = lval;
parse.c~:    parser->parser_yylval->val = Qundef;
parse.c~:    if (!NIL_P(parser->delayed)) {
parse.c~:	node->flags |= NODE_FL_NEWLINE;
parse.c~:	end->nd_end = end;
parse.c~:	end = h->nd_end;
parse.c~:    nd = end->nd_head;
parse.c~:	tail->nd_end = tail;
parse.c~:    end->nd_next = tail;
parse.c~:    h->nd_end = tail->nd_end;
parse.c~:    if (list->nd_next) {
parse.c~:	last = list->nd_next->nd_end;
parse.c~:    list->nd_alen += 1;
parse.c~:    last->nd_next = NEW_LIST(item);
parse.c~:    list->nd_next->nd_end = last->nd_next;
parse.c~:    if (head->nd_next) {
parse.c~:	last = head->nd_next->nd_end;
parse.c~:    head->nd_alen += tail->nd_alen;
parse.c~:    last->nd_next = tail;
parse.c~:    if (tail->nd_next) {
parse.c~:	head->nd_next->nd_end = tail->nd_next->nd_end;
parse.c~:	head->nd_next->nd_end = tail;
parse.c~:	    if (!literal_concat0(parser, head->nd_lit, tail->nd_lit)) {
parse.c~:	    if (!literal_concat0(parser, head->nd_lit, tail->nd_lit))
parse.c~:	    tail->nd_lit = head->nd_lit;
parse.c~:	    tail->nd_head = NEW_STR(tail->nd_lit);
parse.c~:	    head->nd_alen = 1;
parse.c~:	    if (TYPE(node1->nd_lit) == T_REGEXP) {
parse.c~:	    if (TYPE(node2->nd_lit) == T_REGEXP) {
parse.c~:	return NEW_LIT(rb_enc_from_encoding(parser->enc));
parse.c~:	    rb_warningS("shadowing outer local variable - %s", rb_id2name(name));
parse.c~:	    vtable_add(lvtbl->vars, name);
parse.c~:	compile_error(PARSER_ARG "invalid local variable - %s",
parse.c~:	compile_error(PARSER_ARG "Can't set variable $%ld", node->nd_nth);
parse.c~:	compile_error(PARSER_ARG "Can't set variable $%c", (int)node->nd_nth);
parse.c~:	node1->nd_iter = arg_concat(node1->nd_iter, node2);
parse.c~:	node1->nd_body = list_concat(NEW_LIST(node1->nd_body), node2);
parse.c~:	    nd_type(node1->nd_body) != NODE_ARRAY) break;
parse.c~:	node1->nd_body = list_concat(node1->nd_body, node2);
parse.c~:	node1->nd_head = arg_append(node1->nd_head, node2);
parse.c~:	node1->nd_body = list_append(NEW_LIST(node1->nd_body), node2);
parse.c~:    if (nd_type(node) == NODE_SPLAT) node = node->nd_head;
parse.c~:	lhs->nd_value = rhs;
parse.c~:	lhs->nd_args = arg_append(lhs->nd_args, rhs);
parse.c~:	    while (node->nd_next) {
parse.c~:		node = node->nd_next;
parse.c~:	    node = node->nd_head;
parse.c~:	    node = node->nd_body;
parse.c~:	    if (!node->nd_body) {
parse.c~:		node = node->nd_else;
parse.c~:	    else if (!node->nd_else) {
parse.c~:		node = node->nd_body;
parse.c~:	    if (!value_expr(node->nd_body)) return Qfalse;
parse.c~:	    node = node->nd_else;
parse.c~:	    node = node->nd_2nd;
parse.c~:	switch (node->nd_mid) {
parse.c~:	  case '-':
parse.c~:	    useless = rb_id2name(node->nd_mid);
parse.c~:	if (!node->nd_next) return;
parse.c~:	void_expr0(node->nd_head);
parse.c~:	node = node->nd_next;
parse.c~:    while (n1 && nd_type(n1) == NODE_BEGIN && n1->nd_body) {
parse.c~:	*n = n1 = n1->nd_body;
parse.c~:    ((!node->n1) ? (node->n2 ? (body = &node->n2, 1) : 0) : \
parse.c~:     (!node->n2) ? (body = &node->n1, 1) : \
parse.c~:     (reduce_nodes(&node->n1), body = &node->n2, 1))
parse.c~:	    *body = node = node->nd_stts;
parse.c~:	    *body = node = node->nd_body;
parse.c~:	    body = &node->nd_end->nd_head;
parse.c~:	    body = &node->nd_body;
parse.c~:    switch (nd_type(node->nd_value)) {
parse.c~:	parser_warn(node->nd_value, "found = in conditional, should be ==");
parse.c~:	next = node->nd_next;
parse.c~:	head = node->nd_head;
parse.c~:	    val = rb_range_new(head->nd_beg->nd_lit, head->nd_end->nd_lit,
parse.c~:	    rb_gc_force_recycle((VALUE)head->nd_beg);
parse.c~:	    rb_gc_force_recycle((VALUE)head->nd_end);
parse.c~:	    head->nd_lit = val;
parse.c~:    if (type == NODE_LIT && FIXNUM_P(node->nd_lit)) {
parse.c~:	node->nd_1st = cond0(parser, node->nd_1st);
parse.c~:	node->nd_2nd = cond0(parser, node->nd_2nd);
parse.c~:	node->nd_beg = range_op(parser, node->nd_beg);
parse.c~:	node->nd_end = range_op(parser, node->nd_end);
parse.c~:	    int b = literal_node(node->nd_beg);
parse.c~:	    int e = literal_node(node->nd_end);
parse.c~:	if (TYPE(node->nd_lit) == T_REGEXP) {
parse.c~:	while ((second = node->nd_2nd) != 0 && nd_type(second) == type) {
parse.c~:	node->nd_2nd = NEW_NODE(type, second, right, 0);
parse.c~:	    if (node->nd_next == 0) {
parse.c~:		node = node->nd_head;
parse.c~:    switch (TYPE(node->nd_lit)) {
parse.c~:	node->nd_lit = LONG2FIX(-FIX2LONG(node->nd_lit));
parse.c~:	node->nd_lit = rb_funcall(node->nd_lit,tUMINUS,0,0);
parse.c~:	RFLOAT(node->nd_lit)->float_value = -RFLOAT_VALUE(node->nd_lit);
parse.c~:	node2->nd_head = node1;
parse.c~:    node = NEW_ARGS(m ? m->nd_plen : 0, o);
parse.c~:    i1 = m ? m->nd_next : 0;
parse.c~:    node->nd_next = NEW_ARGS_AUX(r, b);
parse.c~:	i2 = p->nd_next;
parse.c~:	node->nd_next->nd_next = NEW_ARGS_AUX(p->nd_pid, p->nd_plen);
parse.c~:	node->nd_next->nd_next = NEW_ARGS_AUX(0, 0);
parse.c~:	node->nd_next->nd_next->nd_next = NEW_NODE(NODE_AND, i1, i2, 0);
parse.c~:    local->prev = lvtbl;
parse.c~:    local->args = vtable_alloc(0);
parse.c~:    local->vars = vtable_alloc(inherit_dvars ? DVARS_INHERIT : DVARS_TOPSCOPE);
parse.c~:    struct local_vars *local = lvtbl->prev;
parse.c~:    vtable_free(lvtbl->args);
parse.c~:    vtable_free(lvtbl->vars);
parse.c~:            buf[i] = src->tbl[i];
parse.c~:    int cnt = vtable_size(lvtbl->args) + vtable_size(lvtbl->vars);
parse.c~:    vtable_tblcpy(buf+1, lvtbl->args);
parse.c~:    vtable_tblcpy(buf+vtable_size(lvtbl->args)+1, lvtbl->vars);
parse.c~:    vtable_add(lvtbl->args, id);
parse.c~:    return vtable_size(lvtbl->args) - 1;
parse.c~:    vtable_add(lvtbl->vars, id);
parse.c~:    return vtable_size(lvtbl->vars) - 1;
parse.c~:    vars = lvtbl->vars;
parse.c~:    args = lvtbl->args;
parse.c~:    while (vars && POINTER_P(vars->prev)) {
parse.c~:	vars = vars->prev;
parse.c~:	args = args->prev;
parse.c~:    if (vars && vars->prev == DVARS_INHERIT) {
parse.c~:    lvtbl->args = vtable_alloc(lvtbl->args);
parse.c~:    lvtbl->vars = vtable_alloc(lvtbl->vars);
parse.c~:    tmp = lvtbl->args;
parse.c~:    lvtbl->args = lvtbl->args->prev;
parse.c~:    tmp = lvtbl->vars;
parse.c~:    lvtbl->vars = lvtbl->vars->prev;
parse.c~:    return POINTER_P(lvtbl->vars) && lvtbl->vars->prev != DVARS_TOPSCOPE;
parse.c~:    args = lvtbl->args;
parse.c~:    vars = lvtbl->vars;
parse.c~:	args = args->prev;
parse.c~:	vars = vars->prev;
parse.c~:    return (vtable_included(lvtbl->args, id) ||
parse.c~:	    vtable_included(lvtbl->vars, id));
parse.c~:    else if (parser->enc == rb_usascii_encoding()) {
parse.c~:    struct parser_params* parser = arg->parser;
parse.c~:    rb_encoding *enc = arg->enc;
parse.c~:    int len = name_end - name;
parse.c~:    arg->num++;
parse.c~:    if (arg->succ_block == 0) {
parse.c~:        arg->succ_block = NEW_BEGIN(0);
parse.c~:        arg->fail_block = NEW_BEGIN(0);
parse.c~:        rb_warningS("named capture conflicts a local variable - %s",
parse.c~:    arg->succ_block = block_append(arg->succ_block,
parse.c~:    arg->fail_block = block_append(arg->fail_block,
parse.c~:    onig_foreach_name(RREGEXP(regexp)->ptr, reg_named_capture_assign_iter, (void*)&arg);
parse.c~:    node = node->nd_body;
parse.c~:	node = node->nd_body;
parse.c~:	prelude->nd_body = node;
parse.c~:	scope->nd_body = prelude;
parse.c~:	scope->nd_body = node;
parse.c~:    node = node->nd_body;
parse.c~:	node = node->nd_body;
parse.c~:	prelude->nd_body = node;
parse.c~:	scope->nd_body = prelude;
parse.c~:	scope->nd_body = node;
parse.c~:    {'-',	"-(binary)"},
parse.c~:    {tUMINUS,	"-@"},
parse.c~:    if (key1->id == key2->id && key1->klass == key2->klass) {
parse.c~:    return (key->id << 8) ^ (key->klass >> 2);
parse.c~:    ID id = (ID)vtable_size(lvtbl->args) + (ID)vtable_size(lvtbl->vars);
parse.c~:    id += ((tLAST_TOKEN - ID_INTERNAL) >> ID_SCOPE_SHIFT) + 1;
parse.c~:      case '-':
parse.c~:      case '+': case '-':
parse.c~:    last = len-1;
parse.c~:	    if (!--mb) enc = rb_ascii8bit_encoding();
parse.c~:    if (m - name < len) id = ID_JUNK;
parse.c~:	 * rb_intern_str() taking care of code-range.
parse.c~:        if (RBASIC(str)->klass == 0)
parse.c~:            RBASIC(str)->klass = rb_cString;
parse.c~:            if (RBASIC(str)->klass == 0)
parse.c~:                RBASIC(str)->klass = rb_cString;
parse.c~: *  call-seq:
parse.c~:    VALUE ary = rb_ary_new2(global_symbols.sym_id->num_entries);
parse.c~:    parser->eofp = Qfalse;
parse.c~:    parser->parser_lex_strterm = 0;
parse.c~:    parser->parser_cond_stack = 0;
parse.c~:    parser->parser_cmdarg_stack = 0;
parse.c~:    parser->parser_class_nest = 0;
parse.c~:    parser->parser_paren_nest = 0;
parse.c~:    parser->parser_lpar_beg = 0;
parse.c~:    parser->parser_in_single = 0;
parse.c~:    parser->parser_in_def = 0;
parse.c~:    parser->parser_in_defined = 0;
parse.c~:    parser->parser_compile_for_eval = 0;
parse.c~:    parser->parser_cur_mid = 0;
parse.c~:    parser->parser_tokenbuf = NULL;
parse.c~:    parser->parser_tokidx = 0;
parse.c~:    parser->parser_toksiz = 0;
parse.c~:    parser->parser_heredoc_end = 0;
parse.c~:    parser->parser_command_start = Qtrue;
parse.c~:    parser->parser_deferred_nodes = 0;
parse.c~:    parser->parser_lex_pbeg = 0;
parse.c~:    parser->parser_lex_p = 0;
parse.c~:    parser->parser_lex_pend = 0;
parse.c~:    parser->parser_lvtbl = 0;
parse.c~:    parser->parser_ruby__end__seen = 0;
parse.c~:    parser->parser_ruby_sourcefile = 0;
parse.c~:    parser->is_ripper = 0;
parse.c~:    parser->parser_eval_tree_begin = 0;
parse.c~:    parser->parser_eval_tree = 0;
parse.c~:    parser->is_ripper = 1;
parse.c~:    parser->parser_ruby_sourcefile_string = Qnil;
parse.c~:    parser->delayed = Qnil;
parse.c~:    parser->result = Qnil;
parse.c~:    parser->parsing_thread = Qnil;
parse.c~:    parser->toplevel_p = Qtrue;
parse.c~:    parser->heap = NULL;
parse.c~:    parser->enc = rb_usascii_encoding();
parse.c~:    rb_gc_mark((VALUE)p->parser_lex_strterm);
parse.c~:    rb_gc_mark((VALUE)p->parser_deferred_nodes);
parse.c~:    rb_gc_mark(p->parser_lex_input);
parse.c~:    rb_gc_mark(p->parser_lex_lastline);
parse.c~:    rb_gc_mark(p->parser_lex_nextline);
parse.c~:    rb_gc_mark((VALUE)p->parser_eval_tree_begin) ;
parse.c~:    rb_gc_mark((VALUE)p->parser_eval_tree) ;
parse.c~:    rb_gc_mark(p->debug_lines);
parse.c~:    rb_gc_mark(p->parser_ruby_sourcefile_string);
parse.c~:    rb_gc_mark(p->delayed);
parse.c~:    rb_gc_mark(p->value);
parse.c~:    rb_gc_mark(p->result);
parse.c~:    rb_gc_mark(p->parsing_thread);
parse.c~:    rb_gc_mark((VALUE)p->heap);
parse.c~:    if (p->parser_tokenbuf) {
parse.c~:        xfree(p->parser_tokenbuf);
parse.c~:    for (local = p->parser_lvtbl; local; local = prev) {
parse.c~:	if (local->vars) xfree(local->vars);
parse.c~:	prev = local->prev;
parse.c~:    xfree(p->parser_ruby_sourcefile);
parse.c~: *  call-seq:
parse.c~: *    ripper#end_seen?   -> Boolean
parse.c~: *  call-seq:
parse.c~: *    ripper#encoding   -> encoding
parse.c~:    return rb_enc_from_encoding(parser->enc);
parse.c~: *  call-seq:
parse.c~: *    ripper.yydebug   -> true or false
parse.c~: *  call-seq:
parse.c~:#define NEWHEAP() rb_node_newnode(NODE_ALLOCA, 0, (VALUE)parser->heap, 0)
parse.c~:#define ADD2HEAP(n, c, p) ((parser->heap = (n))->u1.node = (p), \
parse.c~:			   (n)->u3.cnt = (c), (p))
parse.c~:    if (ptr && (n = parser->heap) != NULL) {
parse.c~:	    if (n->u1.node == ptr) {
parse.c~:		n->u1.node = ptr = xrealloc(ptr, size);
parse.c~:		if (n->u3.cnt) n->u3.cnt = cnt;
parse.c~:	} while ((n = n->u2.node) != NULL);
parse.c~:    NODE **prev = &parser->heap, *n;
parse.c~:	if (n->u1.node == ptr) {
parse.c~:	    *prev = n->u2.node;
parse.c~:	prev = &n->u2.node;
parse.c~:    return rb_funcall(parser->value, mid, 0);
parse.c~:    return rb_funcall(parser->value, mid, 1, a);
parse.c~:    return rb_funcall(parser->value, mid, 2, a, b);
parse.c~:    return rb_funcall(parser->value, mid, 3, a, b, c);
parse.c~:    return rb_funcall(parser->value, mid, 4, a, b, c, d);
parse.c~:    return rb_funcall(parser->value, mid, 5, a, b, c, d, e);
parse.c~:    for (a = keyword_to_name; a->id; a++) {
parse.c~:        if (a->id == id)
parse.c~:            return a->name;
parse.c~:    rb_funcall(parser->value, rb_intern("compile_error"), 1, str);
parse.c~:    rb_funcall(parser->value, rb_intern("warn"), 1, STR_NEW2(fmt));
parse.c~:    rb_funcall(parser->value, rb_intern("warn"), 2,
parse.c~:    rb_funcall(parser->value, rb_intern("warn"), 2,
parse.c~:    rb_funcall(parser->value, rb_intern("warning"), 1, STR_NEW2(fmt));
parse.c~:    rb_funcall(parser->value, rb_intern("warning"), 2,
parse.c~:    p->value = self;
parse.c~:#define ripper_initialized_p(r) ((r)->parser_lex_input != 0)
parse.c~: *  call-seq:
parse.c~: *    Ripper.new(src, filename="(ripper)", lineno=1) -> ripper
parse.c~:        parser->parser_lex_gets = ripper_lex_get_generic;
parse.c~:        parser->parser_lex_gets = lex_get_str;
parse.c~:    parser->parser_lex_input = src;
parse.c~:    parser->eofp = Qfalse;
parse.c~:    parser->parser_ruby_sourcefile_string = fname;
parse.c~:    parser->parser_ruby_sourcefile = RSTRING_PTR(fname);
parse.c~:    parser->parser_ruby_sourceline = NIL_P(lineno) ? 0 : NUM2INT(lineno) - 1;
parse.c~:    return parser->result;
parse.c~:    parser->parsing_thread = Qnil;
parse.c~: *  call-seq:
parse.c~:    if (!NIL_P(parser->parsing_thread)) {
parse.c~:        if (parser->parsing_thread == rb_thread_current())
parse.c~:            rb_raise(rb_eArgError, "Ripper#parse is not multithread-safe");
parse.c~:    parser->parsing_thread = rb_thread_current();
parse.c~:    return parser->result;
parse.c~: *  call-seq:
parse.c~: *    ripper#column   -> Integer
parse.c~:    if (NIL_P(parser->parsing_thread)) return Qnil;
parse.c~:    col = parser->tokp - parser->parser_lex_pbeg;
parse.c~: *  call-seq:
parse.c~: *    ripper#lineno   -> Integer
parse.c~:    if (NIL_P(parser->parsing_thread)) return Qnil;
parse.c~:    return INT2NUM(parser->parser_ruby_sourceline);
parse.c~:    rb_define_method(Ripper, "initialize", ripper_initialize, -1);
parse.h:/* Skeleton interface for Bison's Yacc-like parsers in C
parse.h:   Boston, MA 02110-1301, USA.  */
ãã¤ããªã¼ã»ãã¡ã¤ã«parse.oã¯ä¸è´ãã¾ãã
parse.y:  parse.y -
parse.y:  Copyright (C) 1993-2007 Yukihiro Matsumoto
parse.y:    EXPR_BEG,			/* ignore newline, +/- is a sign. */
parse.y:    EXPR_END,			/* newline significant, +/- is an operator. */
parse.y:    EXPR_ARG,			/* newline significant, +/- is an operator. */
parse.y:    EXPR_CMDARG,		/* newline significant, +/- is an operator. */
parse.y:    EXPR_MID,			/* newline significant, +/- is an operator. */
parse.y:        return tbl->pos;
parse.y:    tbl->pos = 0;
parse.y:    tbl->capa = 8;
parse.y:    tbl->tbl = ALLOC_N(ID, tbl->capa);
parse.y:    tbl->prev = prev;
parse.y:        if (tbl->tbl) {
parse.y:            xfree(tbl->tbl);
parse.y:    if (tbl->pos == tbl->capa) {
parse.y:        tbl->capa = tbl->capa * 2;
parse.y:        REALLOC_N(tbl->tbl, ID, tbl->capa);
parse.y:    tbl->tbl[tbl->pos++] = id;
parse.y:        for (i = 0; i < tbl->pos; i++) {
parse.y:            if (tbl->tbl[i] == id) {
parse.y:    |-----------+--------------+------------|
parse.y:                |<------------>|
parse.y:#define UTF8_ENC() (parser->utf8 ? parser->utf8 : \
parse.y:		    (parser->utf8 = rb_utf8_encoding()))
parse.y:#define STR_NEW(p,n) rb_enc_str_new((p),(n),parser->enc)
parse.y:#define STR_NEW0() rb_enc_str_new(0,0,parser->enc)
parse.y:#define STR_NEW2(p) rb_enc_str_new((p),strlen(p),parser->enc)
parse.y:#define STR_NEW3(p,n,e,func) parser_str_new((p),(n),(e),(func),parser->enc)
parse.y:#define TOK_INTERN(mb) rb_intern3(tok(), toklen(), parser->enc)
parse.y:#define lex_strterm		(parser->parser_lex_strterm)
parse.y:#define lex_state		(parser->parser_lex_state)
parse.y:#define cond_stack		(parser->parser_cond_stack)
parse.y:#define cmdarg_stack		(parser->parser_cmdarg_stack)
parse.y:#define class_nest		(parser->parser_class_nest)
parse.y:#define paren_nest		(parser->parser_paren_nest)
parse.y:#define lpar_beg		(parser->parser_lpar_beg)
parse.y:#define in_single		(parser->parser_in_single)
parse.y:#define in_def			(parser->parser_in_def)
parse.y:#define compile_for_eval	(parser->parser_compile_for_eval)
parse.y:#define cur_mid			(parser->parser_cur_mid)
parse.y:#define in_defined		(parser->parser_in_defined)
parse.y:#define tokenbuf		(parser->parser_tokenbuf)
parse.y:#define tokidx			(parser->parser_tokidx)
parse.y:#define toksiz			(parser->parser_toksiz)
parse.y:#define lex_input		(parser->parser_lex_input)
parse.y:#define lex_lastline		(parser->parser_lex_lastline)
parse.y:#define lex_nextline		(parser->parser_lex_nextline)
parse.y:#define lex_pbeg		(parser->parser_lex_pbeg)
parse.y:#define lex_p			(parser->parser_lex_p)
parse.y:#define lex_pend		(parser->parser_lex_pend)
parse.y:#define heredoc_end		(parser->parser_heredoc_end)
parse.y:#define command_start		(parser->parser_command_start)
parse.y:#define deferred_nodes		(parser->parser_deferred_nodes)
parse.y:#define lex_gets_ptr		(parser->parser_lex_gets_ptr)
parse.y:#define lex_gets		(parser->parser_lex_gets)
parse.y:#define lvtbl			(parser->parser_lvtbl)
parse.y:#define ruby__end__seen		(parser->parser_ruby__end__seen)
parse.y:#define ruby_sourceline		(parser->parser_ruby_sourceline)
parse.y:#define ruby_sourcefile		(parser->parser_ruby_sourcefile)
parse.y:#define yydebug			(parser->parser_yydebug)
parse.y:#define ruby_eval_tree		(parser->parser_eval_tree)
parse.y:#define ruby_eval_tree_begin	(parser->parser_eval_tree_begin)
parse.y:#define ruby_debug_lines	(parser->debug_lines)
parse.y:#define ruby_coverage		(parser->coverage)
parse.y:#define SIGN_EXTEND(x,n) (((1<<(n)-1)^((x)&~(~0<<(n))))-(1<<(n)-1))
parse.y:#define nd_term(node) ((signed short)(node)->u2.id)
parse.y:#define nd_term(node) SIGN_EXTEND((node)->u2.id, CHAR_BIT*2)
parse.y:#define nd_paren(node) (char)((node)->u2.id >> CHAR_BIT*2)
parse.y:# define compile_error parser->nerr++,rb_compile_error
parse.y:%parse-param {struct parser_params *parser}
parse.y:%token tUMINUS		/* unary- */
parse.y:%token <id> tOP_ASGN	/* +=, -=  etc. */
parse.y:%token tLAMBDA		/* -> */
parse.y:%left  '+' '-'
parse.y:				while (node->nd_next) {
parse.y:				    node = node->nd_next;
parse.y:				void_expr(node->nd_head);
parse.y:			parser->result = dispatch1(program, $$);
parse.y:			sprintf(buf, "$%c", (char)$3->nd_nth);
parse.y:			    $$ = NEW_WHILE(cond($3), $1->nd_body, 0);
parse.y:			    $$ = NEW_UNTIL(cond($3), $1->nd_body, 0);
parse.y:			$1->nd_value = $3;
parse.y:			    ID vid = $1->nd_vid;
parse.y:				$1->nd_value = $3;
parse.y:				    $$->nd_aid = vid;
parse.y:				$1->nd_value = $3;
parse.y:				$$->nd_value = NEW_CALL(gettable(vid), $2, NEW_LIST($3));
parse.y:			$1->nd_value = $3;
parse.y:			$1->nd_value = $3;
parse.y:		        $3->nd_iter = NEW_FCALL($1, $2);
parse.y:		        $5->nd_iter = NEW_CALL($1, $3, $4);
parse.y:		        $5->nd_iter = NEW_CALL($1, $3, $4);
parse.y:			$$ = NEW_MASGN($1, -1);
parse.y:			$$ = NEW_MASGN($1, NEW_POSTARG(-1, $4));
parse.y:			$$ = NEW_MASGN(0, -1);
parse.y:			$$ = NEW_MASGN(0, NEW_POSTARG(-1, $3));
parse.y:		| '-'		{ ifndef_ripper($$ = '-'); }
parse.y:			    ID vid = $1->nd_vid;
parse.y:				$1->nd_value = $3;
parse.y:				    $$->nd_aid = vid;
parse.y:				$1->nd_value = $3;
parse.y:				$$->nd_value = NEW_CALL(gettable(vid), $2, NEW_LIST($3));
parse.y:			    ID vid = $1->nd_vid;
parse.y:				$1->nd_value = $3;
parse.y:				    $$->nd_aid = vid;
parse.y:				$1->nd_value = $3;
parse.y:				$$->nd_value = NEW_CALL(gettable(vid), $2, NEW_LIST($3));
parse.y:			yyerror("constant re-assignment");
parse.y:			yyerror("constant re-assignment");
parse.y:			if (nd_type($1) == NODE_LIT && FIXNUM_P($1->nd_lit) &&
parse.y:			    nd_type($3) == NODE_LIT && FIXNUM_P($3->nd_lit)) {
parse.y:			if (nd_type($1) == NODE_LIT && FIXNUM_P($1->nd_lit) &&
parse.y:			    nd_type($3) == NODE_LIT && FIXNUM_P($3->nd_lit)) {
parse.y:		| arg '-' arg
parse.y:			$$ = call_bin_op($1, '-', $3);
parse.y:			$$ = dispatch3(binary, $1, ID2SYM('-'), $3);
parse.y:			$$ = dispatch2(unary, ripper_intern("-@"), $$);
parse.y:			$$ = dispatch2(unary, ripper_intern("-@"), $$);
parse.y:			$$ = dispatch2(unary, ripper_intern("-@"), $2);
parse.y:                        if (nd_type($1) == NODE_LIT && TYPE($1->nd_lit) == T_REGEXP) {
parse.y:                            $$ = reg_named_capture_assign($1->nd_lit, $$);
parse.y:			$2->nd_iter = NEW_FCALL($1, 0);
parse.y:			fixpos($2->nd_iter, $2);
parse.y:			block_dup_check($1->nd_args, $2);
parse.y:			$2->nd_iter = $1;
parse.y:			    m->nd_next = block_append(
parse.y:				$2->nd_value = NEW_DVAR(id);
parse.y:				m->nd_plen = 1;
parse.y:				m->nd_next = $2;
parse.y:				m->nd_next = node_assign(NEW_MASGN(NEW_LIST($2), 0), NEW_DVAR(id));
parse.y:			fixpos($$->nd_defn, $4);
parse.y:			in_def--;
parse.y:			fixpos($$->nd_defn, $2);
parse.y:			in_single--;
parse.y:			$$ = NEW_MASGN($1, -1);
parse.y:			$$ = NEW_MASGN($1, NEW_POSTARG(-1, $5));
parse.y:			$$ = NEW_MASGN(0, -1);
parse.y:			$$ = NEW_MASGN(0, NEW_POSTARG(-1, $3));
parse.y:			$$->nd_body = NEW_SCOPE($2->nd_head, $3);
parse.y:			    block_dup_check($1->nd_args, $2);
parse.y:			$2->nd_iter = $1;
parse.y:			nd_set_line($$->nd_body, $<num>2);
parse.y:			nd_set_line($$->nd_body->nd_body, $<num>2);
parse.y:				VALUE src = node->nd_lit;
parse.y:				node->nd_lit = reg_compile(src, options);
parse.y:			    node->nd_cflag = options & RE_OPTION_MASK;
parse.y:                            reg_fragment_check(node->nd_lit, options);
parse.y:                            for (list = node->nd_next; list; list = list->nd_next) {
parse.y:                                if (nd_type(list->nd_head) == NODE_STR) {
parse.y:                                    reg_fragment_check(list->nd_head->nd_lit, options);
parse.y:			if ($3) $3->flags &= ~NODE_FL_NEWLINE;
parse.y:				lit = $$->nd_lit;
parse.y:				$$->nd_lit = ID2SYM(rb_intern_str(lit));
parse.y:			$$ = dispatch2(unary, ripper_intern("-@"), $2);
parse.y:			$$ = dispatch2(unary, ripper_intern("-@"), $2);
parse.y:			    $2->nd_value = NEW_DVAR(tid);
parse.y:			    $2->nd_value = NEW_LVAR(tid);
parse.y:			$$->nd_next = $2;
parse.y:			$$->nd_plen++;
parse.y:			$$->nd_next = block_append($$->nd_next, $3->nd_next);
parse.y:			while (opts->nd_next) {
parse.y:			    opts = opts->nd_next;
parse.y:			opts->nd_next = $3;
parse.y:			while (opts->nd_next) {
parse.y:			    opts = opts->nd_next;
parse.y:			opts->nd_next = $3;
parse.y:# define yylval  (*((YYSTYPE*)(parser->parser_yylval)))
parse.y:#define ripper_flush(p) (p->tokp = p->parser_lex_p)
parse.y:    if (lex_p < parser->tokp) rb_raise(rb_eRuntimeError, "lex_p < tokp");
parse.y:    if (lex_p == parser->tokp) return;
parse.y:    str = STR_NEW(parser->tokp, lex_p - parser->tokp);
parse.y:    const char *saved_tokp = parser->tokp;
parse.y:    ruby_sourceline = parser->delayed_line;
parse.y:    parser->tokp = lex_pbeg + parser->delayed_col;
parse.y:    yylval.val = ripper_dispatch1(parser, ripper_token2eventid(t), parser->delayed);
parse.y:    parser->delayed = Qnil;
parse.y:    parser->tokp = saved_tokp;
parse.y:# define SIGN_EXTEND_CHAR(c) ((((unsigned char)(c)) ^ 128) - 128)
parse.y:#define parser_encoding_name()  (parser->enc->name)
parse.y:#define parser_mbclen()  mbclen((lex_p-1),lex_pend,parser->enc)
parse.y:#define parser_precise_mbclen()  rb_enc_precise_mbclen((lex_p-1),lex_pend,parser->enc)
parse.y:#define parser_is_identchar() (!parser->eofp && is_identchar((lex_p-1),lex_pend,parser->enc))
parse.y:#define parser_isascii() ISASCII(*(lex_p-1))
parse.y:    const char *p, *pend = lex_p - strlen(token);
parse.y:	    column = (((column - 1) / 8) + 1) * 8;
parse.y:    const char *p, *pend = lex_p - strlen(token);
parse.y:    ptinfo->token = token;
parse.y:    ptinfo->linenum = ruby_sourceline;
parse.y:    ptinfo->column = token_info_get_column(parser, token);
parse.y:    ptinfo->nonspc = token_info_has_nonspaces(parser, token);
parse.y:    ptinfo->next = parser->parser_token_info;
parse.y:    parser->parser_token_info = ptinfo;
parse.y:    token_info *ptinfo = parser->parser_token_info;
parse.y:    parser->parser_token_info = ptinfo->next;
parse.y:    if (token_info_get_column(parser, token) == ptinfo->column) { /* OK */
parse.y:    if (linenum == ptinfo->linenum) { /* SKIP */
parse.y:    if (token_info_has_nonspaces(parser, token) || ptinfo->nonspc) { /* SKIP */
parse.y:	       token, ptinfo->token, ptinfo->linenum);
parse.y:	p--;
parse.y:    len = pe - p;
parse.y:	    if (lex_p - p > max_line_margin) {
parse.y:		p = rb_enc_prev_char(p, lex_p - max_line_margin, pe, rb_enc_get(lex_lastline));
parse.y:	    if (pe - lex_p > max_line_margin) {
parse.y:	    len = pe - p;
parse.y:	i = lex_p - p;
parse.y:    if (RTEST(coverages) && RBASIC(coverages)->klass == 0) {
parse.y:	RBASIC(lines)->klass = 0;
parse.y:	RARRAY(lines)->as.heap.len = n;
parse.y:    if (strcmp(ruby_sourcefile, "-e") == 0)
parse.y:	    } while (--n);
parse.y:    if (parser->nerr) {
parse.y:	    scope->nd_body = NEW_PRELUDE(ruby_eval_tree_begin, scope->nd_body);
parse.y:    ruby_sourceline = line - 1;
parse.y:    lex_gets_ptr = end - RSTRING_PTR(s);
parse.y:    return rb_enc_str_new(beg, end - beg, rb_enc_get(s));
parse.y:    VALUE line = (*parser->parser_lex_gets)(parser, parser->parser_lex_input);
parse.y:#define lex_goto_eol(parser) (parser->parser_lex_p = parser->parser_lex_pend)
parse.y:	    if (parser->eofp)
parse.y:		return -1;
parse.y:		parser->eofp = Qtrue;
parse.y:		return -1;
parse.y:	    if (parser->tokp < lex_pend) {
parse.y:		if (NIL_P(parser->delayed)) {
parse.y:		    parser->delayed = rb_str_buf_new(1024);
parse.y:		    rb_str_buf_cat(parser->delayed,
parse.y:				   parser->tokp, lex_pend - parser->tokp);
parse.y:		    parser->delayed_line = ruby_sourceline;
parse.y:		    parser->delayed_col = parser->tokp - lex_pbeg;
parse.y:		    rb_str_buf_cat(parser->delayed,
parse.y:				   parser->tokp, lex_pend - parser->tokp);
parse.y:	    parser->line_count++;
parse.y:    if (c == -1) return;
parse.y:    lex_p--;
parse.y:    if (lex_p > lex_pbeg && lex_p[0] == '\n' && lex_p[-1] == '\r') {
parse.y:	lex_p--;
parse.y:#define toklast() (tokidx>0?tokenbuf[tokidx-1]:0)
parse.y:    return &tokenbuf[tokidx-n];
parse.y:#define tokcopy(n) memcpy(tokspace(n), lex_p - (n), (n))
parse.y:      case 'r':	/* carriage-return */
parse.y:      case 'f':	/* form-feed */
parse.y:	if ((c = nextc()) != '-') {
parse.y:	else if (c == -1 || !ISASCII(c)) goto eof;
parse.y:	if ((c = nextc()) != '-') {
parse.y:	else if (c == -1 || !ISASCII(c)) goto eof;
parse.y:      case -1:
parse.y:	    oct = scan_oct(--lex_p, 3, &numlen);
parse.y:	if ((c = nextc()) != '-') {
parse.y:	if ((c = nextc()) != '-') {
parse.y:	else if (c == -1) goto eof;
parse.y:      case -1:
parse.y:	return -1;
parse.y:	compile_error(PARSER_ARG "unknown regexp option%s - %s",
parse.y:    if (RBASIC(str)->flags & RSTRING_NOEMBED)
parse.y:	return -1;
parse.y:    lex_p += --len;
parse.y:	int len = sizeof(mixed_msg) - 4;	\
parse.y:    while ((c = nextc()) != -1) {
parse.y:	    --*nest;
parse.y:	    const char *beg = lex_p - 1;
parse.y:			return -1;
parse.y:	    if (tokadd_mbchar(c) == -1) return -1;
parse.y:    int func = quote->nd_func;
parse.y:    rb_encoding *enc = parser->enc;
parse.y:    if (func == -1) return tSTRING_END;
parse.y:    if (c == term && !quote->nd_nest) {
parse.y:	    quote->nd_func = -1;
parse.y:    if (tokadd_string(func, term, paren, &quote->nd_nest,
parse.y:		      &enc) == -1) {
parse.y:	    if (parser->eofp)
parse.y:	    if (parser->eofp)
parse.y:    if (c == '-') {
parse.y:	while ((c = nextc()) != -1 && c != term) {
parse.y:	    if (tokadd_mbchar(c) == -1) return 0;
parse.y:	if (c == -1) {
parse.y:		pushback('-');
parse.y:	    if (tokadd_mbchar(c) == -1) return 0;
parse.y:	} while ((c = nextc()) != -1 && parser_is_identchar());
parse.y:    len = lex_p - lex_pbeg;
parse.y:    if (!NIL_P(parser->delayed))
parse.y:    line = here->nd_orig;
parse.y:    lex_p = lex_pbeg + here->nd_nth;
parse.y:    dispose_string(here->nd_lit);
parse.y:    n= lex_pend - (p + len);
parse.y:    eos = RSTRING_PTR(here->nd_lit);
parse.y:    len = RSTRING_LEN(here->nd_lit) - 1;
parse.y:    if ((c = nextc()) == -1) {
parse.y:		switch (pend[-1]) {
parse.y:		    if (--pend == p || pend[-1] != '\r') {
parse.y:		    --pend;
parse.y:		rb_str_cat(str, p, pend - p);
parse.y:		str = STR_NEW(p, pend - p);
parse.y:	    if (nextc() == -1) {
parse.y:	rb_encoding *enc = parser->enc;
parse.y:	    if ((c = tokadd_string(func, '\n', 0, NULL, &enc)) == -1) {
parse.y:		if (parser->eofp) goto error;
parse.y:	    if ((c = nextc()) == -1) goto error;
parse.y:    lex_strterm = NEW_STRTERM(-1, 0, 0);
parse.y:/* emacsen -*- hack */
parse.y:    if (len > 5 && name[nlen = len - 5] == '-') {
parse.y:    if (len > 4 && name[nlen = len - 5] == '-') {
parse.y:    parser->enc = enc;
parse.y:    const char *p = lex_pbeg, *pend = lex_p - 1;
parse.y:    if (parser->line_count != (parser->has_shebang ? 2 : 1)) return 0;
parse.y:	  case '-':
parse.y:	    if (str[i-1] == '*' && str[i-2] == '-') {
parse.y:	    if (str[i+1] != '-') {
parse.y:	    else if (str[i-1] != '-') {
parse.y:    if (!(end = magic_comment_marker(beg, str + len - beg))) return Qfalse;
parse.y:    len = end - beg - 3;
parse.y:	for (; len > 0 && *str; str++, --len) {
parse.y:	for (beg = str; len > 0; str++, --len) {
parse.y:	for (end = str; len > 0 && ISSPACE(*str); str++, --len);
parse.y:	do str++; while (--len > 0 && ISSPACE(*str));
parse.y:	    for (vbeg = ++str; --len > 0 && *str != '"'; str++) {
parse.y:		    --len;
parse.y:		--len;
parse.y:	    for (vbeg = str; len > 0 && *str != '"' && *str != ';' && !ISSPACE(*str); --len, str++);
parse.y:	while (len > 0 && (*str == ';' || ISSPACE(*str))) --len, str++;
parse.y:	n = end - beg;
parse.y:	    if (*s == '-') *s = '_';
parse.y:	    if (STRNCASECMP(p->name, s, n) == 0) {
parse.y:		n = vend - vbeg;
parse.y:		if (p->length) {
parse.y:		    n = (*p->length)(parser, vbeg, n);
parse.y:		(*p->func)(parser, s, RSTRING_PTR(val));
parse.y:	if (send - str <= 6) return;
parse.y:	if (STRNCASECMP(str-6, "coding", 6) == 0) break;
parse.y:    while ((*str == '-' || *str == '_' || ISALNUM(*str)) && ++str < send);
parse.y:    s = rb_str_new(beg, parser_encode_length(parser, beg, str - beg));
parse.y:	if (peek('!')) parser->has_shebang = 1;
parse.y:      case 0xef:		/* UTF-8 BOM marker */
parse.y:	if (lex_pend - lex_p >= 2 &&
parse.y:	    parser->enc = rb_utf8_encoding();
parse.y:    parser->enc = rb_enc_get(lex_lastline);
parse.y:      case -1:			/* end of script. */
parse.y:	if (!parser_magic_comment(parser, lex_p, lex_pend - lex_p)) {
parse.y:		--ruby_sourceline;
parse.y:	      case -1:		/* EOF no decrement*/
parse.y:		if (c != -1) {
parse.y:		    parser->tokp = lex_p;
parse.y:		    if (c == -1) {
parse.y:	if (c == -1) {
parse.y:	if (rb_enc_isspace(c, parser->enc)) {
parse.y:	enc = parser->enc;
parse.y:	    if (tokadd_mbchar(c) == -1) return 0;
parse.y:	else if ((rb_enc_isalnum(c, parser->enc) || c == '_') &&
parse.y:		 lex_p < lex_pend && is_identchar(lex_p, lex_pend, parser->enc)) {
parse.y:	    if (c != -1 && ISDIGIT(c)) {
parse.y:      case '-':
parse.y:	    return '-';
parse.y:            set_yylval_id('-');
parse.y:	    if (c != -1 && ISDIGIT(c)) {
parse.y:	return '-';
parse.y:	if (c != -1 && ISDIGIT(c)) {
parse.y:	    if (c == '-' || c == '+') {
parse.y:		    if (c != -1 && ISXDIGIT(c)) {
parse.y:			} while ((c = nextc()) != -1);
parse.y:			} while ((c = nextc()) != -1);
parse.y:		    if (c != -1 && ISDIGIT(c)) {
parse.y:			} while ((c = nextc()) != -1);
parse.y:		    if (c == -1 || c == '_' || !ISDIGIT(c)) {
parse.y:		    } while ((c = nextc()) != -1);
parse.y:			if (c0 == -1 || !ISDIGIT(c0)) {
parse.y:		    if (c != '-' && c != '+') continue;
parse.y:	paren_nest--;
parse.y:	if (lex_state == EXPR_END || lex_state == EXPR_ENDARG || (c != -1 && ISSPACE(c))) {
parse.y:	    --paren_nest;
parse.y:	    if (c == -1 || !ISALNUM(c)) {
parse.y:		if (rb_enc_isalnum(term, parser->enc) || !parser_isascii()) {
parse.y:	    if (c == -1 || term == -1) {
parse.y:	  case '~':		/* $~: match-data */
parse.y:	  case '-':
parse.y:		if (tokadd_mbchar(c) == -1) return 0;
parse.y:	    } while (c != -1 && ISDIGIT(c));
parse.y:	if (c != -1 && ISDIGIT(c)) {
parse.y:	    parser->eofp = Qtrue;
parse.y:	    return -1;
parse.y:	if (tokadd_mbchar(c) == -1) return 0;
parse.y:		    lex_state = kw->state;
parse.y:                        set_yylval_id(rb_intern(kw->name));
parse.y:			return kw->id[0];
parse.y:		    if (kw->id[0] == keyword_do) {
parse.y:			    --paren_nest;
parse.y:			return kw->id[0];
parse.y:			if (kw->id[0] != kw->id[1])
parse.y:			return kw->id[1];
parse.y:    parser->parser_yylval = lval;
parse.y:    parser->parser_yylval->val = Qundef;
parse.y:    if (!NIL_P(parser->delayed)) {
parse.y:	node->flags |= NODE_FL_NEWLINE;
parse.y:	end->nd_end = end;
parse.y:	end = h->nd_end;
parse.y:    nd = end->nd_head;
parse.y:	tail->nd_end = tail;
parse.y:    end->nd_next = tail;
parse.y:    h->nd_end = tail->nd_end;
parse.y:    if (list->nd_next) {
parse.y:	last = list->nd_next->nd_end;
parse.y:    list->nd_alen += 1;
parse.y:    last->nd_next = NEW_LIST(item);
parse.y:    list->nd_next->nd_end = last->nd_next;
parse.y:    if (head->nd_next) {
parse.y:	last = head->nd_next->nd_end;
parse.y:    head->nd_alen += tail->nd_alen;
parse.y:    last->nd_next = tail;
parse.y:    if (tail->nd_next) {
parse.y:	head->nd_next->nd_end = tail->nd_next->nd_end;
parse.y:	head->nd_next->nd_end = tail;
parse.y:	    if (!literal_concat0(parser, head->nd_lit, tail->nd_lit)) {
parse.y:	    if (!literal_concat0(parser, head->nd_lit, tail->nd_lit))
parse.y:	    tail->nd_lit = head->nd_lit;
parse.y:	    tail->nd_head = NEW_STR(tail->nd_lit);
parse.y:	    head->nd_alen = 1;
parse.y:	    if (TYPE(node1->nd_lit) == T_REGEXP) {
parse.y:	    if (TYPE(node2->nd_lit) == T_REGEXP) {
parse.y:	return NEW_LIT(rb_enc_from_encoding(parser->enc));
parse.y:	    rb_warningS("shadowing outer local variable - %s", rb_id2name(name));
parse.y:	    vtable_add(lvtbl->vars, name);
parse.y:	compile_error(PARSER_ARG "invalid local variable - %s",
parse.y:	compile_error(PARSER_ARG "Can't set variable $%ld", node->nd_nth);
parse.y:	compile_error(PARSER_ARG "Can't set variable $%c", (int)node->nd_nth);
parse.y:	node1->nd_iter = arg_concat(node1->nd_iter, node2);
parse.y:	node1->nd_body = list_concat(NEW_LIST(node1->nd_body), node2);
parse.y:	    nd_type(node1->nd_body) != NODE_ARRAY) break;
parse.y:	node1->nd_body = list_concat(node1->nd_body, node2);
parse.y:	node1->nd_head = arg_append(node1->nd_head, node2);
parse.y:	node1->nd_body = list_append(NEW_LIST(node1->nd_body), node2);
parse.y:    if (nd_type(node) == NODE_SPLAT) node = node->nd_head;
parse.y:	lhs->nd_value = rhs;
parse.y:	lhs->nd_args = arg_append(lhs->nd_args, rhs);
parse.y:	    while (node->nd_next) {
parse.y:		node = node->nd_next;
parse.y:	    node = node->nd_head;
parse.y:	    node = node->nd_body;
parse.y:	    if (!node->nd_body) {
parse.y:		node = node->nd_else;
parse.y:	    else if (!node->nd_else) {
parse.y:		node = node->nd_body;
parse.y:	    if (!value_expr(node->nd_body)) return Qfalse;
parse.y:	    node = node->nd_else;
parse.y:	    node = node->nd_2nd;
parse.y:	switch (node->nd_mid) {
parse.y:	  case '-':
parse.y:	    useless = rb_id2name(node->nd_mid);
parse.y:	if (!node->nd_next) return;
parse.y:	void_expr0(node->nd_head);
parse.y:	node = node->nd_next;
parse.y:    while (n1 && nd_type(n1) == NODE_BEGIN && n1->nd_body) {
parse.y:	*n = n1 = n1->nd_body;
parse.y:    ((!node->n1) ? (node->n2 ? (body = &node->n2, 1) : 0) : \
parse.y:     (!node->n2) ? (body = &node->n1, 1) : \
parse.y:     (reduce_nodes(&node->n1), body = &node->n2, 1))
parse.y:	    *body = node = node->nd_stts;
parse.y:	    *body = node = node->nd_body;
parse.y:	    body = &node->nd_end->nd_head;
parse.y:	    body = &node->nd_body;
parse.y:    switch (nd_type(node->nd_value)) {
parse.y:	parser_warn(node->nd_value, "found = in conditional, should be ==");
parse.y:	next = node->nd_next;
parse.y:	head = node->nd_head;
parse.y:	    val = rb_range_new(head->nd_beg->nd_lit, head->nd_end->nd_lit,
parse.y:	    rb_gc_force_recycle((VALUE)head->nd_beg);
parse.y:	    rb_gc_force_recycle((VALUE)head->nd_end);
parse.y:	    head->nd_lit = val;
parse.y:    if (type == NODE_LIT && FIXNUM_P(node->nd_lit)) {
parse.y:	node->nd_1st = cond0(parser, node->nd_1st);
parse.y:	node->nd_2nd = cond0(parser, node->nd_2nd);
parse.y:	node->nd_beg = range_op(parser, node->nd_beg);
parse.y:	node->nd_end = range_op(parser, node->nd_end);
parse.y:	    int b = literal_node(node->nd_beg);
parse.y:	    int e = literal_node(node->nd_end);
parse.y:	if (TYPE(node->nd_lit) == T_REGEXP) {
parse.y:	while ((second = node->nd_2nd) != 0 && nd_type(second) == type) {
parse.y:	node->nd_2nd = NEW_NODE(type, second, right, 0);
parse.y:	    if (node->nd_next == 0) {
parse.y:		node = node->nd_head;
parse.y:    switch (TYPE(node->nd_lit)) {
parse.y:	node->nd_lit = LONG2FIX(-FIX2LONG(node->nd_lit));
parse.y:	node->nd_lit = rb_funcall(node->nd_lit,tUMINUS,0,0);
parse.y:	RFLOAT(node->nd_lit)->float_value = -RFLOAT_VALUE(node->nd_lit);
parse.y:	node2->nd_head = node1;
parse.y:    node = NEW_ARGS(m ? m->nd_plen : 0, o);
parse.y:    i1 = m ? m->nd_next : 0;
parse.y:    node->nd_next = NEW_ARGS_AUX(r, b);
parse.y:	i2 = p->nd_next;
parse.y:	node->nd_next->nd_next = NEW_ARGS_AUX(p->nd_pid, p->nd_plen);
parse.y:	node->nd_next->nd_next = NEW_ARGS_AUX(0, 0);
parse.y:	node->nd_next->nd_next->nd_next = NEW_NODE(NODE_AND, i1, i2, 0);
parse.y:    local->prev = lvtbl;
parse.y:    local->args = vtable_alloc(0);
parse.y:    local->vars = vtable_alloc(inherit_dvars ? DVARS_INHERIT : DVARS_TOPSCOPE);
parse.y:    struct local_vars *local = lvtbl->prev;
parse.y:    vtable_free(lvtbl->args);
parse.y:    vtable_free(lvtbl->vars);
parse.y:            buf[i] = src->tbl[i];
parse.y:    int cnt = vtable_size(lvtbl->args) + vtable_size(lvtbl->vars);
parse.y:    vtable_tblcpy(buf+1, lvtbl->args);
parse.y:    vtable_tblcpy(buf+vtable_size(lvtbl->args)+1, lvtbl->vars);
parse.y:    vtable_add(lvtbl->args, id);
parse.y:    return vtable_size(lvtbl->args) - 1;
parse.y:    vtable_add(lvtbl->vars, id);
parse.y:    return vtable_size(lvtbl->vars) - 1;
parse.y:    vars = lvtbl->vars;
parse.y:    args = lvtbl->args;
parse.y:    while (vars && POINTER_P(vars->prev)) {
parse.y:	vars = vars->prev;
parse.y:	args = args->prev;
parse.y:    if (vars && vars->prev == DVARS_INHERIT) {
parse.y:    lvtbl->args = vtable_alloc(lvtbl->args);
parse.y:    lvtbl->vars = vtable_alloc(lvtbl->vars);
parse.y:    tmp = lvtbl->args;
parse.y:    lvtbl->args = lvtbl->args->prev;
parse.y:    tmp = lvtbl->vars;
parse.y:    lvtbl->vars = lvtbl->vars->prev;
parse.y:    return POINTER_P(lvtbl->vars) && lvtbl->vars->prev != DVARS_TOPSCOPE;
parse.y:    args = lvtbl->args;
parse.y:    vars = lvtbl->vars;
parse.y:	args = args->prev;
parse.y:	vars = vars->prev;
parse.y:    return (vtable_included(lvtbl->args, id) ||
parse.y:	    vtable_included(lvtbl->vars, id));
parse.y:    else if (parser->enc == rb_usascii_encoding()) {
parse.y:    struct parser_params* parser = arg->parser;
parse.y:    rb_encoding *enc = arg->enc;
parse.y:    int len = name_end - name;
parse.y:    arg->num++;
parse.y:    if (arg->succ_block == 0) {
parse.y:        arg->succ_block = NEW_BEGIN(0);
parse.y:        arg->fail_block = NEW_BEGIN(0);
parse.y:        rb_warningS("named capture conflicts a local variable - %s",
parse.y:    arg->succ_block = block_append(arg->succ_block,
parse.y:    arg->fail_block = block_append(arg->fail_block,
parse.y:    onig_foreach_name(RREGEXP(regexp)->ptr, reg_named_capture_assign_iter, (void*)&arg);
parse.y:    node = node->nd_body;
parse.y:	node = node->nd_body;
parse.y:	prelude->nd_body = node;
parse.y:	scope->nd_body = prelude;
parse.y:	scope->nd_body = node;
parse.y:    node = node->nd_body;
parse.y:	node = node->nd_body;
parse.y:	prelude->nd_body = node;
parse.y:	scope->nd_body = prelude;
parse.y:	scope->nd_body = node;
parse.y:    {'-',	"-(binary)"},
parse.y:    {tUMINUS,	"-@"},
parse.y:    if (key1->id == key2->id && key1->klass == key2->klass) {
parse.y:    return (key->id << 8) ^ (key->klass >> 2);
parse.y:    ID id = (ID)vtable_size(lvtbl->args) + (ID)vtable_size(lvtbl->vars);
parse.y:    id += ((tLAST_TOKEN - ID_INTERNAL) >> ID_SCOPE_SHIFT) + 1;
parse.y:      case '-':
parse.y:      case '+': case '-':
parse.y:    last = len-1;
parse.y:	    if (!--mb) enc = rb_ascii8bit_encoding();
parse.y:    if (m - name < len) id = ID_JUNK;
parse.y:	 * rb_intern_str() taking care of code-range.
parse.y:        if (RBASIC(str)->klass == 0)
parse.y:            RBASIC(str)->klass = rb_cString;
parse.y:            if (RBASIC(str)->klass == 0)
parse.y:                RBASIC(str)->klass = rb_cString;
parse.y: *  call-seq:
parse.y:    VALUE ary = rb_ary_new2(global_symbols.sym_id->num_entries);
parse.y:    parser->eofp = Qfalse;
parse.y:    parser->parser_lex_strterm = 0;
parse.y:    parser->parser_cond_stack = 0;
parse.y:    parser->parser_cmdarg_stack = 0;
parse.y:    parser->parser_class_nest = 0;
parse.y:    parser->parser_paren_nest = 0;
parse.y:    parser->parser_lpar_beg = 0;
parse.y:    parser->parser_in_single = 0;
parse.y:    parser->parser_in_def = 0;
parse.y:    parser->parser_in_defined = 0;
parse.y:    parser->parser_compile_for_eval = 0;
parse.y:    parser->parser_cur_mid = 0;
parse.y:    parser->parser_tokenbuf = NULL;
parse.y:    parser->parser_tokidx = 0;
parse.y:    parser->parser_toksiz = 0;
parse.y:    parser->parser_heredoc_end = 0;
parse.y:    parser->parser_command_start = Qtrue;
parse.y:    parser->parser_deferred_nodes = 0;
parse.y:    parser->parser_lex_pbeg = 0;
parse.y:    parser->parser_lex_p = 0;
parse.y:    parser->parser_lex_pend = 0;
parse.y:    parser->parser_lvtbl = 0;
parse.y:    parser->parser_ruby__end__seen = 0;
parse.y:    parser->parser_ruby_sourcefile = 0;
parse.y:    parser->is_ripper = 0;
parse.y:    parser->parser_eval_tree_begin = 0;
parse.y:    parser->parser_eval_tree = 0;
parse.y:    parser->is_ripper = 1;
parse.y:    parser->parser_ruby_sourcefile_string = Qnil;
parse.y:    parser->delayed = Qnil;
parse.y:    parser->result = Qnil;
parse.y:    parser->parsing_thread = Qnil;
parse.y:    parser->toplevel_p = Qtrue;
parse.y:    parser->heap = NULL;
parse.y:    parser->enc = rb_usascii_encoding();
parse.y:    rb_gc_mark((VALUE)p->parser_lex_strterm);
parse.y:    rb_gc_mark((VALUE)p->parser_deferred_nodes);
parse.y:    rb_gc_mark(p->parser_lex_input);
parse.y:    rb_gc_mark(p->parser_lex_lastline);
parse.y:    rb_gc_mark(p->parser_lex_nextline);
parse.y:    rb_gc_mark((VALUE)p->parser_eval_tree_begin) ;
parse.y:    rb_gc_mark((VALUE)p->parser_eval_tree) ;
parse.y:    rb_gc_mark(p->debug_lines);
parse.y:    rb_gc_mark(p->parser_ruby_sourcefile_string);
parse.y:    rb_gc_mark(p->delayed);
parse.y:    rb_gc_mark(p->value);
parse.y:    rb_gc_mark(p->result);
parse.y:    rb_gc_mark(p->parsing_thread);
parse.y:    rb_gc_mark((VALUE)p->heap);
parse.y:    if (p->parser_tokenbuf) {
parse.y:        xfree(p->parser_tokenbuf);
parse.y:    for (local = p->parser_lvtbl; local; local = prev) {
parse.y:	if (local->vars) xfree(local->vars);
parse.y:	prev = local->prev;
parse.y:    xfree(p->parser_ruby_sourcefile);
parse.y: *  call-seq:
parse.y: *    ripper#end_seen?   -> Boolean
parse.y: *  call-seq:
parse.y: *    ripper#encoding   -> encoding
parse.y:    return rb_enc_from_encoding(parser->enc);
parse.y: *  call-seq:
parse.y: *    ripper.yydebug   -> true or false
parse.y: *  call-seq:
parse.y:#define NEWHEAP() rb_node_newnode(NODE_ALLOCA, 0, (VALUE)parser->heap, 0)
parse.y:#define ADD2HEAP(n, c, p) ((parser->heap = (n))->u1.node = (p), \
parse.y:			   (n)->u3.cnt = (c), (p))
parse.y:    if (ptr && (n = parser->heap) != NULL) {
parse.y:	    if (n->u1.node == ptr) {
parse.y:		n->u1.node = ptr = xrealloc(ptr, size);
parse.y:		if (n->u3.cnt) n->u3.cnt = cnt;
parse.y:	} while ((n = n->u2.node) != NULL);
parse.y:    NODE **prev = &parser->heap, *n;
parse.y:	if (n->u1.node == ptr) {
parse.y:	    *prev = n->u2.node;
parse.y:	prev = &n->u2.node;
parse.y:    return rb_funcall(parser->value, mid, 0);
parse.y:    return rb_funcall(parser->value, mid, 1, a);
parse.y:    return rb_funcall(parser->value, mid, 2, a, b);
parse.y:    return rb_funcall(parser->value, mid, 3, a, b, c);
parse.y:    return rb_funcall(parser->value, mid, 4, a, b, c, d);
parse.y:    return rb_funcall(parser->value, mid, 5, a, b, c, d, e);
parse.y:    for (a = keyword_to_name; a->id; a++) {
parse.y:        if (a->id == id)
parse.y:            return a->name;
parse.y:    rb_funcall(parser->value, rb_intern("compile_error"), 1, str);
parse.y:    rb_funcall(parser->value, rb_intern("warn"), 1, STR_NEW2(fmt));
parse.y:    rb_funcall(parser->value, rb_intern("warn"), 2,
parse.y:    rb_funcall(parser->value, rb_intern("warn"), 2,
parse.y:    rb_funcall(parser->value, rb_intern("warning"), 1, STR_NEW2(fmt));
parse.y:    rb_funcall(parser->value, rb_intern("warning"), 2,
parse.y:    p->value = self;
parse.y:#define ripper_initialized_p(r) ((r)->parser_lex_input != 0)
parse.y: *  call-seq:
parse.y: *    Ripper.new(src, filename="(ripper)", lineno=1) -> ripper
parse.y:        parser->parser_lex_gets = ripper_lex_get_generic;
parse.y:        parser->parser_lex_gets = lex_get_str;
parse.y:    parser->parser_lex_input = src;
parse.y:    parser->eofp = Qfalse;
parse.y:    parser->parser_ruby_sourcefile_string = fname;
parse.y:    parser->parser_ruby_sourcefile = RSTRING_PTR(fname);
parse.y:    parser->parser_ruby_sourceline = NIL_P(lineno) ? 0 : NUM2INT(lineno) - 1;
parse.y:    return parser->result;
parse.y:    parser->parsing_thread = Qnil;
parse.y: *  call-seq:
parse.y:    if (!NIL_P(parser->parsing_thread)) {
parse.y:        if (parser->parsing_thread == rb_thread_current())
parse.y:            rb_raise(rb_eArgError, "Ripper#parse is not multithread-safe");
parse.y:    parser->parsing_thread = rb_thread_current();
parse.y:    return parser->result;
parse.y: *  call-seq:
parse.y: *    ripper#column   -> Integer
parse.y:    if (NIL_P(parser->parsing_thread)) return Qnil;
parse.y:    col = parser->tokp - parser->parser_lex_pbeg;
parse.y: *  call-seq:
parse.y: *    ripper#lineno   -> Integer
parse.y:    if (NIL_P(parser->parsing_thread)) return Qnil;
parse.y:    return INT2NUM(parser->parser_ruby_sourceline);
parse.y:    rb_define_method(Ripper, "initialize", ripper_initialize, -1);
parse.y~:  parse.y -
parse.y~:  Copyright (C) 1993-2007 Yukihiro Matsumoto
parse.y~:    EXPR_BEG,			/* ignore newline, +/- is a sign. */
parse.y~:    EXPR_END,			/* newline significant, +/- is an operator. */
parse.y~:    EXPR_ARG,			/* newline significant, +/- is an operator. */
parse.y~:    EXPR_CMDARG,		/* newline significant, +/- is an operator. */
parse.y~:    EXPR_MID,			/* newline significant, +/- is an operator. */
parse.y~:        return tbl->pos;
parse.y~:    tbl->pos = 0;
parse.y~:    tbl->capa = 8;
parse.y~:    tbl->tbl = ALLOC_N(ID, tbl->capa);
parse.y~:    tbl->prev = prev;
parse.y~:        if (tbl->tbl) {
parse.y~:            xfree(tbl->tbl);
parse.y~:    if (tbl->pos == tbl->capa) {
parse.y~:        tbl->capa = tbl->capa * 2;
parse.y~:        REALLOC_N(tbl->tbl, ID, tbl->capa);
parse.y~:    tbl->tbl[tbl->pos++] = id;
parse.y~:        for (i = 0; i < tbl->pos; i++) {
parse.y~:            if (tbl->tbl[i] == id) {
parse.y~:    |-----------+--------------+------------|
parse.y~:                |<------------>|
parse.y~:#define UTF8_ENC() (parser->utf8 ? parser->utf8 : \
parse.y~:		    (parser->utf8 = rb_utf8_encoding()))
parse.y~:#define STR_NEW(p,n) rb_enc_str_new((p),(n),parser->enc)
parse.y~:#define STR_NEW0() rb_enc_str_new(0,0,parser->enc)
parse.y~:#define STR_NEW2(p) rb_enc_str_new((p),strlen(p),parser->enc)
parse.y~:#define STR_NEW3(p,n,e,func) parser_str_new((p),(n),(e),(func),parser->enc)
parse.y~:#define TOK_INTERN(mb) rb_intern3(tok(), toklen(), parser->enc)
parse.y~:#define lex_strterm		(parser->parser_lex_strterm)
parse.y~:#define lex_state		(parser->parser_lex_state)
parse.y~:#define cond_stack		(parser->parser_cond_stack)
parse.y~:#define cmdarg_stack		(parser->parser_cmdarg_stack)
parse.y~:#define class_nest		(parser->parser_class_nest)
parse.y~:#define paren_nest		(parser->parser_paren_nest)
parse.y~:#define lpar_beg		(parser->parser_lpar_beg)
parse.y~:#define in_single		(parser->parser_in_single)
parse.y~:#define in_def			(parser->parser_in_def)
parse.y~:#define compile_for_eval	(parser->parser_compile_for_eval)
parse.y~:#define cur_mid			(parser->parser_cur_mid)
parse.y~:#define in_defined		(parser->parser_in_defined)
parse.y~:#define tokenbuf		(parser->parser_tokenbuf)
parse.y~:#define tokidx			(parser->parser_tokidx)
parse.y~:#define toksiz			(parser->parser_toksiz)
parse.y~:#define lex_input		(parser->parser_lex_input)
parse.y~:#define lex_lastline		(parser->parser_lex_lastline)
parse.y~:#define lex_nextline		(parser->parser_lex_nextline)
parse.y~:#define lex_pbeg		(parser->parser_lex_pbeg)
parse.y~:#define lex_p			(parser->parser_lex_p)
parse.y~:#define lex_pend		(parser->parser_lex_pend)
parse.y~:#define heredoc_end		(parser->parser_heredoc_end)
parse.y~:#define command_start		(parser->parser_command_start)
parse.y~:#define deferred_nodes		(parser->parser_deferred_nodes)
parse.y~:#define lex_gets_ptr		(parser->parser_lex_gets_ptr)
parse.y~:#define lex_gets		(parser->parser_lex_gets)
parse.y~:#define lvtbl			(parser->parser_lvtbl)
parse.y~:#define ruby__end__seen		(parser->parser_ruby__end__seen)
parse.y~:#define ruby_sourceline		(parser->parser_ruby_sourceline)
parse.y~:#define ruby_sourcefile		(parser->parser_ruby_sourcefile)
parse.y~:#define yydebug			(parser->parser_yydebug)
parse.y~:#define ruby_eval_tree		(parser->parser_eval_tree)
parse.y~:#define ruby_eval_tree_begin	(parser->parser_eval_tree_begin)
parse.y~:#define ruby_debug_lines	(parser->debug_lines)
parse.y~:#define ruby_coverage		(parser->coverage)
parse.y~:#define SIGN_EXTEND(x,n) (((1<<(n)-1)^((x)&~(~0<<(n))))-(1<<(n)-1))
parse.y~:#define nd_term(node) ((signed short)(node)->u2.id)
parse.y~:#define nd_term(node) SIGN_EXTEND((node)->u2.id, CHAR_BIT*2)
parse.y~:#define nd_paren(node) (char)((node)->u2.id >> CHAR_BIT*2)
parse.y~:# define compile_error parser->nerr++,rb_compile_error
parse.y~:%parse-param {struct parser_params *parser}
parse.y~:%token tUMINUS		/* unary- */
parse.y~:%token <id> tOP_ASGN	/* +=, -=  etc. */
parse.y~:%token tLAMBDA		/* -> */
parse.y~:%left  '+' '-'
parse.y~:				while (node->nd_next) {
parse.y~:				    node = node->nd_next;
parse.y~:				void_expr(node->nd_head);
parse.y~:			parser->result = dispatch1(program, $$);
parse.y~:			sprintf(buf, "$%c", (char)$3->nd_nth);
parse.y~:			    $$ = NEW_WHILE(cond($3), $1->nd_body, 0);
parse.y~:			    $$ = NEW_UNTIL(cond($3), $1->nd_body, 0);
parse.y~:			$1->nd_value = $3;
parse.y~:			    ID vid = $1->nd_vid;
parse.y~:				$1->nd_value = $3;
parse.y~:				    $$->nd_aid = vid;
parse.y~:				$1->nd_value = $3;
parse.y~:				$$->nd_value = NEW_CALL(gettable(vid), $2, NEW_LIST($3));
parse.y~:			$1->nd_value = $3;
parse.y~:			$1->nd_value = $3;
parse.y~:		        $3->nd_iter = NEW_FCALL($1, $2);
parse.y~:		        $5->nd_iter = NEW_CALL($1, $3, $4);
parse.y~:		        $5->nd_iter = NEW_CALL($1, $3, $4);
parse.y~:			$$ = NEW_MASGN($1, -1);
parse.y~:			$$ = NEW_MASGN($1, NEW_POSTARG(-1, $4));
parse.y~:			$$ = NEW_MASGN(0, -1);
parse.y~:			$$ = NEW_MASGN(0, NEW_POSTARG(-1, $3));
parse.y~:		| '-'		{ ifndef_ripper($$ = '-'); }
parse.y~:			    ID vid = $1->nd_vid;
parse.y~:				$1->nd_value = $3;
parse.y~:				    $$->nd_aid = vid;
parse.y~:				$1->nd_value = $3;
parse.y~:				$$->nd_value = NEW_CALL(gettable(vid), $2, NEW_LIST($3));
parse.y~:			    ID vid = $1->nd_vid;
parse.y~:				$1->nd_value = $3;
parse.y~:				    $$->nd_aid = vid;
parse.y~:				$1->nd_value = $3;
parse.y~:				$$->nd_value = NEW_CALL(gettable(vid), $2, NEW_LIST($3));
parse.y~:			yyerror("constant re-assignment");
parse.y~:			yyerror("constant re-assignment");
parse.y~:			if (nd_type($1) == NODE_LIT && FIXNUM_P($1->nd_lit) &&
parse.y~:			    nd_type($3) == NODE_LIT && FIXNUM_P($3->nd_lit)) {
parse.y~:			if (nd_type($1) == NODE_LIT && FIXNUM_P($1->nd_lit) &&
parse.y~:			    nd_type($3) == NODE_LIT && FIXNUM_P($3->nd_lit)) {
parse.y~:		| arg '-' arg
parse.y~:			$$ = call_bin_op($1, '-', $3);
parse.y~:			$$ = dispatch3(binary, $1, ID2SYM('-'), $3);
parse.y~:			$$ = dispatch2(unary, ripper_intern("-@"), $$);
parse.y~:			$$ = dispatch2(unary, ripper_intern("-@"), $$);
parse.y~:			$$ = dispatch2(unary, ripper_intern("-@"), $2);
parse.y~:                        if (nd_type($1) == NODE_LIT && TYPE($1->nd_lit) == T_REGEXP) {
parse.y~:                            $$ = reg_named_capture_assign($1->nd_lit, $$);
parse.y~:			$2->nd_iter = NEW_FCALL($1, 0);
parse.y~:			fixpos($2->nd_iter, $2);
parse.y~:			block_dup_check($1->nd_args, $2);
parse.y~:			$2->nd_iter = $1;
parse.y~:			    m->nd_next = block_append(
parse.y~:				$2->nd_value = NEW_DVAR(id);
parse.y~:				m->nd_plen = 1;
parse.y~:				m->nd_next = $2;
parse.y~:				m->nd_next = node_assign(NEW_MASGN(NEW_LIST($2), 0), NEW_DVAR(id));
parse.y~:			fixpos($$->nd_defn, $4);
parse.y~:			in_def--;
parse.y~:			fixpos($$->nd_defn, $2);
parse.y~:			in_single--;
parse.y~:			$$ = NEW_MASGN($1, -1);
parse.y~:			$$ = NEW_MASGN($1, NEW_POSTARG(-1, $5));
parse.y~:			$$ = NEW_MASGN(0, -1);
parse.y~:			$$ = NEW_MASGN(0, NEW_POSTARG(-1, $3));
parse.y~:			$$->nd_body = NEW_SCOPE($2->nd_head, $3);
parse.y~:			    block_dup_check($1->nd_args, $2);
parse.y~:			$2->nd_iter = $1;
parse.y~:			nd_set_line($$->nd_body, $<num>2);
parse.y~:			nd_set_line($$->nd_body->nd_body, $<num>2);
parse.y~:				VALUE src = node->nd_lit;
parse.y~:				node->nd_lit = reg_compile(src, options);
parse.y~:			    node->nd_cflag = options & RE_OPTION_MASK;
parse.y~:                            reg_fragment_check(node->nd_lit, options);
parse.y~:                            for (list = node->nd_next; list; list = list->nd_next) {
parse.y~:                                if (nd_type(list->nd_head) == NODE_STR) {
parse.y~:                                    reg_fragment_check(list->nd_head->nd_lit, options);
parse.y~:			if ($3) $3->flags &= ~NODE_FL_NEWLINE;
parse.y~:				lit = $$->nd_lit;
parse.y~:				$$->nd_lit = ID2SYM(rb_intern_str(lit));
parse.y~:			$$ = dispatch2(unary, ripper_intern("-@"), $2);
parse.y~:			$$ = dispatch2(unary, ripper_intern("-@"), $2);
parse.y~:			    $2->nd_value = NEW_DVAR(tid);
parse.y~:			    $2->nd_value = NEW_LVAR(tid);
parse.y~:			$$->nd_next = $2;
parse.y~:			$$->nd_plen++;
parse.y~:			$$->nd_next = block_append($$->nd_next, $3->nd_next);
parse.y~:			while (opts->nd_next) {
parse.y~:			    opts = opts->nd_next;
parse.y~:			opts->nd_next = $3;
parse.y~:			while (opts->nd_next) {
parse.y~:			    opts = opts->nd_next;
parse.y~:			opts->nd_next = $3;
parse.y~:# define yylval  (*((YYSTYPE*)(parser->parser_yylval)))
parse.y~:#define ripper_flush(p) (p->tokp = p->parser_lex_p)
parse.y~:    if (lex_p < parser->tokp) rb_raise(rb_eRuntimeError, "lex_p < tokp");
parse.y~:    if (lex_p == parser->tokp) return;
parse.y~:    str = STR_NEW(parser->tokp, lex_p - parser->tokp);
parse.y~:    const char *saved_tokp = parser->tokp;
parse.y~:    ruby_sourceline = parser->delayed_line;
parse.y~:    parser->tokp = lex_pbeg + parser->delayed_col;
parse.y~:    yylval.val = ripper_dispatch1(parser, ripper_token2eventid(t), parser->delayed);
parse.y~:    parser->delayed = Qnil;
parse.y~:    parser->tokp = saved_tokp;
parse.y~:# define SIGN_EXTEND_CHAR(c) ((((unsigned char)(c)) ^ 128) - 128)
parse.y~:#define parser_encoding_name()  (parser->enc->name)
parse.y~:#define parser_mbclen()  mbclen((lex_p-1),lex_pend,parser->enc)
parse.y~:#define parser_precise_mbclen()  rb_enc_precise_mbclen((lex_p-1),lex_pend,parser->enc)
parse.y~:#define parser_is_identchar() (!parser->eofp && is_identchar((lex_p-1),lex_pend,parser->enc))
parse.y~:#define parser_isascii() ISASCII(*(lex_p-1))
parse.y~:    const char *p, *pend = lex_p - strlen(token);
parse.y~:	    column = (((column - 1) / 8) + 1) * 8;
parse.y~:    const char *p, *pend = lex_p - strlen(token);
parse.y~:    ptinfo->token = token;
parse.y~:    ptinfo->linenum = ruby_sourceline;
parse.y~:    ptinfo->column = token_info_get_column(parser, token);
parse.y~:    ptinfo->nonspc = token_info_has_nonspaces(parser, token);
parse.y~:    ptinfo->next = parser->parser_token_info;
parse.y~:    parser->parser_token_info = ptinfo;
parse.y~:    token_info *ptinfo = parser->parser_token_info;
parse.y~:    parser->parser_token_info = ptinfo->next;
parse.y~:    if (token_info_get_column(parser, token) == ptinfo->column) { /* OK */
parse.y~:    if (linenum == ptinfo->linenum) { /* SKIP */
parse.y~:    if (token_info_has_nonspaces(parser, token) || ptinfo->nonspc) { /* SKIP */
parse.y~:	       token, ptinfo->token, ptinfo->linenum);
parse.y~:	p--;
parse.y~:    len = pe - p;
parse.y~:	    if (lex_p - p > max_line_margin) {
parse.y~:		p = rb_enc_prev_char(p, lex_p - max_line_margin, pe, rb_enc_get(lex_lastline));
parse.y~:	    if (pe - lex_p > max_line_margin) {
parse.y~:	    len = pe - p;
parse.y~:	i = lex_p - p;
parse.y~:    if (RTEST(coverages) && RBASIC(coverages)->klass == 0) {
parse.y~:	RBASIC(lines)->klass = 0;
parse.y~:	RARRAY(lines)->as.heap.len = n;
parse.y~:    if (strcmp(ruby_sourcefile, "-e") == 0)
parse.y~:	    } while (--n);
parse.y~:    if (parser->nerr) {
parse.y~:	    scope->nd_body = NEW_PRELUDE(ruby_eval_tree_begin, scope->nd_body);
parse.y~:    ruby_sourceline = line - 1;
parse.y~:    lex_gets_ptr = end - RSTRING_PTR(s);
parse.y~:    return rb_enc_str_new(beg, end - beg, rb_enc_get(s));
parse.y~:    VALUE line = (*parser->parser_lex_gets)(parser, parser->parser_lex_input);
parse.y~:#define lex_goto_eol(parser) (parser->parser_lex_p = parser->parser_lex_pend)
parse.y~:	    if (parser->eofp)
parse.y~:		return -1;
parse.y~:		parser->eofp = Qtrue;
parse.y~:		return -1;
parse.y~:	    if (parser->tokp < lex_pend) {
parse.y~:		if (NIL_P(parser->delayed)) {
parse.y~:		    parser->delayed = rb_str_buf_new(1024);
parse.y~:		    rb_str_buf_cat(parser->delayed,
parse.y~:				   parser->tokp, lex_pend - parser->tokp);
parse.y~:		    parser->delayed_line = ruby_sourceline;
parse.y~:		    parser->delayed_col = parser->tokp - lex_pbeg;
parse.y~:		    rb_str_buf_cat(parser->delayed,
parse.y~:				   parser->tokp, lex_pend - parser->tokp);
parse.y~:	    parser->line_count++;
parse.y~:    if (c == -1) return;
parse.y~:    lex_p--;
parse.y~:    if (lex_p > lex_pbeg && lex_p[0] == '\n' && lex_p[-1] == '\r') {
parse.y~:	lex_p--;
parse.y~:#define toklast() (tokidx>0?tokenbuf[tokidx-1]:0)
parse.y~:    return &tokenbuf[tokidx-n];
parse.y~:#define tokcopy(n) memcpy(tokspace(n), lex_p - (n), (n))
parse.y~:      case 'r':	/* carriage-return */
parse.y~:      case 'f':	/* form-feed */
parse.y~:	if ((c = nextc()) != '-') {
parse.y~:	else if (c == -1 || !ISASCII(c)) goto eof;
parse.y~:	if ((c = nextc()) != '-') {
parse.y~:	else if (c == -1 || !ISASCII(c)) goto eof;
parse.y~:      case -1:
parse.y~:	    oct = scan_oct(--lex_p, 3, &numlen);
parse.y~:	if ((c = nextc()) != '-') {
parse.y~:	if ((c = nextc()) != '-') {
parse.y~:	else if (c == -1) goto eof;
parse.y~:      case -1:
parse.y~:	return -1;
parse.y~:	compile_error(PARSER_ARG "unknown regexp option%s - %s",
parse.y~:    if (RBASIC(str)->flags & RSTRING_NOEMBED)
parse.y~:	return -1;
parse.y~:    lex_p += --len;
parse.y~:	int len = sizeof(mixed_msg) - 4;	\
parse.y~:    while ((c = nextc()) != -1) {
parse.y~:	    --*nest;
parse.y~:	    const char *beg = lex_p - 1;
parse.y~:			return -1;
parse.y~:	    if (tokadd_mbchar(c) == -1) return -1;
parse.y~:    int func = quote->nd_func;
parse.y~:    rb_encoding *enc = parser->enc;
parse.y~:    if (func == -1) return tSTRING_END;
parse.y~:    if (c == term && !quote->nd_nest) {
parse.y~:	    quote->nd_func = -1;
parse.y~:    if (tokadd_string(func, term, paren, &quote->nd_nest,
parse.y~:		      &enc) == -1) {
parse.y~:	    if (parser->eofp)
parse.y~:	    if (parser->eofp)
parse.y~:    if (c == '-') {
parse.y~:	while ((c = nextc()) != -1 && c != term) {
parse.y~:	    if (tokadd_mbchar(c) == -1) return 0;
parse.y~:	if (c == -1) {
parse.y~:		pushback('-');
parse.y~:	    if (tokadd_mbchar(c) == -1) return 0;
parse.y~:	} while ((c = nextc()) != -1 && parser_is_identchar());
parse.y~:    len = lex_p - lex_pbeg;
parse.y~:    if (!NIL_P(parser->delayed))
parse.y~:    line = here->nd_orig;
parse.y~:    lex_p = lex_pbeg + here->nd_nth;
parse.y~:    dispose_string(here->nd_lit);
parse.y~:    n= lex_pend - (p + len);
parse.y~:    eos = RSTRING_PTR(here->nd_lit);
parse.y~:    len = RSTRING_LEN(here->nd_lit) - 1;
parse.y~:    if ((c = nextc()) == -1) {
parse.y~:		switch (pend[-1]) {
parse.y~:		    if (--pend == p || pend[-1] != '\r') {
parse.y~:		    --pend;
parse.y~:		rb_str_cat(str, p, pend - p);
parse.y~:		str = STR_NEW(p, pend - p);
parse.y~:	    if (nextc() == -1) {
parse.y~:	rb_encoding *enc = parser->enc;
parse.y~:	    if ((c = tokadd_string(func, '\n', 0, NULL, &enc)) == -1) {
parse.y~:		if (parser->eofp) goto error;
parse.y~:	    if ((c = nextc()) == -1) goto error;
parse.y~:    lex_strterm = NEW_STRTERM(-1, 0, 0);
parse.y~:/* emacsen -*- hack */
parse.y~:    if (len > 5 && name[nlen = len - 5] == '-') {
parse.y~:    if (len > 4 && name[nlen = len - 5] == '-') {
parse.y~:    parser->enc = enc;
parse.y~:    const char *p = lex_pbeg, *pend = lex_p - 1;
parse.y~:    if (parser->line_count != (parser->has_shebang ? 2 : 1)) return 0;
parse.y~:	  case '-':
parse.y~:	    if (str[i-1] == '*' && str[i-2] == '-') {
parse.y~:	    if (str[i+1] != '-') {
parse.y~:	    else if (str[i-1] != '-') {
parse.y~:    if (!(end = magic_comment_marker(beg, str + len - beg))) return Qfalse;
parse.y~:    len = end - beg - 3;
parse.y~:	for (; len > 0 && *str; str++, --len) {
parse.y~:	for (beg = str; len > 0; str++, --len) {
parse.y~:	for (end = str; len > 0 && ISSPACE(*str); str++, --len);
parse.y~:	do str++; while (--len > 0 && ISSPACE(*str));
parse.y~:	    for (vbeg = ++str; --len > 0 && *str != '"'; str++) {
parse.y~:		    --len;
parse.y~:		--len;
parse.y~:	    for (vbeg = str; len > 0 && *str != '"' && *str != ';' && !ISSPACE(*str); --len, str++);
parse.y~:	while (len > 0 && (*str == ';' || ISSPACE(*str))) --len, str++;
parse.y~:	n = end - beg;
parse.y~:	    if (*s == '-') *s = '_';
parse.y~:	    if (STRNCASECMP(p->name, s, n) == 0) {
parse.y~:		n = vend - vbeg;
parse.y~:		if (p->length) {
parse.y~:		    n = (*p->length)(parser, vbeg, n);
parse.y~:		(*p->func)(parser, s, RSTRING_PTR(val));
parse.y~:	if (send - str <= 6) return;
parse.y~:	if (STRNCASECMP(str-6, "coding", 6) == 0) break;
parse.y~:    while ((*str == '-' || *str == '_' || ISALNUM(*str)) && ++str < send);
parse.y~:    s = rb_str_new(beg, parser_encode_length(parser, beg, str - beg));
parse.y~:	if (peek('!')) parser->has_shebang = 1;
parse.y~:      case 0xef:		/* UTF-8 BOM marker */
parse.y~:	if (lex_pend - lex_p >= 2 &&
parse.y~:	    parser->enc = rb_utf8_encoding();
parse.y~:    parser->enc = rb_enc_get(lex_lastline);
parse.y~:      case -1:			/* end of script. */
parse.y~:	if (!parser_magic_comment(parser, lex_p, lex_pend - lex_p)) {
parse.y~:		--ruby_sourceline;
parse.y~:	      case -1:		/* EOF no decrement*/
parse.y~:		if (c != -1) {
parse.y~:		    parser->tokp = lex_p;
parse.y~:		    if (c == -1) {
parse.y~:	if (c == -1) {
parse.y~:	if (rb_enc_isspace(c, parser->enc)) {
parse.y~:	enc = parser->enc;
parse.y~:	    if (tokadd_mbchar(c) == -1) return 0;
parse.y~:	else if ((rb_enc_isalnum(c, parser->enc) || c == '_') &&
parse.y~:		 lex_p < lex_pend && is_identchar(lex_p, lex_pend, parser->enc)) {
parse.y~:	    if (c != -1 && ISDIGIT(c)) {
parse.y~:      case '-':
parse.y~:	    return '-';
parse.y~:            set_yylval_id('-');
parse.y~:	    if (c != -1 && ISDIGIT(c)) {
parse.y~:	return '-';
parse.y~:	if (c != -1 && ISDIGIT(c)) {
parse.y~:	    if (c == '-' || c == '+') {
parse.y~:		    if (c != -1 && ISXDIGIT(c)) {
parse.y~:			} while ((c = nextc()) != -1);
parse.y~:			} while ((c = nextc()) != -1);
parse.y~:		    if (c != -1 && ISDIGIT(c)) {
parse.y~:			} while ((c = nextc()) != -1);
parse.y~:		    if (c == -1 || c == '_' || !ISDIGIT(c)) {
parse.y~:		    } while ((c = nextc()) != -1);
parse.y~:			if (c0 == -1 || !ISDIGIT(c0)) {
parse.y~:		    if (c != '-' && c != '+') continue;
parse.y~:	paren_nest--;
parse.y~:	if (lex_state == EXPR_END || lex_state == EXPR_ENDARG || (c != -1 && ISSPACE(c))) {
parse.y~:	    --paren_nest;
parse.y~:	    if (c == -1 || !ISALNUM(c)) {
parse.y~:		if (rb_enc_isalnum(term, parser->enc) || !parser_isascii()) {
parse.y~:	    if (c == -1 || term == -1) {
parse.y~:	  case '~':		/* $~: match-data */
parse.y~:	  case '-':
parse.y~:		if (tokadd_mbchar(c) == -1) return 0;
parse.y~:	    } while (c != -1 && ISDIGIT(c));
parse.y~:	if (c != -1 && ISDIGIT(c)) {
parse.y~:	    parser->eofp = Qtrue;
parse.y~:	    return -1;
parse.y~:	if (tokadd_mbchar(c) == -1) return 0;
parse.y~:		    lex_state = kw->state;
parse.y~:                        set_yylval_id(rb_intern(kw->name));
parse.y~:			return kw->id[0];
parse.y~:		    if (kw->id[0] == keyword_do) {
parse.y~:			    --paren_nest;
parse.y~:			return kw->id[0];
parse.y~:			if (kw->id[0] != kw->id[1])
parse.y~:			return kw->id[1];
parse.y~:    parser->parser_yylval = lval;
parse.y~:    parser->parser_yylval->val = Qundef;
parse.y~:    if (!NIL_P(parser->delayed)) {
parse.y~:	node->flags |= NODE_FL_NEWLINE;
parse.y~:	end->nd_end = end;
parse.y~:	end = h->nd_end;
parse.y~:    nd = end->nd_head;
parse.y~:	tail->nd_end = tail;
parse.y~:    end->nd_next = tail;
parse.y~:    h->nd_end = tail->nd_end;
parse.y~:    if (list->nd_next) {
parse.y~:	last = list->nd_next->nd_end;
parse.y~:    list->nd_alen += 1;
parse.y~:    last->nd_next = NEW_LIST(item);
parse.y~:    list->nd_next->nd_end = last->nd_next;
parse.y~:    if (head->nd_next) {
parse.y~:	last = head->nd_next->nd_end;
parse.y~:    head->nd_alen += tail->nd_alen;
parse.y~:    last->nd_next = tail;
parse.y~:    if (tail->nd_next) {
parse.y~:	head->nd_next->nd_end = tail->nd_next->nd_end;
parse.y~:	head->nd_next->nd_end = tail;
parse.y~:	    if (!literal_concat0(parser, head->nd_lit, tail->nd_lit)) {
parse.y~:	    if (!literal_concat0(parser, head->nd_lit, tail->nd_lit))
parse.y~:	    tail->nd_lit = head->nd_lit;
parse.y~:	    tail->nd_head = NEW_STR(tail->nd_lit);
parse.y~:	    head->nd_alen = 1;
parse.y~:	    if (TYPE(node1->nd_lit) == T_REGEXP) {
parse.y~:	    if (TYPE(node2->nd_lit) == T_REGEXP) {
parse.y~:	return NEW_LIT(rb_enc_from_encoding(parser->enc));
parse.y~:	    rb_warningS("shadowing outer local variable - %s", rb_id2name(name));
parse.y~:	    vtable_add(lvtbl->vars, name);
parse.y~:	compile_error(PARSER_ARG "invalid local variable - %s",
parse.y~:	compile_error(PARSER_ARG "Can't set variable $%ld", node->nd_nth);
parse.y~:	compile_error(PARSER_ARG "Can't set variable $%c", (int)node->nd_nth);
parse.y~:	node1->nd_iter = arg_concat(node1->nd_iter, node2);
parse.y~:	node1->nd_body = list_concat(NEW_LIST(node1->nd_body), node2);
parse.y~:	    nd_type(node1->nd_body) != NODE_ARRAY) break;
parse.y~:	node1->nd_body = list_concat(node1->nd_body, node2);
parse.y~:	node1->nd_head = arg_append(node1->nd_head, node2);
parse.y~:	node1->nd_body = list_append(NEW_LIST(node1->nd_body), node2);
parse.y~:    if (nd_type(node) == NODE_SPLAT) node = node->nd_head;
parse.y~:	lhs->nd_value = rhs;
parse.y~:	lhs->nd_args = arg_append(lhs->nd_args, rhs);
parse.y~:	    while (node->nd_next) {
parse.y~:		node = node->nd_next;
parse.y~:	    node = node->nd_head;
parse.y~:	    node = node->nd_body;
parse.y~:	    if (!node->nd_body) {
parse.y~:		node = node->nd_else;
parse.y~:	    else if (!node->nd_else) {
parse.y~:		node = node->nd_body;
parse.y~:	    if (!value_expr(node->nd_body)) return Qfalse;
parse.y~:	    node = node->nd_else;
parse.y~:	    node = node->nd_2nd;
parse.y~:	switch (node->nd_mid) {
parse.y~:	  case '-':
parse.y~:	    useless = rb_id2name(node->nd_mid);
parse.y~:	if (!node->nd_next) return;
parse.y~:	void_expr0(node->nd_head);
parse.y~:	node = node->nd_next;
parse.y~:    while (n1 && nd_type(n1) == NODE_BEGIN && n1->nd_body) {
parse.y~:	*n = n1 = n1->nd_body;
parse.y~:    ((!node->n1) ? (node->n2 ? (body = &node->n2, 1) : 0) : \
parse.y~:     (!node->n2) ? (body = &node->n1, 1) : \
parse.y~:     (reduce_nodes(&node->n1), body = &node->n2, 1))
parse.y~:	    *body = node = node->nd_stts;
parse.y~:	    *body = node = node->nd_body;
parse.y~:	    body = &node->nd_end->nd_head;
parse.y~:	    body = &node->nd_body;
parse.y~:    switch (nd_type(node->nd_value)) {
parse.y~:	parser_warn(node->nd_value, "found = in conditional, should be ==");
parse.y~:	next = node->nd_next;
parse.y~:	head = node->nd_head;
parse.y~:	    val = rb_range_new(head->nd_beg->nd_lit, head->nd_end->nd_lit,
parse.y~:	    rb_gc_force_recycle((VALUE)head->nd_beg);
parse.y~:	    rb_gc_force_recycle((VALUE)head->nd_end);
parse.y~:	    head->nd_lit = val;
parse.y~:    if (type == NODE_LIT && FIXNUM_P(node->nd_lit)) {
parse.y~:	node->nd_1st = cond0(parser, node->nd_1st);
parse.y~:	node->nd_2nd = cond0(parser, node->nd_2nd);
parse.y~:	node->nd_beg = range_op(parser, node->nd_beg);
parse.y~:	node->nd_end = range_op(parser, node->nd_end);
parse.y~:	    int b = literal_node(node->nd_beg);
parse.y~:	    int e = literal_node(node->nd_end);
parse.y~:	if (TYPE(node->nd_lit) == T_REGEXP) {
parse.y~:	while ((second = node->nd_2nd) != 0 && nd_type(second) == type) {
parse.y~:	node->nd_2nd = NEW_NODE(type, second, right, 0);
parse.y~:	    if (node->nd_next == 0) {
parse.y~:		node = node->nd_head;
parse.y~:    switch (TYPE(node->nd_lit)) {
parse.y~:	node->nd_lit = LONG2FIX(-FIX2LONG(node->nd_lit));
parse.y~:	node->nd_lit = rb_funcall(node->nd_lit,tUMINUS,0,0);
parse.y~:	RFLOAT(node->nd_lit)->float_value = -RFLOAT_VALUE(node->nd_lit);
parse.y~:	node2->nd_head = node1;
parse.y~:    node = NEW_ARGS(m ? m->nd_plen : 0, o);
parse.y~:    i1 = m ? m->nd_next : 0;
parse.y~:    node->nd_next = NEW_ARGS_AUX(r, b);
parse.y~:	i2 = p->nd_next;
parse.y~:	node->nd_next->nd_next = NEW_ARGS_AUX(p->nd_pid, p->nd_plen);
parse.y~:	node->nd_next->nd_next = NEW_ARGS_AUX(0, 0);
parse.y~:	node->nd_next->nd_next->nd_next = NEW_NODE(NODE_AND, i1, i2, 0);
parse.y~:    local->prev = lvtbl;
parse.y~:    local->args = vtable_alloc(0);
parse.y~:    local->vars = vtable_alloc(inherit_dvars ? DVARS_INHERIT : DVARS_TOPSCOPE);
parse.y~:    struct local_vars *local = lvtbl->prev;
parse.y~:    vtable_free(lvtbl->args);
parse.y~:    vtable_free(lvtbl->vars);
parse.y~:            buf[i] = src->tbl[i];
parse.y~:    int cnt = vtable_size(lvtbl->args) + vtable_size(lvtbl->vars);
parse.y~:    vtable_tblcpy(buf+1, lvtbl->args);
parse.y~:    vtable_tblcpy(buf+vtable_size(lvtbl->args)+1, lvtbl->vars);
parse.y~:    vtable_add(lvtbl->args, id);
parse.y~:    return vtable_size(lvtbl->args) - 1;
parse.y~:    vtable_add(lvtbl->vars, id);
parse.y~:    return vtable_size(lvtbl->vars) - 1;
parse.y~:    vars = lvtbl->vars;
parse.y~:    args = lvtbl->args;
parse.y~:    while (vars && POINTER_P(vars->prev)) {
parse.y~:	vars = vars->prev;
parse.y~:	args = args->prev;
parse.y~:    if (vars && vars->prev == DVARS_INHERIT) {
parse.y~:    lvtbl->args = vtable_alloc(lvtbl->args);
parse.y~:    lvtbl->vars = vtable_alloc(lvtbl->vars);
parse.y~:    tmp = lvtbl->args;
parse.y~:    lvtbl->args = lvtbl->args->prev;
parse.y~:    tmp = lvtbl->vars;
parse.y~:    lvtbl->vars = lvtbl->vars->prev;
parse.y~:    return POINTER_P(lvtbl->vars) && lvtbl->vars->prev != DVARS_TOPSCOPE;
parse.y~:    args = lvtbl->args;
parse.y~:    vars = lvtbl->vars;
parse.y~:	args = args->prev;
parse.y~:	vars = vars->prev;
parse.y~:    return (vtable_included(lvtbl->args, id) ||
parse.y~:	    vtable_included(lvtbl->vars, id));
parse.y~:    else if (parser->enc == rb_usascii_encoding()) {
parse.y~:    struct parser_params* parser = arg->parser;
parse.y~:    rb_encoding *enc = arg->enc;
parse.y~:    int len = name_end - name;
parse.y~:    arg->num++;
parse.y~:    if (arg->succ_block == 0) {
parse.y~:        arg->succ_block = NEW_BEGIN(0);
parse.y~:        arg->fail_block = NEW_BEGIN(0);
parse.y~:        rb_warningS("named capture conflicts a local variable - %s",
parse.y~:    arg->succ_block = block_append(arg->succ_block,
parse.y~:    arg->fail_block = block_append(arg->fail_block,
parse.y~:    onig_foreach_name(RREGEXP(regexp)->ptr, reg_named_capture_assign_iter, (void*)&arg);
parse.y~:    node = node->nd_body;
parse.y~:	node = node->nd_body;
parse.y~:	prelude->nd_body = node;
parse.y~:	scope->nd_body = prelude;
parse.y~:	scope->nd_body = node;
parse.y~:    node = node->nd_body;
parse.y~:	node = node->nd_body;
parse.y~:	prelude->nd_body = node;
parse.y~:	scope->nd_body = prelude;
parse.y~:	scope->nd_body = node;
parse.y~:    {'-',	"-(binary)"},
parse.y~:    {tUMINUS,	"-@"},
parse.y~:    if (key1->id == key2->id && key1->klass == key2->klass) {
parse.y~:    return (key->id << 8) ^ (key->klass >> 2);
parse.y~:    ID id = (ID)vtable_size(lvtbl->args) + (ID)vtable_size(lvtbl->vars);
parse.y~:    id += ((tLAST_TOKEN - ID_INTERNAL) >> ID_SCOPE_SHIFT) + 1;
parse.y~:      case '-':
parse.y~:      case '+': case '-':
parse.y~:    last = len-1;
parse.y~:	    if (!--mb) enc = rb_ascii8bit_encoding();
parse.y~:    if (m - name < len) id = ID_JUNK;
parse.y~:	 * rb_intern_str() taking care of code-range.
parse.y~:        if (RBASIC(str)->klass == 0)
parse.y~:            RBASIC(str)->klass = rb_cString;
parse.y~:            if (RBASIC(str)->klass == 0)
parse.y~:                RBASIC(str)->klass = rb_cString;
parse.y~: *  call-seq:
parse.y~:    VALUE ary = rb_ary_new2(global_symbols.sym_id->num_entries);
parse.y~:    parser->eofp = Qfalse;
parse.y~:    parser->parser_lex_strterm = 0;
parse.y~:    parser->parser_cond_stack = 0;
parse.y~:    parser->parser_cmdarg_stack = 0;
parse.y~:    parser->parser_class_nest = 0;
parse.y~:    parser->parser_paren_nest = 0;
parse.y~:    parser->parser_lpar_beg = 0;
parse.y~:    parser->parser_in_single = 0;
parse.y~:    parser->parser_in_def = 0;
parse.y~:    parser->parser_in_defined = 0;
parse.y~:    parser->parser_compile_for_eval = 0;
parse.y~:    parser->parser_cur_mid = 0;
parse.y~:    parser->parser_tokenbuf = NULL;
parse.y~:    parser->parser_tokidx = 0;
parse.y~:    parser->parser_toksiz = 0;
parse.y~:    parser->parser_heredoc_end = 0;
parse.y~:    parser->parser_command_start = Qtrue;
parse.y~:    parser->parser_deferred_nodes = 0;
parse.y~:    parser->parser_lex_pbeg = 0;
parse.y~:    parser->parser_lex_p = 0;
parse.y~:    parser->parser_lex_pend = 0;
parse.y~:    parser->parser_lvtbl = 0;
parse.y~:    parser->parser_ruby__end__seen = 0;
parse.y~:    parser->parser_ruby_sourcefile = 0;
parse.y~:    parser->is_ripper = 0;
parse.y~:    parser->parser_eval_tree_begin = 0;
parse.y~:    parser->parser_eval_tree = 0;
parse.y~:    parser->is_ripper = 1;
parse.y~:    parser->parser_ruby_sourcefile_string = Qnil;
parse.y~:    parser->delayed = Qnil;
parse.y~:    parser->result = Qnil;
parse.y~:    parser->parsing_thread = Qnil;
parse.y~:    parser->toplevel_p = Qtrue;
parse.y~:    parser->heap = NULL;
parse.y~:    parser->enc = rb_usascii_encoding();
parse.y~:    rb_gc_mark((VALUE)p->parser_lex_strterm);
parse.y~:    rb_gc_mark((VALUE)p->parser_deferred_nodes);
parse.y~:    rb_gc_mark(p->parser_lex_input);
parse.y~:    rb_gc_mark(p->parser_lex_lastline);
parse.y~:    rb_gc_mark(p->parser_lex_nextline);
parse.y~:    rb_gc_mark((VALUE)p->parser_eval_tree_begin) ;
parse.y~:    rb_gc_mark((VALUE)p->parser_eval_tree) ;
parse.y~:    rb_gc_mark(p->debug_lines);
parse.y~:    rb_gc_mark(p->parser_ruby_sourcefile_string);
parse.y~:    rb_gc_mark(p->delayed);
parse.y~:    rb_gc_mark(p->value);
parse.y~:    rb_gc_mark(p->result);
parse.y~:    rb_gc_mark(p->parsing_thread);
parse.y~:    rb_gc_mark((VALUE)p->heap);
parse.y~:    if (p->parser_tokenbuf) {
parse.y~:        xfree(p->parser_tokenbuf);
parse.y~:    for (local = p->parser_lvtbl; local; local = prev) {
parse.y~:	if (local->vars) xfree(local->vars);
parse.y~:	prev = local->prev;
parse.y~:    xfree(p->parser_ruby_sourcefile);
parse.y~: *  call-seq:
parse.y~: *    ripper#end_seen?   -> Boolean
parse.y~: *  call-seq:
parse.y~: *    ripper#encoding   -> encoding
parse.y~:    return rb_enc_from_encoding(parser->enc);
parse.y~: *  call-seq:
parse.y~: *    ripper.yydebug   -> true or false
parse.y~: *  call-seq:
parse.y~:#define NEWHEAP() rb_node_newnode(NODE_ALLOCA, 0, (VALUE)parser->heap, 0)
parse.y~:#define ADD2HEAP(n, c, p) ((parser->heap = (n))->u1.node = (p), \
parse.y~:			   (n)->u3.cnt = (c), (p))
parse.y~:    if (ptr && (n = parser->heap) != NULL) {
parse.y~:	    if (n->u1.node == ptr) {
parse.y~:		n->u1.node = ptr = xrealloc(ptr, size);
parse.y~:		if (n->u3.cnt) n->u3.cnt = cnt;
parse.y~:	} while ((n = n->u2.node) != NULL);
parse.y~:    NODE **prev = &parser->heap, *n;
parse.y~:	if (n->u1.node == ptr) {
parse.y~:	    *prev = n->u2.node;
parse.y~:	prev = &n->u2.node;
parse.y~:    return rb_funcall(parser->value, mid, 0);
parse.y~:    return rb_funcall(parser->value, mid, 1, a);
parse.y~:    return rb_funcall(parser->value, mid, 2, a, b);
parse.y~:    return rb_funcall(parser->value, mid, 3, a, b, c);
parse.y~:    return rb_funcall(parser->value, mid, 4, a, b, c, d);
parse.y~:    return rb_funcall(parser->value, mid, 5, a, b, c, d, e);
parse.y~:    for (a = keyword_to_name; a->id; a++) {
parse.y~:        if (a->id == id)
parse.y~:            return a->name;
parse.y~:    rb_funcall(parser->value, rb_intern("compile_error"), 1, str);
parse.y~:    rb_funcall(parser->value, rb_intern("warn"), 1, STR_NEW2(fmt));
parse.y~:    rb_funcall(parser->value, rb_intern("warn"), 2,
parse.y~:    rb_funcall(parser->value, rb_intern("warn"), 2,
parse.y~:    rb_funcall(parser->value, rb_intern("warning"), 1, STR_NEW2(fmt));
parse.y~:    rb_funcall(parser->value, rb_intern("warning"), 2,
parse.y~:    p->value = self;
parse.y~:#define ripper_initialized_p(r) ((r)->parser_lex_input != 0)
parse.y~: *  call-seq:
parse.y~: *    Ripper.new(src, filename="(ripper)", lineno=1) -> ripper
parse.y~:        parser->parser_lex_gets = ripper_lex_get_generic;
parse.y~:        parser->parser_lex_gets = lex_get_str;
parse.y~:    parser->parser_lex_input = src;
parse.y~:    parser->eofp = Qfalse;
parse.y~:    parser->parser_ruby_sourcefile_string = fname;
parse.y~:    parser->parser_ruby_sourcefile = RSTRING_PTR(fname);
parse.y~:    parser->parser_ruby_sourceline = NIL_P(lineno) ? 0 : NUM2INT(lineno) - 1;
parse.y~:    return parser->result;
parse.y~:    parser->parsing_thread = Qnil;
parse.y~: *  call-seq:
parse.y~:    if (!NIL_P(parser->parsing_thread)) {
parse.y~:        if (parser->parsing_thread == rb_thread_current())
parse.y~:            rb_raise(rb_eArgError, "Ripper#parse is not multithread-safe");
parse.y~:    parser->parsing_thread = rb_thread_current();
parse.y~:    return parser->result;
parse.y~: *  call-seq:
parse.y~: *    ripper#column   -> Integer
parse.y~:    if (NIL_P(parser->parsing_thread)) return Qnil;
parse.y~:    col = parser->tokp - parser->parser_lex_pbeg;
parse.y~: *  call-seq:
parse.y~: *    ripper#lineno   -> Integer
parse.y~:    if (NIL_P(parser->parsing_thread)) return Qnil;
parse.y~:    return INT2NUM(parser->parser_ruby_sourceline);
parse.y~:    rb_define_method(Ripper, "initialize", ripper_initialize, -1);
prelude.c:"#   * Encoding.default_external does not reflects -E.\n"
prelude.c:"      :arch => \"i686-linux\",\n"
prelude.c:"    # Deduce Ruby's --program-prefix and --program-suffix from its install name\n"
prelude.c:"    # The default system-wide source info cache directory\n"
prelude.c:"    # The default user-specific source info cache directory\n"
prelude.c:"              dash = gem_directory_name.rindex(\"-\")\n"
prelude.c:"              new_version = calculate_integers_for_gem_version(gem_directory_name[dash+1..-1])\n"
prelude.c:"                if (current_version <=> new_version) == -1\n"
prelude.c:"        # gem directories must come after -I and ENV['RUBYLIB']\n"
prelude.c:    rb_usascii_str_new(prelude_code0, sizeof(prelude_code0) - 1),
prelude.c:    rb_usascii_str_new(prelude_name0, sizeof(prelude_name0) - 1),
prelude.c:    rb_usascii_str_new(prelude_code1, sizeof(prelude_code1) - 1),
prelude.c:    rb_usascii_str_new(prelude_name1, sizeof(prelude_name1) - 1),
prelude.c:    rb_usascii_str_new(prelude_code2, sizeof(prelude_code2) - 1),
prelude.c:    rb_usascii_str_new(prelude_name2, sizeof(prelude_name2) - 1),
ãã¤ããªã¼ã»ãã¡ã¤ã«prelude.oã¯ä¸è´ãã¾ãã
proc.c:  proc.c - Proc, Binding, Env
proc.c:  Copyright (C) 2004-2007 Koichi Sasada
proc.c:	RUBY_MARK_UNLESS_NULL(proc->envval);
proc.c:	RUBY_MARK_UNLESS_NULL(proc->blockprocval);
proc.c:	RUBY_MARK_UNLESS_NULL(proc->block.proc);
proc.c:	RUBY_MARK_UNLESS_NULL(proc->block.self);
proc.c:	if (proc->block.iseq && RUBY_VM_IFUNC_P(proc->block.iseq)) {
proc.c:	    RUBY_MARK_UNLESS_NULL((VALUE)(proc->block.iseq));
proc.c:	RDATA(proc)->dfree == (RUBY_DATA_FUNC) proc_free) {
proc.c:    dst->block = src->block;
proc.c:    dst->block.proc = procval;
proc.c:    dst->envval = src->envval;
proc.c:    dst->safe_level = src->safe_level;
proc.c:    dst->is_lambda = src->is_lambda;
proc.c: * call-seq:
proc.c: * It expand single-array argument.
proc.c: * even if a non-lambda Proc object is given.
proc.c:    return proc->is_lambda ? Qtrue : Qfalse;
proc.c:	RUBY_MARK_UNLESS_NULL(bind->env);
proc.c:    dst->env = src->env;
proc.c:    rb_control_frame_t *cfp = rb_vm_get_ruby_level_next_cfp(th, th->cfp);
proc.c:    bind->env = rb_vm_make_env_object(th, cfp);
proc.c: *  call-seq:
proc.c: *     binding -> a_binding
proc.c: *  call-seq:
proc.c:    rb_control_frame_t *cfp = th->cfp;
proc.c:    if ((GC_GUARDED_PTR_REF(cfp->lfp[0])) != 0 &&
proc.c:	!RUBY_VM_CLASS_SPECIAL_P(cfp->lfp[0])) {
proc.c:	block = GC_GUARDED_PTR_REF(cfp->lfp[0]);
proc.c:	if ((GC_GUARDED_PTR_REF(cfp->lfp[0])) != 0 &&
proc.c:	    !RUBY_VM_CLASS_SPECIAL_P(cfp->lfp[0])) {
proc.c:	    block = GC_GUARDED_PTR_REF(cfp->lfp[0]);
proc.c:    procval = block->proc;
proc.c:	if (RBASIC(procval)->klass == klass) {
proc.c:	    RBASIC(newprocval)->klass = klass;
proc.c:	proc->is_lambda = Qtrue;
proc.c: *  call-seq:
proc.c: * call-seq:
proc.c: * call-seq:
proc.c: *  call-seq:
proc.c: *  call-seq:
proc.c:    iseq = proc->block.iseq;
proc.c:    if (BUILTIN_TYPE(iseq) == T_NODE || iseq->arg_block != -1) {
proc.c:	    blockptr = &proc->block;
proc.c:    return rb_vm_invoke_proc(GET_THREAD(), proc, proc->block.self,
proc.c:    return rb_vm_invoke_proc(GET_THREAD(), proc, proc->block.self,
proc.c:	block = &pass_proc->block;
proc.c:    return rb_vm_invoke_proc(GET_THREAD(), proc, proc->block.self,
proc.c: *  call-seq:
proc.c: *     prc.arity -> fixnum
proc.c: *  arguments, return -n-1, where n is the number of mandatory
proc.c: *     Proc.new {|*a|}.arity      #=> -1
proc.c: *     Proc.new {|a,*b|}.arity    #=> -2
proc.c: *     Proc.new {|a,*b, c|}.arity    #=> -3
proc.c:    iseq = proc->block.iseq;
proc.c:	    if (iseq->arg_rest < 0) {
proc.c:		return INT2FIX(iseq->argc);
proc.c:		return INT2FIX(-(iseq->argc + 1 + iseq->arg_post_len));
proc.c:	    if (nd_type(node) == NODE_IFUNC && node->nd_cfnc == bmcall) {
proc.c:		return INT2FIX(method_arity(node->nd_tval));
proc.c:    return INT2FIX(-1);
proc.c:    iseq = proc->block.iseq;
proc.c:    loc[0] = iseq->filename;
proc.c:    if (iseq->insn_info_table) {
proc.c: * call-seq:
proc.c: * call-seq:
proc.c:	    RDATA(other)->dmark  == proc_mark) {
proc.c:	    if (p1->envval == p2->envval &&
proc.c:		p1->block.iseq->iseq_size == p2->block.iseq->iseq_size &&
proc.c:		p1->block.iseq->local_size == p2->block.iseq->local_size &&
proc.c:		MEMCMP(p1->block.iseq->iseq, p2->block.iseq->iseq, VALUE,
proc.c:		       p1->block.iseq->iseq_size) == 0) {
proc.c: * call-seq:
proc.c:    hash = (long)proc->block.iseq;
proc.c:    hash ^= (long)proc->envval;
proc.c:    hash ^= (long)proc->block.lfp >> 16;
proc.c: * call-seq:
proc.c:    iseq = proc->block.iseq;
proc.c:    is_lambda = proc->is_lambda ? " (lambda)" : "";
proc.c:	if (iseq->insn_info_table) {
proc.c:			 RSTRING_PTR(iseq->filename),
proc.c:	str = rb_sprintf("#<%s:%p%s>", cname, (void *)proc->block.iseq,
proc.c: *  call-seq:
proc.c: *     prc.to_proc -> prc
proc.c:    rb_gc_mark(data->rclass);
proc.c:    rb_gc_mark(data->oclass);
proc.c:    rb_gc_mark(data->recv);
proc.c:    rb_gc_mark((VALUE)data->body);
proc.c:	RDATA(method)->dmark == (RUBY_DATA_FUNC) bm_mark) {
proc.c:	return data->body;
proc.c:    if (scope && (body->nd_noex & NOEX_MASK) != NOEX_PUBLIC) {
proc.c:	rb_print_undef(rclass, oid, (int)(body->nd_noex & NOEX_MASK));
proc.c:    klass = body->nd_clss;
proc.c:    body = body->nd_body;
proc.c:	klass = RBASIC(klass)->klass;
proc.c:    method = Data_Make_Struct(mclass, struct METHOD, bm_mark, -1, data);
proc.c:    data->oclass = klass;
proc.c:    data->recv = obj;
proc.c:    data->id = id;
proc.c:    data->body = body;
proc.c:    data->rclass = rclass;
proc.c:    data->oid = oid;
proc.c: * Document-class : Method
proc.c: * call-seq:
proc.c:	|| RDATA(other)->dmark != (RUBY_DATA_FUNC) bm_mark)
proc.c:    if (m1->oclass != m2->oclass || m1->rclass != m2->rclass ||
proc.c:	m1->recv != m2->recv || m1->body != m2->body)
proc.c: * call-seq:
proc.c:    hash = (long)m->oclass;
proc.c:    hash ^= (long)m->rclass;
proc.c:    hash ^= (long)m->recv;
proc.c:    hash ^= (long)m->body;
proc.c: *  call-seq:
proc.c:	Data_Make_Struct(rb_cUnboundMethod, struct METHOD, bm_mark, -1, data);
proc.c:    data->oclass = orig->oclass;
proc.c:    data->recv = Qundef;
proc.c:    data->id = orig->id;
proc.c:    data->body = orig->body;
proc.c:    data->rclass = orig->rclass;
proc.c:    data->oid = orig->oid;
proc.c: *  call-seq:
proc.c:    return data->recv;
proc.c: *  call-seq:
proc.c:    return ID2SYM(data->id);
proc.c: *  call-seq:
proc.c:    return data->oclass;
proc.c: *  call-seq:
proc.c: *  call-seq:
proc.c: *  call-seq:
proc.c:    if (RDATA(body)->dmark == (RUBY_DATA_FUNC) bm_mark) {
proc.c:	VALUE rclass = method->rclass;
proc.c:	node = method->body;
proc.c:	if (BUILTIN_TYPE(proc->block.iseq) != T_NODE) {
proc.c:	    proc->block.iseq->defined_method_id = id;
proc.c:	    proc->block.iseq->klass = mod;
proc.c:	    proc->is_lambda = Qtrue;
proc.c:	    proc->is_from_method = Qtrue;
proc.c:    clone = Data_Make_Struct(CLASS_OF(self), struct METHOD, bm_mark, -1, data);
proc.c: *  call-seq:
proc.c:    volatile int safe = -1;
proc.c:    if (data->recv == Qundef) {
proc.c:	result = rb_vm_call(th, data->oclass, data->recv, data->id, data->oid,
proc.c:			    argc, argv, data->body, 0);
proc.c: * Document-class: UnboundMethod
proc.c: *  call-seq:
proc.c: *     umeth.bind(obj) -> method
proc.c:    if (data->rclass != CLASS_OF(recv)) {
proc.c:	if (FL_TEST(data->rclass, FL_SINGLETON)) {
proc.c:	if (!rb_obj_is_kind_of(recv, data->rclass)) {
proc.c:		     rb_class2name(data->rclass));
proc.c:    method = Data_Make_Struct(rb_cMethod, struct METHOD, bm_mark, -1, bound);
proc.c:    bound->recv = recv;
proc.c:    bound->rclass = CLASS_OF(recv);
proc.c:	if (body->nd_argc < 0)
proc.c:	    return -1;
proc.c:	return check_argc(body->nd_argc);
proc.c:	return -1;
proc.c:	return rb_proc_arity(body->nd_cval);
proc.c:	    GetISeqPtr((VALUE)body->nd_body, iseq);
proc.c:	    if (iseq->arg_rest == -1 && iseq->arg_opts == 0) {
proc.c:		return iseq->argc;
proc.c:		return -(iseq->argc + 1 + iseq->arg_post_len);
proc.c: *  call-seq:
proc.c: *  arguments, returns -n-1, where n is the number of required
proc.c: *  arguments. For methods written in C, returns -1 if the call takes a
proc.c: *     c.method(:three).arity   #=> -1
proc.c: *     c.method(:five).arity    #=> -3
proc.c: *     c.method(:six).arity     #=> -3
proc.c: *     "cat".method(:squeeze).arity   #=> -1
proc.c: *     "cat".method(:count).arity     #=> -1
proc.c:    return rb_node_arity(data->body);
proc.c:    body = data->body;
proc.c:	GetISeqPtr((VALUE)body->nd_body, iseq);
proc.c: * call-seq:
proc.c: *  call-seq:
proc.c:    if (FL_TEST(data->oclass, FL_SINGLETON)) {
proc.c:	VALUE v = rb_iv_get(data->oclass, "__attached__");
proc.c:	if (data->recv == Qundef) {
proc.c:	    rb_str_buf_append(str, rb_inspect(data->oclass));
proc.c:	else if (data->recv == v) {
proc.c:	    rb_str_buf_append(str, rb_inspect(data->recv));
proc.c:	rb_str_buf_cat2(str, rb_class2name(data->rclass));
proc.c:	if (data->rclass != data->oclass) {
proc.c:	    rb_str_buf_cat2(str, rb_class2name(data->oclass));
proc.c:    rb_str_append(str, rb_id2str(data->oid));
proc.c: *  call-seq:
proc.c:    proc->is_from_method = 1;
proc.c:    if (TYPE(m) == T_DATA && RDATA(m)->dmark == (RUBY_DATA_FUNC) bm_mark) {
proc.c: * call-seq:
proc.c: *  call-seq:
proc.c:    if (TYPE(proc->block.iseq) == T_NODE) {
proc.c:    bind->env = proc->envval;
proc.c:    is_lambda = procp->is_lambda;
proc.c:    procp->is_lambda = is_lambda;
proc.c:  *  call-seq:
proc.c:	marity = -marity - 1;
proc.c:    rb_define_singleton_method(rb_cProc, "new", rb_proc_s_new, -1);
proc.c:    rb_define_method(rb_cProc, "call", proc_call, -1);
proc.c:    rb_define_method(rb_cProc, "[]", proc_call, -1);
proc.c:    rb_define_method(rb_cProc, "===", proc_call, -1);
proc.c:    rb_define_method(rb_cProc, "yield", proc_call, -1);
proc.c:    rb_define_method(rb_cProc, "curry", proc_curry, -1);
proc.c:    rb_define_method(rb_cMethod, "call", rb_method_call, -1);
proc.c:    rb_define_method(rb_cMethod, "[]", rb_method_call, -1);
proc.c:    rb_define_private_method(rb_cModule, "define_method", rb_mod_define_method, -1);
proc.c:    rb_define_method(rb_mKernel, "define_singleton_method", rb_obj_define_method, -1);
proc.c: *     k2 = Demo.new(-3)
proc.c: *     eval("@secret", b2)   #=> -3
proc.c: *  Binding objects have no class-specific methods.
proc.c:    rb_define_method(rb_cBinding, "eval", bind_eval, -1);
ãã¤ããªã¼ã»ãã¡ã¤ã«proc.oã¯ä¸è´ãã¾ãã
process.c:  process.c -
process.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
process.c:  Copyright (C) 2000  Information-technology Promotion Agency, Japan
process.c: *  call-seq:
process.c: *  call-seq:
process.c: * Document-class: Process::Status
process.c: *  status of a running or terminated system process. The built-in
process.c: *  Posix systems record information on processes using a 16-bit
process.c: *  however, these objects retain a bit-oriented interface. In the
process.c:    return GET_THREAD()->last_status;
process.c:    th->last_status = rb_obj_alloc(rb_cProcessStatus);
process.c:    rb_iv_set(th->last_status, "status", INT2FIX(status));
process.c:    rb_iv_set(th->last_status, "pid", PIDT2NUM(pid));
process.c:    GET_THREAD()->last_status = Qnil;
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c:    if (data->status != -1) return ST_STOP;
process.c:    data->pid = pid;
process.c:    data->status = status;
process.c:    result = waitpid(arg->pid, arg->st, arg->flags);
process.c:    result = wait4(arg->pid, arg->st, arg->flags, NULL);
process.c:	return (rb_pid_t)-1;
process.c:	if (pid == (rb_pid_t)-1) {
process.c:	    data.pid = (rb_pid_t)-1;
process.c:	    data.status = -1;
process.c:	    if (data.status != -1) {
process.c:	    return (rb_pid_t)-1;
process.c:	if (result == pid || pid == (rb_pid_t)-1) {
process.c: *  call-seq:
process.c: *     Process.wait(pid=-1, flags=0)      => fixnum
process.c: *     Process.waitpid(pid=-1, flags=0)   => fixnum
process.c: *  -1::    Waits for any child process (the default if no _pid_ is
process.c: *  < -1::  Waits for any child whose process group ID equals the absolute
process.c: *     Time.now                         #=> 2008-03-08 19:56:16 +0900
process.c: *     Time.now                         #=> 2008-03-08 19:56:16 +0900
process.c: *     Time.now                         #=> 2008-03-08 19:56:19 +0900
process.c:	pid = -1;
process.c: *  call-seq:
process.c: *     Process.wait2(pid=-1, flags=0)      => [pid, status]
process.c: *     Process.waitpid2(pid=-1, flags=0)   => [pid, status]
process.c: *  call-seq:
process.c:    for (pid = -1;;) {
process.c:	pid = rb_waitpid(-1, &status, 0);
process.c:	if (pid == -1) {
process.c: *  call-seq:
process.c: *     system("ps -ho pid,state -p #{p1}")
process.c: *     system("ps -ho pid,state -p #{p1}")
process.c:#define after_fork() (GET_THREAD()->thrown_errinfo = 0, after_exec())
process.c:	    rb_raise(rb_eSecurityError, "Insecure PATH - %s", str);
process.c:	return -1;
process.c:		/* no-op */;
process.c:	    for (; n > 0; n--)
process.c:		return -1;
process.c:    return -1;
process.c:    return -1;
process.c:	    int status = -1;
process.c:		execl(shell, "sh", "-c", str, (char *) NULL);
process.c:	    if (status != -1)
process.c:	    execl("/bin/sh", "sh", "-c", str, (char *)NULL);
process.c:	    return -1;
process.c:    a = argv = ALLOCA_N(char*, (s-str)/2+2);
process.c:    ss = ALLOCA_N(char, s-str+1);
process.c:    memcpy(ss, str, s-str);
process.c:    ss[s-str] = '\0';
process.c:    return -1;
process.c:	return -1;
process.c:    rb_last_status_set(status == -1 ? 127 : status, 0);
process.c:    return -1;
process.c:	    status = shell?spawnl(P_WAIT,shell,"sh","-c",str,(char*)NULL):system(str);
process.c:	    rb_last_status_set(status == -1 ? 127 : status, 0);
process.c:    a = argv = ALLOCA_N(char*, (s - str) / 2 + 2);
process.c:    s = ALLOCA_N(char, s - str + 1);
process.c:    return argv[0] ? proc_spawn_v(argv, 0) : -1;
process.c:    RBASIC(obj)->klass = 0;
process.c:        if (fptr->tied_io_for_writing)
process.c:        fd = fptr->fd;
process.c:    VALUE options = e->options;
process.c:            (rtype = rlimit_type_by_lname(rb_id2name(id)+7)) != -1) {
process.c:    int maxhint = -1;
process.c:        hash = rb_check_convert_type((*argv_p)[*argc_p-1], T_HASH, "Hash", "to_hash");
process.c:            (*argc_p)--;
process.c:            (*argc_p)--;
process.c:    e->options = options;
process.c:    e->argc = argc;
process.c:    e->argv = argv;
process.c:    e->prog = prog ? RSTRING_PTR(prog) : 0;
process.c:    e->redirect_fds = check_exec_fds(e->options);
process.c: *  call-seq:
process.c: *  expansion. If +command+ is a two-element array, the first
process.c:        if (save_fd == -1) return -1;
process.c:    return *(int*)a - *(int*)b;
process.c:    int extra_fd = -1;
process.c:        pairs[i].older_index = -1;
process.c:            while (pairs < found && (found-1)->oldfd == newfd)
process.c:                found--;
process.c:            while (found < pairs+n && found->oldfd == newfd) {
process.c:                found->older_index = i;
process.c:    /* non-cyclic redirection: O(n) */
process.c:        while (j != -1 && pairs[j].oldfd != -1 && pairs[j].num_newer == 0) {
process.c:            if (ret == -1)
process.c:            pairs[j].oldfd = -1;
process.c:            if (j != -1)
process.c:                pairs[j].num_newer--;
process.c:        if (pairs[i].oldfd == -1)
process.c:            if (ret == -1)
process.c:                if (ret == -1)
process.c:            pairs[i].oldfd = -1;
process.c:        if (extra_fd == -1) {
process.c:            if (extra_fd == -1)
process.c:            if (ret == -1)
process.c:        pairs[i].older_index = -1;
process.c:        while (j != -1) {
process.c:            if (ret == -1)
process.c:            pairs[j].oldfd = -1;
process.c:    if (extra_fd != -1) {
process.c:        if (ret == -1)
process.c:    return -1;
process.c:        if (ret == -1)
process.c:            return -1;
process.c:        if (fd2 == -1) return -1;
process.c:                    return -1;
process.c:                if (ret == -1) return -1;
process.c:            if (ret == -1) return -1;
process.c:            if (getrlimit(rtype, &rlim) == -1)
process.c:                return -1;
process.c:        if (setrlimit(rtype, &rlim) == -1)
process.c:            return -1;
process.c:    VALUE options = e->options;
process.c:        s->argc = 0;
process.c:        s->argv = NULL;
process.c:        s->prog = NULL;
process.c:        s->options = soptions = hide_obj(rb_ary_new());
process.c:        s->redirect_fds = Qnil;
process.c:        if (run_exec_pgroup(obj, soptions) == -1)
process.c:            return -1;
process.c:        if (run_exec_rlimit(obj, soptions) == -1)
process.c:            return -1;
process.c:        if (chdir(RSTRING_PTR(obj)) == -1)
process.c:            return -1;
process.c:        if (run_exec_dup2(obj, soptions) == -1)
process.c:            return -1;
process.c:            if (run_exec_close(obj) == -1)
process.c:                return -1;
process.c:        rb_close_before_exec(3, FIX2LONG(obj), e->redirect_fds);
process.c:        if (run_exec_open(obj, soptions) == -1)
process.c:            return -1;
process.c:    int argc = e->argc;
process.c:    VALUE *argv = e->argv;
process.c:    const char *prog = e->prog;
process.c:        return -1;
process.c:    return -1;
process.c:            if (ret == -1)
process.c:                return -1;
process.c:    if (ret == -1)
process.c:        return -1;
process.c:        if (move_fds_to_avoid_crash(filedes, 2, fds) == -1) {
process.c:            return -1;
process.c: * In the case of the function is called and returns non-zero value,
process.c: * the child process exits with non-+EXIT_SUCCESS+ value (normally
process.c: * returns -1 in the parent process.  On the other platforms, just
process.c:	if (pipe_nocrash(ep, fds)) return -1;
process.c:	    return -1;
process.c:	    return -1;
process.c:	    return -1;
process.c: *  call-seq:
process.c:      case -1:
process.c: *  call-seq:
process.c: *     Process.exit!(fixnum=-1)
process.c:    if (GET_THREAD()->tag) {
process.c: *  call-seq:
process.c: *  call-seq:
process.c:	if (!NIL_P(GET_THREAD()->errinfo)) {
process.c:    } while (i == -1 && errno == EINTR);
process.c:        return -1;
process.c:    if (status == -1)
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  spawn closes all non-standard unspecified descriptors by default.
process.c:    if (pid == -1) rb_sys_fail(RSTRING_PTR(argv[0]));
process.c: *  call-seq:
process.c: *     Time.new    #=> 2008-03-08 19:56:19 +0900
process.c: *     Time.new    #=> 2008-03-08 19:56:20 +0900
process.c: *     Time.new    #=> 2008-03-08 19:56:22 +0900
process.c:    end = time(0) - beg;
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c:    if (ret == -1) rb_sys_fail(0);
process.c: *  call-seq:
process.c: *  call-seq:
process.c:    if (16 < len) return -1;
process.c:                return -1;
process.c:    return -1;
process.c:    if (r != -1)
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  [AS] total available memory (bytes) (SUSv3, NetBSD, FreeBSD, OpenBSD but 4.4BSD-Lite)
process.c: * Document-class: Process::Sys
process.c: *  same names instead of the more-portable versions of the same
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  <code>-1</code> for either means to leave that ID unchanged. Not
process.c: *  call-seq:
process.c: *  value of <code>-1</code> for any value means to
process.c: *  call-seq:
process.c: *  call-seq:
process.c:    if (setresuid(uid, -1, -1) < 0) rb_sys_fail(0);
process.c:    if (setreuid(uid, -1) < 0) rb_sys_fail(0);
process.c: * Document-class: Process::UID
process.c:static rb_uid_t SAVED_USER_ID = -1;
process.c:    if (ruid != -1 && ruid != getuid()) {
process.c:	if (euid == -1) euid = geteuid();
process.c:	if (setuid(ruid) < 0) return -1;
process.c:    if (euid != -1 && euid != geteuid()) {
process.c:	if (seteuid(euid) < 0) return -1;
process.c: *  call-seq:
process.c:    if (geteuid() == 0) { /* root-user */
process.c:		if (setreuid(-1, uid) < 0) rb_sys_fail(0);
process.c:		    if (setreuid(-1, SAVED_USER_ID) < 0) rb_sys_fail(0);
process.c:		    if (setreuid(0, -1) < 0) rb_sys_fail(0);
process.c:	if (setresuid((getuid() == uid)? -1: uid,
process.c:		      (geteuid() == uid)? -1: uid,
process.c:		      (SAVED_USER_ID == uid)? -1: uid) < 0) rb_sys_fail(0);
process.c:	    if (setreuid((getuid() == uid)? -1: uid,
process.c:			 (geteuid() == uid)? -1: uid) < 0) rb_sys_fail(0);
process.c:	    if (setreuid(uid, (geteuid() == uid)? -1: uid) < 0) rb_sys_fail(0);
process.c:	    if (setreuid(uid, -1) < 0) rb_sys_fail(0);
process.c:	    if (setreuid(-1, SAVED_USER_ID) < 0) rb_sys_fail(0);
process.c:	    if (setreuid(uid, -1) < 0) rb_sys_fail(0);
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  <code>-1</code> for either means to leave that ID unchanged. Not
process.c: *  call-seq:
process.c: *  respectively. A value of <code>-1</code> for any value means to
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c:    if (setresgid(gid, -1, -1) < 0) rb_sys_fail(0);
process.c:    if (setregid(gid, -1) < 0) rb_sys_fail(0);
process.c: *  call-seq:
process.c:    if (ngroups == -1)
process.c: *  call-seq:
process.c:		groups[i] = gr->gr_gid;
process.c:    if (i == -1)
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c:      case -1:
process.c:	return INT2FIX(-1);
process.c:    /* must not be process-leader */
process.c:      case -1:
process.c:	return INT2FIX(-1);
process.c:    if (!RTEST(noclose) && (n = open("/dev/null", O_RDWR, 0)) != -1) {
process.c: * Document-class: Process::GID
process.c:static int SAVED_GROUP_ID = -1;
process.c:    if (rgid != -1 && rgid != getgid()) {
process.c:	if (egid == -1) egid = getegid();
process.c:	if (setgid(rgid) < 0) return -1;
process.c:    if (egid != -1 && egid != getegid()) {
process.c:	if (setegid(egid) < 0) return -1;
process.c: *  call-seq:
process.c:    if (geteuid() == 0) { /* root-user */
process.c:		if (setregid(-1, gid) < 0) rb_sys_fail(0);
process.c:		    if (setregid(-1, SAVED_GROUP_ID) < 0) rb_sys_fail(0);
process.c:	if (setresgid((getgid() == gid)? -1: gid,
process.c:		      (getegid() == gid)? -1: gid,
process.c:		      (SAVED_GROUP_ID == gid)? -1: gid) < 0) rb_sys_fail(0);
process.c:	    if (setregid((getgid() == gid)? -1: gid,
process.c:			 (getegid() == gid)? -1: gid) < 0) rb_sys_fail(0);
process.c:	    if (setregid(gid, (getegid() == gid)? -1: gid) < 0) rb_sys_fail(0);
process.c:	    if (setregid(gid, -1) < 0) rb_sys_fail(0);
process.c:	    if (setregid(-1, SAVED_GROUP_ID) < 0) rb_sys_fail(0);
process.c:	    if (setregid(gid, -1) < 0) rb_sys_fail(0);
process.c: *  call-seq:
process.c: *  call-seq:
process.c:    if (setresuid(-1, uid, -1) < 0) rb_sys_fail(0);
process.c:    if (setreuid(-1, uid) < 0) rb_sys_fail(0);
process.c:	if (setresuid(-1,euid,euid) < 0) rb_sys_fail(0);
process.c:	if (setresuid(-1,euid,-1) < 0) rb_sys_fail(0);
process.c:    if (setreuid(-1, euid) < 0) rb_sys_fail(0);
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c:    if (setresgid(-1, gid, -1) < 0) rb_sys_fail(0);
process.c:    if (setregid(-1, gid) < 0) rb_sys_fail(0);
process.c:	if (setresgid(-1,egid,egid) < 0) rb_sys_fail(0);
process.c:	if (setresgid(-1,egid,-1) < 0) rb_sys_fail(0);
process.c:    if (setregid(-1, egid) < 0) rb_sys_fail(0);
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c: *  call-seq:
process.c:    rb_define_global_function("exec", rb_f_exec, -1);
process.c:    rb_define_global_function("exit!", rb_f_exit_bang, -1);
process.c:    rb_define_global_function("system", rb_f_system, -1);
process.c:    rb_define_global_function("spawn", rb_f_spawn, -1);
process.c:    rb_define_global_function("sleep", rb_f_sleep, -1);
process.c:    rb_define_global_function("exit", rb_f_exit, -1);
process.c:    rb_define_global_function("abort", rb_f_abort, -1);
process.c:    rb_define_singleton_method(rb_mProcess, "exec", rb_f_exec, -1);
process.c:    rb_define_singleton_method(rb_mProcess, "spawn", rb_f_spawn, -1);
process.c:    rb_define_singleton_method(rb_mProcess, "exit!", rb_f_exit_bang, -1);
process.c:    rb_define_singleton_method(rb_mProcess, "exit", rb_f_exit, -1);
process.c:    rb_define_singleton_method(rb_mProcess, "abort", rb_f_abort, -1);
process.c:    rb_define_module_function(rb_mProcess, "kill", rb_f_kill, -1); /* in signal.c */
process.c:    rb_define_module_function(rb_mProcess, "wait", proc_wait, -1);
process.c:    rb_define_module_function(rb_mProcess, "wait2", proc_wait2, -1);
process.c:    rb_define_module_function(rb_mProcess, "waitpid", proc_wait, -1);
process.c:    rb_define_module_function(rb_mProcess, "waitpid2", proc_wait2, -1);
process.c:    rb_define_module_function(rb_mProcess, "setrlimit", proc_setrlimit, -1);
process.c:    rb_define_module_function(rb_mProcess, "daemon", proc_daemon, -1);
ãã¤ããªã¼ã»ãã¡ã¤ã«process.oã¯ä¸è´ãã¾ãã
random.c:  random.c -
random.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
random.c:contact <http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html>.
random.c:   A C-program for MT19937, with initialization improved 2002/2/10.
random.c:   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
random.c:#define UMASK 0x80000000UL /* most significant w-r bits */
random.c:#define genrand_initialized(mt) ((mt)->next != 0)
random.c:#define uninit_genrand(mt) ((mt)->next = 0)
random.c:    mt->state[0] = s & 0xffffffffUL;
random.c:        mt->state[j] = (1812433253UL * (mt->state[j-1] ^ (mt->state[j-1] >> 30)) + j);
random.c:        mt->state[j] &= 0xffffffffUL;  /* for >32 bit machines */
random.c:    mt->left = 1;
random.c:    mt->next = mt->state + N - 1;
random.c:/* initialize by an array with array-length */
random.c:    for (; k; k--) {
random.c:        mt->state[i] = (mt->state[i] ^ ((mt->state[i-1] ^ (mt->state[i-1] >> 30)) * 1664525UL))
random.c:        mt->state[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
random.c:        if (i>=N) { mt->state[0] = mt->state[N-1]; i=1; }
random.c:    for (k=N-1; k; k--) {
random.c:        mt->state[i] = (mt->state[i] ^ ((mt->state[i-1] ^ (mt->state[i-1] >> 30)) * 1566083941UL))
random.c:          - i; /* non linear */
random.c:        mt->state[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
random.c:        if (i>=N) { mt->state[0] = mt->state[N-1]; i=1; }
random.c:    mt->state[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */
random.c:    unsigned long *p = mt->state;
random.c:    mt->left = N;
random.c:    mt->next = mt->state;
random.c:    for (j=N-M+1; --j; p++)
random.c:    for (j=M; --j; p++)
random.c:        *p = p[M-N] ^ TWIST(p[0], p[1]);
random.c:    *p = p[M-N] ^ TWIST(p[0], mt->state[0]);
random.c:/* generates a random number on [0,0xffffffff]-interval */
random.c:    if (--mt->left <= 0) next_state(mt);
random.c:    y = *mt->next++;
random.c:/* generates a random number on [0,1) with 53-bit resolution*/
random.c:        for (i = RBIGNUM_LEN(seed)-1; 0 <= i; i--) {
random.c:    while (1 < len && buf[len-1] == 0) {
random.c:        len--;
random.c:        if (buf[len-1] == 1) /* remove leading-zero-guard */
random.c:            len--;
random.c:    /* set leading-zero-guard if need. */
random.c:    digits[RBIGNUM_LEN(big)-1] = digits[RBIGNUM_LEN(big)-2] <= 1 ? 1 : 0;
random.c: *  call-seq:
random.c:    for (i = SIZEOF_LONG/4-1; 0 <= i; i--) {
random.c:    for (i = len-1; 0 <= i; i--) {
random.c: *  call-seq:
random.c: *  Mersenne Twister with a period of 2**19937-1.
random.c:            vmax = rb_dbl2big(-RFLOAT_VALUE(vmax));
random.c:                if (FIX2LONG((VALUE)limit) == -1)
random.c:    if (max < 0) max = -max;
random.c:    val = limited_rand(mt, max-1);
random.c:    rb_define_global_function("srand", rb_f_srand, -1);
random.c:    rb_define_global_function("rand", rb_f_rand, -1);
ãã¤ããªã¼ã»ãã¡ã¤ã«random.oã¯ä¸è´ãã¾ãã
range.c:  range.c -
range.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
range.c:#define RANGE_BEG(r) (RSTRUCT(r)->as.ary[0])
range.c:#define RANGE_END(r) (RSTRUCT(r)->as.ary[1])
range.c:#define RANGE_EXCL(r) (RSTRUCT(r)->as.ary[2])
range.c:#define SET_EXCL(r,v) (RSTRUCT(r)->as.ary[2] = (v) ? Qtrue : Qfalse)
range.c:    RSTRUCT(range)->as.ary[0] = beg;
range.c:    RSTRUCT(range)->as.ary[1] = end;
range.c: *  call-seq:
range.c: *  call-seq:
range.c: *  call-seq:
range.c: *  call-seq:
range.c: * call-seq:
range.c:	iter[0] -= INT2FIX(1) & ~FIXNUM_FLAG;
range.c:	iter[0] = rb_funcall(iter[0], '-', 1, INT2FIX(1));
range.c: *  call-seq:
range.c: *  in the class-level documentation.
range.c: *  call-seq:
range.c: *  call-seq:
range.c: *  call-seq:
range.c:    n--;
range.c: *  call-seq:
range.c: *  call-seq:
range.c: *  call-seq:
range.c: *  call-seq:
range.c:		return LONG2NUM(FIX2LONG(e) - 1);
range.c:	    return rb_funcall(e, '-', 1, INT2FIX(1));
range.c:    len = end - beg;
range.c: * call-seq:
range.c: * call-seq:
range.c: *  call-seq:
range.c: *  call-seq:
range.c:    /* TODO: ruby_frame->this_func = rb_intern("include?"); */
range.c: *  call-seq:
range.c:    if (TYPE(obj) != T_OBJECT || RBASIC(obj)->klass != rb_cObject) {
range.c:    RSTRUCT(range)->as.ary[0] = rb_ivar_get(obj, id_beg);
range.c:    RSTRUCT(range)->as.ary[1] = rb_ivar_get(obj, id_end);
range.c:    RSTRUCT(range)->as.ary[2] = rb_ivar_get(obj, id_excl);
range.c:/*  A <code>Range</code> represents an interval---a set of values with a
range.c: *     (-1..-5).to_a      #=> []
range.c: *     (-5..-1).to_a      #=> [-5, -4, -3, -2, -1]
range.c:    rb_define_method(rb_cRange, "initialize", range_initialize, -1);
range.c:    rb_define_method(rb_cRange, "step", range_step, -1);
range.c:    rb_define_method(rb_cRange, "first", range_first, -1);
range.c:    rb_define_method(rb_cRange, "last", range_last, -1);
ãã¤ããªã¼ã»ãã¡ã¤ã«range.oã¯ä¸è´ãã¾ãã
rational.c:	long c = FIX2LONG(x) - FIX2LONG(y);
rational.c:	    c = -1;
rational.c:    return rb_funcall(x, '-', 1, y);
rational.c:	x = -x;
rational.c:	y = -y;
rational.c:    obj->num = num;
rational.c:    obj->den = den;
rational.c:	  case -1:
rational.c:      case -1:
rational.c:      case -1:
rational.c:    return dat->num;
rational.c:    return dat->den;
rational.c:			    dat->num, dat->den,
rational.c:			    adat->num, adat->den,
rational.c:			    bdat->num, bdat->den, '+');
rational.c:			    dat->num, dat->den,
rational.c:			    other, ONE, '-');
rational.c:			    adat->num, adat->den,
rational.c:			    bdat->num, bdat->den, '-');
rational.c:	return rb_num_coerce_bin(self, other, '-');
rational.c:			    dat->num, dat->den,
rational.c:			    adat->num, adat->den,
rational.c:			    bdat->num, bdat->den, '*');
rational.c:			    dat->num, dat->den,
rational.c:			    adat->num, adat->den,
rational.c:			    bdat->num, bdat->den, '/');
rational.c:	if (f_one_p(dat->den))
rational.c:	    other = dat->num; /* good? */
rational.c:		num = f_expt(dat->num, other);
rational.c:		den = f_expt(dat->den, other);
rational.c:	      case -1:
rational.c:		num = f_expt(dat->den, f_negate(other));
rational.c:		den = f_expt(dat->num, f_negate(other));
rational.c:	    if (FIXNUM_P(dat->den) && FIX2LONG(dat->den) == 1)
rational.c:		return f_cmp(dat->num, other);
rational.c:	    if (FIXNUM_P(adat->num) && FIXNUM_P(adat->den) &&
rational.c:		FIXNUM_P(bdat->num) && FIXNUM_P(bdat->den)) {
rational.c:		num1 = f_imul(FIX2LONG(adat->num), FIX2LONG(bdat->den));
rational.c:		num2 = f_imul(FIX2LONG(bdat->num), FIX2LONG(adat->den));
rational.c:		num1 = f_mul(adat->num, bdat->den);
rational.c:		num2 = f_mul(bdat->num, adat->den);
rational.c:	    if (f_zero_p(dat->num) && f_zero_p(other))
rational.c:	    if (!FIXNUM_P(dat->den))
rational.c:	    if (FIX2LONG(dat->den) != 1)
rational.c:	    if (f_equal_p(dat->num, other))
rational.c:	    if (f_zero_p(adat->num) && f_zero_p(bdat->num))
rational.c:	    return f_boolcast(f_equal_p(adat->num, bdat->num) &&
rational.c:			      f_equal_p(adat->den, bdat->den));
rational.c:	if (k_exact_p(RCOMPLEX(other)->imag) && f_zero_p(RCOMPLEX(other)->imag))
rational.c:				(CLASS_OF(self), RCOMPLEX(other)->real), self);
rational.c:    return f_idiv(dat->num, dat->den);
rational.c:    return f_negate(f_idiv(f_negate(dat->num), dat->den));
rational.c:    if (f_negative_p(dat->num))
rational.c:	return f_negate(f_idiv(f_negate(dat->num), dat->den));
rational.c:    return f_idiv(dat->num, dat->den);
rational.c:    if (f_negative_p(dat->num)) {
rational.c:	num = f_negate(dat->num);
rational.c:	num = f_add(f_mul(num, TWO), dat->den);
rational.c:	den = f_mul(dat->den, TWO);
rational.c:	VALUE num = f_add(f_mul(dat->num, TWO), dat->den);
rational.c:	VALUE den = f_mul(dat->den, TWO);
rational.c:    q = (NUM2LONG(f_size(x)) - sizeof(long)) * 8 + 1;
rational.c:    r = -1;
rational.c:	if (f_zero_p(dat->num))
rational.c:	num = dat->num;
rational.c:	den = dat->den;
rational.c:	ne = nl - ml;
rational.c:	de = dl - ml;
rational.c:    e = (int)(ne - de);
rational.c:	f = -f;
rational.c:    return f_xor(f_hash(dat->num), f_hash(dat->den));
rational.c:    s = (*func)(dat->num);
rational.c:    rb_str_concat(s, (*func)(dat->den));
rational.c:    a = rb_assoc_new(dat->num, dat->den);
rational.c:    dat->num = RARRAY_PTR(a)[0];
rational.c:    dat->den = RARRAY_PTR(a)[1];
rational.c:    if (f_zero_p(dat->den))
rational.c:/* --- */
rational.c:    n -= DBL_MANT_DIG;
rational.c:#define NUMERATOR "(?:" DIGITS "?\\.)?" DIGITS "(?:[eE][-+]?" DIGITS ")?"
rational.c:#define PATTERN "\\A" WS "([-+])?(" NUMERATOR ")(?:\\/(" DENOMINATOR "))?" WS
rational.c:    rat_pat = rb_reg_new(rat_pat_source, sizeof rat_pat_source - 1, 0);
rational.c:    an_e_pat = rb_reg_new(an_e_pat_source, sizeof an_e_pat_source - 1, 0);
rational.c:    a_dot_pat = rb_reg_new(a_dot_pat_source, sizeof a_dot_pat_source - 1, 0);
rational.c:				 sizeof underscores_pat_source - 1, 0);
rational.c:	if (!NIL_P(si) && *StringValuePtr(si) == '-')
rational.c:	if (k_exact_p(RCOMPLEX(a1)->imag) && f_zero_p(RCOMPLEX(a1)->imag))
rational.c:	    a1 = RCOMPLEX(a1)->real;
rational.c:	if (k_exact_p(RCOMPLEX(a2)->imag) && f_zero_p(RCOMPLEX(a2)->imag))
rational.c:	    a2 = RCOMPLEX(a2)->real;
rational.c:    id_negate = rb_intern("-@");
rational.c:    ml = (long)(log(DBL_MAX) / log(2.0) - 1);
rational.c:    rb_define_private_method(CLASS_OF(rb_cRational), "new!", nurat_s_new_bang, -1);
rational.c:    rb_define_private_method(CLASS_OF(rb_cRational), "new", nurat_s_new, -1);
rational.c:    rb_define_global_function("Rational", nurat_f_rational, -1);
rational.c:    rb_define_method(rb_cRational, "-", nurat_sub, 1);
rational.c:    /* --- */
rational.c:    rb_define_private_method(CLASS_OF(rb_cRational), "convert", nurat_s_convert, -1);
rational.c:c-file-style: "ruby"
ãã¤ããªã¼ã»ãã¡ã¤ã«rational.oã¯ä¸è´ãã¾ãã
rbconfig.rb:  TOPDIR = File.dirname(__FILE__).chomp!("/lib/ruby/1.9.1/i686-linux")
rbconfig.rb:  CONFIG["INSTALL"] = '/usr/bin/install -c'
rbconfig.rb:  CONFIG["rubyhdrdir"] = "$(includedir)/$(RUBY_INSTALL_NAME)-$(ruby_version)"
rbconfig.rb:  CONFIG["sitearch"] = "i686-linux"
rbconfig.rb:  CONFIG["arch"] = "i686-linux"
rbconfig.rb:  CONFIG["DLDLIBS"] = " -lc"
rbconfig.rb:  CONFIG["LIBRUBYARG_SHARED"] = "-Wl,-R -Wl,$(libdir) -L$(libdir) -l$(RUBY_SO_NAME)"
rbconfig.rb:  CONFIG["LIBRUBYARG_STATIC"] = "-Wl,-R -Wl,$(libdir) -L$(libdir) -l$(RUBY_SO_NAME)-static"
rbconfig.rb:  CONFIG["LIBRUBY_A"] = "lib$(RUBY_SO_NAME)-static.a"
rbconfig.rb:  CONFIG["LIBRUBY_LDSHARED"] = "$(CC) -shared"
rbconfig.rb:  CONFIG["warnflags"] = "-Wall -Wno-parentheses"
rbconfig.rb:  CONFIG["debugflags"] = "-g"
rbconfig.rb:  CONFIG["optflags"] = "-O2"
rbconfig.rb:  CONFIG["RDOCTARGET"] = "install-doc"
rbconfig.rb:  CONFIG["STRIP"] = "strip -S -x"
rbconfig.rb:  CONFIG["RPATHFLAG"] = " -Wl,-R%1$-s"
rbconfig.rb:  CONFIG["LIBPATHFLAG"] = " -L%1$-s"
rbconfig.rb:  CONFIG["LDSHAREDXX"] = "$(CXX) -shared"
rbconfig.rb:  CONFIG["LDSHARED"] = "$(CC) -shared"
rbconfig.rb:  CONFIG["CCDLFLAGS"] = " -fPIC"
rbconfig.rb:  CONFIG["RMALL"] = "rm -fr"
rbconfig.rb:  CONFIG["MAKEDIRS"] = "mkdir -p"
rbconfig.rb:  CONFIG["RM"] = "rm -f"
rbconfig.rb:  CONFIG["INSTALL_DATA"] = "$(INSTALL) -m 644"
rbconfig.rb:  CONFIG["LN_S"] = "ln -s"
rbconfig.rb:  CONFIG["COUTFLAG"] = "-o "
rbconfig.rb:  CONFIG["OUTFLAG"] = "-o "
rbconfig.rb:  CONFIG["CPPOUTFILE"] = "-o conftest.i"
rbconfig.rb:  CONFIG["EGREP"] = "/bin/grep -E"
rbconfig.rb:  CONFIG["CPP"] = "gcc -E"
rbconfig.rb:  CONFIG["LDFLAGS"] = "-L.  -rdynamic -Wl,-export-dynamic"
rbconfig.rb:  CONFIG["target"] = "i686-pc-linux-gnu"
rbconfig.rb:  CONFIG["host_os"] = "linux-gnu"
rbconfig.rb:  CONFIG["host"] = "i686-pc-linux-gnu"
rbconfig.rb:  CONFIG["build_os"] = "linux-gnu"
rbconfig.rb:  CONFIG["build"] = "i686-pc-linux-gnu"
rbconfig.rb:  CONFIG["LIBS"] = "-lpthread -lrt -ldl -lcrypt -lm "
rbconfig.rb:  CONFIG["ECHO_N"] = "-n"
rbconfig.rb:  CONFIG["DEFS"] = "-D_FILE_OFFSET_BITS=64"
rbconfig.rb:Config = RbConfig # compatibility for ruby-1.8.4 and older.
re.c:  re.c -
re.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
re.c:#define BEG(no) regs->beg[no]
re.c:#define END(no) regs->end[no]
re.c:        /* '('     ')'     '*'     '+'     ','     '-'     '.'     '/' */
re.c:    while (len--) {
re.c:	if ((tmp = casetable[(unsigned)*p1++] - casetable[(unsigned)*p2++]))
re.c:    VALUE hx, hy, mask = VALUE_MAX >> ((SIZEOF_VALUE - m) * CHAR_BIT);
re.c:	    return -1;
re.c:    return y - ys - m;
re.c:	qstable[*x] = xe - x;
re.c:	    return y - ys;
re.c:    return -1;
re.c:	qstable[rb_memsearch_qs_utf8_hash(x)] = xe - x;
re.c:	    return y - ys;
re.c:    return -1;
re.c:    if (m > n) return -1;
re.c:	return memcmp(x0, y0, m) == 0 ? 0 : -1;
re.c:		return y - ys;
re.c:	return -1;
re.c:        *kcode = -1;
re.c:	*kcode = rb_enc_find_index("EUC-JP");
re.c:	*kcode = rb_enc_find_index("Windows-31J");
re.c:	*kcode = rb_enc_find_index("UTF-8");
re.c:	*kcode = -1;
re.c:    if (!RREGEXP(re)->ptr || !RREGEXP_SRC(re) || !RREGEXP_SRC_PTR(re)) {
re.c:        if (c == -1) {
re.c:	    else if (c == -1) {
re.c:	if (*option_to_str(opts, RREGEXP(re)->ptr->options))
re.c: *  call-seq:
re.c: * call-seq:
re.c: * Produce a nicely formatted string-version of _rxp_. Perhaps surprisingly,
re.c:    if (!RREGEXP(re)->ptr || !RREGEXP_SRC(re) || !RREGEXP_SRC_PTR(re)) {
re.c: *  call-seq:
re.c: *      s1 = r1.to_s            #=> "(?ix-m:ab+c)"
re.c: *      r2 = Regexp.new(s1)     #=> /(?ix-m:ab+c)/
re.c: *      r2.source               #=> "(?ix-m:ab+c)"
re.c:    options = RREGEXP(re)->ptr->options;
re.c:	if ((len -= 2) > 0) {
re.c:	    } while (--len > 0);
re.c:	if (len > 1 && *ptr == '-') {
re.c:	    --len;
re.c:	    } while (--len > 0);
re.c:	    --len;
re.c:	if (*ptr == ':' && ptr[len-1] == ')') {
re.c: 		 len -= 2;
re.c:	    options = RREGEXP(re)->ptr->options;
re.c:	optbuf[0] = '-';
re.c: *  call-seq:
re.c: *  Returns the value of the case-insensitive flag.
re.c:    if (RREGEXP(re)->ptr->options & ONIG_OPTION_IGNORECASE) return Qtrue;
re.c: *  call-seq:
re.c:    rb_ary_push(ary, rb_str_new((const char *)name, name_end-name));
re.c: * call-seq:
re.c:    onig_foreach_name(RREGEXP(re)->ptr, reg_names_iter, (void*)ary);
re.c:    rb_hash_aset(hash, rb_str_new((const char*)name, name_end-name),ary);
re.c: * call-seq:
re.c:    onig_foreach_name(RREGEXP(re)->ptr, reg_named_captures_iter, (void*)hash);
re.c: *  Document-class: MatchData
re.c:    match->str = 0;
re.c:    match->rmatch = 0;
re.c:    match->regexp = 0;
re.c:    match->rmatch = ALLOC(struct rmatch);
re.c:    MEMZERO(match->rmatch, struct rmatch, 1);
re.c:    return ((pair_t*)pair1)->byte_pos - ((pair_t*)pair2)->byte_pos;
re.c:    struct rmatch *rm = RMATCH(match)->rmatch;
re.c:    if (rm->char_offset_updated)
re.c:    regs = &rm->regs;
re.c:    num_regs = rm->regs.num_regs;
re.c:    if (rm->char_offset_num_allocated < num_regs) {
re.c:        REALLOC_N(rm->char_offset, struct rmatch_offset, num_regs);
re.c:        rm->char_offset_num_allocated = num_regs;
re.c:    enc = rb_enc_get(RMATCH(match)->str);
re.c:            rm->char_offset[i].beg = BEG(i);
re.c:            rm->char_offset[i].end = END(i);
re.c:        rm->char_offset_updated = 1;
re.c:    s = p = RSTRING_PTR(RMATCH(match)->str);
re.c:    e = s + RSTRING_LEN(RMATCH(match)->str);
re.c:            rm->char_offset[i].beg = -1;
re.c:            rm->char_offset[i].end = -1;
re.c:        rm->char_offset[i].beg = found->char_pos;
re.c:        rm->char_offset[i].end = found->char_pos;
re.c:    rm->char_offset_updated = 1;
re.c:    if (!RMATCH(match)->regexp) {
re.c:    RMATCH(obj)->str = RMATCH(orig)->str;
re.c:    RMATCH(obj)->regexp = RMATCH(orig)->regexp;
re.c:    rm = RMATCH(obj)->rmatch;
re.c:    onig_region_copy(&rm->regs, RMATCH_REGS(orig));
re.c:    if (!RMATCH(orig)->rmatch->char_offset_updated) {
re.c:        rm->char_offset_updated = 0;
re.c:        if (rm->char_offset_num_allocated < rm->regs.num_regs) {
re.c:            REALLOC_N(rm->char_offset, struct rmatch_offset, rm->regs.num_regs);
re.c:            rm->char_offset_num_allocated = rm->regs.num_regs;
re.c:        MEMCPY(rm->char_offset, RMATCH(orig)->rmatch->char_offset,
re.c:               struct rmatch_offset, rm->regs.num_regs);
re.c:        rm->char_offset_updated = 1;
re.c: * call-seq:
re.c:    return RMATCH(match)->regexp;
re.c: * call-seq:
re.c:    return rb_reg_names(RMATCH(match)->regexp);
re.c: *  call-seq:
re.c:    return INT2FIX(RMATCH_REGS(match)->num_regs);
re.c:    VALUE regexp = RMATCH(match)->regexp;
re.c:    num = onig_name_to_backref_number(RREGEXP(regexp)->ptr,
re.c: *  call-seq:
re.c: *  Returns a two-element array containing the beginning and ending offsets of
re.c:    if (i < 0 || regs->num_regs <= i)
re.c:    return rb_assoc_new(INT2FIX(RMATCH(match)->rmatch->char_offset[i].beg),
re.c:			INT2FIX(RMATCH(match)->rmatch->char_offset[i].end));
re.c: *  call-seq:
re.c:    if (i < 0 || regs->num_regs <= i)
re.c:    return INT2FIX(RMATCH(match)->rmatch->char_offset[i].beg);
re.c: *  call-seq:
re.c:    if (i < 0 || regs->num_regs <= i)
re.c:    return INT2FIX(RMATCH(match)->rmatch->char_offset[i].end);
re.c: *  call-seq:
re.c: *      r =~ "\xa1\xa2 a".force_encoding("euc-jp")      #=> 2
re.c: *      r =~ "abc".force_encoding("euc-jp")             #=> 0
re.c: *      r.encoding                                      #=> #<Encoding:UTF-8>
re.c: *      r =~ "\xa1\xa2".force_encoding("euc-jp")        #=> ArgumentError
re.c: *      r =~ "abc".force_encoding("euc-jp")             #=> 0
re.c: *      r.encoding                                      #=> #<Encoding:UTF-8>
re.c: *      r =~ "\xa1\xa2".force_encoding("euc-jp")        #=> ArgumentError
re.c: *      r =~ "abc".force_encoding("euc-jp")             #=> nil
re.c:	     rb_enc_name(RREGEXP(re)->ptr->enc),
re.c:        if (RREGEXP(re)->ptr->enc != enc) {
re.c:        if (RREGEXP(re)->ptr->enc != enc &&
re.c:	    (!rb_enc_asciicompat(RREGEXP(re)->ptr->enc) ||
re.c:	enc = RREGEXP(re)->ptr->enc;
re.c:    if (warn && (RBASIC(re)->flags & REG_ENCODING_NONE) &&
re.c:    regex_t *reg = RREGEXP(re)->ptr;
re.c:    if (reg->enc == enc) return reg;
re.c:    reg = RREGEXP(re)->ptr;
re.c:		 reg->options, enc,
re.c:	range = -pos;
re.c:	range = RSTRING_LEN(str) - pos;
re.c:	 return p - string;
re.c:	return -1;
re.c:    tmpreg = reg != RREGEXP(re)->ptr;
re.c:    if (!tmpreg) RREGEXP(re)->usecnt++;
re.c:    if (!tmpreg) RREGEXP(re)->usecnt--;
re.c:	if (RREGEXP(re)->usecnt) {
re.c:	    onig_free(RREGEXP(re)->ptr);
re.c:	    RREGEXP(re)->ptr = reg;
re.c:    RMATCH(match)->str = rb_str_new4(str);
re.c:    RMATCH(match)->regexp = re;
re.c:    RMATCH(match)->rmatch->char_offset_updated = 0;
re.c:    if (nth >= regs->num_regs) {
re.c:	nth += regs->num_regs;
re.c:    if (BEG(nth) == -1) return Qfalse;
re.c:    if (nth >= regs->num_regs) {
re.c:	nth += regs->num_regs;
re.c:    if (start == -1) return Qnil;
re.c:    len = end - start;
re.c:    str = rb_str_subseq(RMATCH(match)->str, start, len);
re.c: *  call-seq:
re.c:    if (BEG(0) == -1) return Qnil;
re.c:    str = rb_str_subseq(RMATCH(match)->str, 0, BEG(0));
re.c: *  call-seq:
re.c:    if (BEG(0) == -1) return Qnil;
re.c:    str = RMATCH(match)->str;
re.c:    str = rb_str_subseq(str, pos, RSTRING_LEN(str) - pos);
re.c:    if (BEG(0) == -1) return Qnil;
re.c:    for (i=regs->num_regs-1; BEG(i) == -1 && i > 0; i--)
re.c:    VALUE ary = rb_ary_new2(regs->num_regs);
re.c:    VALUE target = RMATCH(match)->str;
re.c:    for (i=start; i<regs->num_regs; i++) {
re.c:	if (regs->beg[i] == -1) {
re.c:	    VALUE str = rb_str_subseq(target, regs->beg[i], regs->end[i]-regs->beg[i]);
re.c: *  call-seq:
re.c: *  call-seq:
re.c: *  Returns the array of captures; equivalent to <code>mtch.to_a[1..-1]</code>.
re.c:    num = onig_name_to_backref_number(RREGEXP(regexp)->ptr,
re.c:	VALUE s = rb_str_new(name, (long )(name_end - name));
re.c: *  call-seq:
re.c: *  Match Reference---<code>MatchData</code> acts as an array, and may be
re.c: *     m[-3, 2]   #=> ["X", "113"]
re.c:                       RMATCH(match)->regexp, p, p + strlen(p));
re.c: *  call-seq:
re.c: *     m.values_at(0, 2, -2)   #=> ["HX1138", "X", "113"]
re.c:    return rb_get_values_at(match, regs->num_regs, argc, argv, match_entry);
re.c: *  call-seq:
re.c:    if (OBJ_TAINTED(RMATCH(match)->str)) OBJ_TAINT(str);
re.c: *  call-seq:
re.c:    return RMATCH(match)->str;	/* str is frozen */
re.c:        arg[back_refs[i]].len = name_end - name;
re.c: * call-seq:
re.c:    int num_regs = regs->num_regs;
re.c:    VALUE regexp = RMATCH(match)->regexp;
re.c:    onig_foreach_name(RREGEXP(regexp)->ptr,
re.c:    retbyte = -1;
re.c:        return -1;
re.c:        return -1;
re.c:        p--;
re.c:        code = ruby_scan_oct(p, end < p+3 ? end-p : 3, &len);
re.c:        code = ruby_scan_hex(p, end < p+2 ? end-p : 2, &len);
re.c:            return -1;
re.c:      case 'M': /* \M-X, \M-\C-X, \M-\cX */
re.c:            return -1;
re.c:        if (p+1 < end && *p++ == '-' && (*p & 0x80) == 0) {
re.c:        return -1;
re.c:      case 'C': /* \C-X, \C-\M-X */
re.c:        if (p == end || *p++ != '-') {
re.c:            return -1;
re.c:      case 'c': /* \cX, \c\M-X */
re.c:            return -1;
re.c:        return -1;
re.c:        return -1;
re.c:        return -1;
re.c:    if (byte == -1) {
re.c:        return -1;
re.c:        if (byte == -1) {
re.c:            return -1;
re.c:        return -1;
re.c:            errcpy(err, "escaped non ASCII character in UTF-8 regexp");
re.c:            return -1;
re.c:        return -1;
re.c:        return -1;
re.c:            errcpy(err, "UTF-8 character in non UTF-8 regexp");
re.c:            return -1;
re.c:        code = ruby_scan_hex(p, end-p, &len);
re.c:            return -1;
re.c:            return -1;
re.c:        return -1;
re.c:        return -1;
re.c:        return -1;
re.c:        return -1;
re.c:            return -1;
re.c:                errcpy(err, "non ASCII character in UTF-8 regexp");
re.c:                return -1;
re.c:                return -1;
re.c:                    if (ruby_scan_oct(p-1, end-(p-1), &octlen) <= 0177) {
re.c:                           re-escaping may break backref */
re.c:              case 'c': /* \cX, \c\M-X */
re.c:              case 'C': /* \C-X, \C-\M-X */
re.c:              case 'M': /* \M-X, \M-\C-X, \M-\cX */
re.c:                p = p-2;
re.c:                    return -1;
re.c:                    return -1;
re.c:                        return -1;
re.c:                        return -1;
re.c:                        return -1;
re.c:    if (re->ptr)
re.c:    re->ptr = 0;
re.c:	    return -1;
re.c:        return -1;
re.c:	    return -1;
re.c:	re->basic.flags |= KCODE_FIXED;
re.c:        re->basic.flags |= REG_ENCODING_NONE;
re.c:    re->ptr = make_regexp(RSTRING_PTR(unescaped), RSTRING_LEN(unescaped), enc,
re.c:    if (!re->ptr) return -1;
re.c:    re->src = rb_enc_str_new(s, len, enc);
re.c:    OBJ_FREEZE(re->src);
re.c:                errcpy(err, "/.../n has a non escaped non ASCII character in non ASCII-8BIT script");
re.c:                return -1;
re.c:    re->ptr = 0;
re.c:    re->src = 0;
re.c:    re->usecnt = 0;
re.c: * call-seq:
re.c:    hashval = RREGEXP(re)->ptr->options;
re.c:    while (len--) {
re.c: *  call-seq:
re.c: *  Equality---Two regexps are equal if their patterns are identical, they have
re.c:    if (RREGEXP(re1)->ptr->options != RREGEXP(re2)->ptr->options) return Qfalse;
re.c:	return -1;
re.c: *  call-seq:
re.c: *  Match---Matches <i>rxp</i> against <i>str</i>.
re.c: *  The parser detects 'regexp-literal =~ expression' for the assignment.
re.c: *  call-seq:
re.c: *  Case Equality---Synonym for <code>Regexp#=~</code> used in case statements.
re.c: *     when /^[a-z]*$/; print "Lower case\n"
re.c: *     when /^[A-Z]*$/; print "Upper case\n"
re.c: *  call-seq:
re.c: *  Match---Matches <i>rxp</i> against the contents of <code>$_</code>.
re.c: *  call-seq:
re.c: * Document-method: compile
re.c: *  call-seq:
re.c: *  <em>or</em>-ed together. Otherwise, if <i>options</i> is not
re.c: *     r1 = Regexp.new('^a-z+:\\s+\w+')           #=> /^a-z+:\s+\w+/
re.c:		rb_warn("encoding option is ignored - %s", kcode);
re.c:	if (c == -1) {
re.c:	  case '(': case ')': case '|': case '-':
re.c:    memcpy(t, RSTRING_PTR(str), s - RSTRING_PTR(str));
re.c:    t += s - RSTRING_PTR(str);
re.c:	if (c == -1) {
re.c:	    while (n--)
re.c:	  case '(': case ')': case '|': case '-':
re.c:    rb_str_resize(tmp, t - RSTRING_PTR(tmp));
re.c: *  call-seq:
re.c:    options = RREGEXP(re)->ptr->options & ARG_REG_OPTION_MASK;
re.c:    if (RBASIC(re)->flags & KCODE_FIXED) options |= ARG_ENCODING_FIXED;
re.c:    if (RBASIC(re)->flags & REG_ENCODING_NONE) options |= ARG_ENCODING_NONE;
re.c: *  call-seq:
re.c: *     Regexp.try_convert(obj) -> re or nil
re.c: *  call-seq:
re.c: *     Regexp.union(/dogs/, /cats/i)        #=> /(?-mix:dogs)|(?i-mx:cats)/
re.c:#define ASCGET(s,e,cl) (acompat ? (*cl=1,ISASCII(s[0])?s[0]:-1) : rb_enc_ascget(s, e, cl, str_enc))
re.c:	if (c == -1) {
re.c:	    val = rb_str_buf_new(ss-p);
re.c:        rb_enc_str_buf_cat(val, p, ss-p, str_enc);
re.c:        if (c == -1) {
re.c:	    rb_enc_str_buf_cat(val, ss, s-ss, str_enc);
re.c:            if (onig_noname_group_capture_is_active(RREGEXP(regexp)->ptr)) {
re.c:                no = c - '0';
re.c:                    name_end += c == -1 ? mbclen(name_end, e, str_enc) : clen;
re.c:            rb_enc_str_buf_cat(val, ss, s-ss, str_enc);
re.c:	    rb_enc_str_buf_cat(val, RSTRING_PTR(src)+END(0), RSTRING_LEN(src)-END(0), src_enc);
re.c:	    no = regs->num_regs-1;
re.c:	    while (BEG(no) == -1 && no > 0) no--;
re.c:	    rb_enc_str_buf_cat(val, s-clen, clen, str_enc);
re.c:	    rb_enc_str_buf_cat(val, ss, s-ss, str_enc);
re.c:	    if (no >= regs->num_regs) continue;
re.c:	    if (BEG(no) == -1) continue;
re.c:	    rb_enc_str_buf_cat(val, RSTRING_PTR(src)+BEG(no), END(no)-BEG(no), src_enc);
re.c:        rb_enc_str_buf_cat(val, p, e-p, str_enc);
re.c: *  call-seq:
re.c: *  Document-class: Regexp
re.c:    rb_define_virtual_variable("$-K", kcode_getter, kcode_setter);
re.c:    rb_define_singleton_method(rb_cRegexp, "compile", rb_class_new_instance, -1);
re.c:    rb_define_singleton_method(rb_cRegexp, "union", rb_reg_s_union_m, -2);
re.c:    rb_define_singleton_method(rb_cRegexp, "last_match", rb_reg_s_last_match, -1);
re.c:    rb_define_method(rb_cRegexp, "initialize", rb_reg_initialize_m, -1);
re.c:    rb_define_method(rb_cRegexp, "match", rb_reg_match_m, -1);
re.c:    rb_define_method(rb_cMatch, "[]", match_aref, -1);
re.c:    rb_define_method(rb_cMatch, "values_at", match_values_at, -1);
ãã¤ããªã¼ã»ãã¡ã¤ã«re.oã¯ä¸è´ãã¾ãã
regcomp.c:  regcomp.c -  Oniguruma (regular expression library)
regcomp.c:/*-
regcomp.c: * Copyright (c) 2002-2007  K.Kosako  <sndgk393 AT ybb DOT ne DOT jp>
regcomp.c:  int len = end - s;
regcomp.c:    if (sn->capa == 0) {
regcomp.c:      int len = sn->end - sn->s;
regcomp.c:      sn->s   = sn->buf;
regcomp.c:      sn->end = sn->s + len;
regcomp.c:    if (sn->capa == 0) {
regcomp.c:      int len = sn->end - sn->s;
regcomp.c:      sn->s   = sn->buf;
regcomp.c:      sn->end = sn->s + len;
regcomp.c:    if (d1 <= ONIG_INFINITE_DISTANCE - d2) return d1 + d2;
regcomp.c:    buf->p = NULL;
regcomp.c:    buf->p = (UChar* )xmalloc(size);
regcomp.c:    if (IS_NULL(buf->p)) return(ONIGERR_MEMORY);
regcomp.c:  buf->alloc = size;
regcomp.c:  buf->used  = 0;
regcomp.c:  uslist->num   = 0;
regcomp.c:  uslist->alloc = size;
regcomp.c:  uslist->us    = p;
regcomp.c:  if (IS_NOT_NULL(uslist->us))
regcomp.c:    xfree(uslist->us);
regcomp.c:  if (uslist->num >= uslist->alloc) {
regcomp.c:    size = uslist->alloc * 2;
regcomp.c:    p = (UnsetAddr* )xrealloc(uslist->us, sizeof(UnsetAddr) * size);
regcomp.c:    uslist->alloc = size;
regcomp.c:    uslist->us    = p;
regcomp.c:  uslist->us[uslist->num].offset = offset;
regcomp.c:  uslist->us[uslist->num].target = node;
regcomp.c:  uslist->num++;
regcomp.c:  int saved_num_null_check = reg->num_null_check;
regcomp.c:    r = add_mem_num(reg, reg->num_null_check); /* NULL CHECK ID */
regcomp.c:    reg->num_null_check++;
regcomp.c:  r = unset_addr_list_add(node->unset_addr_list, BBUF_GET_OFFSET_POS(reg),
regcomp.c:                          node->target);
regcomp.c:  OnigEncoding enc = reg->enc;
regcomp.c:  if (sn->end <= sn->s)
regcomp.c:  p = prev = sn->s;
regcomp.c:  prev_len = enclen(enc, p, sn->end);
regcomp.c:  for (; p < sn->end; ) {
regcomp.c:    len = enclen(enc, p, sn->end);
regcomp.c:  if (sn->end <= sn->s)
regcomp.c:  return add_compile_string_length(sn->s, 1 /* sb */, sn->end - sn->s, reg, 0);
regcomp.c:  OnigEncoding enc = reg->enc;
regcomp.c:  if (sn->end <= sn->s)
regcomp.c:  end = sn->end;
regcomp.c:  p = prev = sn->s;
regcomp.c:  if (sn->end <= sn->s)
regcomp.c:  return add_compile_string(sn->s, 1 /* sb */, sn->end - sn->s, reg, 0);
regcomp.c:  add_length(reg, mbuf->used);
regcomp.c:  return add_bytes(reg, mbuf->p, mbuf->used);
regcomp.c:  add_length(reg, mbuf->used + (WORD_ALIGNMENT_SIZE - 1));
regcomp.c:  r = add_bytes(reg, mbuf->p, mbuf->used);
regcomp.c:  pad_size = (WORD_ALIGNMENT_SIZE - 1) - pad_size;
regcomp.c:  if (IS_NULL(cc->mbuf)) {
regcomp.c:    if (ONIGENC_MBC_MINLEN(reg->enc) > 1 || bitset_is_empty(cc->bs)) {
regcomp.c:    len += SIZE_LENGTH + cc->mbuf->used;
regcomp.c:    len += SIZE_LENGTH + cc->mbuf->used + (WORD_ALIGNMENT_SIZE - 1);
regcomp.c:  if (IS_NULL(cc->mbuf)) {
regcomp.c:    r = add_bitset(reg, cc->bs);
regcomp.c:    if (ONIGENC_MBC_MINLEN(reg->enc) > 1 || bitset_is_empty(cc->bs)) {
regcomp.c:      r = add_multi_byte_cclass(cc->mbuf, reg);
regcomp.c:      r = add_bitset(reg, cc->bs);
regcomp.c:      r = add_multi_byte_cclass(cc->mbuf, reg);
regcomp.c:  if (reg->repeat_range_alloc == 0) {
regcomp.c:    reg->repeat_range = p;
regcomp.c:    reg->repeat_range_alloc = REPEAT_RANGE_ALLOC;
regcomp.c:  else if (reg->repeat_range_alloc <= id) {
regcomp.c:    n = reg->repeat_range_alloc + REPEAT_RANGE_ALLOC;
regcomp.c:    p = (OnigRepeatRange* )xrealloc(reg->repeat_range,
regcomp.c:    reg->repeat_range = p;
regcomp.c:    reg->repeat_range_alloc = n;
regcomp.c:    p = reg->repeat_range;
regcomp.c:  int num_repeat = reg->num_repeat;
regcomp.c:  r = add_opcode(reg, qn->greedy ? OP_REPEAT : OP_REPEAT_NG);
regcomp.c:  reg->num_repeat++;
regcomp.c:  r = entry_repeat_range(reg, num_repeat, qn->lower, qn->upper);
regcomp.c:  r = compile_tree_empty_check(qn->target, reg, empty_info);
regcomp.c:      reg->num_call > 0 ||
regcomp.c:    r = add_opcode(reg, qn->greedy ? OP_REPEAT_INC_SG : OP_REPEAT_INC_NG_SG);
regcomp.c:    r = add_opcode(reg, qn->greedy ? OP_REPEAT_INC : OP_REPEAT_INC_NG);
regcomp.c:  if (qn->greedy && IS_REPEAT_INFINITE(qn->upper) &&
regcomp.c:      NTYPE(qn->target) == NT_CANY)
regcomp.c:  int infinite = IS_REPEAT_INFINITE(qn->upper);
regcomp.c:  int empty_info = qn->target_empty_info;
regcomp.c:  int tlen = compile_length_tree(qn->target, reg);
regcomp.c:  ckn = ((reg->num_comb_exp_check > 0) ? qn->comb_exp_check_num : 0);
regcomp.c:  if (NTYPE(qn->target) == NT_CANY) {
regcomp.c:    if (qn->greedy && infinite) {
regcomp.c:      if (IS_NOT_NULL(qn->next_head_exact) && !CKN_ON)
regcomp.c:        return SIZE_OP_ANYCHAR_STAR_PEEK_NEXT + tlen * qn->lower + cklen;
regcomp.c:        return SIZE_OP_ANYCHAR_STAR + tlen * qn->lower + cklen;
regcomp.c:  if (infinite && qn->lower <= 1) {
regcomp.c:    if (qn->greedy) {
regcomp.c:      if (qn->lower == 1)
regcomp.c:      if (qn->lower == 0)
regcomp.c:  else if (qn->upper == 0) {
regcomp.c:    if (qn->is_refered != 0) /* /(?<n>..){0}/ */
regcomp.c:  else if (qn->upper == 1 && qn->greedy) {
regcomp.c:    if (qn->lower == 0) {
regcomp.c:  else if (!qn->greedy && qn->upper == 1 && qn->lower == 0) { /* '??' */
regcomp.c:  int infinite = IS_REPEAT_INFINITE(qn->upper);
regcomp.c:  int empty_info = qn->target_empty_info;
regcomp.c:  int tlen = compile_length_tree(qn->target, reg);
regcomp.c:  ckn = ((reg->num_comb_exp_check > 0) ? qn->comb_exp_check_num : 0);
regcomp.c:    r = compile_tree_n_times(qn->target, qn->lower, reg);
regcomp.c:    if (IS_NOT_NULL(qn->next_head_exact) && !CKN_ON) {
regcomp.c:      if (IS_MULTILINE(reg->options))
regcomp.c:      return add_bytes(reg, NSTR(qn->next_head_exact)->s, 1);
regcomp.c:      if (IS_MULTILINE(reg->options)) {
regcomp.c:  if (infinite && qn->lower <= 1) {
regcomp.c:    if (qn->greedy) {
regcomp.c:      if (qn->lower == 1) {
regcomp.c:      r = compile_tree_empty_check(qn->target, reg, empty_info);
regcomp.c:	      -(mod_tlen + (int )SIZE_OP_JUMP
regcomp.c:      if (qn->lower == 0) {
regcomp.c:      r = compile_tree_empty_check(qn->target, reg, empty_info);
regcomp.c:		 -(mod_tlen + (int )SIZE_OP_STATE_CHECK_PUSH_OR_JUMP));
regcomp.c:	r = add_opcode_rel_addr(reg, OP_PUSH, -(mod_tlen + (int )SIZE_OP_PUSH));
regcomp.c:  else if (qn->upper == 0) {
regcomp.c:    if (qn->is_refered != 0) { /* /(?<n>..){0}/ */
regcomp.c:      r = compile_tree(qn->target, reg);
regcomp.c:  else if (qn->upper == 1 && qn->greedy) {
regcomp.c:    if (qn->lower == 0) {
regcomp.c:    r = compile_tree(qn->target, reg);
regcomp.c:  else if (!qn->greedy && qn->upper == 1 && qn->lower == 0) { /* '??' */
regcomp.c:    r = compile_tree(qn->target, reg);
regcomp.c:  int infinite = IS_REPEAT_INFINITE(qn->upper);
regcomp.c:  int empty_info = qn->target_empty_info;
regcomp.c:  int tlen = compile_length_tree(qn->target, reg);
regcomp.c:  if (NTYPE(qn->target) == NT_CANY) {
regcomp.c:    if (qn->greedy && infinite) {
regcomp.c:      if (IS_NOT_NULL(qn->next_head_exact))
regcomp.c:        return SIZE_OP_ANYCHAR_STAR_PEEK_NEXT + tlen * qn->lower;
regcomp.c:        return SIZE_OP_ANYCHAR_STAR + tlen * qn->lower;
regcomp.c:      (qn->lower <= 1 || tlen * qn->lower <= QUANTIFIER_EXPAND_LIMIT_SIZE)) {
regcomp.c:    if (qn->lower == 1 && tlen > QUANTIFIER_EXPAND_LIMIT_SIZE) {
regcomp.c:      len = tlen * qn->lower;
regcomp.c:    if (qn->greedy) {
regcomp.c:      if (IS_NOT_NULL(qn->head_exact))
regcomp.c:      else if (IS_NOT_NULL(qn->next_head_exact))
regcomp.c:  else if (qn->upper == 0 && qn->is_refered != 0) { /* /(?<n>..){0}/ */
regcomp.c:  else if (!infinite && qn->greedy &&
regcomp.c:           (qn->upper == 1 || (tlen + SIZE_OP_PUSH) * qn->upper
regcomp.c:    len = tlen * qn->lower;
regcomp.c:    len += (SIZE_OP_PUSH + tlen) * (qn->upper - qn->lower);
regcomp.c:  else if (!qn->greedy && qn->upper == 1 && qn->lower == 0) { /* '??' */
regcomp.c:  int infinite = IS_REPEAT_INFINITE(qn->upper);
regcomp.c:  int empty_info = qn->target_empty_info;
regcomp.c:  int tlen = compile_length_tree(qn->target, reg);
regcomp.c:    r = compile_tree_n_times(qn->target, qn->lower, reg);
regcomp.c:    if (IS_NOT_NULL(qn->next_head_exact)) {
regcomp.c:      if (IS_MULTILINE(reg->options))
regcomp.c:      return add_bytes(reg, NSTR(qn->next_head_exact)->s, 1);
regcomp.c:      if (IS_MULTILINE(reg->options))
regcomp.c:      (qn->lower <= 1 || tlen * qn->lower <= QUANTIFIER_EXPAND_LIMIT_SIZE)) {
regcomp.c:    if (qn->lower == 1 && tlen > QUANTIFIER_EXPAND_LIMIT_SIZE) {
regcomp.c:      if (qn->greedy) {
regcomp.c:	if (IS_NOT_NULL(qn->head_exact))
regcomp.c:	else if (IS_NOT_NULL(qn->next_head_exact))
regcomp.c:      r = compile_tree_n_times(qn->target, qn->lower, reg);
regcomp.c:    if (qn->greedy) {
regcomp.c:      if (IS_NOT_NULL(qn->head_exact)) {
regcomp.c:	add_bytes(reg, NSTR(qn->head_exact)->s, 1);
regcomp.c:	r = compile_tree_empty_check(qn->target, reg, empty_info);
regcomp.c:	-(mod_tlen + (int )SIZE_OP_JUMP + (int )SIZE_OP_PUSH_OR_JUMP_EXACT1));
regcomp.c:      else if (IS_NOT_NULL(qn->next_head_exact)) {
regcomp.c:	add_bytes(reg, NSTR(qn->next_head_exact)->s, 1);
regcomp.c:	r = compile_tree_empty_check(qn->target, reg, empty_info);
regcomp.c:          -(mod_tlen + (int )SIZE_OP_JUMP + (int )SIZE_OP_PUSH_IF_PEEK_NEXT));
regcomp.c:	r = compile_tree_empty_check(qn->target, reg, empty_info);
regcomp.c:		     -(mod_tlen + (int )SIZE_OP_JUMP + (int )SIZE_OP_PUSH));
regcomp.c:      r = compile_tree_empty_check(qn->target, reg, empty_info);
regcomp.c:      r = add_opcode_rel_addr(reg, OP_PUSH, -(mod_tlen + (int )SIZE_OP_PUSH));
regcomp.c:  else if (qn->upper == 0 && qn->is_refered != 0) { /* /(?<n>..){0}/ */
regcomp.c:    r = compile_tree(qn->target, reg);
regcomp.c:  else if (!infinite && qn->greedy &&
regcomp.c:           (qn->upper == 1 || (tlen + SIZE_OP_PUSH) * qn->upper
regcomp.c:    int n = qn->upper - qn->lower;
regcomp.c:    r = compile_tree_n_times(qn->target, qn->lower, reg);
regcomp.c:			   (n - i) * tlen + (n - i - 1) * SIZE_OP_PUSH);
regcomp.c:      r = compile_tree(qn->target, reg);
regcomp.c:  else if (!qn->greedy && qn->upper == 1 && qn->lower == 0) { /* '??' */
regcomp.c:    r = compile_tree(qn->target, reg);
regcomp.c:  OnigOptionType prev = reg->options;
regcomp.c:  reg->options = node->option;
regcomp.c:  tlen = compile_length_tree(node->target, reg);
regcomp.c:  reg->options = prev;
regcomp.c:  if (IS_DYNAMIC_OPTION(prev ^ node->option)) {
regcomp.c:  OnigOptionType prev = reg->options;
regcomp.c:  if (IS_DYNAMIC_OPTION(prev ^ node->option)) {
regcomp.c:    r = add_opcode_option(reg, OP_SET_OPTION_PUSH, node->option);
regcomp.c:  reg->options = node->option;
regcomp.c:  r = compile_tree(node->target, reg);
regcomp.c:  reg->options = prev;
regcomp.c:  if (IS_DYNAMIC_OPTION(prev ^ node->option)) {
regcomp.c:  if (node->type == ENCLOSE_OPTION)
regcomp.c:  if (node->target) {
regcomp.c:    tlen = compile_length_tree(node->target, reg);
regcomp.c:  switch (node->type) {
regcomp.c:      if (BIT_STATUS_AT(reg->bt_mem_end, node->regnum))
regcomp.c:      if (BIT_STATUS_AT(reg->bt_mem_start, node->regnum))
regcomp.c:      len += tlen + (BIT_STATUS_AT(reg->bt_mem_end, node->regnum)
regcomp.c:      QtfrNode* qn = NQTFR(node->target);
regcomp.c:      tlen = compile_length_tree(qn->target, reg);
regcomp.c:      len = tlen * qn->lower
regcomp.c:  if (node->type == ENCLOSE_OPTION)
regcomp.c:  switch (node->type) {
regcomp.c:      node->call_addr = BBUF_GET_OFFSET_POS(reg) + SIZE_ABSADDR + SIZE_OP_JUMP;
regcomp.c:      node->state |= NST_ADDR_FIXED;
regcomp.c:      r = add_abs_addr(reg, (int )node->call_addr);
regcomp.c:      len = compile_length_tree(node->target, reg);
regcomp.c:      if (BIT_STATUS_AT(reg->bt_mem_end, node->regnum))
regcomp.c:    if (BIT_STATUS_AT(reg->bt_mem_start, node->regnum))
regcomp.c:    r = add_mem_num(reg, node->regnum);
regcomp.c:    r = compile_tree(node->target, reg);
regcomp.c:      if (BIT_STATUS_AT(reg->bt_mem_end, node->regnum))
regcomp.c:      r = add_mem_num(reg, node->regnum);
regcomp.c:      if (BIT_STATUS_AT(reg->bt_mem_end, node->regnum))
regcomp.c:      r = add_mem_num(reg, node->regnum);
regcomp.c:      QtfrNode* qn = NQTFR(node->target);
regcomp.c:      r = compile_tree_n_times(qn->target, qn->lower, reg);
regcomp.c:      len = compile_length_tree(qn->target, reg);
regcomp.c:      r = compile_tree(qn->target, reg);
regcomp.c:	 -((int )SIZE_OP_PUSH + len + (int )SIZE_OP_POP + (int )SIZE_OP_JUMP));
regcomp.c:      r = compile_tree(node->target, reg);
regcomp.c:  if (node->target) {
regcomp.c:    tlen = compile_length_tree(node->target, reg);
regcomp.c:  switch (node->type) {
regcomp.c:  switch (node->type) {
regcomp.c:    r = compile_tree(node->target, reg);
regcomp.c:    len = compile_length_tree(node->target, reg);
regcomp.c:    r = compile_tree(node->target, reg);
regcomp.c:      if (node->char_len < 0) {
regcomp.c:	r = get_char_length_tree(node->target, reg, &n);
regcomp.c:	n = node->char_len;
regcomp.c:      r = compile_tree(node->target, reg);
regcomp.c:      len = compile_length_tree(node->target, reg);
regcomp.c:      if (node->char_len < 0) {
regcomp.c:	r = get_char_length_tree(node->target, reg, &n);
regcomp.c:	n = node->char_len;
regcomp.c:      r = compile_tree(node->target, reg);
regcomp.c:      r += (SIZE_OP_PUSH + SIZE_OP_JUMP) * (n - 1);
regcomp.c:            SIZE_LENGTH + (SIZE_MEMNUM * br->back_num);
regcomp.c:      if (br->back_num == 1) {
regcomp.c:	r = ((!IS_IGNORECASE(reg->options) && br->back_static[0] <= 2)
regcomp.c:	r = SIZE_OPCODE + SIZE_LENGTH + (SIZE_MEMNUM * br->back_num);
regcomp.c:      pos = reg->used + len;  /* goal position */
regcomp.c:	  len = pos - (reg->used + SIZE_OP_JUMP);
regcomp.c:      switch (NCTYPE(node)->ctype) {
regcomp.c:	if (NCTYPE(node)->not != 0)  op = OP_NOT_WORD;
regcomp.c:    if (IS_MULTILINE(reg->options))
regcomp.c:	r = add_option(reg, (reg->options & ONIG_OPTION_IGNORECASE));
regcomp.c:	r = add_length(reg, br->nest_level);
regcomp.c:      if (br->back_num == 1) {
regcomp.c:	n = br->back_static[0];
regcomp.c:	if (IS_IGNORECASE(reg->options)) {
regcomp.c:        if (IS_IGNORECASE(reg->options)) {
regcomp.c:	r = add_length(reg, br->back_num);
regcomp.c:	for (i = br->back_num - 1; i >= 0; i--) {
regcomp.c:      Node** ptarget = &(NQTFR(node)->target);
regcomp.c:      if (en->type == ENCLOSE_MEMORY) {
regcomp.c:	  map[en->regnum].new_val = *counter;
regcomp.c:	  en->regnum = *counter;
regcomp.c:	  r = noname_disable_map(&(en->target), map, counter);
regcomp.c:	  *plink = en->target;
regcomp.c:	  en->target = NULL_NODE;
regcomp.c:	r = noname_disable_map(&(en->target), map, counter);
regcomp.c:  old_num = bn->back_num;
regcomp.c:  if (IS_NULL(bn->back_dynamic))
regcomp.c:    backs = bn->back_static;
regcomp.c:    backs = bn->back_dynamic;
regcomp.c:  bn->back_num = pos;
regcomp.c:    r = renumber_by_map(NQTFR(node)->target, map);
regcomp.c:    r = renumber_by_map(NENCLOSE(node)->target, map);
regcomp.c:    r = numbered_ref_check(NQTFR(node)->target);
regcomp.c:    r = numbered_ref_check(NENCLOSE(node)->target);
regcomp.c:  map = (GroupNumRemap* )xalloca(sizeof(GroupNumRemap) * (env->num_mem + 1));
regcomp.c:  for (i = 1; i <= env->num_mem; i++) {
regcomp.c:  for (i = 1, pos = 1; i <= env->num_mem; i++) {
regcomp.c:  loc = env->capture_history;
regcomp.c:  BIT_STATUS_CLEAR(env->capture_history);
regcomp.c:      BIT_STATUS_ON_AT_SIMPLE(env->capture_history, map[i].new_val);
regcomp.c:  env->num_mem = env->num_named;
regcomp.c:  reg->num_mem = env->num_named;
regcomp.c:  for (i = 0; i < uslist->num; i++) {
regcomp.c:    en = NENCLOSE(uslist->us[i].target);
regcomp.c:    addr = en->call_addr;
regcomp.c:    offset = uslist->us[i].offset;
regcomp.c:      r = quantifiers_memory_node_info(NCALL(node)->target);
regcomp.c:      if (qn->upper != 0) {
regcomp.c:	r = quantifiers_memory_node_info(qn->target);
regcomp.c:      switch (en->type) {
regcomp.c:	r = quantifiers_memory_node_info(en->target);
regcomp.c:      if (br->state & NST_RECURSION) break;
regcomp.c:      if (backs[0] > env->num_mem)  return ONIGERR_INVALID_BACKREF;
regcomp.c:      for (i = 1; i < br->back_num; i++) {
regcomp.c:	if (backs[i] > env->num_mem)  return ONIGERR_INVALID_BACKREF;
regcomp.c:      EncloseNode* en = NENCLOSE(NCALL(node)->target);
regcomp.c:	*min = en->min_len;
regcomp.c:      r = get_min_match_length(NCALL(node)->target, min, env);
regcomp.c:      *min = sn->end - sn->s;
regcomp.c:      if (qn->lower > 0) {
regcomp.c:	r = get_min_match_length(qn->target, min, env);
regcomp.c:	  *min = distance_multiply(*min, qn->lower);
regcomp.c:      switch (en->type) {
regcomp.c:	  *min = en->min_len;
regcomp.c:	  r = get_min_match_length(en->target, min, env);
regcomp.c:	    en->min_len = *min;
regcomp.c:	r = get_min_match_length(en->target, min, env);
regcomp.c:      *max = sn->end - sn->s;
regcomp.c:    *max = ONIGENC_MBC_MAXLEN_DIST(env->enc);
regcomp.c:    *max = ONIGENC_MBC_MAXLEN_DIST(env->enc);
regcomp.c:      if (br->state & NST_RECURSION) {
regcomp.c:      for (i = 0; i < br->back_num; i++) {
regcomp.c:	if (backs[i] > env->num_mem)  return ONIGERR_INVALID_BACKREF;
regcomp.c:      r = get_max_match_length(NCALL(node)->target, max, env);
regcomp.c:      if (qn->upper != 0) {
regcomp.c:	r = get_max_match_length(qn->target, max, env);
regcomp.c:	  if (! IS_REPEAT_INFINITE(qn->upper))
regcomp.c:	    *max = distance_multiply(*max, qn->upper);
regcomp.c:      switch (en->type) {
regcomp.c:	  *max = en->max_len;
regcomp.c:	  r = get_max_match_length(en->target, max, env);
regcomp.c:	    en->max_len = *max;
regcomp.c:	r = get_max_match_length(en->target, max, env);
regcomp.c:#define GET_CHAR_LEN_VARLEN           -1
regcomp.c:#define GET_CHAR_LEN_TOP_ALT_VARLEN   -2
regcomp.c:      UChar *s = sn->s;
regcomp.c:      while (s < sn->end) {
regcomp.c:	s += enclen(reg->enc, s, sn->end);
regcomp.c:      if (qn->lower == qn->upper) {
regcomp.c:	r = get_char_length_tree1(qn->target, reg, &tlen, level);
regcomp.c:	  *len = distance_multiply(tlen, qn->lower);
regcomp.c:      r = get_char_length_tree1(NCALL(node)->target, reg, len, level);
regcomp.c:      switch (en->type) {
regcomp.c:	  *len = en->char_len;
regcomp.c:	  r = get_char_length_tree1(en->target, reg, len, level);
regcomp.c:	    en->char_len = *len;
regcomp.c:	r = get_char_length_tree1(en->target, reg, len, level);
regcomp.c:	if (NCTYPE(y)->ctype == NCTYPE(x)->ctype &&
regcomp.c:	    NCTYPE(y)->not   != NCTYPE(x)->not)
regcomp.c:	switch (NCTYPE(y)->ctype) {
regcomp.c:	  if (NCTYPE(y)->not == 0) {
regcomp.c:	    if (IS_NULL(xc->mbuf) && !IS_NCCLASS_NOT(xc)) {
regcomp.c:		if (BITSET_AT(xc->bs, i)) {
regcomp.c:		  if (IS_CODE_SB_WORD(reg->enc, i)) return 0;
regcomp.c:	      if (! IS_CODE_SB_WORD(reg->enc, i)) {
regcomp.c:		  if (BITSET_AT(xc->bs, i))
regcomp.c:		  if (! BITSET_AT(xc->bs, i))
regcomp.c:	    v = BITSET_AT(xc->bs, i);
regcomp.c:	      v = BITSET_AT(yc->bs, i);
regcomp.c:	  if ((IS_NULL(xc->mbuf) && !IS_NCCLASS_NOT(xc)) ||
regcomp.c:	      (IS_NULL(yc->mbuf) && !IS_NCCLASS_NOT(yc)))
regcomp.c:      c = *(xs->s);
regcomp.c:	switch (NCTYPE(y)->ctype) {
regcomp.c:	  if (ONIGENC_IS_MBC_WORD(reg->enc, xs->s, xs->end))
regcomp.c:	    return NCTYPE(y)->not;
regcomp.c:	    return !(NCTYPE(y)->not);
regcomp.c:	  code = ONIGENC_MBC_TO_CODE(reg->enc, xs->s,
regcomp.c:				     xs->s + ONIGENC_MBC_MAXLEN(reg->enc));
regcomp.c:	  return (onig_is_code_in_cc(reg->enc, code, cc) != 0 ? 0 : 1);
regcomp.c:	    for (i = 0, p = ys->s, q = xs->s; i < len; i++, p++, q++) {
regcomp.c:      if (sn->end <= sn->s)
regcomp.c:	  !NSTRING_IS_RAW(node) && IS_IGNORECASE(reg->options)) {
regcomp.c:      if (qn->lower > 0) {
regcomp.c:	if (IS_NOT_NULL(qn->head_exact))
regcomp.c:	  n = qn->head_exact;
regcomp.c:	  n = get_head_value_node(qn->target, exact, reg);
regcomp.c:      switch (en->type) {
regcomp.c:	  OnigOptionType options = reg->options;
regcomp.c:	  reg->options = NENCLOSE(node)->option;
regcomp.c:	  n = get_head_value_node(NENCLOSE(node)->target, exact, reg);
regcomp.c:	  reg->options = options;
regcomp.c:	n = get_head_value_node(en->target, exact, reg);
regcomp.c:    if (NANCHOR(node)->type == ANCHOR_PREC_READ)
regcomp.c:      n = get_head_value_node(NANCHOR(node)->target, exact, reg);
regcomp.c:    r = check_type_tree(NQTFR(node)->target, type_mask, enclose_mask,
regcomp.c:      if ((en->type & enclose_mask) == 0)
regcomp.c:      r = check_type_tree(en->target, type_mask, enclose_mask, anchor_mask);
regcomp.c:    type = NANCHOR(node)->type;
regcomp.c:    if (NANCHOR(node)->target)
regcomp.c:      r = check_type_tree(NANCHOR(node)->target,
regcomp.c:    r = subexp_inf_recursive_check(NQTFR(node)->target, env, head);
regcomp.c:      if (NQTFR(node)->lower == 0) r = 0;
regcomp.c:      switch (an->type) {
regcomp.c:	r = subexp_inf_recursive_check(an->target, env, head);
regcomp.c:    r = subexp_inf_recursive_check(NCALL(node)->target, env, head);
regcomp.c:      r = subexp_inf_recursive_check(NENCLOSE(node)->target, env, head);
regcomp.c:    r = subexp_inf_recursive_check_trav(NQTFR(node)->target, env);
regcomp.c:      switch (an->type) {
regcomp.c:	r = subexp_inf_recursive_check_trav(an->target, env);
regcomp.c:	r = subexp_inf_recursive_check(en->target, env, 1);
regcomp.c:      r = subexp_inf_recursive_check_trav(en->target, env);
regcomp.c:    r = subexp_recursive_check(NQTFR(node)->target);
regcomp.c:      switch (an->type) {
regcomp.c:	r = subexp_recursive_check(an->target);
regcomp.c:    r = subexp_recursive_check(NCALL(node)->target);
regcomp.c:      r = subexp_recursive_check(NENCLOSE(node)->target);
regcomp.c:    r = subexp_recursive_check_trav(NQTFR(node)->target, env);
regcomp.c:    if (NQTFR(node)->upper == 0) {
regcomp.c:	NQTFR(node)->is_refered = 1;
regcomp.c:      switch (an->type) {
regcomp.c:	r = subexp_recursive_check_trav(an->target, env);
regcomp.c:	  r = subexp_recursive_check(en->target);
regcomp.c:      r = subexp_recursive_check_trav(en->target, env);
regcomp.c:    r = setup_subexp_call(NQTFR(node)->target, env);
regcomp.c:    r = setup_subexp_call(NENCLOSE(node)->target, env);
regcomp.c:      if (cn->group_num != 0) {
regcomp.c:	int gnum = cn->group_num;
regcomp.c:	if (env->num_named > 0 &&
regcomp.c:	    IS_SYNTAX_BV(env->syntax, ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP) &&
regcomp.c:	    !ONIG_IS_OPTION_ON(env->option, ONIG_OPTION_CAPTURE_GROUP)) {
regcomp.c:	if (gnum > env->num_mem) {
regcomp.c:		 ONIGERR_UNDEFINED_GROUP_REFERENCE, cn->name, cn->name_end);
regcomp.c:	cn->target = nodes[cn->group_num];
regcomp.c:	if (IS_NULL(cn->target)) {
regcomp.c:		 ONIGERR_UNDEFINED_NAME_REFERENCE, cn->name, cn->name_end);
regcomp.c:	SET_ENCLOSE_STATUS(cn->target, NST_CALLED);
regcomp.c:	BIT_STATUS_ON_AT(env->bt_mem_start, cn->group_num);
regcomp.c:	cn->unset_addr_list = env->unset_addr_list;
regcomp.c:	int n = onig_name_to_group_numbers(env->reg, cn->name, cn->name_end,
regcomp.c:		 ONIGERR_UNDEFINED_NAME_REFERENCE, cn->name, cn->name_end);
regcomp.c:	    ONIGERR_MULTIPLEX_DEFINITION_NAME_CALL, cn->name, cn->name_end);
regcomp.c:	  cn->group_num = refs[0];
regcomp.c:      switch (an->type) {
regcomp.c:	r = setup_subexp_call(an->target, env);
regcomp.c:/* divide different length alternatives in look-behind.
regcomp.c:  int anc_type = an->type;
regcomp.c:  head = an->target;
regcomp.c:  NANCHOR(head)->target = np;
regcomp.c:    NANCHOR(insert_node)->target = NCAR(np);
regcomp.c:      SET_NTYPE(np, NT_LIST);  /* alt -> list */
regcomp.c:  r = get_char_length_tree(an->target, reg, &len);
regcomp.c:    an->char_len = len;
regcomp.c:    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_DIFFERENT_LEN_ALT_LOOK_BEHIND))
regcomp.c:    if (qn->greedy && IS_REPEAT_INFINITE(qn->upper)) {
regcomp.c:      /* '\0': for UTF-16BE etc... */
regcomp.c:      if (IS_NOT_NULL(n) && NSTR(n)->s[0] != '\0') {
regcomp.c:	qn->next_head_exact = n;
regcomp.c:      if (qn->lower <= 1) {
regcomp.c:	int ttype = NTYPE(qn->target);
regcomp.c:	  x = get_head_value_node(qn->target, 0, reg);
regcomp.c:	      NENCLOSE(node)->target = en;
regcomp.c:    if (en->type == ENCLOSE_MEMORY) {
regcomp.c:      node = en->target;
regcomp.c:  end = sn->end;
regcomp.c:  sbuf_size = (end - sn->s) * 2;
regcomp.c:  p = sn->s;
regcomp.c:    len = ONIGENC_MBC_CASE_FOLD(reg->enc, reg->case_fold_flag, &p, end, buf);
regcomp.c:      len = ONIGENC_CODE_TO_MBC(reg->enc, items[i].code[j], buf);
regcomp.c:  start = sn->s;
regcomp.c:  end   = sn->end;
regcomp.c:    n = ONIGENC_GET_CASE_FOLD_CODES_BY_STR(reg->enc, reg->case_fold_flag,
regcomp.c:    len = enclen(reg->enc, p, end);
regcomp.c:      Node* target = qn->target;
regcomp.c:      if (! IS_REPEAT_INFINITE(qn->upper)) {
regcomp.c:	if (qn->upper > 1) {
regcomp.c:	  if (env->backrefed_mem == 0) {
regcomp.c:	    if (NTYPE(qn->target) == NT_ENCLOSE) {
regcomp.c:	      EncloseNode* en = NENCLOSE(qn->target);
regcomp.c:	      if (en->type == ENCLOSE_MEMORY) {
regcomp.c:		if (NTYPE(en->target) == NT_QTFR) {
regcomp.c:		  QtfrNode* q = NQTFR(en->target);
regcomp.c:		  if (IS_REPEAT_INFINITE(q->upper)
regcomp.c:		      && q->greedy == qn->greedy) {
regcomp.c:		    qn->upper = (qn->lower == 0 ? 1 : qn->lower);
regcomp.c:		    if (qn->upper == 1)
regcomp.c:	qn->comb_exp_check_num = -1;
regcomp.c:	if (IS_REPEAT_INFINITE(qn->upper)) {
regcomp.c:	  var_num = qn->upper - qn->lower;
regcomp.c:	  if (qn->comb_exp_check_num == 0) {
regcomp.c:	    env->num_comb_exp_check++;
regcomp.c:	    qn->comb_exp_check_num = env->num_comb_exp_check;
regcomp.c:	    if (env->curr_max_regnum > env->comb_exp_max_regnum)
regcomp.c:	      env->comb_exp_max_regnum = env->curr_max_regnum;
regcomp.c:      switch (en->type) {
regcomp.c:	  if (env->curr_max_regnum < en->regnum)
regcomp.c:	    env->curr_max_regnum = en->regnum;
regcomp.c:	  r = setup_comb_exp_check(en->target, state, env);
regcomp.c:	r = setup_comb_exp_check(en->target, state, env);
regcomp.c:      env->has_recursion = 1;
regcomp.c:      r = setup_comb_exp_check(NCALL(node)->target, state, env);
regcomp.c: 1. check empty loop. (set qn->target_empty_info)
regcomp.c: 2. expand ignore-case in char class.
regcomp.c: 3. set memory status bit flags. (reg->mem_stats)
regcomp.c: 4. set qn->head_exact for [push, exact] -> [push_or_jump_exact1, exact].
regcomp.c: 5. find invalid patterns in look-behind.
regcomp.c:    if (IS_IGNORECASE(reg->options) && !NSTRING_IS_RAW(node)) {
regcomp.c:      for (i = 0; i < br->back_num; i++) {
regcomp.c:	if (p[i] > env->num_mem)  return ONIGERR_INVALID_BACKREF;
regcomp.c:	BIT_STATUS_ON_AT(env->backrefed_mem, p[i]);
regcomp.c:	BIT_STATUS_ON_AT(env->bt_mem_start, p[i]);
regcomp.c:	  BIT_STATUS_ON_AT(env->bt_mem_end, p[i]);
regcomp.c:      Node* target = qn->target;
regcomp.c:        qn->state |= NST_IN_REPEAT;
regcomp.c:      if (IS_REPEAT_INFINITE(qn->upper) || qn->upper >= 1) {
regcomp.c:	  qn->target_empty_info = NQ_TARGET_IS_EMPTY;
regcomp.c:	    qn->target_empty_info = r;
regcomp.c:	    qn->upper = 1;
regcomp.c:	    if (qn->lower > 1) qn->lower = 1;
regcomp.c:	      qn->upper = qn->lower = 0;  /* /(?:)+/ ==> // */
regcomp.c:      if (qn->lower != qn->upper)
regcomp.c:	if (!IS_REPEAT_INFINITE(qn->lower) && qn->lower == qn->upper &&
regcomp.c:	    qn->lower > 1 && qn->lower <= EXPAND_STRING_MAX_LENGTH) {
regcomp.c:	  if (len * qn->lower <= EXPAND_STRING_MAX_LENGTH) {
regcomp.c:	    int i, n = qn->lower;
regcomp.c:	    onig_node_conv_to_str_node(node, NSTR(target)->flag);
regcomp.c:	      r = onig_node_str_cat(node, sn->s, sn->end);
regcomp.c:      if (qn->greedy && (qn->target_empty_info != 0)) {
regcomp.c:	  if (IS_NOT_NULL(tqn->head_exact)) {
regcomp.c:	    qn->head_exact  = tqn->head_exact;
regcomp.c:	    tqn->head_exact = NULL;
regcomp.c:	  qn->head_exact = get_head_value_node(qn->target, 1, reg);
regcomp.c:      switch (en->type) {
regcomp.c:	  OnigOptionType options = reg->options;
regcomp.c:	  reg->options = NENCLOSE(node)->option;
regcomp.c:	  r = setup_tree(NENCLOSE(node)->target, reg, state, env);
regcomp.c:	  reg->options = options;
regcomp.c:	  BIT_STATUS_ON_AT(env->bt_mem_start, en->regnum);
regcomp.c:        r = setup_tree(en->target, reg, state, env);
regcomp.c:	  Node* target = en->target;
regcomp.c:	    if (IS_REPEAT_INFINITE(tqn->upper) && tqn->lower <= 1 &&
regcomp.c:		tqn->greedy != 0) {  /* (?>a*), a*+ etc... */
regcomp.c:	      int qtype = NTYPE(tqn->target);
regcomp.c:      switch (an->type) {
regcomp.c:	r = setup_tree(an->target, reg, state, env);
regcomp.c:	r = setup_tree(an->target, reg, (state | IN_NOT), env);
regcomp.c:/* allowed node types in look-behind */
regcomp.c:	  r = check_type_tree(an->target, ALLOWED_TYPE_IN_LB,
regcomp.c:	  r = setup_tree(an->target, reg, state, env);
regcomp.c:	  r = check_type_tree(an->target, ALLOWED_TYPE_IN_LB,
regcomp.c:	  r = setup_tree(an->target, reg, (state | IN_NOT), env);
regcomp.c:/* set skip map for Boyer-Moor search */
regcomp.c:  len = end - s;
regcomp.c:    for (i = 0; i < len - 1; i++)
regcomp.c:      skip[s[i]] = len - 1 - i;
regcomp.c:    for (i = 0; i < len - 1; i++)
regcomp.c:      (*int_skip)[s[i]] = len - 1 - i;
regcomp.c:  /* 1000 / (min-max-dist + 1) */
regcomp.c:  if (mm->max == ONIG_INFINITE_DISTANCE) return 0;
regcomp.c:  d = mm->max - mm->min;
regcomp.c:    /* return dist_vals[d] * 16 / (mm->min + 12); */
regcomp.c:  if (v2 <= 0) return -1;
regcomp.c:  if (v2 < v1) return -1;
regcomp.c:  if (d2->min < d1->min) return  1;
regcomp.c:  if (d2->min > d1->min) return -1;
regcomp.c:  return (a->min == b->min && a->max == b->max) ? 1 : 0;
regcomp.c:  mml->min = min;
regcomp.c:  mml->max = max;
regcomp.c:  mml->min = mml->max = 0;
regcomp.c:  to->min = from->min;
regcomp.c:  to->max = from->max;
regcomp.c:  to->min = distance_add(to->min, from->min);
regcomp.c:  to->max = distance_add(to->max, from->max);
regcomp.c:  to->min = distance_add(to->min, len);
regcomp.c:  to->max = distance_add(to->max, len);
regcomp.c:  if (to->min > from->min) to->min = from->min;
regcomp.c:  if (to->max < from->max) to->max = from->max;
regcomp.c:  anc->left_anchor  = 0;
regcomp.c:  anc->right_anchor = 0;
regcomp.c:  to->left_anchor = left->left_anchor;
regcomp.c:    to->left_anchor |= right->left_anchor;
regcomp.c:  to->right_anchor = right->right_anchor;
regcomp.c:    to->right_anchor |= left->right_anchor;
regcomp.c:  if ((to->left_anchor & anc) != 0) return 1;
regcomp.c:  return ((to->right_anchor & anc) != 0 ? 1 : 0);
regcomp.c:    to->left_anchor |= anc;
regcomp.c:    to->right_anchor |= anc;
regcomp.c:    to->left_anchor &= ~anc;
regcomp.c:    to->right_anchor &= ~anc;
regcomp.c:  to->left_anchor  &= add->left_anchor;
regcomp.c:  to->right_anchor &= add->right_anchor;
regcomp.c:  return (ex->len >= OPT_EXACT_MAXLEN ? 1 : 0);
regcomp.c:  clear_mml(&ex->mmd);
regcomp.c:  clear_opt_anc_info(&ex->anc);
regcomp.c:  ex->reach_end   = 0;
regcomp.c:  ex->ignore_case = 0;
regcomp.c:  ex->len         = 0;
regcomp.c:  ex->s[0]        = '\0';
regcomp.c:  if (! to->ignore_case && add->ignore_case) {
regcomp.c:    if (to->len >= add->len) return ;  /* avoid */
regcomp.c:    to->ignore_case = 1;
regcomp.c:  p = add->s;
regcomp.c:  end = p + add->len;
regcomp.c:  for (i = to->len; p < end; ) {
regcomp.c:      to->s[i++] = *p++;
regcomp.c:  to->len = i;
regcomp.c:  to->reach_end = (p == end ? add->reach_end : 0);
regcomp.c:  concat_opt_anc_info(&tanc, &to->anc, &add->anc, 1, 1);
regcomp.c:  if (! to->reach_end) tanc.right_anchor = 0;
regcomp.c:  copy_opt_anc_info(&to->anc, &tanc);
regcomp.c:  for (i = to->len, p = s; p < end && i < OPT_EXACT_MAXLEN; ) {
regcomp.c:      to->s[i++] = *p++;
regcomp.c:  to->len = i;
regcomp.c:  if (add->len == 0 || to->len == 0) {
regcomp.c:  if (! is_equal_mml(&to->mmd, &add->mmd)) {
regcomp.c:  for (i = 0; i < to->len && i < add->len; ) {
regcomp.c:    if (to->s[i] != add->s[i]) break;
regcomp.c:    len = enclen(env->enc, to->s + i, to->s + to->len);
regcomp.c:      if (to->s[i+j] != add->s[i+j]) break;
regcomp.c:  if (! add->reach_end || i < add->len || i < to->len) {
regcomp.c:    to->reach_end = 0;
regcomp.c:  to->len = i;
regcomp.c:  to->ignore_case |= add->ignore_case;
regcomp.c:  alt_merge_opt_anc_info(&to->anc, &add->anc);
regcomp.c:  if (! to->reach_end) to->anc.right_anchor = 0;
regcomp.c:  v1 = now->len;
regcomp.c:  v2 = alt->len;
regcomp.c:    /* ByteValTable[x] is big value --> low price */
regcomp.c:    v2 = map_position_value(enc, now->s[0]);
regcomp.c:    v1 = map_position_value(enc, alt->s[0]);
regcomp.c:    if (now->len > 1) v1 += 5;
regcomp.c:    if (alt->len > 1) v2 += 5;
regcomp.c:  if (now->ignore_case == 0) v1 *= 2;
regcomp.c:  if (alt->ignore_case == 0) v2 *= 2;
regcomp.c:  if (comp_distance_value(&now->mmd, &alt->mmd, v1, v2) > 0)
regcomp.c:  if (map->map[c] == 0) {
regcomp.c:    map->map[c] = 1;
regcomp.c:    map->value += map_position_value(enc, c);
regcomp.c:  if (alt->value == 0) return ;
regcomp.c:  if (now->value == 0) {
regcomp.c:  v1 = z / now->value;
regcomp.c:  v2 = z / alt->value;
regcomp.c:  if (comp_distance_value(&now->mmd, &alt->mmd, v1, v2) > 0)
regcomp.c:  if (m->value <= 0) return -1;
regcomp.c:  ve = COMP_EM_BASE * e->len * (e->ignore_case ? 1 : 2);
regcomp.c:  vm = COMP_EM_BASE * 5 * 2 / m->value;
regcomp.c:  return comp_distance_value(&e->mmd, &m->mmd, ve, vm);
regcomp.c:  /* if (! is_equal_mml(&to->mmd, &add->mmd)) return ; */
regcomp.c:  if (to->value == 0) return ;
regcomp.c:  if (add->value == 0 || to->mmd.max < add->mmd.min) {
regcomp.c:  alt_merge_mml(&to->mmd, &add->mmd);
regcomp.c:    if (add->map[i])
regcomp.c:      to->map[i] = 1;
regcomp.c:    if (to->map[i])
regcomp.c:  to->value = val;
regcomp.c:  alt_merge_opt_anc_info(&to->anc, &add->anc);
regcomp.c:  copy_mml(&(opt->exb.mmd),  mmd);
regcomp.c:  copy_mml(&(opt->expr.mmd), mmd);
regcomp.c:  copy_mml(&(opt->map.mmd),  mmd);
regcomp.c:  clear_mml(&opt->len);
regcomp.c:  clear_opt_anc_info(&opt->anc);
regcomp.c:  clear_opt_exact_info(&opt->exb);
regcomp.c:  clear_opt_exact_info(&opt->exm);
regcomp.c:  clear_opt_exact_info(&opt->expr);
regcomp.c:  clear_opt_map_info(&opt->map);
regcomp.c:  concat_opt_anc_info(&tanc, &to->anc, &add->anc, to->len.max, add->len.max);
regcomp.c:  copy_opt_anc_info(&to->anc, &tanc);
regcomp.c:  if (add->exb.len > 0 && to->len.max == 0) {
regcomp.c:    concat_opt_anc_info(&tanc, &to->anc, &add->exb.anc,
regcomp.c:			to->len.max, add->len.max);
regcomp.c:    copy_opt_anc_info(&add->exb.anc, &tanc);
regcomp.c:  if (add->map.value > 0 && to->len.max == 0) {
regcomp.c:    if (add->map.mmd.max == 0)
regcomp.c:      add->map.anc.left_anchor |= to->anc.left_anchor;
regcomp.c:  exb_reach = to->exb.reach_end;
regcomp.c:  exm_reach = to->exm.reach_end;
regcomp.c:  if (add->len.max != 0)
regcomp.c:    to->exb.reach_end = to->exm.reach_end = 0;
regcomp.c:  if (add->exb.len > 0) {
regcomp.c:      concat_opt_exact_info(&to->exb, &add->exb, enc);
regcomp.c:      clear_opt_exact_info(&add->exb);
regcomp.c:      concat_opt_exact_info(&to->exm, &add->exb, enc);
regcomp.c:      clear_opt_exact_info(&add->exb);
regcomp.c:  select_opt_exact_info(enc, &to->exm, &add->exb);
regcomp.c:  select_opt_exact_info(enc, &to->exm, &add->exm);
regcomp.c:  if (to->expr.len > 0) {
regcomp.c:    if (add->len.max > 0) {
regcomp.c:      if (to->expr.len > (int )add->len.max)
regcomp.c:	to->expr.len = add->len.max;
regcomp.c:      if (to->expr.mmd.max == 0)
regcomp.c:	select_opt_exact_info(enc, &to->exb, &to->expr);
regcomp.c:	select_opt_exact_info(enc, &to->exm, &to->expr);
regcomp.c:  else if (add->expr.len > 0) {
regcomp.c:    copy_opt_exact_info(&to->expr, &add->expr);
regcomp.c:  select_opt_map_info(&to->map, &add->map);
regcomp.c:  add_mml(&to->len, &add->len);
regcomp.c:  alt_merge_opt_anc_info  (&to->anc,  &add->anc);
regcomp.c:  alt_merge_opt_exact_info(&to->exb,  &add->exb, env);
regcomp.c:  alt_merge_opt_exact_info(&to->exm,  &add->exm, env);
regcomp.c:  alt_merge_opt_exact_info(&to->expr, &add->expr, env);
regcomp.c:  alt_merge_opt_map_info(env->enc, &to->map,  &add->map);
regcomp.c:  alt_merge_mml(&to->len, &add->len);
regcomp.c:  set_bound_node_opt_info(opt, &env->mmd);
regcomp.c:	  concat_left_node_opt_info(env->enc, opt, &nopt);
regcomp.c:      int slen = sn->end - sn->s;
regcomp.c:	concat_opt_exact_info_str(&opt->exb, sn->s, sn->end,
regcomp.c:				  NSTRING_IS_RAW(node), env->enc);
regcomp.c:	  add_char_opt_map_info(&opt->map, *(sn->s), env->enc);
regcomp.c:        set_mml(&opt->len, slen, slen);
regcomp.c:          int n = onigenc_strlen(env->enc, sn->s, sn->end);
regcomp.c:          max = ONIGENC_MBC_MAXLEN_DIST(env->enc) * n;
regcomp.c:	  concat_opt_exact_info_str(&opt->exb, sn->s, sn->end,
regcomp.c:				    is_raw, env->enc);
regcomp.c:	  opt->exb.ignore_case = 1;
regcomp.c:	    r = add_char_amb_opt_map_info(&opt->map, sn->s, sn->end,
regcomp.c:					  env->enc, env->case_fold_flag);
regcomp.c:        set_mml(&opt->len, slen, max);
regcomp.c:      if (opt->exb.len == slen)
regcomp.c:	opt->exb.reach_end = 1;
regcomp.c:      if (IS_NOT_NULL(cc->mbuf) || IS_NCCLASS_NOT(cc)) {
regcomp.c:        OnigDistance min = ONIGENC_MBC_MINLEN(env->enc);
regcomp.c:	OnigDistance max = ONIGENC_MBC_MAXLEN_DIST(env->enc);
regcomp.c:	set_mml(&opt->len, min, max);
regcomp.c:          z = BITSET_AT(cc->bs, i);
regcomp.c:            add_char_opt_map_info(&opt->map, (UChar )i, env->enc);
regcomp.c:	set_mml(&opt->len, 1, 1);
regcomp.c:      max = ONIGENC_MBC_MAXLEN_DIST(env->enc);
regcomp.c:	switch (NCTYPE(node)->ctype) {
regcomp.c:	  if (NCTYPE(node)->not != 0) {
regcomp.c:	      if (! ONIGENC_IS_CODE_WORD(env->enc, i)) {
regcomp.c:		add_char_opt_map_info(&opt->map, (UChar )i, env->enc);
regcomp.c:	      if (ONIGENC_IS_CODE_WORD(env->enc, i)) {
regcomp.c:		add_char_opt_map_info(&opt->map, (UChar )i, env->enc);
regcomp.c:        min = ONIGENC_MBC_MINLEN(env->enc);
regcomp.c:      set_mml(&opt->len, min, max);
regcomp.c:      OnigDistance min = ONIGENC_MBC_MINLEN(env->enc);
regcomp.c:      OnigDistance max = ONIGENC_MBC_MAXLEN_DIST(env->enc);
regcomp.c:      set_mml(&opt->len, min, max);
regcomp.c:    switch (NANCHOR(node)->type) {
regcomp.c:      add_opt_anc_info(&opt->anc, NANCHOR(node)->type);
regcomp.c:	r = optimize_node_left(NANCHOR(node)->target, &nopt, env);
regcomp.c:	    copy_opt_exact_info(&opt->expr, &nopt.exb);
regcomp.c:	    copy_opt_exact_info(&opt->expr, &nopt.exm);
regcomp.c:	  opt->expr.reach_end = 0;
regcomp.c:	    copy_opt_map_info(&opt->map, &nopt.map);
regcomp.c:      Node** nodes = SCANENV_MEM_NODES(env->scan_env);
regcomp.c:      if (br->state & NST_RECURSION) {
regcomp.c:	set_mml(&opt->len, 0, ONIG_INFINITE_DISTANCE);
regcomp.c:      r = get_min_match_length(nodes[backs[0]], &min, env->scan_env);
regcomp.c:      r = get_max_match_length(nodes[backs[0]], &max, env->scan_env);
regcomp.c:      for (i = 1; i < br->back_num; i++) {
regcomp.c:	r = get_min_match_length(nodes[backs[i]], &tmin, env->scan_env);
regcomp.c:	r = get_max_match_length(nodes[backs[i]], &tmax, env->scan_env);
regcomp.c:      if (r == 0) set_mml(&opt->len, min, max);
regcomp.c:      set_mml(&opt->len, 0, ONIG_INFINITE_DISTANCE);
regcomp.c:      OnigOptionType save = env->options;
regcomp.c:      env->options = NENCLOSE(NCALL(node)->target)->option;
regcomp.c:      r = optimize_node_left(NCALL(node)->target, opt, env);
regcomp.c:      env->options = save;
regcomp.c:      r = optimize_node_left(qn->target, &nopt, env);
regcomp.c:      if (qn->lower == 0 && IS_REPEAT_INFINITE(qn->upper)) {
regcomp.c:	if (env->mmd.max == 0 &&
regcomp.c:	    NTYPE(qn->target) == NT_CANY && qn->greedy) {
regcomp.c:	  if (IS_MULTILINE(env->options))
regcomp.c:	    add_opt_anc_info(&opt->anc, ANCHOR_ANYCHAR_STAR_ML);
regcomp.c:	    add_opt_anc_info(&opt->anc, ANCHOR_ANYCHAR_STAR);
regcomp.c:	if (qn->lower > 0) {
regcomp.c:	      for (i = 2; i < qn->lower &&
regcomp.c:		          ! is_full_opt_exact_info(&opt->exb); i++) {
regcomp.c:		concat_opt_exact_info(&opt->exb, &nopt.exb, env->enc);
regcomp.c:	      if (i < qn->lower) {
regcomp.c:		opt->exb.reach_end = 0;
regcomp.c:	  if (qn->lower != qn->upper) {
regcomp.c:	    opt->exb.reach_end = 0;
regcomp.c:	    opt->exm.reach_end = 0;
regcomp.c:	  if (qn->lower > 1)
regcomp.c:	    opt->exm.reach_end = 0;
regcomp.c:      min = distance_multiply(nopt.len.min, qn->lower);
regcomp.c:      if (IS_REPEAT_INFINITE(qn->upper))
regcomp.c:	max = distance_multiply(nopt.len.max, qn->upper);
regcomp.c:      set_mml(&opt->len, min, max);
regcomp.c:      switch (en->type) {
regcomp.c:	  OnigOptionType save = env->options;
regcomp.c:	  env->options = en->option;
regcomp.c:	  r = optimize_node_left(en->target, opt, env);
regcomp.c:	  env->options = save;
regcomp.c:	en->opt_count++;
regcomp.c:	if (en->opt_count > MAX_NODE_OPT_INFO_REF_COUNT) {
regcomp.c:	  if (IS_ENCLOSE_MIN_FIXED(en)) min = en->min_len;
regcomp.c:	  if (IS_ENCLOSE_MAX_FIXED(en)) max = en->max_len;
regcomp.c:	  set_mml(&opt->len, min, max);
regcomp.c:	  r = optimize_node_left(en->target, opt, env);
regcomp.c:	  if (is_set_opt_anc_info(&opt->anc, ANCHOR_ANYCHAR_STAR_MASK)) {
regcomp.c:	    if (BIT_STATUS_AT(env->scan_env->backrefed_mem, en->regnum))
regcomp.c:	      remove_opt_anc_info(&opt->anc, ANCHOR_ANYCHAR_STAR_MASK);
regcomp.c:	r = optimize_node_left(en->target, opt, env);
regcomp.c:  if (e->len == 0) return 0;
regcomp.c:  if (e->ignore_case) {
regcomp.c:    reg->exact = (UChar* )xmalloc(e->len);
regcomp.c:    CHECK_NULL_RETURN_MEMERR(reg->exact);
regcomp.c:    xmemcpy(reg->exact, e->s, e->len);
regcomp.c:    reg->exact_end = reg->exact + e->len;
regcomp.c:    reg->optimize = ONIG_OPTIMIZE_EXACT_IC;
regcomp.c:    reg->exact = str_dup(e->s, e->s + e->len);
regcomp.c:    CHECK_NULL_RETURN_MEMERR(reg->exact);
regcomp.c:    reg->exact_end = reg->exact + e->len;
regcomp.c:	ONIGENC_IS_ALLOWED_REVERSE_MATCH(reg->enc, reg->exact, reg->exact_end);
regcomp.c:    if (e->len >= 3 || (e->len >= 2 && allow_reverse)) {
regcomp.c:      r = set_bm_skip(reg->exact, reg->exact_end, reg->enc,
regcomp.c:	              reg->map, &(reg->int_map));
regcomp.c:      reg->optimize = (allow_reverse != 0
regcomp.c:      reg->optimize = ONIG_OPTIMIZE_EXACT;
regcomp.c:  reg->dmin = e->mmd.min;
regcomp.c:  reg->dmax = e->mmd.max;
regcomp.c:  if (reg->dmin != ONIG_INFINITE_DISTANCE) {
regcomp.c:    reg->threshold_len = reg->dmin + (reg->exact_end - reg->exact);
regcomp.c:    reg->map[i] = m->map[i];
regcomp.c:  reg->optimize   = ONIG_OPTIMIZE_MAP;
regcomp.c:  reg->dmin       = m->mmd.min;
regcomp.c:  reg->dmax       = m->mmd.max;
regcomp.c:  if (reg->dmin != ONIG_INFINITE_DISTANCE) {
regcomp.c:    reg->threshold_len = reg->dmin + 1;
regcomp.c:  reg->sub_anchor |= anc->left_anchor  & ANCHOR_BEGIN_LINE;
regcomp.c:  reg->sub_anchor |= anc->right_anchor & ANCHOR_END_LINE;
regcomp.c:  env.enc            = reg->enc;
regcomp.c:  env.options        = reg->options;
regcomp.c:  env.case_fold_flag = reg->case_fold_flag;
regcomp.c:  reg->anchor = opt.anc.left_anchor & (ANCHOR_BEGIN_BUF |
regcomp.c:  reg->anchor |= opt.anc.right_anchor & (ANCHOR_END_BUF | ANCHOR_SEMI_END_BUF);
regcomp.c:  if (reg->anchor & (ANCHOR_END_BUF | ANCHOR_SEMI_END_BUF)) {
regcomp.c:    reg->anchor_dmin = opt.len.min;
regcomp.c:    reg->anchor_dmax = opt.len.max;
regcomp.c:    select_opt_exact_info(reg->enc, &opt.exb, &opt.exm);
regcomp.c:    reg->sub_anchor |= opt.anc.left_anchor & ANCHOR_BEGIN_LINE;
regcomp.c:      reg->sub_anchor |= opt.anc.right_anchor & ANCHOR_END_LINE;
regcomp.c:  reg->optimize      = ONIG_OPTIMIZE_NONE;
regcomp.c:  reg->anchor        = 0;
regcomp.c:  reg->anchor_dmin   = 0;
regcomp.c:  reg->anchor_dmax   = 0;
regcomp.c:  reg->sub_anchor    = 0;
regcomp.c:  reg->exact_end     = (UChar* )NULL;
regcomp.c:  reg->threshold_len = 0;
regcomp.c:  if (IS_NOT_NULL(reg->exact)) {
regcomp.c:    xfree(reg->exact);
regcomp.c:    reg->exact = (UChar* )NULL;
regcomp.c:  fputs("-", f);
regcomp.c:    fprintf(f, "begin-buf");
regcomp.c:    fprintf(f, "begin-line");
regcomp.c:    fprintf(f, "begin-pos");
regcomp.c:    fprintf(f, "end-buf");
regcomp.c:    fprintf(f, "semi-end-buf");
regcomp.c:    fprintf(f, "end-line");
regcomp.c:    fprintf(f, "anychar-star");
regcomp.c:    fprintf(f, "anychar-star-pl");
regcomp.c:  fprintf(f, "optimize: %s\n", on[reg->optimize]);
regcomp.c:  fprintf(f, "  anchor: "); print_anchor(f, reg->anchor);
regcomp.c:  if ((reg->anchor & ANCHOR_END_BUF_MASK) != 0)
regcomp.c:    print_distance_range(f, reg->anchor_dmin, reg->anchor_dmax);
regcomp.c:  if (reg->optimize) {
regcomp.c:    fprintf(f, "  sub anchor: "); print_anchor(f, reg->sub_anchor);
regcomp.c:  if (reg->exact) {
regcomp.c:    for (p = reg->exact; p < reg->exact_end; p++) {
regcomp.c:    fprintf(f, "]: length: %d\n", (reg->exact_end - reg->exact));
regcomp.c:  else if (reg->optimize & ONIG_OPTIMIZE_MAP) {
regcomp.c:      if (reg->map[i]) n++;
regcomp.c:	if (reg->map[i] != 0) {
regcomp.c:          if (ONIGENC_MBC_MAXLEN(reg->enc) == 1 &&
regcomp.c:              ONIGENC_IS_CODE_PRINT(reg->enc, (OnigCodePoint )i))
regcomp.c:  if (IS_NOT_NULL(reg->p))                xfree(reg->p);
regcomp.c:  if (IS_NOT_NULL(reg->exact))            xfree(reg->exact);
regcomp.c:  if (IS_NOT_NULL(reg->int_map))          xfree(reg->int_map);
regcomp.c:  if (IS_NOT_NULL(reg->int_map_backward)) xfree(reg->int_map_backward);
regcomp.c:  if (IS_NOT_NULL(reg->repeat_range))     xfree(reg->repeat_range);
regcomp.c:  if (IS_NOT_NULL(reg->chain))            onig_free(reg->chain);
regcomp.c:  (to)->state = ONIG_STATE_MODIFY;\
regcomp.c:  while (IS_NOT_NULL((reg)->chain)) {\
regcomp.c:    (reg) = (reg)->chain;\
regcomp.c:  to->chain = add;
regcomp.c:  head = prev->chain;
regcomp.c:    reg->state = ONIG_STATE_MODIFY;
regcomp.c:    while (IS_NOT_NULL(head->chain)) {
regcomp.c:      head = head->chain;
regcomp.c:    prev->chain = (regex_t* )NULL;
regcomp.c:    if (IS_NOT_NULL(from->chain) && ONIG_STATE(reg) == ONIG_STATE_NORMAL) {
regcomp.c:                      from->enc, ONIG_SYNTAX_DEFAULT);
regcomp.c:  reg->chain = (regex_t* )NULL;
regcomp.c:  reg->state = ONIG_STATE_NORMAL;
regcomp.c:  if (from->p) {
regcomp.c:    reg->p = (UChar* )xmalloc(reg->alloc);
regcomp.c:    if (IS_NULL(reg->p)) goto mem_error;
regcomp.c:    xmemcpy(reg->p, from->p, reg->alloc);
regcomp.c:  if (from->exact) {
regcomp.c:    reg->exact = (UChar* )xmalloc(from->exact_end - from->exact);
regcomp.c:    if (IS_NULL(reg->exact)) goto mem_error;
regcomp.c:    reg->exact_end = reg->exact + (from->exact_end - from->exact);
regcomp.c:    xmemcpy(reg->exact, from->exact, reg->exact_end - reg->exact);
regcomp.c:  if (from->int_map) {
regcomp.c:    reg->int_map = (int* )xmalloc(size);
regcomp.c:    if (IS_NULL(reg->int_map)) goto mem_error;
regcomp.c:    xmemcpy(reg->int_map, from->int_map, size);
regcomp.c:  if (from->int_map_backward) {
regcomp.c:    reg->int_map_backward = (int* )xmalloc(size);
regcomp.c:    if (IS_NULL(reg->int_map_backward)) goto mem_error;
regcomp.c:    xmemcpy(reg->int_map_backward, from->int_map_backward, size);
regcomp.c:  reg->name_table = names_clone(from); /* names_clone is not implemented */
regcomp.c:  reg->state = ONIG_STATE_COMPILING;
regcomp.c:  print_enc_string(stderr, reg->enc, pattern, pattern_end);
regcomp.c:  if (reg->alloc == 0) {
regcomp.c:    init_size = (pattern_end - pattern) * 2;
regcomp.c:    reg->used = 0;
regcomp.c:  reg->num_mem            = 0;
regcomp.c:  reg->num_repeat         = 0;
regcomp.c:  reg->num_null_check     = 0;
regcomp.c:  reg->repeat_range_alloc = 0;
regcomp.c:  reg->repeat_range       = (OnigRepeatRange* )NULL;
regcomp.c:  reg->num_comb_exp_check = 0;
regcomp.c:  /* mixed use named group and no-named group */
regcomp.c:      !ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_CAPTURE_GROUP)) {
regcomp.c:    reg->num_call = scan_env.num_call;
regcomp.c:    reg->num_call = 0;
regcomp.c:  reg->capture_history  = scan_env.capture_history;
regcomp.c:  reg->bt_mem_start     = scan_env.bt_mem_start;
regcomp.c:  reg->bt_mem_start    |= reg->capture_history;
regcomp.c:  if (IS_FIND_CONDITION(reg->options))
regcomp.c:    BIT_STATUS_ON_ALL(reg->bt_mem_end);
regcomp.c:    reg->bt_mem_end  = scan_env.bt_mem_end;
regcomp.c:    reg->bt_mem_end |= reg->capture_history;
regcomp.c:  reg->num_comb_exp_check = scan_env.num_comb_exp_check;
regcomp.c:    if ((reg->num_repeat != 0) || (reg->bt_mem_end != 0))
regcomp.c:      reg->stack_pop_level = STACK_POP_LEVEL_ALL;
regcomp.c:      if (reg->bt_mem_start != 0)
regcomp.c:	reg->stack_pop_level = STACK_POP_LEVEL_MEM_START;
regcomp.c:	reg->stack_pop_level = STACK_POP_LEVEL_FREE;
regcomp.c:  reg->state = ONIG_STATE_NORMAL;
regcomp.c:      einfo->enc     = scan_env.enc;
regcomp.c:      einfo->par     = scan_env.error;
regcomp.c:      einfo->par_end = scan_env.error_end;
regcomp.c:  (*reg)->state = ONIG_STATE_MODIFY;
regcomp.c:    option |= syntax->options;
regcomp.c:    option |= syntax->options;
regcomp.c:  (*reg)->enc              = enc;
regcomp.c:  (*reg)->options          = option;
regcomp.c:  (*reg)->syntax           = syntax;
regcomp.c:  (*reg)->optimize         = 0;
regcomp.c:  (*reg)->exact            = (UChar* )NULL;
regcomp.c:  (*reg)->int_map          = (int* )NULL;
regcomp.c:  (*reg)->int_map_backward = (int* )NULL;
regcomp.c:  (*reg)->chain            = (regex_t* )NULL;
regcomp.c:  (*reg)->p                = (UChar* )NULL;
regcomp.c:  (*reg)->alloc            = 0;
regcomp.c:  (*reg)->used             = 0;
regcomp.c:  (*reg)->name_table       = (void* )NULL;
regcomp.c:  (*reg)->case_fold_flag   = case_fold_flag;
regcomp.c:  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;
regcomp.c:    if (IS_NULL(cc->mbuf)) {
regcomp.c:      found = (onig_is_in_code_range(cc->mbuf->p, code) != 0 ? 1 : 0);
regcomp.c:    found = (BITSET_AT(cc->bs, code) == 0 ? 0 : 1);
regcomp.c:#define ARG_SPECIAL     -1
regcomp.c:  { OP_EXACTMB2N1,        "exactmb2-n1",     ARG_SPECIAL },
regcomp.c:  { OP_EXACTMB2N2,        "exactmb2-n2",     ARG_SPECIAL },
regcomp.c:  { OP_EXACTMB2N3,        "exactmb2-n3",     ARG_SPECIAL },
regcomp.c:  { OP_EXACTMB2N,         "exactmb2-n",      ARG_SPECIAL },
regcomp.c:  { OP_EXACT1_IC,         "exact1-ic",       ARG_SPECIAL },
regcomp.c:  { OP_EXACTN_IC,         "exactn-ic",       ARG_SPECIAL },
regcomp.c:  { OP_CCLASS_MB,         "cclass-mb",       ARG_SPECIAL },
regcomp.c:  { OP_CCLASS_MIX,        "cclass-mix",      ARG_SPECIAL },
regcomp.c:  { OP_CCLASS_NOT,        "cclass-not",      ARG_SPECIAL },
regcomp.c:  { OP_CCLASS_MB_NOT,     "cclass-mb-not",   ARG_SPECIAL },
regcomp.c:  { OP_CCLASS_MIX_NOT,    "cclass-mix-not",  ARG_SPECIAL },
regcomp.c:  { OP_CCLASS_NODE,       "cclass-node",     ARG_SPECIAL },
regcomp.c:  { OP_ANYCHAR_ML,        "anychar-ml",      ARG_NON },
regcomp.c:  { OP_ANYCHAR_ML_STAR,   "anychar-ml*",     ARG_NON },
regcomp.c:  { OP_ANYCHAR_STAR_PEEK_NEXT, "anychar*-peek-next", ARG_SPECIAL },
regcomp.c:  { OP_ANYCHAR_ML_STAR_PEEK_NEXT, "anychar-ml*-peek-next", ARG_SPECIAL },
regcomp.c:  { OP_NOT_WORD,            "not-word",        ARG_NON },
regcomp.c:  { OP_WORD_BOUND,          "word-bound",      ARG_NON },
regcomp.c:  { OP_NOT_WORD_BOUND,      "not-word-bound",  ARG_NON },
regcomp.c:  { OP_WORD_BEGIN,          "word-begin",      ARG_NON },
regcomp.c:  { OP_WORD_END,            "word-end",        ARG_NON },
regcomp.c:  { OP_BEGIN_BUF,           "begin-buf",       ARG_NON },
regcomp.c:  { OP_END_BUF,             "end-buf",         ARG_NON },
regcomp.c:  { OP_BEGIN_LINE,          "begin-line",      ARG_NON },
regcomp.c:  { OP_END_LINE,            "end-line",        ARG_NON },
regcomp.c:  { OP_SEMI_END_BUF,        "semi-end-buf",    ARG_NON },
regcomp.c:  { OP_BEGIN_POSITION,      "begin-position",  ARG_NON },
regcomp.c:  { OP_BACKREFN_IC,         "backrefn-ic",          ARG_SPECIAL },
regcomp.c:  { OP_BACKREF_MULTI_IC,    "backref_multi-ic",     ARG_SPECIAL },
regcomp.c:  { OP_MEMORY_START_PUSH,   "mem-start-push",       ARG_MEMNUM  },
regcomp.c:  { OP_MEMORY_START,        "mem-start",            ARG_MEMNUM  },
regcomp.c:  { OP_MEMORY_END_PUSH,     "mem-end-push",         ARG_MEMNUM  },
regcomp.c:  { OP_MEMORY_END_PUSH_REC, "mem-end-push-rec",     ARG_MEMNUM  },
regcomp.c:  { OP_MEMORY_END,          "mem-end",              ARG_MEMNUM  },
regcomp.c:  { OP_MEMORY_END_REC,      "mem-end-rec",          ARG_MEMNUM  },
regcomp.c:  { OP_SET_OPTION_PUSH,     "set-option-push",      ARG_OPTION  },
regcomp.c:  { OP_SET_OPTION,          "set-option",           ARG_OPTION  },
regcomp.c:  { OP_PUSH_OR_JUMP_EXACT1, "push-or-jump-e1",      ARG_SPECIAL },
regcomp.c:  { OP_PUSH_IF_PEEK_NEXT,   "push-if-peek-next",    ARG_SPECIAL },
regcomp.c:  { OP_REPEAT_NG,           "repeat-ng",            ARG_SPECIAL },
regcomp.c:  { OP_REPEAT_INC,          "repeat-inc",           ARG_MEMNUM  },
regcomp.c:  { OP_REPEAT_INC_NG,       "repeat-inc-ng",        ARG_MEMNUM  },
regcomp.c:  { OP_REPEAT_INC_SG,       "repeat-inc-sg",        ARG_MEMNUM  },
regcomp.c:  { OP_REPEAT_INC_NG_SG,    "repeat-inc-ng-sg",     ARG_MEMNUM  },
regcomp.c:  { OP_NULL_CHECK_START,    "null-check-start",     ARG_MEMNUM  },
regcomp.c:  { OP_NULL_CHECK_END,      "null-check-end",       ARG_MEMNUM  },
regcomp.c:  { OP_NULL_CHECK_END_MEMST,"null-check-end-memst", ARG_MEMNUM  },
regcomp.c:  { OP_NULL_CHECK_END_MEMST_PUSH,"null-check-end-memst-push", ARG_MEMNUM  },
regcomp.c:  { OP_PUSH_POS,             "push-pos",             ARG_NON },
regcomp.c:  { OP_POP_POS,              "pop-pos",              ARG_NON },
regcomp.c:  { OP_PUSH_POS_NOT,         "push-pos-not",         ARG_RELADDR },
regcomp.c:  { OP_FAIL_POS,             "fail-pos",             ARG_NON },
regcomp.c:  { OP_PUSH_STOP_BT,         "push-stop-bt",         ARG_NON },
regcomp.c:  { OP_POP_STOP_BT,          "pop-stop-bt",          ARG_NON },
regcomp.c:  { OP_LOOK_BEHIND,          "look-behind",          ARG_SPECIAL },
regcomp.c:  { OP_PUSH_LOOK_BEHIND_NOT, "push-look-behind-not", ARG_SPECIAL },
regcomp.c:  { OP_FAIL_LOOK_BEHIND_NOT, "fail-look-behind-not", ARG_NON },
regcomp.c:  { OP_STATE_CHECK_PUSH,         "state-check-push",         ARG_SPECIAL },
regcomp.c:  { OP_STATE_CHECK_PUSH_OR_JUMP, "state-check-push-or-jump", ARG_SPECIAL },
regcomp.c:  { OP_STATE_CHECK,              "state-check",              ARG_STATE_CHECK },
regcomp.c:  { OP_STATE_CHECK_ANYCHAR_STAR, "state-check-anychar*",     ARG_STATE_CHECK },
regcomp.c:    "state-check-anychar-ml*", ARG_STATE_CHECK },
regcomp.c:  { -1, "", ARG_NON }
regcomp.c:  while (len-- > 0) { fputc(*s++, f); }
regcomp.c:  while (x-- > 0) { fputc(*s++, f); }
regcomp.c:	while (n-- > 0) { fputc(*bp++, f); }
regcomp.c:        n = bitset_on_num(cc->bs);
regcomp.c:	      *--bp);
regcomp.c:  UChar* bp = reg->p;
regcomp.c:  UChar* end = reg->p + reg->used;
regcomp.c:  fprintf(f, "code length: %d\n", reg->used);
regcomp.c:    if (bp > reg->p) {
regcomp.c:    onig_print_compiled_byte_code(f, bp, &bp, reg->enc);
regcomp.c:	    (NSTRING_IS_RAW(node) ? "-raw" : ""), (int )node);
regcomp.c:    for (p = NSTR(node)->s; p < NSTR(node)->end; p++) {
regcomp.c:    if (NCCLASS(node)->mbuf) {
regcomp.c:      BBuf* bbuf = NCCLASS(node)->mbuf;
regcomp.c:      for (i = 0; i < bbuf->used; i++) {
regcomp.c:	fprintf(f, "%0x", bbuf->p[i]);
regcomp.c:    switch (NCTYPE(node)->ctype) {
regcomp.c:      if (NCTYPE(node)->not != 0)
regcomp.c:    switch (NANCHOR(node)->type) {
regcomp.c:      for (i = 0; i < br->back_num; i++) {
regcomp.c:      p_string(f, cn->name_end - cn->name, cn->name);
regcomp.c:	    NQTFR(node)->lower, NQTFR(node)->upper,
regcomp.c:	    (NQTFR(node)->greedy ? "" : "?"));
regcomp.c:    print_indent_tree(f, NQTFR(node)->target, indent + add);
regcomp.c:    switch (NENCLOSE(node)->type) {
regcomp.c:      fprintf(f, "option:%d\n", NENCLOSE(node)->option);
regcomp.c:      print_indent_tree(f, NENCLOSE(node)->target, indent + add);
regcomp.c:      fprintf(f, "memory:%d", NENCLOSE(node)->regnum);
regcomp.c:      fprintf(f, "stop-bt");
regcomp.c:    print_indent_tree(f, NENCLOSE(node)->target, indent + add);
ãã¤ããªã¼ã»ãã¡ã¤ã«regcomp.oã¯ä¸è´ãã¾ãã
regenc.c:  regenc.c -  Oniguruma (regular expression library)
regenc.c:/*-
regenc.c: * Copyright (c) 2002-2007  K.Kosako  <sndgk393 AT ybb DOT ne DOT jp>
regenc.c:    return e-p+ONIGENC_MBCLEN_NEEDMORE_LEN(ret);
regenc.c:  return ONIGENC_LEFT_ADJUST_CHAR_HEAD(enc, start, s - 1, end);
regenc.c:  while (ONIG_IS_NOT_NULL(s) && n-- > 0) {
regenc.c:    s = ONIGENC_LEFT_ADJUST_CHAR_HEAD(enc, start, s - 1, end);
regenc.c:  while (n-- > 0) {
regenc.c:        len--;
regenc.c:      if (len == 1) return (int )(p - start);
regenc.c:        len--;
regenc.c:      if (len == 1) return (int )(p - start);
regenc.c:    items[0].code[0] = (OnigCodePoint )(*p - 0x20);
regenc.c:    items[0].code[0] = (OnigCodePoint )(*p - 0x20);
regenc.c:  if (enclen(enc, buf, p) != (p - buf))
regenc.c:  return p - buf;
regenc.c:  if (enclen(enc, buf, p) != (p - buf))
regenc.c:  return p - buf;
regenc.c:    { (UChar* )NULL, -1, 0 }
regenc.c:  for (pb = PBS; IS_NOT_NULL(pb->name); pb++) {
regenc.c:    if (len == pb->len &&
regenc.c:        onigenc_with_ascii_strncmp(enc, p, end, pb->name, pb->len) == 0)
regenc.c:      return pb->ctype;
regenc.c:  while (n-- > 0) {
regenc.c:    x = *sascii - c;
regenc.h:  regenc.h -  Oniguruma (regular expression library)
regenc.h:/*-
regenc.h: * Copyright (c) 2002-2007  K.Kosako  <sndgk393 AT ybb DOT ne DOT jp>
regenc.h:#define enclen(enc,p,e) ((enc->max_enc_len == enc->min_enc_len) ? enc->min_enc_len : ONIGENC_MBC_ENC_LEN(enc,p,e))
ãã¤ããªã¼ã»ãã¡ã¤ã«regenc.oã¯ä¸è´ãã¾ãã
regerror.c:  regerror.c -  Oniguruma (regular expression library)
regerror.c:/*-
regerror.c: * Copyright (c) 2002-2007  K.Kosako  <sndgk393 AT ybb DOT ne DOT jp>
regerror.c:    p = "match-stack limit over"; break;
regerror.c:    p = "default multibyte-encoding is not setted"; break;
regerror.c:    p = "can't convert to wide-char on specified multibyte-encoding"; break;
regerror.c:    p = "empty char-class"; break;
regerror.c:    p = "premature end of char-class"; break;
regerror.c:    p = "invalid meta-code syntax"; break;
regerror.c:    p = "invalid control-code syntax"; break;
regerror.c:    p = "char-class value at end of range"; break;
regerror.c:    p = "char-class value at start of range"; break;
regerror.c:    p = "unmatched range specifier in char-class"; break;
regerror.c:    p = "invalid pattern in look-behind"; break;
regerror.c:    p = "mismatch multibyte code length in char-class range"; break;
regerror.c:    p = "too big wide-char value"; break;
regerror.c:    p = "too long wide-char value"; break;
regerror.c:    len = MIN((end - s), buf_size);
regerror.c:    *is_over = ((buf_size < (end - s)) ? 1 : 0);
regerror.c:    len = to_ascii(einfo->enc, einfo->par, einfo->par_end,
regerror.c:		   parbuf, MAX_ERROR_PAR_LEN - 3, &is_over);
regerror.c:    len = p - s;
regerror.c:  need = (pat_end - pat) * 4 + 4;
regerror.c:	while (len-- > 0) *s++ = *p++;
regerror.c:          while (len-- > 0) *s++ = *p++;
regerror.c:          while (len-- > 0) {
regerror.c:            while (blen-- > 0) *s++ = *bp++;
regerror.c:	while (len-- > 0) *s++ = *bp++;
ãã¤ããªã¼ã»ãã¡ã¤ã«regerror.oã¯ä¸è´ãã¾ãã
regexec.c:  regexec.c -  Oniguruma (regular expression library)
regexec.c:/*-
regexec.c: * Copyright (c) 2002-2007  K.Kosako  <sndgk393 AT ybb DOT ne DOT jp>
regexec.c:    for (i = 0; i < node->num_childs; i++) {
regexec.c:      if (IS_NOT_NULL(node->childs[i])) {
regexec.c:        history_tree_free(node->childs[i]);
regexec.c:    for (i = 0; i < node->allocated; i++) {
regexec.c:      node->childs[i] = (OnigCaptureTreeNode* )0;
regexec.c:    node->num_childs = 0;
regexec.c:    node->beg = ONIG_REGION_NOTPOS;
regexec.c:    node->end = ONIG_REGION_NOTPOS;
regexec.c:    node->group = -1;
regexec.c:  if (IS_NOT_NULL(r->history_root)) {
regexec.c:    history_tree_free(r->history_root);
regexec.c:    r->history_root = (OnigCaptureTreeNode* )0;
regexec.c:  node->childs     = (OnigCaptureTreeNode** )0;
regexec.c:  node->allocated  = 0;
regexec.c:  node->num_childs = 0;
regexec.c:  node->group      = -1;
regexec.c:  node->beg        = ONIG_REGION_NOTPOS;
regexec.c:  node->end        = ONIG_REGION_NOTPOS;
regexec.c:  if (parent->num_childs >= parent->allocated) {
regexec.c:    if (IS_NULL(parent->childs)) {
regexec.c:      parent->childs =
regexec.c:      n = parent->allocated * 2;
regexec.c:      parent->childs =
regexec.c:        (OnigCaptureTreeNode** )xrealloc(parent->childs,
regexec.c:    CHECK_NULL_RETURN_MEMERR(parent->childs);
regexec.c:    for (i = parent->allocated; i < n; i++) {
regexec.c:      parent->childs[i] = (OnigCaptureTreeNode* )0;
regexec.c:    parent->allocated = n;
regexec.c:  parent->childs[parent->num_childs] = child;
regexec.c:  parent->num_childs++;
regexec.c:  clone->beg = node->beg;
regexec.c:  clone->end = node->end;
regexec.c:  for (i = 0; i < node->num_childs; i++) {
regexec.c:    child = history_tree_clone(node->childs[i]);
regexec.c:  return region->history_root;
regexec.c:  for (i = 0; i < region->num_regs; i++) {
regexec.c:    region->beg[i] = region->end[i] = ONIG_REGION_NOTPOS;
regexec.c:  region->num_regs = n;
regexec.c:  if (region->allocated == 0) {
regexec.c:    region->beg = (int* )xmalloc(n * sizeof(int));
regexec.c:    if (region->beg == 0)
regexec.c:    region->end = (int* )xmalloc(n * sizeof(int));
regexec.c:    if (region->end == 0) {
regexec.c:      xfree(region->beg);
regexec.c:    region->allocated = n;
regexec.c:  else if (region->allocated < n) {
regexec.c:    region->allocated = 0;
regexec.c:    tmp = (int* )xrealloc(region->beg, n * sizeof(int));
regexec.c:      xfree(region->beg);
regexec.c:      xfree(region->end);
regexec.c:    region->beg = tmp;
regexec.c:    tmp = (int* )xrealloc(region->end, n * sizeof(int));
regexec.c:      xfree(region->beg);
regexec.c:    region->end = tmp;
regexec.c:    if (region->beg == 0 || region->end == 0)
regexec.c:    region->allocated = n;
regexec.c:  if (at >= region->allocated) {
regexec.c:  region->beg[at] = beg;
regexec.c:  region->end[at] = end;
regexec.c:  region->num_regs     = 0;
regexec.c:  region->allocated    = 0;
regexec.c:  region->beg          = (int* )0;
regexec.c:  region->end          = (int* )0;
regexec.c:  region->history_root = (OnigCaptureTreeNode* )0;
regexec.c:    if (r->allocated > 0) {
regexec.c:      if (r->beg) xfree(r->beg);
regexec.c:      if (r->end) xfree(r->end);
regexec.c:      r->allocated = 0;
regexec.c:#define RREGC_SIZE   (sizeof(int) * from->num_regs)
regexec.c:  onig_region_resize(to, from->num_regs);
regexec.c:  for (i = 0; i < from->num_regs; i++) {
regexec.c:    to->beg[i] = from->beg[i];
regexec.c:    to->end[i] = from->end[i];
regexec.c:  to->num_regs = from->num_regs;
regexec.c:  if (IS_NOT_NULL(from->history_root)) {
regexec.c:    to->history_root = history_tree_clone(from->history_root);
regexec.c:#define INVALID_STACK_INDEX   -1
regexec.c:/* used by normal-POP */
regexec.c:/* handled by normal-POP */
regexec.c:/* avoided by normal-POP */
regexec.c:#define STK_POS                    0x0500  /* used when POP-POS */
regexec.c:              (size_t )(size - (offset))); \
regexec.c:  if (msa->stack_p) {\
regexec.c:    stk_alloc  = (OnigStackType* )(msa->stack_p);\
regexec.c:    stk_end    = stk_base + msa->stack_n;\
regexec.c:    msa->stack_p = stk_base;\
regexec.c:    msa->stack_n = stk_end - stk_base;\
regexec.c:  n = stk_end - stk_base;
regexec.c:  if (stk_base == stk_alloc && IS_NULL(msa->stack_p)) {
regexec.c:      if ((unsigned int )(stk_end - stk_base) == limit_size)
regexec.c:  *arg_stk      = x + (stk - stk_base);
regexec.c:  if (stk_end - stk < (n)) {\
regexec.c:#define GET_STACK_INDEX(stk)   ((stk) - stk_base)
regexec.c:  stk->type = (stack_type);\
regexec.c:#define IS_TO_VOID_TARGET(stk) (((stk)->type & STK_MASK_TO_VOID_TARGET) != 0)
regexec.c:  (((s) - str) * num_comb_exp_check + ((snum) - 1))
regexec.c:  else if ((stk)->type == STK_STATE_CHECK_MARK) { \
regexec.c:    int x = STATE_CHECK_POS(stk->u.state.pstr, stk->u.state.state_check);\
regexec.c:  stk->type = (stack_type);\
regexec.c:  stk->u.state.pcode     = (pat);\
regexec.c:  stk->u.state.pstr      = (s);\
regexec.c:  stk->u.state.pstr_prev = (sprev);\
regexec.c:  stk->u.state.state_check = 0;\
regexec.c:  stk->type = (stack_type);\
regexec.c:  stk->u.state.pcode = (pat);\
regexec.c:  stk->u.state.state_check = 0;\
regexec.c:  stk->type = STK_ALT;\
regexec.c:  stk->u.state.pcode     = (pat);\
regexec.c:  stk->u.state.pstr      = (s);\
regexec.c:  stk->u.state.pstr_prev = (sprev);\
regexec.c:  stk->u.state.state_check = ((state_check_buff != NULL) ? (snum) : 0);\
regexec.c:    stk->type = STK_STATE_CHECK_MARK;\
regexec.c:    stk->u.state.pstr = (s);\
regexec.c:    stk->u.state.state_check = (snum);\
regexec.c:  stk->type = (stack_type);\
regexec.c:  stk->u.state.pcode     = (pat);\
regexec.c:  stk->u.state.pstr      = (s);\
regexec.c:  stk->u.state.pstr_prev = (sprev);\
regexec.c:  stk->type = (stack_type);\
regexec.c:  stk->u.state.pcode = (pat);\
regexec.c:  stk->type = STK_REPEAT;\
regexec.c:  stk->u.repeat.num    = (id);\
regexec.c:  stk->u.repeat.pcode  = (pat);\
regexec.c:  stk->u.repeat.count  = 0;\
regexec.c:  stk->type = STK_REPEAT_INC;\
regexec.c:  stk->u.repeat_inc.si  = (sindex);\
regexec.c:  stk->type = STK_MEM_START;\
regexec.c:  stk->u.mem.num      = (mnum);\
regexec.c:  stk->u.mem.pstr     = (s);\
regexec.c:  stk->u.mem.start    = mem_start_stk[mnum];\
regexec.c:  stk->u.mem.end      = mem_end_stk[mnum];\
regexec.c:  stk->type = STK_MEM_END;\
regexec.c:  stk->u.mem.num    = (mnum);\
regexec.c:  stk->u.mem.pstr   = (s);\
regexec.c:  stk->u.mem.start  = mem_start_stk[mnum];\
regexec.c:  stk->u.mem.end    = mem_end_stk[mnum];\
regexec.c:  stk->type = STK_MEM_END_MARK;\
regexec.c:  stk->u.mem.num = (mnum);\
regexec.c:    k--;\
regexec.c:    if ((k->type & STK_MASK_MEM_END_OR_MARK) != 0 \
regexec.c:      && k->u.mem.num == (mnum)) {\
regexec.c:    else if (k->type == STK_MEM_START && k->u.mem.num == (mnum)) {\
regexec.c:      level--;\
regexec.c:    if (k->type == STK_MEM_START && k->u.mem.num == (mnum)) {\
regexec.c:      if (level == 0) (start) = k->u.mem.pstr;\
regexec.c:    else if (k->type == STK_MEM_END && k->u.mem.num == (mnum)) {\
regexec.c:      level--;\
regexec.c:        (end) = k->u.mem.pstr;\
regexec.c:  stk->type = STK_NULL_CHECK_START;\
regexec.c:  stk->u.null_check.num  = (cnum);\
regexec.c:  stk->u.null_check.pstr = (s);\
regexec.c:  stk->type = STK_NULL_CHECK_END;\
regexec.c:  stk->u.null_check.num  = (cnum);\
regexec.c:  stk->type = STK_CALL_FRAME;\
regexec.c:  stk->u.call_frame.ret_addr = (pat);\
regexec.c:  stk->type = STK_RETURN;\
regexec.c:  stk--;\
regexec.c:      stk--;\
regexec.c:      if ((stk->type & STK_MASK_POP_USED) != 0)  break;\
regexec.c:      stk--;\
regexec.c:      if ((stk->type & STK_MASK_POP_USED) != 0)  break;\
regexec.c:      else if (stk->type == STK_MEM_START) {\
regexec.c:        mem_start_stk[stk->u.mem.num] = stk->u.mem.start;\
regexec.c:        mem_end_stk[stk->u.mem.num]   = stk->u.mem.end;\
regexec.c:      stk--;\
regexec.c:      if ((stk->type & STK_MASK_POP_USED) != 0)  break;\
regexec.c:      else if (stk->type == STK_MEM_START) {\
regexec.c:        mem_start_stk[stk->u.mem.num] = stk->u.mem.start;\
regexec.c:        mem_end_stk[stk->u.mem.num]   = stk->u.mem.end;\
regexec.c:      else if (stk->type == STK_REPEAT_INC) {\
regexec.c:        STACK_AT(stk->u.repeat_inc.si)->u.repeat.count--;\
regexec.c:      else if (stk->type == STK_MEM_END) {\
regexec.c:        mem_start_stk[stk->u.mem.num] = stk->u.mem.start;\
regexec.c:        mem_end_stk[stk->u.mem.num]   = stk->u.mem.end;\
regexec.c:    stk--;\
regexec.c:    if (stk->type == STK_POS_NOT) break;\
regexec.c:    else if (stk->type == STK_MEM_START) {\
regexec.c:      mem_start_stk[stk->u.mem.num] = stk->u.mem.start;\
regexec.c:      mem_end_stk[stk->u.mem.num]   = stk->u.mem.end;\
regexec.c:    else if (stk->type == STK_REPEAT_INC) {\
regexec.c:      STACK_AT(stk->u.repeat_inc.si)->u.repeat.count--;\
regexec.c:    else if (stk->type == STK_MEM_END) {\
regexec.c:      mem_start_stk[stk->u.mem.num] = stk->u.mem.start;\
regexec.c:      mem_end_stk[stk->u.mem.num]   = stk->u.mem.end;\
regexec.c:    stk--;\
regexec.c:    if (stk->type == STK_LOOK_BEHIND_NOT) break;\
regexec.c:    else if (stk->type == STK_MEM_START) {\
regexec.c:      mem_start_stk[stk->u.mem.num] = stk->u.mem.start;\
regexec.c:      mem_end_stk[stk->u.mem.num]   = stk->u.mem.end;\
regexec.c:    else if (stk->type == STK_REPEAT_INC) {\
regexec.c:      STACK_AT(stk->u.repeat_inc.si)->u.repeat.count--;\
regexec.c:    else if (stk->type == STK_MEM_END) {\
regexec.c:      mem_start_stk[stk->u.mem.num] = stk->u.mem.start;\
regexec.c:      mem_end_stk[stk->u.mem.num]   = stk->u.mem.end;\
regexec.c:    k--;\
regexec.c:      k->type = STK_VOID;\
regexec.c:    else if (k->type == STK_POS) {\
regexec.c:      k->type = STK_VOID;\
regexec.c:    k--;\
regexec.c:      k->type = STK_VOID;\
regexec.c:    else if (k->type == STK_STOP_BT) {\
regexec.c:      k->type = STK_VOID;\
regexec.c:    k--;\
regexec.c:    if (k->type == STK_NULL_CHECK_START) {\
regexec.c:      if (k->u.null_check.num == (id)) {\
regexec.c:        (isnull) = (k->u.null_check.pstr == (s));\
regexec.c:    k--;\
regexec.c:    if (k->type == STK_NULL_CHECK_START) {\
regexec.c:      if (k->u.null_check.num == (id)) {\
regexec.c:          (isnull) = (k->u.null_check.pstr == (s));\
regexec.c:        else level--;\
regexec.c:    else if (k->type == STK_NULL_CHECK_END) {\
regexec.c:    k--;\
regexec.c:    if (k->type == STK_NULL_CHECK_START) {\
regexec.c:      if (k->u.null_check.num == (id)) {\
regexec.c:        if (k->u.null_check.pstr != (s)) {\
regexec.c:            if (k->type == STK_MEM_START) {\
regexec.c:              if (k->u.mem.end == INVALID_STACK_INDEX) {\
regexec.c:              if (BIT_STATUS_AT(reg->bt_mem_end, k->u.mem.num))\
regexec.c:                endp = STACK_AT(k->u.mem.end)->u.mem.pstr;\
regexec.c:                endp = (UChar* )k->u.mem.end;\
regexec.c:              if (STACK_AT(k->u.mem.start)->u.mem.pstr != endp) {\
regexec.c:                (isnull) = -1; /* empty, but position changed */ \
regexec.c:    k--;\
regexec.c:    if (k->type == STK_NULL_CHECK_START) {\
regexec.c:      if (k->u.null_check.num == (id)) {\
regexec.c:          if (k->u.null_check.pstr != (s)) {\
regexec.c:              if (k->type == STK_MEM_START) {\
regexec.c:                if (k->u.mem.end == INVALID_STACK_INDEX) {\
regexec.c:                if (BIT_STATUS_AT(reg->bt_mem_end, k->u.mem.num))\
regexec.c:                  endp = STACK_AT(k->u.mem.end)->u.mem.pstr;\
regexec.c:                  endp = (UChar* )k->u.mem.end;\
regexec.c:                if (STACK_AT(k->u.mem.start)->u.mem.pstr != endp) {\
regexec.c:                  (isnull) = -1; /* empty, but position changed */ \
regexec.c:          level--;\
regexec.c:    else if (k->type == STK_NULL_CHECK_END) {\
regexec.c:      if (k->u.null_check.num == (id)) level++;\
regexec.c:    k--;\
regexec.c:    if (k->type == STK_REPEAT) {\
regexec.c:        if (k->u.repeat.num == (id)) {\
regexec.c:    else if (k->type == STK_CALL_FRAME) level--;\
regexec.c:    else if (k->type == STK_RETURN)     level++;\
regexec.c:    k--;\
regexec.c:    if (k->type == STK_CALL_FRAME) {\
regexec.c:        (addr) = k->u.call_frame.ret_addr;\
regexec.c:      else level--;\
regexec.c:    else if (k->type == STK_RETURN)\
regexec.c:  while (len-- > 0) {\
regexec.c:    while (len1-- > 0) {
regexec.c:  while (len-- > 0) {\
regexec.c:    if (k->type == STK_MEM_START) {
regexec.c:      n = k->u.mem.num;
regexec.c:          BIT_STATUS_AT(reg->capture_history, n) != 0) {
regexec.c:        child->group = n;
regexec.c:        child->beg = (int )(k->u.mem.pstr - str);
regexec.c:        child->end = (int )(k->u.mem.pstr - str);
regexec.c:    else if (k->type == STK_MEM_END) {
regexec.c:      if (k->u.mem.num == node->group) {
regexec.c:        node->end = (int )(k->u.mem.pstr - str);
regexec.c:  k--;
regexec.c:    if (k->type == STK_CALL_FRAME) {
regexec.c:      level--;
regexec.c:    else if (k->type == STK_RETURN) {
regexec.c:      if (k->type == STK_MEM_START) {
regexec.c:	if (mem_is_in_memp(k->u.mem.num, mem_num, memp)) {
regexec.c:	  pstart = k->u.mem.pstr;
regexec.c:	    if (pend - pstart > send - *s) return 0; /* or goto next_mem; */
regexec.c:	      if (string_cmp_ic(reg->enc, case_fold_flag,
regexec.c:				pstart, &ss, (int )(pend - pstart), send) == 0)
regexec.c:      else if (k->type == STK_MEM_END) {
regexec.c:	if (mem_is_in_memp(k->u.mem.num, mem_num, memp)) {
regexec.c:	  pend = k->u.mem.pstr;
regexec.c:    k--;
regexec.c:#define TIMEDIFF(te,ts)   (((te).tv_usec - (ts).tv_usec) + \
regexec.c:                           (((te).tv_sec - (ts).tv_sec)*1000000))
regexec.c:#define TIMEDIFF(te,ts)   ((te).tms_utime - (ts).tms_utime)
regexec.c:  if (stk - stk_base > MaxStackDepth) \
regexec.c:    MaxStackDepth = stk - stk_base;\
regexec.c:/* match data(str - end) from position (sstart). */
regexec.c:  OnigOptionType option = reg->options;
regexec.c:  OnigEncoding encode = reg->enc;
regexec.c:  OnigCaseFoldType case_fold_flag = reg->case_fold_flag;
regexec.c:  UChar *p = reg->p;
regexec.c:  unsigned char* state_check_buff = msa->state_check_buff;
regexec.c:  int num_comb_exp_check = reg->num_comb_exp_check;
regexec.c:  n = reg->num_repeat + reg->num_mem * 2;
regexec.c:  pop_level = reg->stack_pop_level;
regexec.c:  num_mem = reg->num_mem;
regexec.c:  mem_start_stk = (OnigStackIndex* )(repeat_stk + reg->num_repeat);
regexec.c:  mem_start_stk--; /* for index start from 1,
regexec.c:  mem_end_stk--;   /* for index start from 1,
regexec.c:	  (int )(end - str), (int )(sstart - str));
regexec.c:      fprintf(stderr, "%4d> \"", (int )(s - str));
regexec.c:	while (len-- > 0) *bp++ = *q++;
regexec.c:      for (i = 0; i < 20 - (bp - buf); i++) fputc(' ', stderr);
regexec.c:      n = s - sstart;
regexec.c:	  if (n > msa->best_len) {
regexec.c:	    msa->best_len = n;
regexec.c:	    msa->best_s   = (UChar* )sstart;
regexec.c:	region = msa->region;
regexec.c:	  if (IS_POSIX_REGION(msa->options)) {
regexec.c:	    rmt[0].rm_so = sstart - str;
regexec.c:	    rmt[0].rm_eo = s      - str;
regexec.c:		if (BIT_STATUS_AT(reg->bt_mem_start, i))
regexec.c:		  rmt[i].rm_so = STACK_AT(mem_start_stk[i])->u.mem.pstr - str;
regexec.c:		  rmt[i].rm_so = (UChar* )((void* )(mem_start_stk[i])) - str;
regexec.c:		rmt[i].rm_eo = (BIT_STATUS_AT(reg->bt_mem_end, i)
regexec.c:				? STACK_AT(mem_end_stk[i])->u.mem.pstr
regexec.c:				: (UChar* )((void* )mem_end_stk[i])) - str;
regexec.c:	    region->beg[0] = sstart - str;
regexec.c:	    region->end[0] = s      - str;
regexec.c:		if (BIT_STATUS_AT(reg->bt_mem_start, i))
regexec.c:		  region->beg[i] = STACK_AT(mem_start_stk[i])->u.mem.pstr - str;
regexec.c:		  region->beg[i] = (UChar* )((void* )mem_start_stk[i]) - str;
regexec.c:		region->end[i] = (BIT_STATUS_AT(reg->bt_mem_end, i)
regexec.c:				  ? STACK_AT(mem_end_stk[i])->u.mem.pstr
regexec.c:				  : (UChar* )((void* )mem_end_stk[i])) - str;
regexec.c:		region->beg[i] = region->end[i] = ONIG_REGION_NOTPOS;
regexec.c:	    if (reg->capture_history != 0) {
regexec.c:              if (IS_NULL(region->history_root)) {
regexec.c:                region->history_root = node = history_node_new();
regexec.c:                node = region->history_root;
regexec.c:              node->group = 0;
regexec.c:              node->beg   = sstart - str;
regexec.c:              node->end   = s      - str;
regexec.c:              r = make_capture_history_tree(region->history_root, &stkp,
regexec.c:      /* default behavior: return first-matching result. */
regexec.c:	while (len-- > 0) {
regexec.c:      while (tlen-- > 0) {
regexec.c:      sprev = s - 1;
regexec.c:	  while (len-- > 0) {
regexec.c:      while (tlen-- > 0) {
regexec.c:      sprev = s - 2;
regexec.c:      while (tlen-- > 0) {
regexec.c:      sprev = s - 3;
regexec.c:      GET_LENGTH_INC(tlen,  p);  /* mb-len */
regexec.c:      while (tlen2-- > 0) {
regexec.c:      sprev = s - tlen;
regexec.c:      s += enclen(encode, s, end);   /* OP_CCLASS can match mb-code. \D, \S */
regexec.c:	if (IS_NOTBOL(msa->options)) goto fail;
regexec.c:	  if (IS_NOTEOL(msa->options)) goto fail;
regexec.c:	  if (IS_NOTEOL(msa->options)) goto fail;
regexec.c:      if (s != msa->start)
regexec.c:      STACK_GET_MEM_START(mem, stkp); /* should be before push mem-end. */
regexec.c:      if (BIT_STATUS_AT(reg->bt_mem_start, mem))
regexec.c:	mem_start_stk[mem] = (OnigStackIndex )((void* )stkp->u.mem.pstr);
regexec.c:	if (BIT_STATUS_AT(reg->bt_mem_start, mem))
regexec.c:	  pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;
regexec.c:	pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)
regexec.c:		? STACK_AT(mem_end_stk[mem])->u.mem.pstr
regexec.c:	n = pend - pstart;
regexec.c:	if (BIT_STATUS_AT(reg->bt_mem_start, mem))
regexec.c:	  pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;
regexec.c:	pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)
regexec.c:		? STACK_AT(mem_end_stk[mem])->u.mem.pstr
regexec.c:	n = pend - pstart;
regexec.c:	  if (BIT_STATUS_AT(reg->bt_mem_start, mem))
regexec.c:	    pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;
regexec.c:	  pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)
regexec.c:		  ? STACK_AT(mem_end_stk[mem])->u.mem.pstr
regexec.c:	  n = pend - pstart;
regexec.c:	  p += (SIZE_MEMNUM * (tlen - i - 1));
regexec.c:	  if (BIT_STATUS_AT(reg->bt_mem_start, mem))
regexec.c:	    pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;
regexec.c:	  pend = (BIT_STATUS_AT(reg->bt_mem_end, mem)
regexec.c:		  ? STACK_AT(mem_end_stk[mem])->u.mem.pstr
regexec.c:	  n = pend - pstart;
regexec.c:	  p += (SIZE_MEMNUM * (tlen - i - 1));
regexec.c:	  if (isnull == -1) goto fail;
regexec.c:	  if (isnull == -1) goto fail;
regexec.c:	if (reg->repeat_range[mem].lower == 0) {
regexec.c:	if (reg->repeat_range[mem].lower == 0) {
regexec.c:      stkp->u.repeat.count++;
regexec.c:      if (stkp->u.repeat.count >= reg->repeat_range[mem].upper) {
regexec.c:      else if (stkp->u.repeat.count >= reg->repeat_range[mem].lower) {
regexec.c:        p = STACK_AT(si)->u.repeat.pcode; /* Don't use stkp after PUSH. */
regexec.c:        p = stkp->u.repeat.pcode;
regexec.c:      stkp->u.repeat.count++;
regexec.c:      if (stkp->u.repeat.count < reg->repeat_range[mem].upper) {
regexec.c:        if (stkp->u.repeat.count >= reg->repeat_range[mem].lower) {
regexec.c:          UChar* pcode = stkp->u.repeat.pcode;
regexec.c:          p = stkp->u.repeat.pcode;
regexec.c:      else if (stkp->u.repeat.count == reg->repeat_range[mem].upper) {
regexec.c:	s     = stkp->u.state.pstr;
regexec.c:	sprev = stkp->u.state.pstr_prev;
regexec.c:	/* too short case -> success. ex. /(?<!XXX)a/.match("a")
regexec.c:      p = reg->p + addr;
regexec.c:      p     = stk->u.state.pcode;
regexec.c:      s     = stk->u.state.pstr;
regexec.c:      sprev = stk->u.state.pstr_prev;
regexec.c:      if (stk->u.state.state_check != 0) {
regexec.c:        stk->type = STK_STATE_CHECK_MARK;
regexec.c:  end -= target_end - target - 1;
regexec.c:  if (enc->max_enc_len == enc->min_enc_len) {
regexec.c:    int n = enc->max_enc_len;
regexec.c:	if (target_end == t || memcmp(t, p, target_end - t) == 0)
regexec.c:      if (target_end == t || memcmp(t, p, target_end - t) == 0)
regexec.c:      lowlen--;
regexec.c:  end -= target_end - target - 1;
regexec.c:  s -= (target_end - target);
regexec.c:  s -= (target_end - target);
regexec.c:  tail = target_end - 1;
regexec.c:  tlen1 = tail - target;
regexec.c:    end = text_end - tlen1;
regexec.c:  if (IS_NULL(reg->int_map)) {
regexec.c:        p--; t--;
regexec.c:      skip = reg->map[*se];
regexec.c:        s += enclen(reg->enc, s, end);
regexec.c:      } while ((s - t) < skip && s < end);
regexec.c:        p--; t--;
regexec.c:      skip = reg->int_map[*se];
regexec.c:        s += enclen(reg->enc, s, end);
regexec.c:      } while ((s - t) < skip && s < end);
regexec.c:  end = text_range + (target_end - target) - 1;
regexec.c:  tail = target_end - 1;
regexec.c:  s = text + (target_end - target) - 1;
regexec.c:  if (IS_NULL(reg->int_map)) {
regexec.c:	p--; t--;
regexec.c:      s += reg->map[*s];
regexec.c:	p--; t--;
regexec.c:      s += reg->int_map[*s];
regexec.c:  len = end - s;
regexec.c:  for (i = len - 1; i > 0; i--)
regexec.c:  s = text_end - (target_end - target);
regexec.c:    s = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc, adjust_text, s, text_end);
regexec.c:    s -= reg->int_map_backward[*s];
regexec.c:    s = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc, adjust_text, s, text_end);
regexec.c:    if (IS_NOT_NULL(reg->chain) && ONIG_STATE(reg) == ONIG_STATE_NORMAL) {
regexec.c:    int offset = at - str;
regexec.c:    STATE_CHECK_BUFF_INIT(msa, end - str, offset, reg->num_comb_exp_check);
regexec.c:    r = onig_region_resize_clear(region, reg->num_mem + 1);
regexec.c:    prev = (UChar* )onigenc_get_prev_char_head(reg->enc, str, at, end);
regexec.c:  if (reg->dmin > 0) {
regexec.c:    if (ONIGENC_IS_SINGLEBYTE(reg->enc)) {
regexec.c:      p += reg->dmin;
regexec.c:      UChar *q = p + reg->dmin;
regexec.c:      while (p < q) p += enclen(reg->enc, p, end);
regexec.c:  switch (reg->optimize) {
regexec.c:    p = slow_search(reg->enc, reg->exact, reg->exact_end, p, end, range);
regexec.c:    p = slow_search_ic(reg->enc, reg->case_fold_flag,
regexec.c:                       reg->exact, reg->exact_end, p, end, range);
regexec.c:    p = bm_search(reg, reg->exact, reg->exact_end, p, end, range);
regexec.c:    p = bm_search_notrev(reg, reg->exact, reg->exact_end, p, end, range);
regexec.c:    p = map_search(reg->enc, reg->map, p, range, end);
regexec.c:    if (p - reg->dmin < s) {
regexec.c:      p += enclen(reg->enc, p, end);
regexec.c:    if (reg->sub_anchor) {
regexec.c:      switch (reg->sub_anchor) {
regexec.c:	  prev = onigenc_get_prev_char_head(reg->enc,
regexec.c:	  if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))
regexec.c:	  prev = (UChar* )onigenc_get_prev_char_head(reg->enc,
regexec.c:	  if (prev && ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))
regexec.c:	else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)
regexec.c:              && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)
regexec.c:    if (reg->dmax == 0) {
regexec.c:	  *low_prev = onigenc_get_prev_char_head(reg->enc, s, p, end);
regexec.c:	  *low_prev = onigenc_get_prev_char_head(reg->enc,
regexec.c:      if (reg->dmax != ONIG_INFINITE_DISTANCE) {
regexec.c:	*low = p - reg->dmax;
regexec.c:	  *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,
regexec.c:	    *low_prev = onigenc_get_prev_char_head(reg->enc,
regexec.c:	    *low_prev = onigenc_get_prev_char_head(reg->enc,
regexec.c:    *high = p - reg->dmin;
regexec.c:	    (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax);
regexec.c:  range += reg->dmin;
regexec.c:  switch (reg->optimize) {
regexec.c:    p = slow_search_backward(reg->enc, reg->exact, reg->exact_end,
regexec.c:    p = slow_search_backward_ic(reg->enc, reg->case_fold_flag,
regexec.c:                                reg->exact, reg->exact_end,
regexec.c:    if (IS_NULL(reg->int_map_backward)) {
regexec.c:      if (s - range < BM_BACKWARD_SEARCH_LENGTH_THRESHOLD)
regexec.c:      r = set_bm_backward_skip(reg->exact, reg->exact_end, reg->enc,
regexec.c:			       &(reg->int_map_backward));
regexec.c:    p = bm_search_backward(reg, reg->exact, reg->exact_end, range, adjrange,
regexec.c:    p = map_search_backward(reg->enc, reg->map, range, adjrange, p, end);
regexec.c:    if (reg->sub_anchor) {
regexec.c:      switch (reg->sub_anchor) {
regexec.c:	  prev = onigenc_get_prev_char_head(reg->enc, str, p, end);
regexec.c:	  if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end)) {
regexec.c:	  prev = onigenc_get_prev_char_head(reg->enc, adjrange, p);
regexec.c:	  if (ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end)) {
regexec.c:	else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)
regexec.c:              && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)
regexec.c:	  p = onigenc_get_prev_char_head(reg->enc, adjrange, p, end);
regexec.c:    if (reg->dmax != ONIG_INFINITE_DISTANCE) {
regexec.c:      *low  = p - reg->dmax;
regexec.c:      *high = p - reg->dmin;
regexec.c:      *high = onigenc_get_right_adjust_char_head(reg->enc, adjrange, *high, end);
regexec.c:	    (int )(*low - str), (int )(*high - str));
regexec.c:    if (IS_NOT_NULL(reg->chain) && ONIG_STATE(reg) == ONIG_STATE_NORMAL) {
regexec.c:     (int )str, (int )(end - str), (int )(start - str), (int )(range - str));
regexec.c:    r = onig_region_resize_clear(region, reg->num_mem + 1);
regexec.c:      if (! IS_FIND_LONGEST(reg->options)) {\
regexec.c:      if (! IS_FIND_LONGEST(reg->options)) {\
regexec.c:  if (reg->anchor != 0 && str < end) {
regexec.c:    if (reg->anchor & ANCHOR_BEGIN_POSITION) {
regexec.c:      /* search start-position only */
regexec.c:    else if (reg->anchor & ANCHOR_BEGIN_BUF) {
regexec.c:      /* search str-position only */
regexec.c:    else if (reg->anchor & ANCHOR_END_BUF) {
regexec.c:      if ((OnigDistance )(max_semi_end - str) < reg->anchor_dmin)
regexec.c:	if ((OnigDistance )(min_semi_end - start) > reg->anchor_dmax) {
regexec.c:	  start = min_semi_end - reg->anchor_dmax;
regexec.c:	    start = onigenc_get_right_adjust_char_head(reg->enc, str, start, end);
regexec.c:	    start = onigenc_get_prev_char_head(reg->enc, str, end, end);
regexec.c:	if ((OnigDistance )(max_semi_end - (range - 1)) < reg->anchor_dmin) {
regexec.c:	  range = max_semi_end - reg->anchor_dmin + 1;
regexec.c:	if ((OnigDistance )(min_semi_end - range) > reg->anchor_dmax) {
regexec.c:	  range = min_semi_end - reg->anchor_dmax;
regexec.c:	if ((OnigDistance )(max_semi_end - start) < reg->anchor_dmin) {
regexec.c:	  start = max_semi_end - reg->anchor_dmin;
regexec.c:	  start = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc, str, start, end);
regexec.c:    else if (reg->anchor & ANCHOR_SEMI_END_BUF) {
regexec.c:      UChar* pre_end = ONIGENC_STEP_BACK(reg->enc, str, end, end, 1);
regexec.c:      if (ONIGENC_IS_MBC_NEWLINE(reg->enc, pre_end, end)) {
regexec.c:	pre_end = ONIGENC_STEP_BACK(reg->enc, str, pre_end, end, 1);
regexec.c:	    ONIGENC_IS_MBC_CRNL(reg->enc, pre_end, end)) {
regexec.c:    else if ((reg->anchor & ANCHOR_ANYCHAR_STAR_ML)) {
regexec.c:    if (reg->threshold_len == 0) {
regexec.c:	  (int )(end - str), (int )(start - str), (int )(range - str));
regexec.c:    int offset = (MIN(start, range) - str);
regexec.c:    STATE_CHECK_BUFF_INIT(msa, end - str, offset, reg->num_comb_exp_check);
regexec.c:      prev = onigenc_get_prev_char_head(reg->enc, str, s, end);
regexec.c:    if (reg->optimize != ONIG_OPTIMIZE_NONE) {
regexec.c:      if (reg->dmax != 0) {
regexec.c:	if (reg->dmax == ONIG_INFINITE_DISTANCE)
regexec.c:	  sch_range += reg->dmax;
regexec.c:      if ((end - start) < reg->threshold_len)
regexec.c:      if (reg->dmax != ONIG_INFINITE_DISTANCE) {
regexec.c:	    s += enclen(reg->enc, s, end);
regexec.c:        if ((reg->anchor & ANCHOR_ANYCHAR_STAR) != 0) {
regexec.c:            s += enclen(reg->enc, s, end);
regexec.c:            while (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end) && s < range) {
regexec.c:              s += enclen(reg->enc, s, end);
regexec.c:      s += enclen(reg->enc, s, end);
regexec.c:	orig_start += enclen(reg->enc, orig_start, end); /* is upper range */
regexec.c:    if (reg->optimize != ONIG_OPTIMIZE_NONE) {
regexec.c:	adjrange = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc, str, range, end);
regexec.c:      if (reg->dmax != ONIG_INFINITE_DISTANCE &&
regexec.c:	  (end - range) >= reg->threshold_len) {
regexec.c:	  sch_start = s + reg->dmax;
regexec.c:	    prev = onigenc_get_prev_char_head(reg->enc, str, s, end);
regexec.c:	if ((end - range) < reg->threshold_len) goto mismatch;
regexec.c:	if (reg->dmax != 0) {
regexec.c:	  if (reg->dmax == ONIG_INFINITE_DISTANCE)
regexec.c:	    sch_start += reg->dmax;
regexec.c:	      sch_start = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc,
regexec.c:      prev = onigenc_get_prev_char_head(reg->enc, str, s, end);
regexec.c:  if (IS_FIND_LONGEST(reg->options)) {
regexec.c:  if (IS_FIND_NOT_EMPTY(reg->options) && region
regexec.c:  return s - str;
regexec.c:  return reg->enc;
regexec.c:  return reg->options;
regexec.c:  return reg->case_fold_flag;
regexec.c:  return reg->syntax;
regexec.c:  return reg->num_mem;
regexec.c:    if (BIT_STATUS_AT(reg->capture_history, i) != 0)
ãã¤ããªã¼ã»ãã¡ã¤ã«regexec.oã¯ä¸è´ãã¾ãã
regint.h:  regint.h -  Oniguruma (regular expression library)
regint.h:/*-
regint.h: * Copyright (c) 2002-2007  K.Kosako  <sndgk393 AT ybb DOT ne DOT jp>
regint.h:/* for byte-code statistical data. */
regint.h:#define USE_BACKREF_WITH_LEVEL        /* \k<name+n>, \k<name-n> */
regint.h:#define USE_WORD_BEGIN_END          /* "\<": word-begin, "\>": word-end */
regint.h:#define ONIG_STATE_INC(reg) (reg)->state++
regint.h:#define ONIG_STATE_DEC(reg) (reg)->state--
regint.h:  (reg)->state++;\
regint.h:  (reg)->state--;\
regint.h:               - ((uintptr_t )(addr) % WORD_ALIGNMENT_SIZE);\
regint.h:  (addr) += (WORD_ALIGNMENT_SIZE - 1);\
regint.h:  (addr) -= ((uintptr_t )(addr) % WORD_ALIGNMENT_SIZE);\
regint.h:#define INT_MAX_LIMIT           ((1UL << (SIZEOF_INT * 8 - 1)) - 1)
regint.h:#define DIGITVAL(code)    ((code) - '0')
regint.h:   : (ONIGENC_IS_CODE_UPPER(enc,code) ? (code) - 'A' + 10 : (code) - 'a' + 10))
regint.h:/* ignore-case and multibyte status are included in compiled code. */
regint.h:#define REPEAT_INFINITE         -1
regint.h:  (buf)->alloc += (inc);\
regint.h:  (buf)->p = (UChar* )xrealloc((buf)->p, (buf)->alloc);\
regint.h:  if (IS_NULL((buf)->p)) return(ONIGERR_MEMORY);\
regint.h:  do { (buf)->alloc *= 2; } while ((buf)->alloc < (unsigned int )low);\
regint.h:  (buf)->p = (UChar* )xrealloc((buf)->p, (buf)->alloc);\
regint.h:  if (IS_NULL((buf)->p)) return(ONIGERR_MEMORY);\
regint.h:  unsigned int new_alloc = (buf)->alloc;\
regint.h:  if ((buf)->alloc != new_alloc) {\
regint.h:    (buf)->p = (UChar* )xrealloc((buf)->p, new_alloc);\
regint.h:    if (IS_NULL((buf)->p)) return(ONIGERR_MEMORY);\
regint.h:    (buf)->alloc = new_alloc;\
regint.h:  if ((buf)->alloc < (unsigned int )used) BBUF_EXPAND((buf),used);\
regint.h:  xmemcpy((buf)->p + (pos), (bytes), (n));\
regint.h:  if ((buf)->used < (unsigned int )used) (buf)->used = used;\
regint.h:  if ((buf)->alloc < (unsigned int )used) BBUF_EXPAND((buf),used);\
regint.h:  (buf)->p[(pos)] = (byte);\
regint.h:  if ((buf)->used < (unsigned int )used) (buf)->used = used;\
regint.h:#define BBUF_ADD(buf,bytes,n)       BBUF_WRITE((buf),(buf)->used,(bytes),(n))
regint.h:#define BBUF_ADD1(buf,byte)         BBUF_WRITE1((buf),(buf)->used,(byte))
regint.h:#define BBUF_GET_ADD_ADDRESS(buf)   ((buf)->p + (buf)->used)
regint.h:#define BBUF_GET_OFFSET_POS(buf)    ((buf)->used)
regint.h:  if ((unsigned int )((to)+(n)) > (buf)->alloc) BBUF_EXPAND((buf),(to) + (n));\
regint.h:  xmemmove((buf)->p + (to), (buf)->p + (from), (n));\
regint.h:  if ((unsigned int )((to)+(n)) > (buf)->used) (buf)->used = (to) + (n);\
regint.h:  xmemmove((buf)->p + (to), (buf)->p + (from), (n));\
regint.h:  xmemmove((buf)->p + (to), (buf)->p + (from), (buf)->used - (from));\
regint.h:  (buf)->used -= (from - to);\
regint.h:  if (pos >= (buf)->used) {\
regint.h:    BBUF_MOVE_RIGHT((buf),(pos),(pos) + (n),((buf)->used - (pos)));\
regint.h:    xmemcpy((buf)->p + (pos), (bytes), (n));\
regint.h:#define BBUF_GET_BYTE(buf, pos) (buf)->p[(pos)]
regint.h:#define ANCHOR_ANYCHAR_STAR_ML  (1<<15)   /* ".*" optimize info (multi-line) */
regint.h:  OP_EXACTMB2N1,        /* mb-length = 2 N = 1 */
regint.h:  OP_EXACTMB2N2,        /* mb-length = 2 N = 2 */
regint.h:  OP_EXACTMB2N3,        /* mb-length = 2 N = 3 */
regint.h:  OP_EXACTMB2N,         /* mb-length = 2 */
regint.h:  OP_EXACTMB3N,         /* mb-length = 3 */
regint.h:  OP_ANYCHAR_ML,              /* "."  multi-line */
regint.h:  OP_ANYCHAR_ML_STAR,         /* ".*" multi-line */
regint.h:  OP_BACKREF_WITH_LEVEL,    /* \k<xxx+n>, \k<xxx-n> */
regint.h:  OP_MEMORY_START_PUSH,   /* push back-tracker to stack */
regint.h:  OP_MEMORY_END_PUSH,     /* push back-tracker to stack */
regint.h:  OP_MEMORY_END_PUSH_REC, /* push back-tracker to stack */
regint.h:  OP_NULL_CHECK_END_MEMST_PUSH, /* with capture status and push check-end */
regint.h:  OP_STATE_CHECK_PUSH_OR_JUMP, /* check ok -> push, else jump  */
regint.h:/* op-code + arg size */
regint.h:#define MC_ESC(syn)               (syn)->meta_char_table.esc
regint.h:#define MC_ANYCHAR(syn)           (syn)->meta_char_table.anychar
regint.h:#define MC_ANYTIME(syn)           (syn)->meta_char_table.anytime
regint.h:#define MC_ZERO_OR_ONE_TIME(syn)  (syn)->meta_char_table.zero_or_one_time
regint.h:#define MC_ONE_OR_MORE_TIME(syn)  (syn)->meta_char_table.one_or_more_time
regint.h:#define MC_ANYCHAR_ANYTIME(syn)   (syn)->meta_char_table.anychar_anytime
regint.h:#define NCCLASS_FLAGS(cc)           ((cc)->flags)
regint.h:  BBuf*  mbuf;   /* multi-byte info or NULL */
regint.h:      /* Following information is setted, if this stack type is MEM-START */
regparse.c:  regparse.c -  Oniguruma (regular expression library)
regparse.c:/*-
regparse.c: * Copyright (c) 2002-2007  K.Kosako  <sndgk393 AT ybb DOT ne DOT jp>
regparse.c:    if (IS_NOT_NULL(bbuf->p)) xfree(bbuf->p);
regparse.c:  r = BBUF_INIT(to, from->alloc);
regparse.c:  to->used = from->used;
regparse.c:  xmemcpy(to->p, from->p, from->used);
regparse.c:  ((env)->num_mem + 1 + (rel_no))
regparse.c:  while (n-- > 0) {
regparse.c:    x = *s2++ - *s1++;
regparse.c:  int len = end - src;
regparse.c:  slen = end - s;
regparse.c:  c = ((enc->max_enc_len == 1) ? *p : ONIGENC_MBC_TO_CODE(enc, p, end)); \
regparse.c:  onig_strcpy(r + (dest_end - dest), src, src_end);
regparse.c:  onig_strcpy(r + (dest_end - dest), src, src_end);
regparse.c:  if ((x->end - x->s) != (y->end - y->s))
regparse.c:  p = x->s;
regparse.c:  q = y->s;
regparse.c:  while (p < x->end) {
regparse.c:    c = (int )*p - (int )*q;
regparse.c:  p = x->s;
regparse.c:  while (p < x->end) {
regparse.c:  key->s   = (UChar* )str_key;
regparse.c:  key->end = (UChar* )end_key;
regparse.c:  fprintf(fp, "%s: ", e->name);
regparse.c:  if (e->back_num == 0)
regparse.c:    fputs("-", fp);
regparse.c:  else if (e->back_num == 1)
regparse.c:    fprintf(fp, "%d", e->back_ref1);
regparse.c:    for (i = 0; i < e->back_num; i++) {
regparse.c:      fprintf(fp, "%d", e->back_refs[i]);
regparse.c:  NameTable* t = (NameTable* )reg->name_table;
regparse.c:  xfree(e->name);
regparse.c:  if (IS_NOT_NULL(e->back_refs)) xfree(e->back_refs);
regparse.c:  NameTable* t = (NameTable* )reg->name_table;
regparse.c:  t = (NameTable* )reg->name_table;
regparse.c:  reg->name_table = (void* )NULL;
regparse.c:  NameTable* t = (NameTable* )reg->name_table;
regparse.c:  int r = (*(arg->func))(e->name,
regparse.c:                         e->name + e->name_len,
regparse.c:                         e->back_num,
regparse.c:			 (e->back_num > 1 ? e->back_refs : &(e->back_ref1)),
regparse.c:			 arg->reg, arg->arg);
regparse.c:    arg->ret = r;
regparse.c:  NameTable* t = (NameTable* )reg->name_table;
regparse.c:    narg.enc  = reg->enc; /* should be pattern encoding. */
regparse.c:  if (e->back_num > 1) {
regparse.c:    for (i = 0; i < e->back_num; i++) {
regparse.c:      e->back_refs[i] = map[e->back_refs[i]].new_val;
regparse.c:  else if (e->back_num == 1) {
regparse.c:    e->back_ref1 = map[e->back_ref1].new_val;
regparse.c:  NameTable* t = (NameTable* )reg->name_table;
regparse.c:  NameTable* t = (NameTable* )reg->name_table;
regparse.c:    return t->num_entries;
regparse.c:  NameTable* t = (NameTable* )reg->name_table;
regparse.c:  if (IS_NOT_NULL(t) && t->num > 0) {
regparse.c:    for (i = 0; i < t->num; i++) {
regparse.c:      e = &(t->e[i]);
regparse.c:      fprintf(fp, "%s: ", e->name);
regparse.c:      if (e->back_num == 0) {
regparse.c:	fputs("-", fp);
regparse.c:      else if (e->back_num == 1) {
regparse.c:	fprintf(fp, "%d", e->back_ref1);
regparse.c:	for (j = 0; j < e->back_num; j++) {
regparse.c:	  fprintf(fp, "%d", e->back_refs[j]);
regparse.c:  NameTable* t = (NameTable* )reg->name_table;
regparse.c:    for (i = 0; i < t->num; i++) {
regparse.c:      e = &(t->e[i]);
regparse.c:      if (IS_NOT_NULL(e->name)) {
regparse.c:	xfree(e->name);
regparse.c:	e->name       = NULL;
regparse.c:	e->name_len   = 0;
regparse.c:	e->back_num   = 0;
regparse.c:	e->back_alloc = 0;
regparse.c:	if (IS_NOT_NULL(e->back_refs)) xfree(e->back_refs);
regparse.c:	e->back_refs = (int* )NULL;
regparse.c:    if (IS_NOT_NULL(t->e)) {
regparse.c:      xfree(t->e);
regparse.c:      t->e = NULL;
regparse.c:    t->num = 0;
regparse.c:  t = (NameTable* )reg->name_table;
regparse.c:  reg->name_table = NULL;
regparse.c:  NameTable* t = (NameTable* )reg->name_table;
regparse.c:    len = name_end - name;
regparse.c:    for (i = 0; i < t->num; i++) {
regparse.c:      e = &(t->e[i]);
regparse.c:      if (len == e->name_len && onig_strncmp(name, e->name, len) == 0)
regparse.c:  NameTable* t = (NameTable* )reg->name_table;
regparse.c:    for (i = 0; i < t->num; i++) {
regparse.c:      e = &(t->e[i]);
regparse.c:      r = (*func)(e->name, e->name + e->name_len, e->back_num,
regparse.c:		  (e->back_num > 1 ? e->back_refs : &(e->back_ref1)),
regparse.c:  NameTable* t = (NameTable* )reg->name_table;
regparse.c:    return t->num;
regparse.c:  NameTable* t = (NameTable* )reg->name_table;
regparse.c:  if (name_end - name <= 0)
regparse.c:      reg->name_table = (void* )t;
regparse.c:    e->name = strdup_with_null(reg->enc, name, name_end);
regparse.c:    if (IS_NULL(e->name)) {
regparse.c:    onig_st_insert_strend(t, e->name, (e->name + (name_end - name)),
regparse.c:    e->name_len   = name_end - name;
regparse.c:    e->back_num   = 0;
regparse.c:    e->back_alloc = 0;
regparse.c:    e->back_refs  = (int* )NULL;
regparse.c:      t->e     = NULL;
regparse.c:      t->alloc = 0;
regparse.c:      t->num   = 0;
regparse.c:      t->e = (NameEntry* )xmalloc(sizeof(NameEntry) * alloc);
regparse.c:      if (IS_NULL(t->e)) {
regparse.c:      t->alloc = alloc;
regparse.c:      reg->name_table = t;
regparse.c:    else if (t->num == t->alloc) {
regparse.c:      alloc = t->alloc * 2;
regparse.c:      t->e = (NameEntry* )xrealloc(t->e, sizeof(NameEntry) * alloc);
regparse.c:      CHECK_NULL_RETURN_MEMERR(t->e);
regparse.c:      t->alloc = alloc;
regparse.c:      for (i = t->num; i < t->alloc; i++) {
regparse.c:	t->e[i].name       = NULL;
regparse.c:	t->e[i].name_len   = 0;
regparse.c:	t->e[i].back_num   = 0;
regparse.c:	t->e[i].back_alloc = 0;
regparse.c:	t->e[i].back_refs  = (int* )NULL;
regparse.c:    e = &(t->e[t->num]);
regparse.c:    t->num++;
regparse.c:    e->name = strdup_with_null(reg->enc, name, name_end);
regparse.c:    e->name_len = name_end - name;
regparse.c:  if (e->back_num >= 1 &&
regparse.c:      ! IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_MULTIPLEX_DEFINITION_NAME)) {
regparse.c:  e->back_num++;
regparse.c:  if (e->back_num == 1) {
regparse.c:    e->back_ref1 = backref;
regparse.c:    if (e->back_num == 2) {
regparse.c:      e->back_refs = (int* )xmalloc(sizeof(int) * alloc);
regparse.c:      CHECK_NULL_RETURN_MEMERR(e->back_refs);
regparse.c:      e->back_alloc = alloc;
regparse.c:      e->back_refs[0] = e->back_ref1;
regparse.c:      e->back_refs[1] = backref;
regparse.c:      if (e->back_num > e->back_alloc) {
regparse.c:	alloc = e->back_alloc * 2;
regparse.c:	e->back_refs = (int* )xrealloc(e->back_refs, sizeof(int) * alloc);
regparse.c:	CHECK_NULL_RETURN_MEMERR(e->back_refs);
regparse.c:	e->back_alloc = alloc;
regparse.c:      e->back_refs[e->back_num - 1] = backref;
regparse.c:  switch (e->back_num) {
regparse.c:    *nums = &(e->back_ref1);
regparse.c:    *nums = e->back_refs;
regparse.c:  return e->back_num;
regparse.c:      for (i = n - 1; i >= 0; i--) {
regparse.c:	if (region->beg[nums[i]] != ONIG_REGION_NOTPOS)
regparse.c:    return nums[n - 1];
regparse.c:  if (ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_DONT_CAPTURE_GROUP))
regparse.c:      IS_SYNTAX_BV(reg->syntax, ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP) &&
regparse.c:      !ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_CAPTURE_GROUP)) {
regparse.c:  BIT_STATUS_CLEAR(env->capture_history);
regparse.c:  BIT_STATUS_CLEAR(env->bt_mem_start);
regparse.c:  BIT_STATUS_CLEAR(env->bt_mem_end);
regparse.c:  BIT_STATUS_CLEAR(env->backrefed_mem);
regparse.c:  env->error      = (UChar* )NULL;
regparse.c:  env->error_end  = (UChar* )NULL;
regparse.c:  env->num_call   = 0;
regparse.c:  env->num_mem    = 0;
regparse.c:  env->num_named  = 0;
regparse.c:  env->mem_alloc         = 0;
regparse.c:  env->mem_nodes_dynamic = (Node** )NULL;
regparse.c:    env->mem_nodes_static[i] = NULL_NODE;
regparse.c:  env->num_comb_exp_check  = 0;
regparse.c:  env->comb_exp_max_regnum = 0;
regparse.c:  env->curr_max_regnum     = 0;
regparse.c:  env->has_recursion       = 0;
regparse.c:  need = env->num_mem + 1;
regparse.c:    if (env->mem_alloc <= need) {
regparse.c:      if (IS_NULL(env->mem_nodes_dynamic)) {
regparse.c:	xmemcpy(p, env->mem_nodes_static,
regparse.c:	alloc = env->mem_alloc * 2;
regparse.c:	p = (Node** )xrealloc(env->mem_nodes_dynamic, sizeof(Node*) * alloc);
regparse.c:      for (i = env->num_mem + 1; i < alloc; i++)
regparse.c:      env->mem_nodes_dynamic = p;
regparse.c:      env->mem_alloc = alloc;
regparse.c:  env->num_mem++;
regparse.c:  return env->num_mem;
regparse.c:  if (env->num_mem >= num)
regparse.c:    if (NSTR(node)->capa != 0 &&
regparse.c:	IS_NOT_NULL(NSTR(node)->s) && NSTR(node)->s != NSTR(node)->buf) {
regparse.c:      xfree(NSTR(node)->s);
regparse.c:	n->next = FreeNodeList;
regparse.c:      if (cc->mbuf)
regparse.c:        bbuf_free(cc->mbuf);
regparse.c:    if (NQTFR(node)->target)
regparse.c:      onig_node_free(NQTFR(node)->target);
regparse.c:    if (NENCLOSE(node)->target)
regparse.c:      onig_node_free(NENCLOSE(node)->target);
regparse.c:    if (IS_NOT_NULL(NBREF(node)->back_dynamic))
regparse.c:      xfree(NBREF(node)->back_dynamic);
regparse.c:    if (NANCHOR(node)->target)
regparse.c:      onig_node_free(NANCHOR(node)->target);
regparse.c:    n->next = FreeNodeList;
regparse.c:    FreeNodeList = FreeNodeList->next;
regparse.c:    FreeNodeList = FreeNodeList->next;
regparse.c:  BITSET_CLEAR(cc->bs);
regparse.c:  /* cc->base.flags = 0; */
regparse.c:  cc->flags = 0;
regparse.c:  cc->mbuf  = NULL;
regparse.c:  BITSET_CLEAR(cc->bs);
regparse.c:        BITSET_SET_BIT(cc->bs, j);
regparse.c:    cc->mbuf = NULL;
regparse.c:    bbuf->alloc = n + 1;
regparse.c:    bbuf->used  = n + 1;
regparse.c:    bbuf->p     = (UChar* )((void* )ranges);
regparse.c:    cc->mbuf = bbuf;
regparse.c:  NCTYPE(node)->ctype = type;
regparse.c:  NCTYPE(node)->not   = not;
regparse.c:  NANCHOR(node)->type     = type;
regparse.c:  NANCHOR(node)->target   = NULL;
regparse.c:  NANCHOR(node)->char_len = -1;
regparse.c:  NBREF(node)->state    = 0;
regparse.c:  NBREF(node)->back_num = back_num;
regparse.c:  NBREF(node)->back_dynamic = (int* )NULL;
regparse.c:    NBREF(node)->state |= NST_NAME_REF;
regparse.c:    NBREF(node)->state |= NST_NEST_LEVEL;
regparse.c:    NBREF(node)->nest_level  = nest_level;
regparse.c:    if (backrefs[i] <= env->num_mem &&
regparse.c:      NBREF(node)->state |= NST_RECURSION;   /* /...(\1).../ */
regparse.c:      NBREF(node)->back_static[i] = backrefs[i];
regparse.c:    NBREF(node)->back_dynamic = p;
regparse.c:  NCALL(node)->state     = 0;
regparse.c:  NCALL(node)->target    = NULL_NODE;
regparse.c:  NCALL(node)->name      = name;
regparse.c:  NCALL(node)->name_end  = name_end;
regparse.c:  NCALL(node)->group_num = gnum;  /* call by number if gnum != 0 */
regparse.c:  NQTFR(node)->state  = 0;
regparse.c:  NQTFR(node)->target = NULL;
regparse.c:  NQTFR(node)->lower  = lower;
regparse.c:  NQTFR(node)->upper  = upper;
regparse.c:  NQTFR(node)->greedy = 1;
regparse.c:  NQTFR(node)->target_empty_info = NQ_TARGET_ISNOT_EMPTY;
regparse.c:  NQTFR(node)->head_exact        = NULL_NODE;
regparse.c:  NQTFR(node)->next_head_exact   = NULL_NODE;
regparse.c:  NQTFR(node)->is_refered        = 0;
regparse.c:    NQTFR(node)->state |= NST_BY_NUMBER;
regparse.c:  NQTFR(node)->comb_exp_check_num = 0;
regparse.c:  NENCLOSE(node)->type      = type;
regparse.c:  NENCLOSE(node)->state     =  0;
regparse.c:  NENCLOSE(node)->regnum    =  0;
regparse.c:  NENCLOSE(node)->option    =  0;
regparse.c:  NENCLOSE(node)->target    = NULL;
regparse.c:  NENCLOSE(node)->call_addr = -1;
regparse.c:  NENCLOSE(node)->opt_count =  0;
regparse.c:  NENCLOSE(node)->option = option;
regparse.c:  NENCLOSE(node)->option = option;
regparse.c:  int addlen = end - s;
regparse.c:    int len  = NSTR(node)->end - NSTR(node)->s;
regparse.c:    if (NSTR(node)->capa > 0 || (len + addlen > NODE_STR_BUF_SIZE - 1)) {
regparse.c:      if (capa <= NSTR(node)->capa) {
regparse.c:	onig_strcpy(NSTR(node)->s + len, s, end);
regparse.c:	if (NSTR(node)->s == NSTR(node)->buf)
regparse.c:	  p = strcat_capa_from_static(NSTR(node)->s, NSTR(node)->end,
regparse.c:	  p = strcat_capa(NSTR(node)->s, NSTR(node)->end, s, end, capa);
regparse.c:	NSTR(node)->s    = p;
regparse.c:	NSTR(node)->capa = capa;
regparse.c:      onig_strcpy(NSTR(node)->s + len, s, end);
regparse.c:    NSTR(node)->end = NSTR(node)->s + len + addlen;
regparse.c:  NSTR(node)->flag = flag;
regparse.c:  NSTR(node)->capa = 0;
regparse.c:  NSTR(node)->s    = NSTR(node)->buf;
regparse.c:  NSTR(node)->end  = NSTR(node)->buf;
regparse.c:  if (NSTR(node)->capa != 0 &&
regparse.c:      IS_NOT_NULL(NSTR(node)->s) && NSTR(node)->s != NSTR(node)->buf) {
regparse.c:    xfree(NSTR(node)->s);
regparse.c:  NSTR(node)->capa = 0;
regparse.c:  NSTR(node)->flag = 0;
regparse.c:  NSTR(node)->s    = NSTR(node)->buf;
regparse.c:  NSTR(node)->end  = NSTR(node)->buf;
regparse.c:  NSTR(node)->capa = 0;
regparse.c:  NSTR(node)->flag = 0;
regparse.c:  NSTR(node)->s    = NSTR(node)->buf;
regparse.c:  NSTR(node)->end  = NSTR(node)->buf;
regparse.c:  if (sn->end > sn->s) {
regparse.c:    p = onigenc_get_prev_char_head(enc, sn->s, sn->end, sn->end);
regparse.c:    if (p && p > sn->s) { /* can be splitted. */
regparse.c:      n = node_new_str(p, sn->end);
regparse.c:      if ((sn->flag & NSTR_RAW) != 0)
regparse.c:      sn->end = (UChar* )p;
regparse.c:  if (sn->end > sn->s) {
regparse.c:    return ((enclen(enc, sn->s, sn->end) < sn->end - sn->s)  ?  1 : 0);
regparse.c:  len = sn->end - sn->s;
regparse.c:  onig_strcpy(buf, sn->s, sn->end);
regparse.c:  onig_strcpy(&(sn->s[num]), buf, buf + len);
regparse.c:  sn->end += num;
regparse.c:    sn->s[i] = val;
regparse.c:      if ((INT_MAX_LIMIT - val) / 10UL < num)
regparse.c:	return -1;  /* overflow */
regparse.c:  while (!PEND && maxlen-- != 0) {
regparse.c:      if ((INT_MAX_LIMIT - val) / 16UL < num)
regparse.c:	return -1;  /* overflow */
regparse.c:  while (!PEND && maxlen-- != 0) {
regparse.c:      if ((INT_MAX_LIMIT - val) / 8UL < num)
regparse.c:	return -1;  /* overflow */
regparse.c:     [n][from-1][to-1][from-2][to-2] ... [from-n][to-n]
regparse.c:    GET_CODE_POINT(n, bbuf->p);
regparse.c:  data = (OnigCodePoint* )(bbuf->p);
regparse.c:    if (to >= data[x*2] - 1)
regparse.c:  inc_n = low + 1 - high;
regparse.c:    if (to < data[(high - 1)*2 + 1])
regparse.c:      to = data[(high - 1)*2 + 1];
regparse.c:    int size = (n - high) * 2 * SIZE_CODE_POINT;
regparse.c:    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))
regparse.c:  data = (OnigCodePoint* )(bbuf->p);
regparse.c:    if (pre <= from - 1) {
regparse.c:      r = add_code_range_to_buf(pbuf, pre, from - 1);
regparse.c:  data1 = (OnigCodePoint* )(bbuf1->p);
regparse.c:	if (from1 <= from2 - 1) {
regparse.c:	  r = add_code_range_to_buf(pbuf, from1, from2-1);
regparse.c:	to1 = from2 - 1;
regparse.c:    if (not1 != 0 && IS_NOT_NULL(bbuf2)) /* not1 != 0 -> not2 == 0 */
regparse.c:  data1 = (OnigCodePoint* )(bbuf1->p);
regparse.c:  data2 = (OnigCodePoint* )(bbuf2->p);
regparse.c:  bsr1 = dest->bs;
regparse.c:  buf1 = dest->mbuf;
regparse.c:  bsr2 = cc->bs;
regparse.c:  buf2 = cc->mbuf;
regparse.c:  if (bsr1 != dest->bs) {
regparse.c:    bitset_copy(dest->bs, bsr1);
regparse.c:    bsr1 = dest->bs;
regparse.c:    bitset_invert(dest->bs);
regparse.c:    dest->mbuf = pbuf;
regparse.c:  bsr1 = dest->bs;
regparse.c:  buf1 = dest->mbuf;
regparse.c:  bsr2 = cc->bs;
regparse.c:  buf2 = cc->mbuf;
regparse.c:  if (bsr1 != dest->bs) {
regparse.c:    bitset_copy(dest->bs, bsr1);
regparse.c:    bsr1 = dest->bs;
regparse.c:    bitset_invert(dest->bs);
regparse.c:    dest->mbuf = pbuf;
regparse.c:  if (IS_SYNTAX_OP(env->syntax, ONIG_SYN_OP_ESC_CONTROL_CHARS)) {
regparse.c:      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ESC_V_VTAB))
regparse.c:    /* return is_invalid_quantifier_target(NENCLOSE(node)->target); */
regparse.c:  if (q->greedy) {
regparse.c:    if (q->lower == 0) {
regparse.c:      if (q->upper == 1) return 0;
regparse.c:      else if (IS_REPEAT_INFINITE(q->upper)) return 1;
regparse.c:    else if (q->lower == 1) {
regparse.c:      if (IS_REPEAT_INFINITE(q->upper)) return 2;
regparse.c:    if (q->lower == 0) {
regparse.c:      if (q->upper == 1) return 3;
regparse.c:      else if (IS_REPEAT_INFINITE(q->upper)) return 4;
regparse.c:    else if (q->lower == 1) {
regparse.c:      if (IS_REPEAT_INFINITE(q->upper)) return 5;
regparse.c:  return -1;
regparse.c:    p->target = c->target;
regparse.c:    p->lower  = 0;  p->upper = REPEAT_INFINITE;  p->greedy = 1;
regparse.c:    p->target = c->target;
regparse.c:    p->lower  = 0;  p->upper = REPEAT_INFINITE;  p->greedy = 0;
regparse.c:    p->target = c->target;
regparse.c:    p->lower  = 0;  p->upper = 1;  p->greedy = 0;
regparse.c:    p->target = cnode;
regparse.c:    p->lower  = 0;  p->upper = 1;  p->greedy = 0;
regparse.c:    c->lower  = 1;  c->upper = REPEAT_INFINITE;  c->greedy = 1;
regparse.c:    p->target = cnode;
regparse.c:    p->lower  = 0;  p->upper = 1;  p->greedy = 1;
regparse.c:    c->lower  = 1;  c->upper = REPEAT_INFINITE;  c->greedy = 0;
regparse.c:    p->target = cnode;
regparse.c:  c->target = NULL_NODE;
regparse.c:  OnigEncoding enc = env->enc;
regparse.c:  syn_allow = IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_INVALID_INTERVAL);
regparse.c:  low = onig_scan_unsigned_number(&p, end, env->enc);
regparse.c:    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_INTERVAL_LOW_ABBREV)) {
regparse.c:    up = onig_scan_unsigned_number(&p, end, env->enc);
regparse.c:  if (IS_SYNTAX_OP(env->syntax, ONIG_SYN_OP_ESC_BRACE_INTERVAL)) {
regparse.c:    if (c != MC_ESC(env->syntax)) goto invalid;
regparse.c:  tok->type = TK_INTERVAL;
regparse.c:  tok->u.repeat.lower = low;
regparse.c:  tok->u.repeat.upper = up;
regparse.c:/* \M-, \C-, \c, or \... */
regparse.c:  OnigEncoding enc = env->enc;
regparse.c:    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ESC_CAPITAL_M_BAR_META)) {
regparse.c:      if (c != '-') return ONIGERR_META_CODE_SYNTAX;
regparse.c:      if (c == MC_ESC(env->syntax)) {
regparse.c:    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ESC_CAPITAL_C_BAR_CONTROL)) {
regparse.c:      if (c != '-') return ONIGERR_CONTROL_CODE_SYNTAX;
regparse.c:    if (IS_SYNTAX_OP(env->syntax, ONIG_SYN_OP_ESC_C_CONTROL)) {
regparse.c:        if (c == MC_ESC(env->syntax)) {
regparse.c:   \k<name+n>, \k<name-n>
regparse.c:   \k<num+n>,  \k<num-n>
regparse.c:   \k<-num+n>, \k<-num-n>
regparse.c:  OnigEncoding enc = env->enc;
regparse.c:    else if (c == '-') {
regparse.c:      sign = -1;
regparse.c:    if (c == end_code || c == ')' || c == '+' || c == '-') {
regparse.c:    if (c == '+' || c == '-') {
regparse.c:      int flag = (c == '-' ? -1 : 1);
regparse.c:  def: 0 -> define name    (don't allow number name)
regparse.c:       1 -> reference name (allow number name)
regparse.c:  OnigEncoding enc = env->enc;
regparse.c:    else if (c == '-') {
regparse.c:	sign = -1;
regparse.c:  OnigEncoding enc = env->enc;
regparse.c:    else if (c == '-') {
regparse.c:      sign = -1;
regparse.c:  if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_WARN_CC_OP_NOT_ESCAPED) &&
regparse.c:      IS_SYNTAX_BV(env->syntax, ONIG_SYN_BACKSLASH_ESCAPE_IN_CC)) {
regparse.c:    onig_snprintf_with_pattern(buf, WARN_BUFSIZE, env->enc,
regparse.c:		env->pattern, env->pattern_end,
regparse.c:  if (IS_SYNTAX_BV((env)->syntax, ONIG_SYN_WARN_CC_OP_NOT_ESCAPED)) {
regparse.c:    onig_snprintf_with_pattern(buf, WARN_BUFSIZE, (env)->enc,
regparse.c:		(env)->pattern, (env)->pattern_end,
regparse.c:  const OnigSyntaxType* syn = env->syntax;
regparse.c:  OnigEncoding enc = env->enc;
regparse.c:    tok->type = TK_EOT;
regparse.c:    return tok->type;
regparse.c:  tok->type = TK_CHAR;
regparse.c:  tok->base = 0;
regparse.c:  tok->u.c  = c;
regparse.c:  tok->escaped = 0;
regparse.c:    tok->type = TK_CC_CLOSE;
regparse.c:  else if (c == '-') {
regparse.c:    tok->type = TK_CC_RANGE;
regparse.c:    tok->escaped = 1;
regparse.c:    tok->u.c = c;
regparse.c:      tok->type = TK_CHAR_TYPE;
regparse.c:      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;
regparse.c:      tok->u.prop.not   = 0;
regparse.c:      tok->type = TK_CHAR_TYPE;
regparse.c:      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;
regparse.c:      tok->u.prop.not   = 1;
regparse.c:      tok->type = TK_CHAR_TYPE;
regparse.c:      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;
regparse.c:      tok->u.prop.not   = 0;
regparse.c:      tok->type = TK_CHAR_TYPE;
regparse.c:      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;
regparse.c:      tok->u.prop.not   = 1;
regparse.c:      tok->type = TK_CHAR_TYPE;
regparse.c:      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;
regparse.c:      tok->u.prop.not   = 0;
regparse.c:      tok->type = TK_CHAR_TYPE;
regparse.c:      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;
regparse.c:      tok->u.prop.not   = 1;
regparse.c:      tok->type = TK_CHAR_TYPE;
regparse.c:      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;
regparse.c:      tok->u.prop.not   = 0;
regparse.c:      tok->type = TK_CHAR_TYPE;
regparse.c:      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;
regparse.c:      tok->u.prop.not   = 1;
regparse.c:	tok->type = TK_CHAR_PROPERTY;
regparse.c:	tok->u.prop.not = (c == 'P' ? 1 : 0);
regparse.c:	    tok->u.prop.not = (tok->u.prop.not == 0 ? 1 : 0);
regparse.c:	  tok->type   = TK_CODE_POINT;
regparse.c:	  tok->base   = 16;
regparse.c:	  tok->u.code = (OnigCodePoint )num;
regparse.c:	tok->type = TK_RAW_BYTE;
regparse.c:	tok->base = 16;
regparse.c:	tok->u.c  = num;
regparse.c:	tok->type   = TK_CODE_POINT;
regparse.c:	tok->base   = 16;
regparse.c:	tok->u.code = (OnigCodePoint )num;
regparse.c:	tok->type = TK_RAW_BYTE;
regparse.c:	tok->base = 8;
regparse.c:	tok->u.c  = num;
regparse.c:      if (tok->u.c != num) {
regparse.c:	tok->u.code = (OnigCodePoint )num;
regparse.c:	tok->type   = TK_CODE_POINT;
regparse.c:      tok->backp = p; /* point at '[' is readed */
regparse.c:	tok->type = TK_POSIX_BRACKET_OPEN;
regparse.c:	tok->type = TK_CC_CC_OPEN;
regparse.c:      tok->type = TK_CC_AND;
regparse.c:  return tok->type;
regparse.c:  OnigEncoding enc = env->enc;
regparse.c:  const OnigSyntaxType* syn = env->syntax;
regparse.c:    tok->type = TK_EOT;
regparse.c:    return tok->type;
regparse.c:  tok->type  = TK_STRING;
regparse.c:  tok->base  = 0;
regparse.c:  tok->backp = p;
regparse.c:    tok->backp = p;
regparse.c:    tok->u.c = c;
regparse.c:    tok->escaped = 1;
regparse.c:      tok->type = TK_OP_REPEAT;
regparse.c:      tok->u.repeat.lower = 0;
regparse.c:      tok->u.repeat.upper = REPEAT_INFINITE;
regparse.c:      tok->type = TK_OP_REPEAT;
regparse.c:      tok->u.repeat.lower = 1;
regparse.c:      tok->u.repeat.upper = REPEAT_INFINITE;
regparse.c:      tok->type = TK_OP_REPEAT;
regparse.c:      tok->u.repeat.lower = 0;
regparse.c:      tok->u.repeat.upper = 1;
regparse.c:	tok->u.repeat.greedy     = 0;
regparse.c:	tok->u.repeat.possessive = 0;
regparse.c:	      tok->type != TK_INTERVAL)  ||
regparse.c:	      tok->type == TK_INTERVAL))) {
regparse.c:	  tok->u.repeat.greedy     = 1;
regparse.c:	  tok->u.repeat.possessive = 1;
regparse.c:	  tok->u.repeat.greedy     = 1;
regparse.c:	  tok->u.repeat.possessive = 0;
regparse.c:      tok->type = TK_ALT;
regparse.c:      tok->type = TK_SUBEXP_OPEN;
regparse.c:      tok->type = TK_SUBEXP_CLOSE;
regparse.c:      tok->type = TK_CHAR_TYPE;
regparse.c:      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;
regparse.c:      tok->u.prop.not   = 0;
regparse.c:      tok->type = TK_CHAR_TYPE;
regparse.c:      tok->u.prop.ctype = ONIGENC_CTYPE_WORD;
regparse.c:      tok->u.prop.not   = 1;
regparse.c:      tok->type = TK_ANCHOR;
regparse.c:      tok->u.anchor = ANCHOR_WORD_BOUND;
regparse.c:      tok->type = TK_ANCHOR;
regparse.c:      tok->u.anchor = ANCHOR_NOT_WORD_BOUND;
regparse.c:      tok->type = TK_ANCHOR;
regparse.c:      tok->u.anchor = ANCHOR_WORD_BEGIN;
regparse.c:      tok->type = TK_ANCHOR;
regparse.c:      tok->u.anchor = ANCHOR_WORD_END;
regparse.c:      tok->type = TK_CHAR_TYPE;
regparse.c:      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;
regparse.c:      tok->u.prop.not   = 0;
regparse.c:      tok->type = TK_CHAR_TYPE;
regparse.c:      tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;
regparse.c:      tok->u.prop.not   = 1;
regparse.c:      tok->type = TK_CHAR_TYPE;
regparse.c:      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;
regparse.c:      tok->u.prop.not   = 0;
regparse.c:      tok->type = TK_CHAR_TYPE;
regparse.c:      tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;
regparse.c:      tok->u.prop.not   = 1;
regparse.c:      tok->type = TK_CHAR_TYPE;
regparse.c:      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;
regparse.c:      tok->u.prop.not   = 0;
regparse.c:      tok->type = TK_CHAR_TYPE;
regparse.c:      tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;
regparse.c:      tok->u.prop.not   = 1;
regparse.c:      tok->type = TK_ANCHOR;
regparse.c:      tok->u.subtype = ANCHOR_BEGIN_BUF;
regparse.c:      tok->type = TK_ANCHOR;
regparse.c:      tok->u.subtype = ANCHOR_SEMI_END_BUF;
regparse.c:      tok->type = TK_ANCHOR;
regparse.c:      tok->u.subtype = ANCHOR_END_BUF;
regparse.c:      tok->type = TK_ANCHOR;
regparse.c:      tok->u.subtype = ANCHOR_BEGIN_POSITION;
regparse.c:	  tok->type   = TK_CODE_POINT;
regparse.c:	  tok->u.code = (OnigCodePoint )num;
regparse.c:	tok->type = TK_RAW_BYTE;
regparse.c:	tok->base = 16;
regparse.c:	tok->u.c  = num;
regparse.c:	tok->type   = TK_CODE_POINT;
regparse.c:	tok->base   = 16;
regparse.c:	tok->u.code = (OnigCodePoint )num;
regparse.c:	  (num <= env->num_mem || num <= 9)) { /* This spec. from GNU regex */
regparse.c:	  if (num > env->num_mem || IS_NULL(SCANENV_MEM_NODES(env)[num]))
regparse.c:	tok->type = TK_BACKREF;
regparse.c:	tok->u.backref.num     = 1;
regparse.c:	tok->u.backref.ref1    = num;
regparse.c:	tok->u.backref.by_name = 0;
regparse.c:	tok->u.backref.exist_level = 0;
regparse.c:	tok->type = TK_RAW_BYTE;
regparse.c:	tok->base = 8;
regparse.c:	tok->u.c  = num;
regparse.c:				    env, &back_num, &tok->u.backref.level);
regparse.c:	  if (r == 1) tok->u.backref.exist_level = 1;
regparse.c:	  else        tok->u.backref.exist_level = 0;
regparse.c:	      if (back_num > env->num_mem ||
regparse.c:	    tok->type = TK_BACKREF;
regparse.c:	    tok->u.backref.by_name = 0;
regparse.c:	    tok->u.backref.num  = 1;
regparse.c:	    tok->u.backref.ref1 = back_num;
regparse.c:	    num = onig_name_to_group_numbers(env->reg, prev, name_end, &backs);
regparse.c:		if (backs[i] > env->num_mem ||
regparse.c:	    tok->type = TK_BACKREF;
regparse.c:	    tok->u.backref.by_name = 1;
regparse.c:	      tok->u.backref.num  = 1;
regparse.c:	      tok->u.backref.ref1 = backs[0];
regparse.c:	      tok->u.backref.num  = num;
regparse.c:	      tok->u.backref.refs = backs;
regparse.c:	  tok->type = TK_CALL;
regparse.c:	  tok->u.call.name     = prev;
regparse.c:	  tok->u.call.name_end = name_end;
regparse.c:	  tok->u.call.gnum     = gnum;
regparse.c:	tok->type = TK_QUOTE_OPEN;
regparse.c:	tok->type = TK_CHAR_PROPERTY;
regparse.c:	tok->u.prop.not = (c == 'P' ? 1 : 0);
regparse.c:	    tok->u.prop.not = (tok->u.prop.not == 0 ? 1 : 0);
regparse.c:      if (tok->u.c != num) {
regparse.c:	tok->type = TK_CODE_POINT;
regparse.c:	tok->u.code = (OnigCodePoint )num;
regparse.c:	p = tok->backp + enclen(enc, tok->backp, end);
regparse.c:    tok->u.c = c;
regparse.c:    tok->escaped = 0;
regparse.c:	tok->type = TK_ANYCHAR_ANYTIME;
regparse.c:      tok->type = TK_ANYCHAR;
regparse.c:      tok->type = TK_OP_REPEAT;
regparse.c:      tok->u.repeat.lower = 0;
regparse.c:      tok->u.repeat.upper = REPEAT_INFINITE;
regparse.c:      tok->type = TK_OP_REPEAT;
regparse.c:      tok->u.repeat.lower = 1;
regparse.c:      tok->u.repeat.upper = REPEAT_INFINITE;
regparse.c:      tok->type = TK_OP_REPEAT;
regparse.c:      tok->u.repeat.lower = 0;
regparse.c:      tok->u.repeat.upper = 1;
regparse.c:      tok->type = TK_ALT;
regparse.c:      tok->type = TK_SUBEXP_OPEN;
regparse.c:      tok->type = TK_SUBEXP_CLOSE;
regparse.c:      tok->type = TK_ANCHOR;
regparse.c:      tok->u.subtype = (IS_SINGLELINE(env->option)
regparse.c:      tok->type = TK_ANCHOR;
regparse.c:      tok->u.subtype = (IS_SINGLELINE(env->option)
regparse.c:      tok->type = TK_CC_OPEN;
regparse.c:      if (*src > env->pattern)   /* /].../ is allowed. */
regparse.c:      if (IS_EXTEND(env->option)) {
regparse.c:      if (IS_EXTEND(env->option))
regparse.c:  return tok->type;
regparse.c:	    r = add_code_range_to_buf(&(cc->mbuf), j,
regparse.c:        BITSET_SET_BIT(cc->bs, j);
regparse.c:      r = add_code_range_to_buf(&(cc->mbuf),
regparse.c:	BITSET_SET_BIT(cc->bs, j);
regparse.c:      BITSET_SET_BIT(cc->bs, j);
regparse.c:	r = add_code_range_to_buf(&(cc->mbuf), prev,
regparse.c:                                  ONIGENC_CODE_RANGE_FROM(mbr, i) - 1);
regparse.c:      r = add_code_range_to_buf(&(cc->mbuf), prev, 0x7fffffff);
regparse.c:  OnigEncoding enc = env->enc;
regparse.c:    return add_ctype_to_cc_by_range(cc, ctype, not, env->enc, sb_out, ranges);
regparse.c:	  BITSET_SET_BIT(cc->bs, c);
regparse.c:      ADD_ALL_MULTI_BYTE_RANGE(enc, cc->mbuf);
regparse.c:	  BITSET_SET_BIT(cc->bs, c);
regparse.c:	  BITSET_SET_BIT(cc->bs, c);
regparse.c:	  BITSET_SET_BIT(cc->bs, c);
regparse.c:      ADD_ALL_MULTI_BYTE_RANGE(enc, cc->mbuf);
regparse.c:	if (IS_CODE_SB_WORD(enc, c)) BITSET_SET_BIT(cc->bs, c);
regparse.c:      ADD_ALL_MULTI_BYTE_RANGE(enc, cc->mbuf);
regparse.c:	  BITSET_SET_BIT(cc->bs, c);
regparse.c:    { (UChar* )NULL,     -1, 0 }
regparse.c:  OnigEncoding enc = env->enc;
regparse.c:  for (pb = PBS; IS_NOT_NULL(pb->name); pb++) {
regparse.c:    if (onigenc_with_ascii_strncmp(enc, p, end, pb->name, pb->len) == 0) {
regparse.c:      p = (UChar* )onigenc_step(enc, p, end, pb->len);
regparse.c:      r = add_ctype_to_cc(cc, pb->ctype, not, env);
regparse.c:  OnigEncoding enc = env->enc;
regparse.c:  if (tok->u.prop.not != 0) NCCLASS_SET_NOT(cc);
regparse.c:      BITSET_SET_BIT(cc->bs, (int )(*vs));
regparse.c:      r = add_code_range(&(cc->mbuf), env, *vs, *vs);
regparse.c:      BITSET_SET_BIT(cc->bs, (int )(*vs));
regparse.c:      r = add_code_range(&(cc->mbuf), env, *vs, *vs);
regparse.c:	  if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))
regparse.c:	bitset_set_range(cc->bs, (int )*vs, (int )v);
regparse.c:	r = add_code_range(&(cc->mbuf), env, *vs, v);
regparse.c:	  if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))
regparse.c:	bitset_set_range(cc->bs, (int )*vs, (int )(v < 0xff ? v : 0xff));
regparse.c:	r = add_code_range(&(cc->mbuf), env, (OnigCodePoint )*vs, v);
regparse.c:  OnigEncoding enc = env->enc;
regparse.c:      if (code == MC_ESC(env->syntax)) in_esc = 1;
regparse.c:  if (r == TK_CHAR && tok->u.c == '^' && tok->escaped == 0) {
regparse.c:                           *src, env->pattern_end, 1, env))
regparse.c:    r = tok->type = TK_CHAR;  /* allow []...] */
regparse.c:      if ((tok->u.code >= SINGLE_BYTE_SIZE) ||
regparse.c:	  (len = ONIGENC_CODE_TO_MBCLEN(env->enc, tok->u.c)) > 1) {
regparse.c:      v = (OnigCodePoint )tok->u.c;
regparse.c:      /* tok->base != 0 : octal or hexadec. */
regparse.c:      if (! ONIGENC_IS_SINGLEBYTE(env->enc) && tok->base != 0) {
regparse.c:	int i, base = tok->base;
regparse.c:	buf[0] = tok->u.c;
regparse.c:	for (i = 1; i < ONIGENC_MBC_MAXLEN(env->enc); i++) {
regparse.c:	  if (r != TK_RAW_BYTE || tok->base != base) {
regparse.c:	  buf[i] = tok->u.c;
regparse.c:	if (i < ONIGENC_MBC_MINLEN(env->enc)) {
regparse.c:	len = enclen(env->enc, buf, buf+i);
regparse.c:	  v = ONIGENC_MBC_TO_CODE(env->enc, buf, bufe);
regparse.c:	v = (OnigCodePoint )tok->u.c;
regparse.c:      v = tok->u.code;
regparse.c:      len = ONIGENC_CODE_TO_MBCLEN(env->enc, v);
regparse.c:	p = tok->backp;
regparse.c:	v = (OnigCodePoint )tok->u.c;
regparse.c:      r = add_ctype_to_cc(cc, tok->u.prop.ctype, tok->u.prop.not, env);
regparse.c:	r = add_ctype_to_cc(cc, ctype, tok->u.prop.not, env);
regparse.c:	if (r == TK_CC_CLOSE) { /* allow [x-] */
regparse.c:	  v = (OnigCodePoint )'-';
regparse.c:	  CC_ESC_WARN(env, (UChar* )"-");
regparse.c:	/* [-xa] is allowed */
regparse.c:	v = (OnigCodePoint )tok->u.c;
regparse.c:	/* [--x] or [a&&-x] is warned. */
regparse.c:	  CC_ESC_WARN(env, (UChar* )"-");
regparse.c:	CC_ESC_WARN(env, (UChar* )"-");
regparse.c:	goto sb_char;  /* [!--x] is allowed */
regparse.c:	if (r == TK_CC_CLOSE) goto range_end_val; /* allow [a-b-] */
regparse.c:	  CC_ESC_WARN(env, (UChar* )"-");
regparse.c:	if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_DOUBLE_RANGE_OP_IN_CC)) {
regparse.c:	  CC_ESC_WARN(env, (UChar* )"-");
regparse.c:	  goto sb_char;   /* [0-9-a] is allowed as [0-9\-a] */
regparse.c:	r = or_cclass(cc, acc, env->enc);
regparse.c:	  r = and_cclass(prev_cc, cc, env->enc);
regparse.c:	  bbuf_free(cc->mbuf);
regparse.c:      r = tok->type;
regparse.c:    r = and_cclass(prev_cc, cc, env->enc);
regparse.c:    bbuf_free(cc->mbuf);
regparse.c:      IS_SYNTAX_BV(env->syntax, ONIG_SYN_NOT_NEWLINE_IN_NEGATIVE_CC)) {
regparse.c:    is_empty = (IS_NULL(cc->mbuf) ? 1 : 0);
regparse.c:      BITSET_IS_EMPTY(cc->bs, is_empty);
regparse.c:      if (ONIGENC_IS_CODE_NEWLINE(env->enc, NEWLINE_CODE)) {
regparse.c:        if (ONIGENC_CODE_TO_MBCLEN(env->enc, NEWLINE_CODE) == 1)
regparse.c:          BITSET_SET_BIT(cc->bs, NEWLINE_CODE);
regparse.c:          add_code_range(&(cc->mbuf), env, NEWLINE_CODE, NEWLINE_CODE);
regparse.c:    bbuf_free(cc->mbuf);
regparse.c:  OnigEncoding enc = env->enc;
regparse.c:  option = env->option;
regparse.c:      IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_GROUP_EFFECT)) {
regparse.c:      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP)) {
regparse.c:	if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP)) {
regparse.c:	  r = name_add(env->reg, name, name_end, num, env);
regparse.c:	  *np = node_new_enclose_memory(env->option, 1);
regparse.c:	  NENCLOSE(*np)->regnum = num;
regparse.c:	    BIT_STATUS_ON_AT_SIMPLE(env->capture_history, num);
regparse.c:	  env->num_named++;
regparse.c:      if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_ATMARK_CAPTURE_HISTORY)) {
regparse.c:	if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP)) {
regparse.c:	*np = node_new_enclose_memory(env->option, 0);
regparse.c:	NENCLOSE(*np)->regnum = num;
regparse.c:	BIT_STATUS_ON_AT_SIMPLE(env->capture_history, num);
regparse.c:    case '-': case 'i': case 'm': case 's': case 'x':
regparse.c:	  case '-':  neg = 1; break;
regparse.c:	    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_PERL)) {
regparse.c:	    if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_PERL)) {
regparse.c:	    else if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_OPTION_RUBY)) {
regparse.c:	    OnigOptionType prev = env->option;
regparse.c:	    env->option     = option;
regparse.c:	    env->option = prev;
regparse.c:	    NENCLOSE(*np)->target = target;
regparse.c:    if (ONIG_IS_OPTION_ON(env->option, ONIG_OPTION_DONT_CAPTURE_GROUP))
regparse.c:    *np = node_new_enclose_memory(env->option, 0);
regparse.c:    NENCLOSE(*np)->regnum = num;
regparse.c:    NANCHOR(*np)->target = target;
regparse.c:    NENCLOSE(*np)->target = target;
regparse.c:    if (NENCLOSE(*np)->type == ENCLOSE_MEMORY) {
regparse.c:      r = scan_env_set_mem_node(env, NENCLOSE(*np)->regnum, *np);
regparse.c:  if (qn->lower == 1 && qn->upper == 1) {
regparse.c:      if (str_node_can_be_split(sn, env->enc)) {
regparse.c:	Node* n = str_node_split_last_char(sn, env->enc);
regparse.c:	  qn->target = n;
regparse.c:	  IS_SYNTAX_BV(env->syntax, ONIG_SYN_WARN_REDUNDANT_NESTED_REPEAT)) {
regparse.c:            onig_snprintf_with_pattern(buf, WARN_BUFSIZE, env->enc,
regparse.c:                                 env->pattern, env->pattern_end,
regparse.c:            onig_snprintf_with_pattern(buf, WARN_BUFSIZE, env->enc,
regparse.c:                                       env->pattern, env->pattern_end,
regparse.c:	  if (! IS_REPEAT_INFINITE(qn->upper) && qn->upper > 1 && qn->greedy) {
regparse.c:	    qn->upper = (qn->lower == 0 ? 1 : qn->lower);
regparse.c:  qn->target = target;
regparse.c:  if (x->type != y->type) return 1;
regparse.c:  if (x->enc  != y->enc)  return 1;
regparse.c:  if (x->not  != y->not)  return 1;
regparse.c:  p = (UChar* )&(key->enc);
regparse.c:  for (i = 0; i < (int )sizeof(key->enc); i++) {
regparse.c:  p = (UChar* )(&key->type);
regparse.c:  for (i = 0; i < (int )sizeof(key->type); i++) {
regparse.c:  val += key->not;
regparse.c:    if (IS_NOT_NULL(cc->mbuf)) xfree(cc->mbuf);
regparse.c:    bitset_invert(cc->bs);
regparse.c:      r = not_code_range_buf(enc, cc->mbuf, &tbuf);
regparse.c:      bbuf_free(cc->mbuf);
regparse.c:      cc->mbuf = tbuf;
regparse.c:  env = iarg->env;
regparse.c:  cc  = iarg->cc;
regparse.c:  bs = cc->bs;
regparse.c:    int is_in = onig_is_code_in_cc(env->enc, from, cc);
regparse.c:      if (ONIGENC_MBC_MINLEN(env->enc) > 1 || *to >= SINGLE_BYTE_SIZE) {
regparse.c:	add_code_range(&(cc->mbuf), env, *to, *to);
regparse.c:      if (ONIGENC_MBC_MINLEN(env->enc) > 1 || *to >= SINGLE_BYTE_SIZE) {
regparse.c:	if (IS_NCCLASS_NOT(cc)) clear_not_flag_cclass(cc, env->enc);
regparse.c:	add_code_range(&(cc->mbuf), env, *to, *to);
regparse.c:    if (onig_is_code_in_cc(env->enc, from, cc)
regparse.c:	len = ONIGENC_CODE_TO_MBC(env->enc, to[i], buf);
regparse.c:	  /* char-class expanded multi-char only
regparse.c:      *(iarg->ptail) = onig_node_new_alt(snode, NULL_NODE);
regparse.c:      CHECK_NULL_RETURN_MEMERR(*(iarg->ptail));
regparse.c:      iarg->ptail = &(NCDR((*(iarg->ptail))));
regparse.c:  if (tok->type == (enum TokenSyms )term)
regparse.c:  switch (tok->type) {
regparse.c:  return tok->type;
regparse.c:      OnigOptionType prev = env->option;
regparse.c:      env->option = NENCLOSE(*np)->option;
regparse.c:      env->option = prev;
regparse.c:      NENCLOSE(*np)->target = target;	
regparse.c:      return tok->type;
regparse.c:    if (! IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP))
regparse.c:    if (tok->escaped) goto tk_raw_byte;
regparse.c:      *np = node_new_str(tok->backp, *src);
regparse.c:	r = onig_node_str_cat(*np, tok->backp, *src);
regparse.c:      *np = node_new_str_raw_char((UChar )tok->u.c);
regparse.c:	if (len >= ONIGENC_MBC_MINLEN(env->enc)) {
regparse.c:	  if (len == enclen(env->enc, NSTR(*np)->s, NSTR(*np)->end)) {
regparse.c:	  if (len < ONIGENC_MBC_MINLEN(env->enc)) {
regparse.c:	    rem = ONIGENC_MBC_MINLEN(env->enc) - len;
regparse.c:	    if (len + rem == enclen(env->enc, NSTR(*np)->s)) {
regparse.c:	r = node_str_cat_char(*np, (UChar )tok->u.c);
regparse.c:      int num = ONIGENC_CODE_TO_MBC(env->enc, tok->u.code, buf);
regparse.c:      end_op[0] = (OnigCodePoint )MC_ESC(env->syntax);
regparse.c:      qend = find_str_position(end_op, 2, qstart, end, &nextp, env->enc);
regparse.c:      switch (tok->u.prop.ctype) {
regparse.c:	*np = node_new_ctype(tok->u.prop.ctype, tok->u.prop.not);
regparse.c:          r = ONIGENC_GET_CTYPE_CODE_RANGE(env->enc, tok->u.prop.ctype,
regparse.c:            key.enc  = env->enc;
regparse.c:            key.not  = tok->u.prop.not;
regparse.c:            key.type = tok->u.prop.ctype;
regparse.c:            *np = node_new_cclass_by_codepoint_range(tok->u.prop.not,
regparse.c:            add_ctype_to_cc(cc, tok->u.prop.ctype, 0, env);
regparse.c:            if (tok->u.prop.not != 0) NCCLASS_SET_NOT(cc);
regparse.c:      if (IS_IGNORECASE(env->option)) {
regparse.c:	r = ONIGENC_APPLY_ALL_CASE_FOLD(env->enc, env->case_fold_flag,
regparse.c:    NQTFR(qn)->target = *np;
regparse.c:    len = tok->u.backref.num;
regparse.c:		   (len > 1 ? tok->u.backref.refs : &(tok->u.backref.ref1)),
regparse.c:			   tok->u.backref.by_name,
regparse.c:			   tok->u.backref.exist_level,
regparse.c:			   tok->u.backref.level,
regparse.c:      int gnum = tok->u.call.gnum;
regparse.c:      *np = node_new_call(tok->u.call.name, tok->u.call.name_end, gnum);
regparse.c:      env->num_call++;
regparse.c:    *np = onig_node_new_anchor(tok->u.anchor);
regparse.c:    if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS)) {
regparse.c:      if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS))
regparse.c:      qn = node_new_quantifier(tok->u.repeat.lower, tok->u.repeat.upper,
regparse.c:      NQTFR(qn)->greedy = tok->u.repeat.greedy;
regparse.c:      if (tok->u.repeat.possessive != 0) {
regparse.c:	NENCLOSE(en)->target = qn;
regparse.c:    if (tok->type != (enum TokenSyms )term)
regparse.c:  env->option         = reg->options;
regparse.c:  env->case_fold_flag = reg->case_fold_flag;
regparse.c:  env->enc            = reg->enc;
regparse.c:  env->syntax         = reg->syntax;
regparse.c:  env->pattern        = (UChar* )pattern;
regparse.c:  env->pattern_end    = (UChar* )end;
regparse.c:  env->reg            = reg;
regparse.c:  reg->num_mem = env->num_mem;
regparse.c:  env->error     = arg;
regparse.c:  env->error_end = arg_end;
regparse.h:  regparse.h -  Oniguruma (regular expression library)
regparse.h:/*-
regparse.h: * Copyright (c) 2002-2007  K.Kosako  <sndgk393 AT ybb DOT ne DOT jp>
regparse.h:#define NTYPE(node)             ((node)->u.base.type)
regparse.h:#define SET_NTYPE(node, ntype)   (node)->u.base.type = (ntype)
regparse.h:#define NSTR(node)         (&((node)->u.str))
regparse.h:#define NCCLASS(node)      (&((node)->u.cclass))
regparse.h:#define NCTYPE(node)       (&((node)->u.ctype))
regparse.h:#define NBREF(node)        (&((node)->u.bref))
regparse.h:#define NQTFR(node)        (&((node)->u.qtfr))
regparse.h:#define NENCLOSE(node)     (&((node)->u.enclose))
regparse.h:#define NANCHOR(node)      (&((node)->u.anchor))
regparse.h:#define NCONS(node)        (&((node)->u.cons))
regparse.h:#define NCALL(node)        (&((node)->u.call))
regparse.h:#define NCAR(node)         (NCONS(node)->car)
regparse.h:#define NCDR(node)         (NCONS(node)->cdr)
regparse.h:#define NODE_STR_BUF_SIZE       24  /* sizeof(CClassNode) - sizeof(int)*4 */
regparse.h:#define NSTRING_LEN(node)             ((node)->u.str.end - (node)->u.str.s)
regparse.h:#define NSTRING_SET_RAW(node)          (node)->u.str.flag |= NSTR_RAW
regparse.h:#define NSTRING_CLEAR_RAW(node)        (node)->u.str.flag &= ~NSTR_RAW
regparse.h:#define NSTRING_SET_AMBIG(node)        (node)->u.str.flag |= NSTR_AMBIG
regparse.h:  (node)->u.str.flag |= NSTR_DONT_GET_OPT_INFO
regparse.h:#define NSTRING_IS_RAW(node)          (((node)->u.str.flag & NSTR_RAW)   != 0)
regparse.h:#define NSTRING_IS_AMBIG(node)        (((node)->u.str.flag & NSTR_AMBIG) != 0)
regparse.h:  (((node)->u.str.flag & NSTR_DONT_GET_OPT_INFO) != 0)
regparse.h:  (IS_NOT_NULL((br)->back_dynamic) ? (br)->back_dynamic : (br)->back_static);
regparse.h:#define SET_ENCLOSE_STATUS(node,f)      (node)->u.enclose.state |=  (f)
regparse.h:#define CLEAR_ENCLOSE_STATUS(node,f)    (node)->u.enclose.state &= ~(f)
regparse.h:#define IS_ENCLOSE_CALLED(en)          (((en)->state & NST_CALLED)        != 0)
regparse.h:#define IS_ENCLOSE_ADDR_FIXED(en)      (((en)->state & NST_ADDR_FIXED)    != 0)
regparse.h:#define IS_ENCLOSE_RECURSION(en)       (((en)->state & NST_RECURSION)     != 0)
regparse.h:#define IS_ENCLOSE_MARK1(en)           (((en)->state & NST_MARK1)         != 0)
regparse.h:#define IS_ENCLOSE_MARK2(en)           (((en)->state & NST_MARK2)         != 0)
regparse.h:#define IS_ENCLOSE_MIN_FIXED(en)       (((en)->state & NST_MIN_FIXED)     != 0)
regparse.h:#define IS_ENCLOSE_MAX_FIXED(en)       (((en)->state & NST_MAX_FIXED)     != 0)
regparse.h:#define IS_ENCLOSE_CLEN_FIXED(en)      (((en)->state & NST_CLEN_FIXED)    != 0)
regparse.h:    (((en)->state & NST_STOP_BT_SIMPLE_REPEAT) != 0)
regparse.h:#define IS_ENCLOSE_NAMED_GROUP(en)     (((en)->state & NST_NAMED_GROUP)   != 0)
regparse.h:#define SET_CALL_RECURSION(node)       (node)->u.call.state |= NST_RECURSION
regparse.h:#define IS_CALL_RECURSION(cn)          (((cn)->state & NST_RECURSION)  != 0)
regparse.h:#define IS_CALL_NAME_REF(cn)           (((cn)->state & NST_NAME_REF)   != 0)
regparse.h:#define IS_BACKREF_NAME_REF(bn)        (((bn)->state & NST_NAME_REF)   != 0)
regparse.h:#define IS_BACKREF_NEST_LEVEL(bn)      (((bn)->state & NST_NEST_LEVEL) != 0)
regparse.h:#define IS_QUANTIFIER_IN_REPEAT(qn)    (((qn)->state & NST_IN_REPEAT)  != 0)
regparse.h:#define IS_QUANTIFIER_BY_NUMBER(qn)    (((qn)->state & NST_BY_NUMBER)  != 0)
regparse.h:#define CALLNODE_REFNUM_UNDEF  -1
regparse.h:  int    capa;    /* (allocated size - 1) or 0: use buf[] */
regparse.h: (IS_NOT_NULL((senv)->mem_nodes_dynamic) ? \
regparse.h:    (senv)->mem_nodes_dynamic : (senv)->mem_nodes_static)
regparse.h:  regex_t*         reg;       /* for reg->names only */
regparse.h:#define IS_SYNTAX_OP(syn, opm)    (((syn)->op  & (opm)) != 0)
regparse.h:#define IS_SYNTAX_OP2(syn, opm)   (((syn)->op2 & (opm)) != 0)
regparse.h:#define IS_SYNTAX_BV(syn, bvm)    (((syn)->behavior & (bvm)) != 0)
ãã¤ããªã¼ã»ãã¡ã¤ã«regparse.oã¯ä¸è´ãã¾ãã
regsyntax.c:  regsyntax.c -  Oniguruma (regular expression library)
regsyntax.c:/*-
regsyntax.c: * Copyright (c) 2002-2006  K.Kosako  <sndgk393 AT ybb DOT ne DOT jp>
regsyntax.c:  syntax->op = op;
regsyntax.c:  syntax->op2 = op2;
regsyntax.c:  syntax->behavior = behavior;
regsyntax.c:  syntax->options = options;
regsyntax.c:  return syntax->op;
regsyntax.c:  return syntax->op2;
regsyntax.c:  return syntax->behavior;
regsyntax.c:  return syntax->options;
regsyntax.c:    enc->meta_char_table.esc = code;
regsyntax.c:    enc->meta_char_table.anychar = code;
regsyntax.c:    enc->meta_char_table.anytime = code;
regsyntax.c:    enc->meta_char_table.zero_or_one_time = code;
regsyntax.c:    enc->meta_char_table.one_or_more_time = code;
regsyntax.c:    enc->meta_char_table.anychar_anytime = code;
ãã¤ããªã¼ã»ãã¡ã¤ã«regsyntax.oã¯ä¸è´ãã¾ãã
ruby.c:  ruby.c -
ruby.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
ruby.c:  Copyright (C) 2000  Information-technology Promotion Agency, Japan
ruby.c:#define src_encoding_index GET_VM()->src_encoding_index
ruby.c:    opt->src.enc.index = src_encoding_index;
ruby.c:     * Removed -h because the user already knows that option. Others? */
ruby.c:	"-0[octal]       specify record separator (\\0, if no argument)",
ruby.c:	"-a              autosplit mode with -n or -p (splits $_ into $F)",
ruby.c:	"-c              check syntax only",
ruby.c:	"-Cdirectory     cd to directory, before executing your script",
ruby.c:	"-d              set debugging flags (set $DEBUG to true)",
ruby.c:	"-e 'command'    one line of script. Several -e's allowed. Omit [programfile]",
ruby.c:	"-Eex[:in]       specify the default external and internal character encodings",
ruby.c:	"-Fpattern       split() pattern for autosplit (-a)",
ruby.c:	"-i[extension]   edit ARGV files in place (make backup if extension supplied)",
ruby.c:	"-Idirectory     specify $LOAD_PATH directory (may be used more than once)",
ruby.c:	"-l              enable line ending processing",
ruby.c:	"-n              assume 'while gets(); ... end' loop around your script",
ruby.c:	"-p              assume loop like -n but print line also like sed",
ruby.c:	"-rlibrary       require the library, before executing your script",
ruby.c:	"-s              enable some switch parsing for switches after script name",
ruby.c:	"-S              look for the script using PATH environment variable",
ruby.c:	"-T[level]       turn on tainting checks",
ruby.c:	"-v              print version number, then turn on verbose mode",
ruby.c:	"-w              turn warnings on for your script",
ruby.c:	"-W[level]       set warning level; 0=silence, 1=medium, 2=verbose (default for level)",
ruby.c:	"-x[directory]   strip off text before #!ruby line and perhaps cd to directory",
ruby.c:	"--copyright     print the copyright",
ruby.c:	"--version       print the version",
ruby.c:    printf("Usage: %s [switches] [--] [programfile] [arguments]\n", name);
ruby.c:	    oldl = newp - oldp;
ruby.c:    ret = rb_str_new(0, l + newl - oldl);
ruby.c:    memcpy(ptr + newl, s + oldl, l - oldl);
ruby.c:    ptr[l + newl - oldl] = 0;
ruby.c:    VALUE load_path = GET_VM()->load_path;
ruby.c:	rb_ary_push(load_path, (*filter)(rubylib_mangled_path(p, s - p)));
ruby.c:	len = s - p;
ruby.c:    _execname(libpath, sizeof(libpath) - 1);
ruby.c:    libpath[sizeof(libpath) - 1] = '\0';
ruby.c:	if (p - libpath > 3 && !STRCASECMP(p - 4, "/bin")) {
ruby.c:	    p -= 4;
ruby.c:    rest = sizeof(libpath) - 1 - (p - libpath);
ruby.c:    load_path = GET_VM()->load_path;
ruby.c:    VALUE list = opt->req_list;
ruby.c:	opt->req_list = list = rb_ary_new();
ruby.c:	RBASIC(list)->klass = 0;
ruby.c:    VALUE list = opt->req_list;
ruby.c:    rb_block_t *prev_base_block = th->base_block;
ruby.c:    int prev_parse_in_eval = th->parse_in_eval;
ruby.c:    th->base_block = 0;
ruby.c:    th->parse_in_eval = 0;
ruby.c:    Init_ext();		/* should be called here for some reason :-( */
ruby.c:    opt->req_list = 0;
ruby.c:    th->parse_in_eval = prev_parse_in_eval;
ruby.c:    th->base_block = prev_base_block;
ruby.c:    if (opt->sflag) {
ruby.c:	    if (s[0] != '-')
ruby.c:	    n--;
ruby.c:	    if (s[1] == '-' && s[2] == '\0')
ruby.c:	    /* check if valid name before replacing - with _ */
ruby.c:		if (*p == '-') {
ruby.c:			rb_str_new2("invalid name for global variable - ");
ruby.c:			rb_str_cat(name_error[0], s, p - s);
ruby.c:		    name_error[1] = args[-1];
ruby.c:		    if (*p == '-')
ruby.c:	n = RARRAY_LEN(argv) - n;
ruby.c:	while (n--) {
ruby.c:    opt->sflag = 0;
ruby.c:    while ((i = proc_options(argc, argv, opt, envopt)) > 1 && (argc -= i) > 0) {
ruby.c:	if (**argv != '-') {
ruby.c:	    *--*argv = '-';
ruby.c:	    --argv;
ruby.c:    rb_warn("unknown argument for --enable: `%.*s'", len, str);
ruby.c:    rb_warn("unknown argument for --disable: `%.*s'", len, str);
ruby.c:    set_option_encoding_once("default_intenal", &opt->intern.enc.name, e, elen)
ruby.c:    set_option_encoding_once("default_extenal", &opt->ext.enc.name, e, elen)
ruby.c:    set_option_encoding_once("source", &opt->src.enc.name, e, elen)
ruby.c:    for (argc--, argv++; argc > 0; argc--, argv++) {
ruby.c:	if (arg[0] != '-' || !arg[1])
ruby.c:	    opt->do_split = Qtrue;
ruby.c:	    opt->do_print = Qtrue;
ruby.c:	    opt->do_loop = Qtrue;
ruby.c:	    opt->yydebug = 1;
ruby.c:	    if (opt->verbose) {
ruby.c:	    opt->verbose = 1;
ruby.c:		int v = 2;	/* -W as -W2 */
ruby.c:	    opt->do_check = Qtrue;
ruby.c:	    forbid_setid("-s");
ruby.c:	    opt->sflag = 1;
ruby.c:	    opt->do_line = Qtrue;
ruby.c:	    forbid_setid("-S");
ruby.c:	    opt->do_search = Qtrue;
ruby.c:	    forbid_setid("-e");
ruby.c:		argc--, argv++;
ruby.c:		rb_raise(rb_eRuntimeError, "no code specified for -e");
ruby.c:	    if (!opt->e_script) {
ruby.c:		opt->e_script = rb_str_new(0, 0);
ruby.c:		if (opt->script == 0)
ruby.c:		    opt->script = "-e";
ruby.c:	    rb_str_cat2(opt->e_script, s);
ruby.c:	    rb_str_cat2(opt->e_script, "\n");
ruby.c:	    forbid_setid("-r");
ruby.c:		argc--, argv++;
ruby.c:	    forbid_setid("-i");
ruby.c:	    opt->xflag = Qtrue;
ruby.c:		argc--, argv++;
ruby.c:	    if (!*++s && (!--argc || !(s = *++argv))) {
ruby.c:		rb_raise(rb_eRuntimeError, "missing argument for -E");
ruby.c:	    set_internal_encoding_once(opt, "UTF-8", 0);
ruby.c:		    enc_name = "EUC-JP";
ruby.c:		    enc_name = "Windows-31J";
ruby.c:		    enc_name = "UTF-8";
ruby.c:		    enc_name = "ASCII-8BIT";
ruby.c:		    opt->src.enc.name = rb_str_new2(enc_name);
ruby.c:		    if (!opt->ext.enc.name)
ruby.c:			opt->ext.enc.name = opt->src.enc.name;
ruby.c:		if (v > opt->safe_level) opt->safe_level = v;
ruby.c:	    forbid_setid("-I");
ruby.c:		argc--, argv++;
ruby.c:	  case '-':
ruby.c:		argc--, argv++;
ruby.c:	    (!(c) || (allow_hyphen && (c) == '-') || (c) == '=')
ruby.c:	     rb_raise(rb_eRuntimeError, "invalid switch in RUBYOPT: --" name))
ruby.c:	    ((*s++ ? !*s : (!--argc || !(s = *++argv))) ?		\
ruby.c:	     rb_raise(rb_eRuntimeError, "missing argument for --" name) \
ruby.c:	    (strncmp(name, s, n = sizeof(name) - 1) == 0 && is_option_end(s[n], allow_hyphen) ? \
ruby.c:		opt->copyright = 1;
ruby.c:		ruby_each_words(s, enable_option, &opt->disable);
ruby.c:		ruby_each_words(s, disable_option, &opt->disable);
ruby.c:			set_##type##_encoding_once(opt, s, p-s); \
ruby.c:			     (arg[1] == '-' ? "--encoding" : "-E"), s);
ruby.c:	    else if (is_option_with_arg("internal-encoding", Qfalse, Qtrue)) {
ruby.c:	    else if (is_option_with_arg("external-encoding", Qfalse, Qtrue)) {
ruby.c:		opt->version = 1;
ruby.c:		opt->verbose = 1;
ruby.c:		opt->yydebug = 1;
ruby.c:		ruby_each_words(s, dump_option, &opt->dump);
ruby.c:			 "invalid option --%s  (-h will show valid options)", s);
ruby.c:			"invalid option -%c  (-h will show valid options)",
ruby.c:			"invalid option -\\x%02X  (-h will show valid options)",
ruby.c:	    rb_raise(rb_eRuntimeError, "invalid switch in RUBYOPT: -%c", *s);
ruby.c:	    rb_raise(rb_eRuntimeError, "invalid switch in RUBYOPT: --%s", s);
ruby.c:    return argc0 - argc;
ruby.c:	rb_raise(rb_eRuntimeError, "unknown encoding name - %s", s);
ruby.c:	rb_raise(rb_eRuntimeError, "dummy encoding is not acceptable - %s ", s);
ruby.c:#define rb_progname (GET_VM()->progname)
ruby.c: *  call-seq:
ruby.c: *  Available only when -p/-n command line option specified.
ruby.c: *  call-seq:
ruby.c: *  Available only when -p/-n command line option specified.
ruby.c: *  call-seq:
ruby.c: *  Available only when -p/-n command line option specified.
ruby.c: *  call-seq:
ruby.c: *  Available only when -p/-n command line option specified.
ruby.c:    struct cmdline_options *opt = argp->opt;
ruby.c:    int argc = argp->argc;
ruby.c:    char **argv = argp->argv;
ruby.c:    argc -= i;
ruby.c:    if (!(opt->disable & DISABLE_BIT(rubyopt)) &&
ruby.c:	opt->safe_level == 0 && (s = getenv("RUBYOPT"))) {
ruby.c:	VALUE src_enc_name = opt->src.enc.name;
ruby.c:	VALUE ext_enc_name = opt->ext.enc.name;
ruby.c:	VALUE int_enc_name = opt->intern.enc.name;
ruby.c:	opt->src.enc.name = opt->ext.enc.name = opt->intern.enc.name = 0;
ruby.c:	    opt->src.enc.name = src_enc_name;
ruby.c:	    opt->ext.enc.name = ext_enc_name;
ruby.c:	    opt->intern.enc.name = int_enc_name;
ruby.c:    if (opt->version) {
ruby.c:    if (opt->copyright) {
ruby.c:    if (opt->safe_level >= 4) {
ruby.c:	OBJ_TAINT(GET_VM()->load_path);
ruby.c:    if (!opt->e_script) {
ruby.c:	    if (opt->verbose)
ruby.c:	    opt->script = "-";
ruby.c:	    opt->script = argv[0];
ruby.c:	    if (opt->script[0] == '\0') {
ruby.c:		opt->script = "-";
ruby.c:	    else if (opt->do_search) {
ruby.c:		opt->script = 0;
ruby.c:		    opt->script = dln_find_file_r(argv[0], path, fbuf, sizeof(fbuf));
ruby.c:		if (!opt->script) {
ruby.c:		    opt->script = dln_find_file_r(argv[0], getenv(PATH_ENV), fbuf, sizeof(fbuf));
ruby.c:		if (!opt->script)
ruby.c:		    opt->script = argv[0];
ruby.c:	    argc--;
ruby.c:    opt->script_name = rb_str_new_cstr(opt->script);
ruby.c:    opt->script = RSTRING_PTR(opt->script_name);
ruby.c:    translate_char(RSTRING_PTR(opt->script_name), '\\', '/');
ruby.c:    rb_obj_freeze(opt->script_name);
ruby.c:    ruby_init_loadpath_safe(opt->safe_level);
ruby.c:    if (opt->yydebug) rb_parser_set_yydebug(parser, Qtrue);
ruby.c:    if (opt->ext.enc.name != 0) {
ruby.c:	opt->ext.enc.index = opt_enc_index(opt->ext.enc.name);
ruby.c:    if (opt->intern.enc.name != 0) {
ruby.c:	opt->intern.enc.index = opt_enc_index(opt->intern.enc.name);
ruby.c:    if (opt->src.enc.name != 0) {
ruby.c:	opt->src.enc.index = opt_enc_index(opt->src.enc.name);
ruby.c:	src_encoding_index = opt->src.enc.index;
ruby.c:    if (opt->ext.enc.index >= 0) {
ruby.c:	enc = rb_enc_from_index(opt->ext.enc.index);
ruby.c:    if (opt->intern.enc.index >= 0) {
ruby.c:	enc = rb_enc_from_index(opt->intern.enc.index);
ruby.c:	opt->intern.enc.index = -1;
ruby.c:    rb_enc_associate(opt->script_name, lenc);
ruby.c:	VALUE load_path = GET_VM()->load_path;
ruby.c:    ruby_init_gems(!(opt->disable & DISABLE_BIT(gems)));
ruby.c:	GetEnvPtr(bind->env, env);
ruby.c:    th->parse_in_eval--; \
ruby.c:    th->base_block = &env->block; \
ruby.c:    th->parse_in_eval++; \
ruby.c:    th->base_block = 0; \
ruby.c:    if (opt->e_script) {
ruby.c:	if (opt->src.enc.index >= 0) {
ruby.c:	    eenc = rb_enc_from_index(opt->src.enc.index);
ruby.c:	rb_enc_associate(opt->e_script, eenc);
ruby.c:	    tree = rb_parser_compile_string(parser, opt->script, opt->e_script, 1);
ruby.c:	if (opt->script[0] == '-' && !opt->script[1]) {
ruby.c:	    tree = load_file(parser, opt->script, 1, opt);
ruby.c:    if (opt->ext.enc.index >= 0) {
ruby.c:	enc = rb_enc_from_index(opt->ext.enc.index);
ruby.c:    if (opt->intern.enc.index >= 0) {
ruby.c:	enc = rb_enc_from_index(opt->intern.enc.index);
ruby.c:    opt->xflag = 0;
ruby.c:    if (opt->safe_level >= 4) {
ruby.c:	FL_UNSET(GET_VM()->load_path, FL_TAINT);
ruby.c:    if (opt->do_check) {
ruby.c:    if (opt->do_print) {
ruby.c:    if (opt->do_loop) {
ruby.c:	    tree = rb_parser_while_loop(parser, tree, opt->do_line, opt->do_split);
ruby.c:	rb_define_global_function("sub", rb_f_sub, -1);
ruby.c:	rb_define_global_function("gsub", rb_f_gsub, -1);
ruby.c:	rb_define_global_function("chomp", rb_f_chomp, -1);
ruby.c:	iseq = rb_iseq_new_main(tree, opt->script_name);
ruby.c:    if (opt->dump & DUMP_BIT(insns)) {
ruby.c:    rb_set_safe_level(opt->safe_level);
ruby.c:    rb_progname = opt->script_name;
ruby.c:    VALUE parser = argp->parser;
ruby.c:    const char *fname = argp->fname;
ruby.c:    int script = argp->script;
ruby.c:    struct cmdline_options *opt = argp->opt;
ruby.c:    if (strcmp(fname, "-") == 0) {
ruby.c:	int no_src_enc = !opt->src.enc.name;
ruby.c:	int no_ext_enc = !opt->ext.enc.name;
ruby.c:	int no_int_enc = !opt->intern.enc.name;
ruby.c:	if (opt->xflag) {
ruby.c:	    forbid_setid("-x");
ruby.c:	    opt->xflag = Qfalse;
ruby.c:		    if (pend[-1] == '\n')
ruby.c:			pend--;	/* chomp line */
ruby.c:		    if (pend[-1] == '\r')
ruby.c:			pend--;
ruby.c:		RSTRING_PTR(line)[RSTRING_LEN(line) - 1] = '\0';
ruby.c:		if (RSTRING_PTR(line)[RSTRING_LEN(line) - 2] == '\r')
ruby.c:		    RSTRING_PTR(line)[RSTRING_LEN(line) - 2] = '\0';
ruby.c:		if ((p = strstr(p, " -")) != 0) {
ruby.c:	    if (no_src_enc && opt->src.enc.name) {
ruby.c:		opt->src.enc.index = opt_enc_index(opt->src.enc.name);
ruby.c:		src_encoding_index = opt->src.enc.index;
ruby.c:	    if (no_ext_enc && opt->ext.enc.name) {
ruby.c:		opt->ext.enc.index = opt_enc_index(opt->ext.enc.name);
ruby.c:	    if (no_int_enc && opt->intern.enc.name) {
ruby.c:		opt->intern.enc.index = opt_enc_index(opt->intern.enc.name);
ruby.c:    if (opt->src.enc.index >= 0) {
ruby.c:	enc = rb_enc_from_index(opt->src.enc.index);
ruby.c:    rb_funcall(f, set_encoding, 2, rb_enc_from_encoding(enc), rb_str_new_cstr("-"));
ruby.c:    return s - argv[0];
ruby.c:	char buf[PST_CLEN + 1];	/* PST_CLEN is 64 (HP-UX 11.23) */
ruby.c:	if (i + 1 < origarg.len) memset(t + 1, ' ', origarg.len - i - 1);
ruby.c:    if (uid != euid) opt->setids |= 1;
ruby.c:    if (egid != gid) opt->setids |= 2;
ruby.c:    if (uid && opt->setids) {
ruby.c:	if (opt->safe_level < 1) opt->safe_level = 1;
ruby.c:    if (opt->setids & 1)
ruby.c:    if (opt->setids & 2)
ruby.c:    if (opt->safe_level > 0)
ruby.c:    rb_define_hooked_variable("$-v", &ruby_verbose, 0, verbose_setter);
ruby.c:    rb_define_hooked_variable("$-w", &ruby_verbose, 0, verbose_setter);
ruby.c:    rb_define_hooked_variable("$-W", &ruby_verbose, opt_W_getter, rb_gvar_readonly_setter);
ruby.c:    rb_define_variable("$-d", &ruby_debug);
ruby.c:    opt.ext.enc.index = -1;
ruby.c:    opt.intern.enc.index = -1;
ruby.c:    rb_define_readonly_boolean("$-p", opt.do_print);
ruby.c:    rb_define_readonly_boolean("$-l", opt.do_line);
ruby.c:    rb_define_readonly_boolean("$-a", opt.do_split);
ãã¤ããªã¼ã»ãã¡ã¤ã«ruby.oã¯ä¸è´ãã¾ãã
runruby.rb:  break ARGV.shift if arg == '--'
runruby.rb:  /\A--([-\w]+)(?:=(.*))?\z/ =~ arg or break
runruby.rb:    debugger = value ? (value.split unless value == "no") : %w"gdb --args"
runruby.rb:  libs << File.expand_path("ext", srcdir) << "-"
runruby.rb:cmd << "-rpurelib.rb" if pure
safe.c:  eval.c -
safe.c:/* safe-level:
safe.c:   0 - strings from streams/environment/ARGV are tainted (default)
safe.c:   1 - no dangerous operation by tainted value
safe.c:   2 - process/file operations prohibited
safe.c:   3 - all generated objects are tainted
safe.c:   4 - no global (non-tainted) variable modification/no direct output
safe.c:    return GET_THREAD()->safe_level;
safe.c:    GET_THREAD()->safe_level = safe;
safe.c:    if (level > th->safe_level) {
safe.c:	th->safe_level = level;
safe.c:    if (level < th->safe_level) {
safe.c:		 th->safe_level, level);
safe.c:    th->safe_level = level;
safe.c:	    rb_raise(rb_eSecurityError, "Insecure operation - %s",
safe.c:	    rb_raise(rb_eSecurityError, "Insecure operation: -r");
ãã¤ããªã¼ã»ãã¡ã¤ã«safe.oã¯ä¸è´ãã¾ãã
signal.c:  signal.c -
signal.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
signal.c:  Copyright (C) 2000  Information-technology Promotion Agency, Japan
signal.c:# define ATOMIC_DEC(var) (--(var))
signal.c:    for (sigs = siglist; sigs->signm; sigs++)
signal.c:	if (strcmp(sigs->signm, nm) == 0)
signal.c:	    return sigs->signo;
signal.c:    for (sigs = siglist; sigs->signm; sigs++)
signal.c:	if (sigs->signo == no)
signal.c:	    return sigs->signm;
signal.c: * call-seq:
signal.c: * call-seq:
signal.c: *  call-seq:
signal.c:#define killpg(pg, sig) kill(-(pg), sig)
signal.c:	rb_raise(rb_eArgError, "wrong number of arguments -- kill(sig, pid...)");
signal.c:	if (s[0] == '-') {
signal.c:	    sig = -sig;
signal.c:	sig = -sig;
signal.c:    return INT2FIX(i-1);
signal.c:    if (ruby_stack_overflowed_p(th, info->si_addr)) {
signal.c:    VALUE trap_exit = vm->trap_list[0].cmd;
signal.c:	vm->trap_list[0].cmd = 0;
signal.c:	signal_exec(trap_exit, vm->trap_list[0].safe, 0);
signal.c:    VALUE cmd = vm->trap_list[sig].cmd;
signal.c:    int safe = vm->trap_list[sig].safe;
signal.c:    int sig = -1;
signal.c:    sighandler_t oldfunc, func = arg->func;
signal.c:    VALUE oldcmd, command = arg->cmd;
signal.c:    int sig = arg->sig;
signal.c:    oldcmd = vm->trap_list[sig].cmd;
signal.c:    vm->trap_list[sig].cmd = command;
signal.c:    vm->trap_list[sig].safe = rb_safe_level();
signal.c:    sigdelset(&arg->mask, sig);
signal.c:    arg->mask &= ~sigmask(sig);
signal.c:    sigprocmask(SIG_SETMASK, &arg->mask, NULL);
signal.c:    sigsetmask(arg->mask);
signal.c:    trap_last_mask = arg->mask;
signal.c: * call-seq:
signal.c:	rb_raise(rb_eArgError, "wrong number of arguments -- trap(sig, cmd)/trap(sig){...}");
signal.c: * call-seq:
signal.c:    for (sigs = siglist; sigs->signm; sigs++) {
signal.c:	rb_hash_aset(h, rb_str_new2(sigs->signm), INT2FIX(sigs->signo));
signal.c:	GET_VM()->trap_list[sig].cmd = 0;
signal.c:    rb_define_global_function("trap", sig_trap, -1);
signal.c:    rb_define_module_function(mSignal, "trap", sig_trap, -1);
signal.c:    rb_define_method(rb_eSignal, "initialize", esignal_init, -1);
signal.c:    rb_define_method(rb_eInterrupt, "initialize", interrupt_init, -1);
ãã¤ããªã¼ã»ãã¡ã¤ã«signal.oã¯ä¸è´ãã¾ãã
sprintf.c:  sprintf.c -
sprintf.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
sprintf.c:  Copyright (C) 2000  Information-technology Promotion Agency, Japan
sprintf.c:    posarg == -1 ? \
sprintf.c:    posarg == -2 ? \
sprintf.c:    posarg == -2 ? \
sprintf.c:    ((n < 1) ? (rb_raise(rb_eArgError, "invalid index - %d$", n), 0) : \
sprintf.c:	       (posarg = -1, GETNTHARG(n))))
sprintf.c:    posarg == -1 ? \
sprintf.c:	int next_n = 10 * n + (*p - '0'); \
sprintf.c:	rb_raise(rb_eArgError, "malformed format string - %%*[0-9]"); \
sprintf.c: *  call-seq:
sprintf.c: *      ------+--------------------------------------------------------------
sprintf.c: *      ------+--------------------------------------------------------------
sprintf.c: *            | with one digit before the decimal point as [-]d.dddddde[+-]dd.
sprintf.c: *        f   | Convert floating point argument as [-]ddd.dddddd, 
sprintf.c: *            | if the exponent is less than -4 or greater than or
sprintf.c: *      ------+--------------------------------------------------------------
sprintf.c: *    ---------+---------------+-----------------------------------------
sprintf.c: *             | eEfgG         | non-negative numbers.
sprintf.c: *    ---------+---------------+-----------------------------------------
sprintf.c: *    ---------+---------------+-----------------------------------------
sprintf.c: *             |               | on non-zero, prefix the result with ``0x'',
sprintf.c: *    ---------+---------------+-----------------------------------------
sprintf.c: *    +        | bBdiouxX      | Add a leading plus sign to non-negative
sprintf.c: *    ---------+---------------+-----------------------------------------
sprintf.c: *    -        | all           | Left-justify the result of this conversion.
sprintf.c: *    ---------+---------------+-----------------------------------------
sprintf.c: *             | eEfgG         | For `o', `x', `X', `b' and `B', radix-1
sprintf.c: *    ---------+---------------+-----------------------------------------
sprintf.c: *             |               | If negative, left-justify the result. If the
sprintf.c: *   # `+' and space flag specifies the sign of non-negative numbers.
sprintf.c: *   sprintf("%+o", -123) #=> "-173"
sprintf.c: *   sprintf("%o", -123)  #=> "..7605"
sprintf.c: *   sprintf("%#o", -123) #=> "..7605"
sprintf.c: *   # `#' flag for `x' add a prefix `0x' for non-zero numbers.
sprintf.c: *   sprintf("%+x", -123) #=> "-7b"
sprintf.c: *   sprintf("%x", -123)  #=> "..f85"
sprintf.c: *   sprintf("%#x", -123) #=> "0x..f85"
sprintf.c: *   # `#' flag for `b' add a prefix `0b' for non-zero numbers.
sprintf.c: *   sprintf("%+b", -123) #=> "-1111011"
sprintf.c: *   sprintf("%b", -123)  #=> "..10000101"
sprintf.c: *   sprintf("%#b", -123) #=> "0b..10000101"
sprintf.c: *   # 0 or radix-1.             <------------------>
sprintf.c: *   sprintf("%-20d", 123)  #=> "123                 "
sprintf.c: *   sprintf("%-+20d", 123) #=> "+123                "
sprintf.c: *   sprintf("%- 20d", 123) #=> " 123                "
sprintf.c: *   sprintf("%020x", -123) #=> "..ffffffffffffffff85"
sprintf.c: *   # minimum number of digits               <------>
sprintf.c: *   sprintf("%20.8d", -123) #=> "           -00000123"
sprintf.c: *   sprintf("%20.8o", -123) #=> "            ..777605"
sprintf.c: *   sprintf("%20.8x", -123) #=> "            ..ffff85"
sprintf.c: *   sprintf("%20.8b", -11)  #=> "            ..110101"
sprintf.c: *   # precision but "0" for `#o' is counted.  <------>
sprintf.c: *   sprintf("%#20.8d", -123) #=> "           -00000123"
sprintf.c: *   sprintf("%#20.8o", -123) #=> "            ..777605"
sprintf.c: *   sprintf("%#20.8x", -123) #=> "          0x..ffff85"
sprintf.c: *   sprintf("%#20.8b", -11)  #=> "          0b..110101"
sprintf.c: *   # digits after the decimal point           <------>
sprintf.c: *   # digits after the decimal point               <------>
sprintf.c: *   # significant digits                          <------->
sprintf.c: *   #                                         <------->
sprintf.c: *   # maximum number of characters                    <------>
sprintf.c: *     sprintf("%1$*2$s %2$d", "hello", -8)       #=> "hello    -8"
sprintf.c: *     sprintf("%+g:% g:%-g", 1.23, 1.23, 1.23)   #=> "+1.23: 1.23:1.23"
sprintf.c: *     sprintf("%u", -123)                        #=> "-123"
sprintf.c:    return rb_str_format(argc - 1, argv + 1, GETNTHARG(0));
sprintf.c:    --argv;
sprintf.c:	PUSH(p, t - p);
sprintf.c:	width = prec = -1;
sprintf.c:		rb_raise(rb_eArgError, "malformed format string - %%%c", *p);
sprintf.c:	  case '-':
sprintf.c:		    rb_raise(rb_eArgError, "value given twice - %d$", n);
sprintf.c:		    rb_raise(rb_eArgError, "malformed name - unmatched parenthesis");
sprintf.c:		id = rb_intern3(start + 1, p - start - 1, enc);
sprintf.c:		width = -width;
sprintf.c:	    p--;
sprintf.c:		rb_raise(rb_eArgError, "invalid format character - %%");
sprintf.c:		    FILL(' ', width-1);
sprintf.c:		    FILL(' ', width-1);
sprintf.c:			len = p - RSTRING_PTR(str);
sprintf.c:		    /* need to adjust multi-byte string pos */
sprintf.c:			width -= slen;
sprintf.c:			    while (width--) {
sprintf.c:			    while (width--) {
sprintf.c:			    v = -v;
sprintf.c:			    sc = '-';
sprintf.c:			    width--;
sprintf.c:			    width--;
sprintf.c:			    width--;
sprintf.c:			snprintf(++s, sizeof(nbuf) - 1, fbuf, v);
sprintf.c:				*--s = d;
sprintf.c:			if (s[0] == '-') {
sprintf.c:			    sc = '-';
sprintf.c:			    width--;
sprintf.c:			    width--;
sprintf.c:			    width--;
sprintf.c:			if (*s == '-') {
sprintf.c:				if (s[0] != 'f') *--s = 'f'; break;
sprintf.c:				if (s[0] != '7') *--s = '7'; break;
sprintf.c:				if (s[0] != '1') *--s = '1'; break;
sprintf.c:		pos = -1;
sprintf.c:		    prec -= 2;
sprintf.c:		    width -= 2;
sprintf.c:			if (flags & FPREC) prec--;
sprintf.c:		    width -= strlen(prefix);
sprintf.c:		    width -= prec;
sprintf.c:		    while (width-- > 0) {
sprintf.c:		CHECK(prec - len);
sprintf.c:		    while (len < prec--) {
sprintf.c:		    while (len < prec--) {
sprintf.c:		while (width-- > 0) {
sprintf.c:			    buf[blen++] = '-';
sprintf.c:			    buf[blen + need - strlen(expr) - 1] = '-';
sprintf.c:			    buf[blen + need - strlen(expr) - 1] = '+';
sprintf.c:			strncpy(&buf[blen + need - strlen(expr)], expr,
sprintf.c:    /* XXX - We cannot validate the number of arguments if (digit)$ style used.
sprintf.c:    if (flags & FMINUS) *buf++ = '-';
sprintf.c:	snprintf(buf, end - buf, "%d", width);
sprintf.c:	snprintf(buf, end - buf, ".%d", prec);
sprintf.c:    VALUE result = (VALUE)fp->_bf._base;
sprintf.c:    char *buf = (char*)fp->_p;
sprintf.c:    size_t blen = buf - RSTRING_PTR(result), bsiz = fp->_w;
sprintf.c:    if (RBASIC(result)->klass) {
sprintf.c:    if ((len = uio->uio_resid) == 0)
sprintf.c:    fp->_w = bsiz;
sprintf.c:    for (iov = uio->uio_iov; len > 0; ++iov) {
sprintf.c:	MEMCPY(buf, iov->iov_base, char, n = iov->iov_len);
sprintf.c:	len -= n;
sprintf.c:    fp->_p = (unsigned char *)buf;
sprintf.c:    RBASIC(result)->klass = 0;
sprintf.c:    RBASIC(result)->klass = rb_cString;
sprintf.c:    rb_str_resize(result, (char *)f._p - RSTRING_PTR(result));
sprintf.c:    klass = RBASIC(str)->klass;
sprintf.c:    RBASIC(str)->klass = 0;
sprintf.c:    RBASIC(str)->klass = klass;
sprintf.c:    rb_str_resize(str, (char *)f._p - RSTRING_PTR(str));
ãã¤ããªã¼ã»ãã¡ã¤ã«sprintf.oã¯ä¸è´ãã¾ãã
st.c:#define EQUAL(table,x,y) ((x)==(y) || (*table->type->compare)((x),(y)) == 0)
st.c:#define do_hash(key,table) (unsigned int)(*(table)->type->hash)((key))
st.c:#define do_hash_bin(key,table) (do_hash(key, table)%(table)->num_bins)
st.c:    return -1;
st.c:    return -1;			/* should raise exception */
st.c:    tbl->type = type;
st.c:    tbl->num_entries = 0;
st.c:    tbl->entries_packed = type == &type_numhash && size/2 <= MAX_PACKED_NUMHASH;
st.c:    tbl->num_bins = size;
st.c:    tbl->bins = (st_table_entry **)Calloc(size, sizeof(st_table_entry*));
st.c:    tbl->head = 0;
st.c:    tbl->tail = 0;
st.c:    if (table->entries_packed) {
st.c:        table->num_entries = 0;
st.c:    for(i = 0; i < table->num_bins; i++) {
st.c:	ptr = table->bins[i];
st.c:	table->bins[i] = 0;
st.c:	    next = ptr->next;
st.c:    table->num_entries = 0;
st.c:    table->head = 0;
st.c:    table->tail = 0;
st.c:    free(table->bins);
st.c:((ptr) != 0 && (ptr->hash != (hash_val) || !EQUAL((table), (key), (ptr)->key)))
st.c:    bin_pos = hash_val%(table)->num_bins;\
st.c:    ptr = (table)->bins[bin_pos];\
st.c:	while (PTR_NOT_EQUAL(table, ptr->next, hash_val, key)) {\
st.c:	    ptr = ptr->next;\
st.c:	ptr = ptr->next;\
st.c:    if (table->entries_packed) {
st.c:        for (i = 0; i < table->num_entries; i++) {
st.c:            if ((st_data_t)table->bins[i*2] == key) {
st.c:                if (value !=0) *value = (st_data_t)table->bins[i*2+1];
st.c:	if (value != 0)  *value = ptr->record;
st.c:    if (table->entries_packed) {
st.c:        for (i = 0; i < table->num_entries; i++) {
st.c:            if ((st_data_t)table->bins[i*2] == key) {
st.c:                if (result !=0) *result = (st_data_t)table->bins[i*2];
st.c:	if (result != 0)  *result = ptr->key;
st.c:    if (table->num_entries/(table->num_bins) > ST_DEFAULT_MAX_DENSITY) {\
st.c:        bin_pos = hash_val % table->num_bins;\
st.c:    entry->hash = hash_val;\
st.c:    entry->key = key;\
st.c:    entry->record = value;\
st.c:    entry->next = table->bins[bin_pos];\
st.c:    if (table->head != 0) {\
st.c:	entry->fore = 0;\
st.c:	(entry->back = table->tail)->fore = entry;\
st.c:	table->tail = entry;\
st.c:	table->head = table->tail = entry;\
st.c:	entry->fore = entry->back = 0;\
st.c:    table->bins[bin_pos] = entry;\
st.c:    table->num_entries++;\
st.c:    int num_entries = table->num_entries;
st.c:    memcpy(packed_bins, table->bins, sizeof(struct st_table_entry *) * num_entries*2);
st.c:    table->entries_packed = 0;
st.c:    table->num_entries = 0;
st.c:    memset(table->bins, 0, sizeof(struct st_table_entry *) * table->num_bins);
st.c:    if (table->entries_packed) {
st.c:        for (i = 0; i < table->num_entries; i++) {
st.c:            if ((st_data_t)table->bins[i*2] == key) {
st.c:                table->bins[i*2+1] = (struct st_table_entry*)value;
st.c:        if ((table->num_entries+1) * 2 <= table->num_bins && table->num_entries+1 <= MAX_PACKED_NUMHASH) {
st.c:            i = table->num_entries++;
st.c:            table->bins[i*2] = (struct st_table_entry*)key;
st.c:            table->bins[i*2+1] = (struct st_table_entry*)value;
st.c:	ptr->record = value;
st.c:    if (table->entries_packed) {
st.c:        if ((table->num_entries+1) * 2 <= table->num_bins && table->num_entries+1 <= MAX_PACKED_NUMHASH) {
st.c:            i = table->num_entries++;
st.c:            table->bins[i*2] = (struct st_table_entry*)key;
st.c:            table->bins[i*2+1] = (struct st_table_entry*)value;
st.c:    bin_pos = hash_val % table->num_bins;
st.c:    new_num_bins = new_size(table->num_bins+1);
st.c:	xrealloc(table->bins, new_num_bins * sizeof(st_table_entry*));
st.c:    table->num_bins = new_num_bins;
st.c:    table->bins = new_bins;
st.c:    if ((ptr = table->head) != 0) {
st.c:	    hash_val = ptr->hash % new_num_bins;
st.c:	    ptr->next = new_bins[hash_val];
st.c:	} while ((ptr = ptr->fore) != 0);
st.c:    int num_bins = old_table->num_bins;
st.c:    new_table->bins = (st_table_entry**)
st.c:    if (new_table->bins == 0) {
st.c:    if (old_table->entries_packed) {
st.c:        memcpy(new_table->bins, old_table->bins, sizeof(struct st_table_entry *) * old_table->num_bins);
st.c:    if ((ptr = old_table->head) != 0) {
st.c:	tail = &new_table->head;
st.c:	    hash_val = entry->hash % num_bins;
st.c:	    entry->next = new_table->bins[hash_val];
st.c:	    new_table->bins[hash_val] = entry;
st.c:	    entry->back = prev;
st.c:	    tail = &entry->fore;
st.c:	} while ((ptr = ptr->fore) != 0);
st.c:	new_table->tail = prev;
st.c:	if (ptr->fore == 0 && ptr->back == 0) {				\
st.c:	    table->head = 0;						\
st.c:	    table->tail = 0;						\
st.c:	    st_table_entry *fore = ptr->fore, *back = ptr->back;	\
st.c:	    if (fore) fore->back = back;				\
st.c:	    if (back) back->fore = fore;				\
st.c:	    if (ptr == table->head) table->head = fore;			\
st.c:	    if (ptr == table->tail) table->tail = back;			\
st.c:	table->num_entries--;						\
st.c:    if (table->entries_packed) {
st.c:        for (i = 0; i < table->num_entries; i++) {
st.c:            if ((st_data_t)table->bins[i*2] == *key) {
st.c:                if (value != 0) *value = (st_data_t)table->bins[i*2+1];
st.c:                table->num_entries--;
st.c:                memmove(&table->bins[i*2], &table->bins[(i+1)*2],
st.c:                        sizeof(struct st_table_entry*) * 2*(table->num_entries-i));
st.c:    for (prev = &table->bins[hash_val]; (ptr = *prev) != 0; prev = &ptr->next) {
st.c:	if (EQUAL(table, *key, ptr->key)) {
st.c:	    *prev = ptr->next;
st.c:	    if (value != 0) *value = ptr->record;
st.c:	    *key = ptr->key;
st.c:    ptr = table->bins[hash_val];
st.c:    for (; ptr != 0; ptr = ptr->next) {
st.c:	if ((ptr->key != never) && EQUAL(table, ptr->key, *key)) {
st.c:	    *key = ptr->key;
st.c:	    if (value != 0) *value = ptr->record;
st.c:	    ptr->key = ptr->record = never;
st.c:    for (i = 0; i < table->num_bins; i++) {
st.c:	ptr = *(last = &table->bins[i]);
st.c:	    if (ptr->key == never) {
st.c:		*last = ptr = ptr->next;
st.c:		ptr = *(last = &ptr->next);
st.c:    if (table->entries_packed) {
st.c:        for (i = 0; i < table->num_entries; i++) {
st.c:            key = (st_data_t)table->bins[i*2];
st.c:            val = (st_data_t)table->bins[i*2+1];
st.c:                for (j = 0; j < table->num_entries; j++) {
st.c:                    if ((st_data_t)table->bins[j*2] == key)
st.c:                if (j == table->num_entries) {
st.c:                table->num_entries--;
st.c:                memmove(&table->bins[i*2], &table->bins[(i+1)*2],
st.c:                        sizeof(struct st_table_entry*) * 2*(table->num_entries-i));
st.c:                i--;
st.c:    if ((ptr = table->head) != 0) {
st.c:	    retval = (*func)(ptr->key, ptr->record, arg);
st.c:		i = ptr->hash % table->num_bins;
st.c:		for (tmp = table->bins[i]; tmp != ptr; tmp = tmp->next) {
st.c:		ptr = ptr->fore;
st.c:		last = &table->bins[ptr->hash % table->num_bins];
st.c:		for (; (tmp = *last) != 0; last = &tmp->next) {
st.c:			tmp = ptr->fore;
st.c:			*last = ptr->next;
st.c:	} while (ptr && table->head);
st.c:    if (table->entries_packed) {
st.c:        for (i = table->num_entries-1; 0 <= i; i--) {
st.c:            key = (st_data_t)table->bins[i*2];
st.c:            val = (st_data_t)table->bins[i*2+1];
st.c:                for (j = 0; j < table->num_entries; j++) {
st.c:                    if ((st_data_t)table->bins[j*2] == key)
st.c:                if (j == table->num_entries) {
st.c:                table->num_entries--;
st.c:                memmove(&table->bins[i*2], &table->bins[(i+1)*2],
st.c:                        sizeof(struct st_table_entry*) * 2*(table->num_entries-i));
st.c:    if ((ptr = table->head) != 0) {
st.c:	ptr = ptr->back;
st.c:	    retval = (*func)(ptr->key, ptr->record, arg, 0);
st.c:		i = ptr->hash % table->num_bins;
st.c:		for (tmp = table->bins[i]; tmp != ptr; tmp = tmp->next) {
st.c:		ptr = ptr->back;
st.c:		last = &table->bins[ptr->hash % table->num_bins];
st.c:		for (; (tmp = *last) != 0; last = &tmp->next) {
st.c:			tmp = ptr->back;
st.c:			*last = ptr->next;
st.c:		ptr = ptr->next;
st.c:		table->num_entries--;
st.c:	} while (ptr && table->head);
st.c: * hash_32 - 32 bit Fowler/Noll/Vo FNV-1a hash code
st.c: * To use the recommended 32 bit FNV-1a hash, pass FNV1_32A_INIT as the
st.c: * Share and Enjoy!	:-)
st.c: * 32 bit FNV-1 and FNV-1a non-zero initial basis
st.c: * The FNV-1 initial basis is the FNV-0 hash of the following 32 octets:
st.c: * NOTE: The \'s above are not back-slashing escape characters.
st.c: * NOTE: The FNV-1a initial basis is the same value as FNV-1 by definition.
st.c: * 32 bit magic FNV-1a prime
st.c:     * FNV-1a hash each octet in the buffer
st.c:            if (c2 != '\0') return -1;
st.c:        if ((unsigned int)(c1 - 'A') <= ('Z' - 'A')) c1 += 'a' - 'A';
st.c:        if ((unsigned int)(c2 - 'A') <= ('Z' - 'A')) c2 += 'a' - 'A';
st.c:                return -1;
st.c:    while (n--) {
st.c:            if (c2 != '\0') return -1;
st.c:        if ((unsigned int)(c1 - 'A') <= ('Z' - 'A')) c1 += 'a' - 'A';
st.c:        if ((unsigned int)(c2 - 'A') <= ('Z' - 'A')) c2 += 'a' - 'A';
st.c:                return -1;
st.c:     * FNV-1a hash each octet in the buffer
st.c:	if ((unsigned int)(c - 'A') <= ('Z' - 'A')) c += 'a' - 'A';
ãã¤ããªã¼ã»ãã¡ã¤ã«st.oã¯ä¸è´ãã¾ãã
strftime.c:/* -*- c-file-style: "linux" -*- */
strftime.c: * Public-domain implementation of ANSI C library routine.
strftime.c: * It's written in old-style C for maximal portability.
strftime.c: * It also doesn't worry about multi-byte characters.
strftime.c:/* min --- return minimum of two numbers */
strftime.c:/* max --- return maximum of two numbers */
strftime.c:/* strftime --- produce formatted time */
strftime.c:	for (; *format && s < endp - 1; format++) {
strftime.c:#define NEEDS(n) do if (s + (n) >= endp - 1) goto err; while (0)
strftime.c:		memset(s, padding ? padding : ' ', precision - i); \
strftime.c:		s += precision - i; \
strftime.c:			l = snprintf(s, endp - s, \
strftime.c:			i = rb_strftime(s, endp - s, fmt, timeptr, ts, gmt); \
strftime.c:				memmove(s + precision - i, s, i);\
strftime.c:				memset(s, padding ? padding : ' ', precision - i); \
strftime.c:		precision = -1;
strftime.c:			format--;
strftime.c:			if (timeptr->tm_wday < 0 || timeptr->tm_wday > 6)
strftime.c:				i = 3, tp = days_l[timeptr->tm_wday];
strftime.c:			if (timeptr->tm_wday < 0 || timeptr->tm_wday > 6)
strftime.c:				i = strlen(tp = days_l[timeptr->tm_wday]);
strftime.c:			if (timeptr->tm_mon < 0 || timeptr->tm_mon > 11)
strftime.c:				i = 3, tp = months_l[timeptr->tm_mon];
strftime.c:			if (timeptr->tm_mon < 0 || timeptr->tm_mon > 11)
strftime.c:				i = strlen(tp = months_l[timeptr->tm_mon]);
strftime.c:		case 'd':	/* day of the month, 01 - 31 */
strftime.c:			i = range(1, timeptr->tm_mday, 31);
strftime.c:		case 'H':	/* hour, 24-hour clock, 00 - 23 */
strftime.c:			i = range(0, timeptr->tm_hour, 23);
strftime.c:		case 'I':	/* hour, 12-hour clock, 01 - 12 */
strftime.c:			i = range(0, timeptr->tm_hour, 23);
strftime.c:				i -= 12;
strftime.c:		case 'j':	/* day of the year, 001 - 366 */
strftime.c:			FMT('0', 3, "d", timeptr->tm_yday + 1);
strftime.c:		case 'm':	/* month, 01 - 12 */
strftime.c:			i = range(0, timeptr->tm_mon, 11);
strftime.c:		case 'M':	/* minute, 00 - 59 */
strftime.c:			i = range(0, timeptr->tm_min, 59);
strftime.c:		case 'p':	/* AM or PM based on 12-hour clock */
strftime.c:		case 'P':	/* am or pm based on 12-hour clock */
strftime.c:			i = range(0, timeptr->tm_hour, 23);
strftime.c:			FMT('0', 1, "d", (int) ts->tv_sec);
strftime.c:		case 'S':	/* second, 00 - 60 */
strftime.c:			i = range(0, timeptr->tm_sec, 60);
strftime.c:		case 'w':	/* weekday, Sunday == 0, 0 - 6 */
strftime.c:			i = range(0, timeptr->tm_wday, 6);
strftime.c:		case 'y':	/* year without a century, 00 - 99 */
strftime.c:			i = timeptr->tm_year % 100;
strftime.c:			FMT('0', 1, "ld", 1900L + timeptr->tm_year);
strftime.c:		 * Date: Sun, 19 Mar 1995 00:33:29 -0600 (CST)
strftime.c: 		case 'z':	/* time zone offset east of GMT e.g. -0600 */
strftime.c:				off = -timeptr->tm_tzadj / 60;
strftime.c:				off = timeptr->tm_gmtoff / 60;
strftime.c:				off = -(daylight ? timezone : altzone) / 60;
strftime.c:				off = -timezone / 60;
strftime.c:				off = -zone.tz_minuteswest;
strftime.c:					off = (now - mktime(&utc)) / 60;
strftime.c:				off = -off;
strftime.c:				*s++ = '-';
strftime.c:			i = snprintf(s, endp - s, (padding == ' ' ? "%*ld" : "%.*ld"),
strftime.c:				     precision - (precision > 4), off);
strftime.c:			i = (daylight && timeptr->tm_isdst > 0); /* 0 or 1 */
strftime.c:			tp = timeptr->tm_zone;
strftime.c:			tp = timeptr->tm_name;
strftime.c:			tp = timezone(zone.tz_minuteswest, timeptr->tm_isdst > 0);
strftime.c:			FMT(' ', 2, "d", range(1, timeptr->tm_mday, 31));
strftime.c:		case 'k':	/* hour, 24-hour clock, blank pad */
strftime.c:			i = range(0, timeptr->tm_hour, 23);
strftime.c:		case 'l':	/* hour, 12-hour clock, 1 - 12, blank pad */
strftime.c:			i = range(0, timeptr->tm_hour, 23);
strftime.c:				i -= 12;
strftime.c:		case 'v':	/* date as dd-bbb-YYYY */
strftime.c:			w = snprintf(s, endp - s, "%2d-%3.3s-%4ld",
strftime.c:				     range(1, timeptr->tm_mday, 31),
strftime.c:				     months_l[range(0, timeptr->tm_mon, 11)],
strftime.c:				     timeptr->tm_year + 1900L);
strftime.c:			FMT('0', 2, "ld", (timeptr->tm_year + 1900L) / 100);
strftime.c:		/* ISO 8601: Weekday as a decimal number [1 (Monday) - 7] */
strftime.c:			FMT('0', 1, "d", timeptr->tm_wday == 0 ? 7 : timeptr->tm_wday);
strftime.c:			if (timeptr->tm_mon == 11 && w == 1)
strftime.c:				y = 1900L + timeptr->tm_year + 1;
strftime.c:			else if (timeptr->tm_mon == 0 && w >= 52)
strftime.c:				y = 1900L + timeptr->tm_year - 1;
strftime.c:				y = 1900L + timeptr->tm_year;
strftime.c:				long n = ts->tv_nsec;
strftime.c:					snprintf(s, endp - s, "%.*ld", w, n);
strftime.c:					memset(s + w, '0', precision - w);
strftime.c:		case 'F':	/*  Equivalent to %Y-%m-%d */
strftime.c:				mon = range(0, timeptr->tm_mon, 11) + 1;
strftime.c:				mday = range(1, timeptr->tm_mday, 31);
strftime.c:				i = snprintf(s, endp - s, "%ld-%02d-%02d",
strftime.c:					     1900L + timeptr->tm_year, mon, mday);
strftime.c:		case '-':
strftime.c:				format = e - 1;
strftime.c:			i = format - sp + 1;
strftime.c:			precision = -1;
strftime.c:				} while (s++, --i);
strftime.c:				} while (s++, --i);
strftime.c:		return (s - start);
strftime.c:/* isleap --- is a year a leap year? */
strftime.c:/* iso8601wknum --- compute week number according to ISO 8601 */
strftime.c:	 *	(timeptr->tm_yday - jan1.tm_yday) MOD 7 ==
strftime.c:	 *		(timeptr->tm_wday - jan1.tm_wday) MOD 7
strftime.c:	 * 	timeptr->tm_wday MOD 7 == timeptr->tm_wday
strftime.c:	jan1day = timeptr->tm_wday - (timeptr->tm_yday % 7);
strftime.c:			dec31ly.tm_year--;
strftime.c:			dec31ly.tm_wday = (jan1day == 0) ? 6 : jan1day - 1;
strftime.c:	if (timeptr->tm_mon == 11) {
strftime.c:		wday = timeptr->tm_wday;
strftime.c:		mday = timeptr->tm_mday;
strftime.c:/* weeknumber --- figure how many weeks into the year */
strftime.c:	int wday = timeptr->tm_wday;
strftime.c:			wday--;
strftime.c:	ret = ((timeptr->tm_yday + 7 - wday) / 7);
strftime.c:/* ADR --- I'm loathe to mess with ado's code ... */
strftime.c: * firstweekday is 0 if starting in Sunday, non-zero if in Monday
strftime.c:    return (timeptr->tm_yday - timeptr->tm_wday +
strftime.c:	    (firstweekday ? (timeptr->tm_wday ? 8 : 1) : 7)) / 7;
strftime.c: *	vogelke@c-17igp.wpafb.af.mil
strftime.c: *	cc -o tst -DTEST_STRFTIME strftime.c
strftime.c:	"(%%H)                          hour (24-hour clock, 00..23)  %H",
strftime.c:	"(%%I)                          hour (12-hour clock, 01..12)  %I",
strftime.c:	"(%%R)                                 time, 24-hour (%%H:%%M)  %R",
strftime.c:	"(%%T)                              time, 24-hour (%%H:%%M:%%S)  %T",
strftime.c:	"(%%e)               day of the month, blank-padded ( 1..31)  %e",
strftime.c:	"(%%k)               hour, 24-hour clock, blank pad ( 0..23)  %k",
strftime.c:	"(%%l)               hour, 12-hour clock, blank pad ( 0..12)  %l",
strftime.c:	"(%%p)              locale's AM or PM based on 12-hour clock  %p",
strftime.c:	"(%%r)                   time, 12-hour (same as %%I:%%M:%%S %%p)  %r",
strftime.c:	"(%%u) ISO 8601: Weekday as decimal number [1 (Monday) - 7]   %u",
strftime.c:	"(%%v)                                VMS date (dd-bbb-YYYY)  %v",
strftime.c:	"(%%z)      timezone offset east of GMT as HHMM (e.g. -0500)  %z",
ãã¤ããªã¼ã»ãã¡ã¤ã«strftime.oã¯ä¸è´ãã¾ãã
string.c:  string.c -
string.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
string.c:  Copyright (C) 2000  Information-technology Promotion Agency, Japan
string.c:#define BEG(no) regs->beg[no]
string.c:#define END(no) regs->end[no]
string.c:    RBASIC(str)->flags &= ~RSTRING_EMBED_LEN_MASK;\
string.c:    RBASIC(str)->flags |= (tmp_n) << RSTRING_EMBED_LEN_SHIFT;\
string.c:	RSTRING(str)->as.heap.len = (n);\
string.c:	n--;\
string.c:	RSTRING(str)->as.heap.len--;\
string.c:	    RSTRING(str)->as.heap.ptr = tmp;\
string.c:	    RSTRING(str)->as.heap.len = RSTRING_LEN(str);\
string.c:	    RSTRING(str)->as.heap.aux.capa = (capacity);\
string.c:	REALLOC_N(RSTRING(str)->as.heap.ptr, char, (capacity)+1);\
string.c:	    RSTRING(str)->as.heap.aux.capa = (capacity);\
string.c:    if (sizeof(VALUE) * 2 < e - p) {
string.c:        const VALUE lowbits = sizeof(VALUE) - 1;
string.c:        /* enc is ASCII-8BIT.  ASCII-8BIT string never be broken. */
string.c:	return e - s;
string.c:	/* enc is ASCII-8BIT.  ASCII-8BIT string never be broken. */
string.c:	return e - s;
string.c:	    return e - s;
string.c:		return p - s;
string.c:		    return e - s;
string.c:	return p - s;
string.c:		return p - s;
string.c:	return p - s;
string.c:	return RSTRING(str)->as.heap.len;
string.c:	return RSTRING(str)->as.heap.aux.capa;
string.c:    str->as.heap.ptr = 0;
string.c:    str->as.heap.len = 0;
string.c:    str->as.heap.aux.capa = 0;
string.c:	RSTRING(str)->as.heap.aux.capa = len;
string.c:	RSTRING(str)->as.heap.ptr = ALLOC_N(char,len+1);
string.c:    ec = rb_econv_open_opts(from->name, to->name, ecflags, ecopts);
string.c:	len = dp - (unsigned char*)RSTRING_PTR(newstr);
string.c:	RSTRING(str2)->as.heap.len = RSTRING_LEN(str);
string.c:	RSTRING(str2)->as.heap.ptr = RSTRING_PTR(str);
string.c:	RSTRING(str2)->as.heap.aux.shared = str;
string.c:    RSTRING(str2)->as.heap.len = RSTRING_LEN(str);
string.c:    RSTRING(str2)->as.heap.ptr = RSTRING_PTR(str);
string.c:	RSTRING(str2)->as.heap.aux.shared = RSTRING(str)->as.heap.aux.shared;
string.c:	RSTRING(str)->as.heap.aux.shared = str2;
string.c:    if (STR_SHARED_P(orig) && (str = RSTRING(orig)->as.heap.aux.shared)) {
string.c:	ofs = RSTRING_LEN(str) - RSTRING_LEN(orig);
string.c:	if ((ofs > 0) || (klass != RBASIC(str)->klass) ||
string.c:	    RSTRING(str)->as.heap.ptr += ofs;
string.c:	    RSTRING(str)->as.heap.len -= ofs;
string.c:	VALUE assoc = RSTRING(orig)->as.heap.aux.shared;
string.c:	RSTRING(str)->as.heap.aux.shared = assoc;
string.c:    RSTRING(str)->as.heap.aux.capa = capa;
string.c:    RSTRING(str)->as.heap.ptr = ALLOC_N(char, capa+1);
string.c:    RSTRING(str)->as.heap.ptr[0] = '\0';
string.c:	xfree(RSTRING(str)->as.heap.ptr);
string.c:    RSTRING(str)->as.heap.ptr = RSTRING_PTR(str2);
string.c:    RSTRING(str)->as.heap.len = RSTRING_LEN(str2);
string.c:	FL_SET(str, RBASIC(str2)->flags & STR_NOCAPA);
string.c:	RSTRING(str)->as.heap.aux.shared = RSTRING(str2)->as.heap.aux.shared;
string.c:	RSTRING(str)->as.heap.aux.capa = RSTRING(str2)->as.heap.aux.capa;
string.c: *  call-seq:
string.c:        return (e - p + rb_enc_mbminlen(enc) - 1) / rb_enc_mbminlen(enc);
string.c:                    return c + (e - p);
string.c:                c += q - p;
string.c:	return (e - p + rb_enc_mbminlen(enc) - 1) / rb_enc_mbminlen(enc);
string.c:		    return c + (e - p);
string.c:		c += q - p;
string.c:	if (sizeof(VALUE) * 2 < e - p) {
string.c:	    const VALUE lowbits = sizeof(VALUE) - 1;
string.c: *  call-seq:
string.c: *  call-seq:
string.c: *  call-seq:
string.c: *  call-seq:
string.c: *  Concatenation---Returns a new <code>String</code> containing
string.c: *  call-seq:
string.c: *  Copy---Returns a new <code>String</code> containing <i>integer</i> copies of
string.c:        memcpy(RSTRING_PTR(str2) + n, RSTRING_PTR(str2), len-n);
string.c: *  call-seq:
string.c: *  Format---Uses <i>str</i> as a format specification, and returns the result
string.c: *     "%-5s: %08x" % [ "ID", self.object_id ]   #=> "ID   : 200e14d6"
string.c:    RSTRING(str)->as.heap.ptr = ptr;
string.c:    RSTRING(str)->as.heap.len = len;
string.c:    RSTRING(str)->as.heap.aux.capa = len;
string.c:	/* Force re-scan later */
string.c:	rb_ary_concat(RSTRING(str)->as.heap.aux.shared, add);
string.c:	    VALUE assoc = RSTRING(str)->as.heap.aux.shared;
string.c:		assoc = RSTRING(assoc)->as.heap.aux.shared;
string.c:	else if (RSTRING(str)->as.heap.aux.capa != RSTRING_LEN(str)) {
string.c:	RBASIC(add)->klass = 0;
string.c:	RSTRING(str)->as.heap.aux.shared = add;
string.c:    if (STR_SHARED_P(str)) str = RSTRING(str)->as.heap.aux.shared;
string.c:	return RSTRING(str)->as.heap.aux.shared;
string.c: *  call-seq:
string.c: *     String.try_convert(obj) -> string or nil
string.c:                nth -= p2 - p;
string.c:            nth--;
string.c:        while (p<e && nth--) {
string.c:    if (!pp) return e - p;
string.c:    return pp - p;
string.c:	const VALUE lowbits = sizeof(VALUE) - 1;
string.c:	    if (is_utf8_lead_byte(*p)) nth--;
string.c:	    nth -= count_utf8_lead_bytes_with_word(s);
string.c:	    nth--;
string.c:    if (!pp) return e - p;
string.c:    return pp - p;
string.c:	    len = RSTRING_LEN(str) - beg;
string.c:	if (len > -beg) len = -beg;
string.c:	if (-beg * rb_enc_mbmaxlen(enc) < RSTRING_LEN(str) / 8) {
string.c:	    beg = -beg;
string.c:	    while (beg-- > len && (e = rb_enc_prev_char(s, e, e, enc)) != 0);
string.c:	    while (len-- > 0 && (p = rb_enc_prev_char(s, p, e, enc)) != 0);
string.c:	    len = e - p;
string.c:        else if (len * char_sz > e - p)
string.c:            len = e - p;
string.c:	RSTRING(str2)->as.heap.ptr += RSTRING(str2)->as.heap.len - len;
string.c:	RSTRING(str2)->as.heap.len = len;
string.c:	VALUE ary = RSTRING(str)->as.heap.aux.shared;
string.c:		RSTRING(str)->as.ary[len] = '\0';
string.c:	    MEMCPY(ptr, RSTRING(str)->as.ary, char, slen);
string.c:	    RSTRING(str)->as.heap.ptr = ptr;
string.c:	    char *ptr = RSTRING(str)->as.heap.ptr;
string.c:	    if (slen > 0) MEMCPY(RSTRING(str)->as.ary, ptr, char, len);
string.c:	    RSTRING(str)->as.ary[len] = '\0';
string.c:	else if (slen < len || slen - len > 1024) {
string.c:	    REALLOC_N(RSTRING(str)->as.heap.ptr, char, len+1);
string.c:	    RSTRING(str)->as.heap.aux.capa = len;
string.c:	RSTRING(str)->as.heap.len = len;
string.c:	RSTRING(str)->as.heap.ptr[len] = '\0';	/* sentinel */
string.c:    long capa, total, off = -1;
string.c:        off = ptr - RSTRING_PTR(str);
string.c:	capa = RSTRING(str)->as.heap.aux.capa = RSTRING_LEN(str);
string.c:	capa = RSTRING(str)->as.heap.aux.capa;
string.c:    if (RSTRING_LEN(str) >= LONG_MAX - len) {
string.c:    if (off != -1) {
string.c:	REALLOC_N(RSTRING(str)->as.heap.ptr, char, RSTRING(str)->as.heap.len+len+1);
string.c:	memcpy(RSTRING(str)->as.heap.ptr + RSTRING(str)->as.heap.len, ptr, len);
string.c:	RSTRING(str)->as.heap.len += len;
string.c:	RSTRING(str)->as.heap.ptr[RSTRING(str)->as.heap.len] = '\0'; /* sentinel */
string.c:        REALLOC_N(RSTRING(str)->as.heap.ptr, char, len+1);
string.c:        memcpy(RSTRING(str)->as.heap.ptr + RSTRING(str)->as.heap.len,
string.c:        RSTRING(str)->as.heap.len = len;
string.c: *  call-seq:
string.c: *  Append---Concatenates the given object to <i>str</i>. If the object is a
string.c:	    t >>= (8 * align) - 8;
string.c:	    data += 4-align;
string.c:	    len -= 4-align;
string.c:	    sl = 8 * (4-align);
string.c:		len -= 4;
string.c:	    len -= pack;
string.c:		len -= 4;
string.c: * call-seq:
string.c:		return -1;
string.c:	return -1;
string.c:    return -1;
string.c: *  call-seq:
string.c: *  Equality---If <i>obj</i> is not a <code>String</code>, returns
string.c: * call-seq:
string.c: *  call-seq:
string.c: *     str <=> other_str   => -1, 0, +1
string.c: *  Comparison---Returns -1 if <i>other_str</i> is greater than, 0 if
string.c: *  <code>$=</code> allowed case-insensitive comparisons; this is now deprecated
string.c: *     "abcdef" <=> "abcdefg"   #=> -1
string.c:		return rb_funcall(LONG2FIX(0), '-', 1, tmp);
string.c:	    result = -FIX2LONG(tmp);
string.c: *  call-seq:
string.c: *     str.casecmp(other_str)   => -1, 0, +1
string.c: *  Case-insensitive version of <code>String#<=></code>.
string.c: *     "abcdef".casecmp("abcdefg")   #=> -1
string.c:                    return INT2FIX(c1 < c2 ? -1 : 1);
string.c:                    return INT2FIX(c1 < c2 ? -1 : 1);
string.c:                    return INT2FIX(r < 0 ? -1 : 1);
string.c:                    return INT2FIX(l1 < l2 ? -1 : 1);
string.c:    return INT2FIX(-1);
string.c:	return -1;
string.c:	if (offset < 0) return -1;
string.c:    if (len - offset < slen) return -1;
string.c:    len = RSTRING_LEN(str) - offset;
string.c:	if ((len -= t - s) <= 0) return -1;
string.c:	offset += t - s;
string.c: *  call-seq:
string.c: *     "hello".index(/[aeiou]/, -3)   #=> 4
string.c:    if (pos == -1) return Qnil;
string.c:	return -1;
string.c:    if (len < slen) return -1;
string.c:    if (len - pos < slen) {
string.c:	pos = len - slen;
string.c:	if (!s) return -1;
string.c:	pos--;
string.c:    return -1;
string.c: *  call-seq:
string.c: *  string to end the search---characters beyond this point will not be
string.c: *     "hello".rindex(/[aeiou]/, -2)   #=> 1
string.c:	if (!RREGEXP(sub)->ptr || RREGEXP_SRC_LEN(sub)) {
string.c: *  call-seq:
string.c: *  Match---If <i>obj</i> is a <code>Regexp</code>, use it as a pattern to match
string.c: *  call-seq:
string.c:        for (i = len-1; 0 <= i && (unsigned char)p[i] == 0xff; i--)
string.c:                memset(p+l, 0xff, len-l);
string.c:        if (MBCLEN_INVALID_P(l) && i < len-1) {
string.c:            for (len2 = len-1; 0 < len2; len2--) {
string.c:            memset(p+len2+1, 0xff, len-(len2+1));
string.c:        for (i = len-1; 0 <= i && (unsigned char)p[i] == 0; i--)
string.c:        --((unsigned char*)p)[i];
string.c:                memset(p+l, 0, len-l);
string.c:        if (MBCLEN_INVALID_P(l) && i < len-1) {
string.c:            for (len2 = len-1; 0 < len2; len2--) {
string.c:            memset(p+len2+1, 0, len-(len2+1));
string.c:  When NEIGHBOR_WRAPPED, carried-out letter is stored into carry.
string.c: *  call-seq:
string.c:    int c = -1;
string.c:        carry_pos = s - sbeg;
string.c:    if (c == -1) {		/* str contains no alnum */
string.c:            carry_pos = s - sbeg;
string.c:    memmove(s + carry_len, s, RSTRING_LEN(str) - carry_pos);
string.c: *  call-seq:
string.c: *  call-seq:
string.c:	if (rb_str_index(str, indx, 0) != -1)
string.c: *  call-seq:
string.c: *  Element Reference---If passed a single <code>Fixnum</code>, returns a
string.c: *     a[-3,2]                #=> "er"
string.c: *     a[-4..-2]              #=> "her"
string.c: *     a[12..-1]              #=> nil
string.c: *     a[-2..-4]              #=> ""
string.c:    nlen = olen - len;
string.c:	int fl = (RBASIC(str)->flags & (STR_NOEMBED|ELTS_SHARED));
string.c:	ptr = RSTRING(str)->as.ary;
string.c:	ptr = RSTRING(str)->as.heap.ptr += len;
string.c:	RSTRING(str)->as.heap.len = nlen;
string.c:	RESIZE_CAPA(str, RSTRING_LEN(str) + RSTRING_LEN(val) - len + 1);
string.c:		RSTRING_LEN(str) - (beg + len));
string.c:	MEMZERO(RSTRING_PTR(str) + RSTRING_LEN(str), char, -len);
string.c:    STR_SET_LEN(str, RSTRING_LEN(str) + RSTRING_LEN(val) - len);
string.c:	if (-beg > slen) {
string.c:	len = slen - beg;
string.c:    beg = p - RSTRING_PTR(str);	/* physical position */
string.c:    len = e - p;		/* physical length */
string.c:    if (nth >= regs->num_regs) {
string.c:	if (-nth >= regs->num_regs) {
string.c:	nth += regs->num_regs;
string.c:    if (start == -1) {
string.c:    len = end - start;
string.c: *  call-seq:
string.c: *  Element Assignment---Replaces some or all of the content of <i>str</i>. The
string.c: *  call-seq:
string.c: *     "abcd".insert(-3, 'X')   #=> "abXcd"
string.c: *     "abcd".insert(-1, 'X')   #=> "abcdX"
string.c:    if (pos == -1) {
string.c: *  call-seq:
string.c: *  call-seq:
string.c:                repl = rb_hash_aref(hash, rb_str_subseq(str, beg0, end0 - beg0));
string.c:			       RSTRING_LEN(str)-end0, str_enc) != ENC_CODERANGE_7BIT) {
string.c:	plen = end0 - beg0;
string.c:	    RESIZE_CAPA(str, RSTRING_LEN(str) + RSTRING_LEN(repl) - plen);
string.c:		    RSTRING_LEN(str) - beg0 - plen);
string.c:	STR_SET_LEN(str, RSTRING_LEN(str) + RSTRING_LEN(repl) - plen);
string.c: *  call-seq:
string.c:                val = rb_hash_aref(hash, rb_str_subseq(str, BEG(0), END(0) - BEG(0)));
string.c:	    if (val == dest) { 	/* paranoid check [ruby-dev:24827] */
string.c:	len = beg - offset;	/* copy pre-match substr */
string.c:        rb_enc_str_buf_cat(dest, cp, RSTRING_LEN(str) - offset, str_enc);
string.c:	RBASIC(dest)->klass = rb_obj_class(str);
string.c: *  call-seq:
string.c: *  call-seq:
string.c: *  call-seq:
string.c:	RSTRING(str)->as.heap.len = len;
string.c:	RSTRING(str)->as.heap.ptr = RSTRING_PTR(str2);
string.c:	RSTRING(str)->as.heap.aux.shared = RSTRING(str2)->as.heap.aux.shared;
string.c: *  call-seq:
string.c: *     string.clear    ->  string
string.c: *  call-seq:
string.c: *     string.chr    ->  string
string.c: *  Returns a one-character string at the beginning of the string.
string.c: *  call-seq:
string.c: *  call-seq:
string.c:    if (pos < -RSTRING_LEN(str) || RSTRING_LEN(str) <= pos)
string.c: *  call-seq:
string.c:		*--p = *s++;
string.c:		p -= clen;
string.c: *  call-seq:
string.c:	    e = RSTRING_END(str) - 1;
string.c: 		*e-- = c;
string.c: *  call-seq:
string.c:    if (i == -1) return Qfalse;
string.c: *  call-seq:
string.c: *  call-seq:
string.c: *  call-seq:
string.c: * call-seq:
string.c:	    rb_enc_str_buf_cat(result, p-n, n, enc);
string.c:            for (q = p-n; q < p; q++) {
string.c: *  call-seq:
string.c:		    int n = rb_enc_precise_mbclen(p-1, pend, enc) - 1;
string.c:			int cc = rb_enc_codepoint(p-1, pend, enc);
string.c:	len += strlen(enc->name);
string.c:		int n = rb_enc_precise_mbclen(p-1, pend, enc) - 1;
string.c:		    int cc = rb_enc_codepoint(p-1, pend, enc);
string.c:	sprintf(q, ".force_encoding(\"%s\")", enc->name);
string.c: *  call-seq:
string.c:		*s = 'A' + (c - 'a');
string.c:		    *s = 'A' + (c - 'a');
string.c: *  call-seq:
string.c: *  uppercase counterparts. The operation is locale insensitive---only
string.c: *  call-seq:
string.c:		*s = 'a' + (c - 'A');
string.c:		    *s = 'a' + (c - 'A');
string.c: *  call-seq:
string.c: *  lowercase counterparts. The operation is locale insensitive---only
string.c: *  call-seq:
string.c: *  call-seq:
string.c: *  call-seq: 
string.c: *  call-seq:
string.c:	if (!t->gen) {
string.c:	    if (t->p == t->pend) return -1;
string.c:	    if (t->p < t->pend - 1 && *t->p == '\\') {
string.c:		t->p++;
string.c:	    t->now = rb_enc_codepoint(t->p, t->pend, enc);
string.c:	    t->p += rb_enc_codelen(t->now, enc);
string.c:	    if (t->p < t->pend - 1 && *t->p == '-') {
string.c:		t->p++;
string.c:		if (t->p < t->pend) {
string.c:		    unsigned int c = rb_enc_codepoint(t->p, t->pend, enc);
string.c:		    t->p += rb_enc_codelen(c, enc);
string.c:		    if (t->now > c) continue;
string.c:		    t->gen = 1;
string.c:		    t->max = c;
string.c:	    return t->now;
string.c:	else if (++t->now < t->max) {
string.c:	    return t->now;
string.c:	    t->gen = 0;
string.c:	    return t->max;
string.c:    const unsigned int errc = -1;
string.c:	int offset, save = -1;
string.c:	    if (c != -1) {
string.c:		save = -1;
string.c:	    while (t - buf + tlen >= max) {
string.c:		offset = t - buf;
string.c:	RSTRING(str)->as.heap.ptr = buf;
string.c:	RSTRING(str)->as.heap.len = t - buf;
string.c:	RSTRING(str)->as.heap.aux.capa = max;
string.c:	    while (t - buf + tlen >= max) {
string.c:		offset = t - buf;
string.c:	    xfree(RSTRING(str)->as.heap.ptr);
string.c:	RSTRING(str)->as.heap.ptr = buf;
string.c:	RSTRING(str)->as.heap.len = t - buf;
string.c:	RSTRING(str)->as.heap.aux.capa = max;
string.c: *  call-seq:
string.c: *  call-seq:
string.c: *  strings may use the c1--c2 notation to denote ranges of characters, and
string.c: *     "hello".tr('a-y', 'b-z')    #=> "ifmmp"
string.c:    const unsigned int errc = -1;
string.c: *  call-seq:
string.c:    STR_SET_LEN(str, t - RSTRING_PTR(str));
string.c: *  call-seq:
string.c: *     "hello".delete "ej-m"          #=> "ho"
string.c: *  call-seq:
string.c:    save = -1;
string.c:    if (t - RSTRING_PTR(str) != RSTRING_LEN(str)) {
string.c:	STR_SET_LEN(str, t - RSTRING_PTR(str));
string.c: *  call-seq:
string.c: *     "putters shoot balls".squeeze("m-z")   #=> "puters shot balls"
string.c: *  call-seq:
string.c: *  call-seq:
string.c: *  call-seq:
string.c: *  negated. The sequence c1--c2 means all characters between c1 and c2.
string.c: *     a.count "ej-m"          #=> 4
string.c: *  call-seq:
string.c: *  pattern matches. Whenever the pattern matches a zero-length string,
string.c: *     "1,2,,3,4,,".split(',', -4)     #=> ["1", "2", "", "3", "4", "", ""]
string.c:		/* Special case - split into chars */
string.c:		    beg = ptr - bptr;
string.c:		    end = ptr - bptr;
string.c:		    rb_ary_push(result, rb_str_subseq(str, beg, end-beg));
string.c:		    beg = ptr - bptr;
string.c:		    end = ptr - bptr;
string.c:	       (end = rb_memsearch(sptr, slen, ptr, eptr - ptr, enc)) >= 0) {
string.c:	    rb_ary_push(result, rb_str_subseq(str, ptr - RSTRING_PTR(str), end));
string.c:	beg = ptr - RSTRING_PTR(str);
string.c:		rb_ary_push(result, rb_str_subseq(str, beg, end-beg));
string.c:	    for (idx=1; idx < regs->num_regs; idx++) {
string.c:		if (BEG(idx) == -1) continue;
string.c:		    tmp = rb_str_subseq(str, BEG(idx), END(idx)-BEG(idx));
string.c:	    tmp = rb_str_subseq(str, beg, RSTRING_LEN(str)-beg);
string.c:	       (tmp = RARRAY_PTR(result)[len-1], RSTRING_LEN(tmp) == 0))
string.c: *  Document-method: lines
string.c: *  call-seq:
string.c: *  Document-method: each_line
string.c: *  call-seq:
string.c: *  block. If a zero-length record separator is supplied, the string is split
string.c:	    p = memchr(p, '\n', pend - p);
string.c:	    line = rb_str_new5(str, s, p - s);
string.c:	    p -= n;
string.c:	    line = rb_str_new5(str, s, p - s + (rslen ? rslen : n));
string.c:	line = rb_str_new5(str, s, pend - s);
string.c: *  Document-method: bytes
string.c: *  call-seq:
string.c: *  Document-method: each_byte
string.c: *  call-seq:
string.c: *  Document-method: chars
string.c: *  call-seq:
string.c: *  Document-method: each_char
string.c: *  call-seq:
string.c: *  Document-method: codepoints
string.c: *  call-seq:
string.c: *  Document-method: each_codepoint
string.c: *  call-seq:
string.c:    return p - beg;
string.c: *  call-seq:
string.c: *  call-seq:
string.c: *  call-seq:
string.c:		pp = rb_enc_left_char_head(p, e-rb_enc_mbminlen(enc), e, enc);
string.c:		pp = e - rb_enc_mbminlen(enc);
string.c:		len = e - RSTRING_PTR(str);
string.c:		if (RSTRING_PTR(str)[len-1] == '\n') {
string.c:			RSTRING_PTR(str)[RSTRING_LEN(str)-1] == '\r') {
string.c:		else if (RSTRING_PTR(str)[len-1] == '\r') {
string.c:	while (len>0 && p[len-1] == '\n') {
string.c:	    len--;
string.c:	    if (len>0 && p[len-1] == '\r')
string.c:		len--;
string.c:    newline = RSTRING_PTR(rs)[rslen-1];
string.c:    pp = e - rslen;
string.c:    if (p[len-1] == newline &&
string.c:	STR_SET_LEN(str, RSTRING_LEN(str) - rslen);
string.c: *  call-seq:
string.c: *  call-seq:
string.c:	STR_SET_LEN(str, t-s);
string.c: *  call-seq:
string.c: *  call-seq:
string.c:	while (s < t && ((c = *(t-1)) == '\0' || rb_enc_isspace(c, enc))) t--;
string.c:	int len = t-RSTRING_PTR(str);
string.c: *  call-seq:
string.c: *  call-seq:
string.c: *  call-seq:
string.c:	if (regs->num_regs == 1) {
string.c:	result = rb_ary_new2(regs->num_regs);
string.c:	for (i=1; i < regs->num_regs; i++) {
string.c: *  call-seq:
string.c:    long last = -1, prev = 0;
string.c: *  call-seq:
string.c: *     "-1234".hex    #=> -4660
string.c: *  call-seq:
string.c: *     "-377".oct      #=> -255
string.c:    return rb_str_to_inum(str, -8, Qfalse);
string.c: *  call-seq:
string.c: *  Applies a one-way cryptographic hash to <i>str</i> by invoking the standard
string.c: *  <code>[a-zA-Z0-9./]</code>.
string.c: *  call-seq:
string.c: *  call-seq:
string.c: *  Return the <code>Integer</code> ordinal of a one-character string.
string.c: *  call-seq:
string.c: *  Returns a basic <em>n</em>-bit checksum of the characters in <i>str</i>,
string.c: *  <i>str</i> modulo <code>2n - 1</code>. This is not a particularly good
string.c:	    mod = rb_funcall(mod, '-', 1, INT2FIX(1));
string.c:           sum &= (((unsigned long)1)<<bits)-1;
string.c:    n = width - len;
string.c:    rlen = n - llen;
string.c:	    llen--;
string.c:	    llen -= fclen;
string.c:	    n = fp - f;
string.c:	    rlen--;
string.c:	    rlen -= fclen;
string.c:	    n = fp - f;
string.c:    STR_SET_LEN(res, p-RSTRING_PTR(res));
string.c: *  call-seq:
string.c: *  call-seq:
string.c: *  call-seq:
string.c: *  call-seq:
string.c:					     RSTRING_LEN(str)-pos-RSTRING_LEN(sep)));
string.c: *  call-seq:
string.c: *  call-seq:
string.c: *  call-seq:
string.c:	s = e - RSTRING_LEN(tmp);
string.c: *  call-seq:
string.c: *  call-seq:
string.c: *    "\xc2\xa1".force_encoding("UTF-8").valid_encoding? => true
string.c: *    "\xc2".force_encoding("UTF-8").valid_encoding? => false
string.c: *    "\x80".force_encoding("UTF-8").valid_encoding? => false
string.c: *  call-seq:
string.c: *    "abc".force_encoding("UTF-8").ascii_only? => true
string.c: *    "abc\u{6666}".force_encoding("UTF-8").ascii_only? => false
string.c: * Document-class: Symbol
string.c: *  call-seq:
string.c: *  Equality---If <i>sym</i> and <i>obj</i> are exactly the same
string.c: *  call-seq:
string.c: *  call-seq:
string.c: * call-seq:
string.c:    return rb_funcall3(obj, (ID)sym, argc - 1, argv + 1);
string.c: * call-seq:
string.c:    rb_define_method(rb_cString, "initialize", rb_str_init, -1);
string.c:    rb_define_method(rb_cString, "[]", rb_str_aref_m, -1);
string.c:    rb_define_method(rb_cString, "[]=", rb_str_aset_m, -1);
string.c:    rb_define_method(rb_cString, "match", rb_str_match_m, -1);
string.c:    rb_define_method(rb_cString, "upto", rb_str_upto, -1);
string.c:    rb_define_method(rb_cString, "index", rb_str_index_m, -1);
string.c:    rb_define_method(rb_cString, "rindex", rb_str_rindex_m, -1);
string.c:    rb_define_method(rb_cString, "to_i", rb_str_to_i, -1);
string.c:    rb_define_method(rb_cString, "split", rb_str_split_m, -1);
string.c:    rb_define_method(rb_cString, "lines", rb_str_each_line, -1);
string.c:    rb_define_method(rb_cString, "start_with?", rb_str_start_with, -1);
string.c:    rb_define_method(rb_cString, "end_with?", rb_str_end_with, -1);
string.c:    rb_define_method(rb_cString, "ljust", rb_str_ljust, -1);
string.c:    rb_define_method(rb_cString, "rjust", rb_str_rjust, -1);
string.c:    rb_define_method(rb_cString, "center", rb_str_center, -1);
string.c:    rb_define_method(rb_cString, "sub", rb_str_sub, -1);
string.c:    rb_define_method(rb_cString, "gsub", rb_str_gsub, -1);
string.c:    rb_define_method(rb_cString, "chomp", rb_str_chomp, -1);
string.c:    rb_define_method(rb_cString, "sub!", rb_str_sub_bang, -1);
string.c:    rb_define_method(rb_cString, "gsub!", rb_str_gsub_bang, -1);
string.c:    rb_define_method(rb_cString, "chomp!", rb_str_chomp_bang, -1);
string.c:    rb_define_method(rb_cString, "delete", rb_str_delete, -1);
string.c:    rb_define_method(rb_cString, "squeeze", rb_str_squeeze, -1);
string.c:    rb_define_method(rb_cString, "count", rb_str_count, -1);
string.c:    rb_define_method(rb_cString, "delete!", rb_str_delete_bang, -1);
string.c:    rb_define_method(rb_cString, "squeeze!", rb_str_squeeze_bang, -1);
string.c:    rb_define_method(rb_cString, "each_line", rb_str_each_line, -1);
string.c:    rb_define_method(rb_cString, "sum", rb_str_sum, -1);
string.c:    rb_define_method(rb_cString, "slice", rb_str_aref_m, -1);
string.c:    rb_define_method(rb_cString, "slice!", rb_str_slice_bang, -1);
string.c:    rb_define_variable("$-F", &rb_fs);
string.c:    rb_define_method(rb_cSymbol, "p-match", patern_equal,1); 
string.c:    rb_define_method(rb_cSymbol, "[]", sym_aref, -1);
string.c:    rb_define_method(rb_cSymbol, "slice", sym_aref, -1);
string.c~:  string.c -
string.c~:  Copyright (C) 1993-2007 Yukihiro Matsumoto
string.c~:  Copyright (C) 2000  Information-technology Promotion Agency, Japan
string.c~:#define BEG(no) regs->beg[no]
string.c~:#define END(no) regs->end[no]
string.c~:    RBASIC(str)->flags &= ~RSTRING_EMBED_LEN_MASK;\
string.c~:    RBASIC(str)->flags |= (tmp_n) << RSTRING_EMBED_LEN_SHIFT;\
string.c~:	RSTRING(str)->as.heap.len = (n);\
string.c~:	n--;\
string.c~:	RSTRING(str)->as.heap.len--;\
string.c~:	    RSTRING(str)->as.heap.ptr = tmp;\
string.c~:	    RSTRING(str)->as.heap.len = RSTRING_LEN(str);\
string.c~:	    RSTRING(str)->as.heap.aux.capa = (capacity);\
string.c~:	REALLOC_N(RSTRING(str)->as.heap.ptr, char, (capacity)+1);\
string.c~:	    RSTRING(str)->as.heap.aux.capa = (capacity);\
string.c~:    if (sizeof(VALUE) * 2 < e - p) {
string.c~:        const VALUE lowbits = sizeof(VALUE) - 1;
string.c~:        /* enc is ASCII-8BIT.  ASCII-8BIT string never be broken. */
string.c~:	return e - s;
string.c~:	/* enc is ASCII-8BIT.  ASCII-8BIT string never be broken. */
string.c~:	return e - s;
string.c~:	    return e - s;
string.c~:		return p - s;
string.c~:		    return e - s;
string.c~:	return p - s;
string.c~:		return p - s;
string.c~:	return p - s;
string.c~:	return RSTRING(str)->as.heap.len;
string.c~:	return RSTRING(str)->as.heap.aux.capa;
string.c~:    str->as.heap.ptr = 0;
string.c~:    str->as.heap.len = 0;
string.c~:    str->as.heap.aux.capa = 0;
string.c~:	RSTRING(str)->as.heap.aux.capa = len;
string.c~:	RSTRING(str)->as.heap.ptr = ALLOC_N(char,len+1);
string.c~:    ec = rb_econv_open_opts(from->name, to->name, ecflags, ecopts);
string.c~:	len = dp - (unsigned char*)RSTRING_PTR(newstr);
string.c~:	RSTRING(str2)->as.heap.len = RSTRING_LEN(str);
string.c~:	RSTRING(str2)->as.heap.ptr = RSTRING_PTR(str);
string.c~:	RSTRING(str2)->as.heap.aux.shared = str;
string.c~:    RSTRING(str2)->as.heap.len = RSTRING_LEN(str);
string.c~:    RSTRING(str2)->as.heap.ptr = RSTRING_PTR(str);
string.c~:	RSTRING(str2)->as.heap.aux.shared = RSTRING(str)->as.heap.aux.shared;
string.c~:	RSTRING(str)->as.heap.aux.shared = str2;
string.c~:    if (STR_SHARED_P(orig) && (str = RSTRING(orig)->as.heap.aux.shared)) {
string.c~:	ofs = RSTRING_LEN(str) - RSTRING_LEN(orig);
string.c~:	if ((ofs > 0) || (klass != RBASIC(str)->klass) ||
string.c~:	    RSTRING(str)->as.heap.ptr += ofs;
string.c~:	    RSTRING(str)->as.heap.len -= ofs;
string.c~:	VALUE assoc = RSTRING(orig)->as.heap.aux.shared;
string.c~:	RSTRING(str)->as.heap.aux.shared = assoc;
string.c~:    RSTRING(str)->as.heap.aux.capa = capa;
string.c~:    RSTRING(str)->as.heap.ptr = ALLOC_N(char, capa+1);
string.c~:    RSTRING(str)->as.heap.ptr[0] = '\0';
string.c~:	xfree(RSTRING(str)->as.heap.ptr);
string.c~:    RSTRING(str)->as.heap.ptr = RSTRING_PTR(str2);
string.c~:    RSTRING(str)->as.heap.len = RSTRING_LEN(str2);
string.c~:	FL_SET(str, RBASIC(str2)->flags & STR_NOCAPA);
string.c~:	RSTRING(str)->as.heap.aux.shared = RSTRING(str2)->as.heap.aux.shared;
string.c~:	RSTRING(str)->as.heap.aux.capa = RSTRING(str2)->as.heap.aux.capa;
string.c~: *  call-seq:
string.c~:        return (e - p + rb_enc_mbminlen(enc) - 1) / rb_enc_mbminlen(enc);
string.c~:                    return c + (e - p);
string.c~:                c += q - p;
string.c~:	return (e - p + rb_enc_mbminlen(enc) - 1) / rb_enc_mbminlen(enc);
string.c~:		    return c + (e - p);
string.c~:		c += q - p;
string.c~:	if (sizeof(VALUE) * 2 < e - p) {
string.c~:	    const VALUE lowbits = sizeof(VALUE) - 1;
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~: *  Concatenation---Returns a new <code>String</code> containing
string.c~: *  call-seq:
string.c~: *  Copy---Returns a new <code>String</code> containing <i>integer</i> copies of
string.c~:        memcpy(RSTRING_PTR(str2) + n, RSTRING_PTR(str2), len-n);
string.c~: *  call-seq:
string.c~: *  Format---Uses <i>str</i> as a format specification, and returns the result
string.c~: *     "%-5s: %08x" % [ "ID", self.object_id ]   #=> "ID   : 200e14d6"
string.c~:    RSTRING(str)->as.heap.ptr = ptr;
string.c~:    RSTRING(str)->as.heap.len = len;
string.c~:    RSTRING(str)->as.heap.aux.capa = len;
string.c~:	/* Force re-scan later */
string.c~:	rb_ary_concat(RSTRING(str)->as.heap.aux.shared, add);
string.c~:	    VALUE assoc = RSTRING(str)->as.heap.aux.shared;
string.c~:		assoc = RSTRING(assoc)->as.heap.aux.shared;
string.c~:	else if (RSTRING(str)->as.heap.aux.capa != RSTRING_LEN(str)) {
string.c~:	RBASIC(add)->klass = 0;
string.c~:	RSTRING(str)->as.heap.aux.shared = add;
string.c~:    if (STR_SHARED_P(str)) str = RSTRING(str)->as.heap.aux.shared;
string.c~:	return RSTRING(str)->as.heap.aux.shared;
string.c~: *  call-seq:
string.c~: *     String.try_convert(obj) -> string or nil
string.c~:                nth -= p2 - p;
string.c~:            nth--;
string.c~:        while (p<e && nth--) {
string.c~:    if (!pp) return e - p;
string.c~:    return pp - p;
string.c~:	const VALUE lowbits = sizeof(VALUE) - 1;
string.c~:	    if (is_utf8_lead_byte(*p)) nth--;
string.c~:	    nth -= count_utf8_lead_bytes_with_word(s);
string.c~:	    nth--;
string.c~:    if (!pp) return e - p;
string.c~:    return pp - p;
string.c~:	    len = RSTRING_LEN(str) - beg;
string.c~:	if (len > -beg) len = -beg;
string.c~:	if (-beg * rb_enc_mbmaxlen(enc) < RSTRING_LEN(str) / 8) {
string.c~:	    beg = -beg;
string.c~:	    while (beg-- > len && (e = rb_enc_prev_char(s, e, e, enc)) != 0);
string.c~:	    while (len-- > 0 && (p = rb_enc_prev_char(s, p, e, enc)) != 0);
string.c~:	    len = e - p;
string.c~:        else if (len * char_sz > e - p)
string.c~:            len = e - p;
string.c~:	RSTRING(str2)->as.heap.ptr += RSTRING(str2)->as.heap.len - len;
string.c~:	RSTRING(str2)->as.heap.len = len;
string.c~:	VALUE ary = RSTRING(str)->as.heap.aux.shared;
string.c~:		RSTRING(str)->as.ary[len] = '\0';
string.c~:	    MEMCPY(ptr, RSTRING(str)->as.ary, char, slen);
string.c~:	    RSTRING(str)->as.heap.ptr = ptr;
string.c~:	    char *ptr = RSTRING(str)->as.heap.ptr;
string.c~:	    if (slen > 0) MEMCPY(RSTRING(str)->as.ary, ptr, char, len);
string.c~:	    RSTRING(str)->as.ary[len] = '\0';
string.c~:	else if (slen < len || slen - len > 1024) {
string.c~:	    REALLOC_N(RSTRING(str)->as.heap.ptr, char, len+1);
string.c~:	    RSTRING(str)->as.heap.aux.capa = len;
string.c~:	RSTRING(str)->as.heap.len = len;
string.c~:	RSTRING(str)->as.heap.ptr[len] = '\0';	/* sentinel */
string.c~:    long capa, total, off = -1;
string.c~:        off = ptr - RSTRING_PTR(str);
string.c~:	capa = RSTRING(str)->as.heap.aux.capa = RSTRING_LEN(str);
string.c~:	capa = RSTRING(str)->as.heap.aux.capa;
string.c~:    if (RSTRING_LEN(str) >= LONG_MAX - len) {
string.c~:    if (off != -1) {
string.c~:	REALLOC_N(RSTRING(str)->as.heap.ptr, char, RSTRING(str)->as.heap.len+len+1);
string.c~:	memcpy(RSTRING(str)->as.heap.ptr + RSTRING(str)->as.heap.len, ptr, len);
string.c~:	RSTRING(str)->as.heap.len += len;
string.c~:	RSTRING(str)->as.heap.ptr[RSTRING(str)->as.heap.len] = '\0'; /* sentinel */
string.c~:        REALLOC_N(RSTRING(str)->as.heap.ptr, char, len+1);
string.c~:        memcpy(RSTRING(str)->as.heap.ptr + RSTRING(str)->as.heap.len,
string.c~:        RSTRING(str)->as.heap.len = len;
string.c~: *  call-seq:
string.c~: *  Append---Concatenates the given object to <i>str</i>. If the object is a
string.c~:	    t >>= (8 * align) - 8;
string.c~:	    data += 4-align;
string.c~:	    len -= 4-align;
string.c~:	    sl = 8 * (4-align);
string.c~:		len -= 4;
string.c~:	    len -= pack;
string.c~:		len -= 4;
string.c~: * call-seq:
string.c~:		return -1;
string.c~:	return -1;
string.c~:    return -1;
string.c~: *  call-seq:
string.c~: *  Equality---If <i>obj</i> is not a <code>String</code>, returns
string.c~: * call-seq:
string.c~: *  call-seq:
string.c~: *     str <=> other_str   => -1, 0, +1
string.c~: *  Comparison---Returns -1 if <i>other_str</i> is greater than, 0 if
string.c~: *  <code>$=</code> allowed case-insensitive comparisons; this is now deprecated
string.c~: *     "abcdef" <=> "abcdefg"   #=> -1
string.c~:		return rb_funcall(LONG2FIX(0), '-', 1, tmp);
string.c~:	    result = -FIX2LONG(tmp);
string.c~: *  call-seq:
string.c~: *     str.casecmp(other_str)   => -1, 0, +1
string.c~: *  Case-insensitive version of <code>String#<=></code>.
string.c~: *     "abcdef".casecmp("abcdefg")   #=> -1
string.c~:                    return INT2FIX(c1 < c2 ? -1 : 1);
string.c~:                    return INT2FIX(c1 < c2 ? -1 : 1);
string.c~:                    return INT2FIX(r < 0 ? -1 : 1);
string.c~:                    return INT2FIX(l1 < l2 ? -1 : 1);
string.c~:    return INT2FIX(-1);
string.c~:	return -1;
string.c~:	if (offset < 0) return -1;
string.c~:    if (len - offset < slen) return -1;
string.c~:    len = RSTRING_LEN(str) - offset;
string.c~:	if ((len -= t - s) <= 0) return -1;
string.c~:	offset += t - s;
string.c~: *  call-seq:
string.c~: *     "hello".index(/[aeiou]/, -3)   #=> 4
string.c~:    if (pos == -1) return Qnil;
string.c~:	return -1;
string.c~:    if (len < slen) return -1;
string.c~:    if (len - pos < slen) {
string.c~:	pos = len - slen;
string.c~:	if (!s) return -1;
string.c~:	pos--;
string.c~:    return -1;
string.c~: *  call-seq:
string.c~: *  string to end the search---characters beyond this point will not be
string.c~: *     "hello".rindex(/[aeiou]/, -2)   #=> 1
string.c~:	if (!RREGEXP(sub)->ptr || RREGEXP_SRC_LEN(sub)) {
string.c~: *  call-seq:
string.c~: *  Match---If <i>obj</i> is a <code>Regexp</code>, use it as a pattern to match
string.c~: *  call-seq:
string.c~:        for (i = len-1; 0 <= i && (unsigned char)p[i] == 0xff; i--)
string.c~:                memset(p+l, 0xff, len-l);
string.c~:        if (MBCLEN_INVALID_P(l) && i < len-1) {
string.c~:            for (len2 = len-1; 0 < len2; len2--) {
string.c~:            memset(p+len2+1, 0xff, len-(len2+1));
string.c~:        for (i = len-1; 0 <= i && (unsigned char)p[i] == 0; i--)
string.c~:        --((unsigned char*)p)[i];
string.c~:                memset(p+l, 0, len-l);
string.c~:        if (MBCLEN_INVALID_P(l) && i < len-1) {
string.c~:            for (len2 = len-1; 0 < len2; len2--) {
string.c~:            memset(p+len2+1, 0, len-(len2+1));
string.c~:  When NEIGHBOR_WRAPPED, carried-out letter is stored into carry.
string.c~: *  call-seq:
string.c~:    int c = -1;
string.c~:        carry_pos = s - sbeg;
string.c~:    if (c == -1) {		/* str contains no alnum */
string.c~:            carry_pos = s - sbeg;
string.c~:    memmove(s + carry_len, s, RSTRING_LEN(str) - carry_pos);
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~:	if (rb_str_index(str, indx, 0) != -1)
string.c~: *  call-seq:
string.c~: *  Element Reference---If passed a single <code>Fixnum</code>, returns a
string.c~: *     a[-3,2]                #=> "er"
string.c~: *     a[-4..-2]              #=> "her"
string.c~: *     a[12..-1]              #=> nil
string.c~: *     a[-2..-4]              #=> ""
string.c~:    nlen = olen - len;
string.c~:	int fl = (RBASIC(str)->flags & (STR_NOEMBED|ELTS_SHARED));
string.c~:	ptr = RSTRING(str)->as.ary;
string.c~:	ptr = RSTRING(str)->as.heap.ptr += len;
string.c~:	RSTRING(str)->as.heap.len = nlen;
string.c~:	RESIZE_CAPA(str, RSTRING_LEN(str) + RSTRING_LEN(val) - len + 1);
string.c~:		RSTRING_LEN(str) - (beg + len));
string.c~:	MEMZERO(RSTRING_PTR(str) + RSTRING_LEN(str), char, -len);
string.c~:    STR_SET_LEN(str, RSTRING_LEN(str) + RSTRING_LEN(val) - len);
string.c~:	if (-beg > slen) {
string.c~:	len = slen - beg;
string.c~:    beg = p - RSTRING_PTR(str);	/* physical position */
string.c~:    len = e - p;		/* physical length */
string.c~:    if (nth >= regs->num_regs) {
string.c~:	if (-nth >= regs->num_regs) {
string.c~:	nth += regs->num_regs;
string.c~:    if (start == -1) {
string.c~:    len = end - start;
string.c~: *  call-seq:
string.c~: *  Element Assignment---Replaces some or all of the content of <i>str</i>. The
string.c~: *  call-seq:
string.c~: *     "abcd".insert(-3, 'X')   #=> "abXcd"
string.c~: *     "abcd".insert(-1, 'X')   #=> "abcdX"
string.c~:    if (pos == -1) {
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~:                repl = rb_hash_aref(hash, rb_str_subseq(str, beg0, end0 - beg0));
string.c~:			       RSTRING_LEN(str)-end0, str_enc) != ENC_CODERANGE_7BIT) {
string.c~:	plen = end0 - beg0;
string.c~:	    RESIZE_CAPA(str, RSTRING_LEN(str) + RSTRING_LEN(repl) - plen);
string.c~:		    RSTRING_LEN(str) - beg0 - plen);
string.c~:	STR_SET_LEN(str, RSTRING_LEN(str) + RSTRING_LEN(repl) - plen);
string.c~: *  call-seq:
string.c~:                val = rb_hash_aref(hash, rb_str_subseq(str, BEG(0), END(0) - BEG(0)));
string.c~:	    if (val == dest) { 	/* paranoid check [ruby-dev:24827] */
string.c~:	len = beg - offset;	/* copy pre-match substr */
string.c~:        rb_enc_str_buf_cat(dest, cp, RSTRING_LEN(str) - offset, str_enc);
string.c~:	RBASIC(dest)->klass = rb_obj_class(str);
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~:	RSTRING(str)->as.heap.len = len;
string.c~:	RSTRING(str)->as.heap.ptr = RSTRING_PTR(str2);
string.c~:	RSTRING(str)->as.heap.aux.shared = RSTRING(str2)->as.heap.aux.shared;
string.c~: *  call-seq:
string.c~: *     string.clear    ->  string
string.c~: *  call-seq:
string.c~: *     string.chr    ->  string
string.c~: *  Returns a one-character string at the beginning of the string.
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~:    if (pos < -RSTRING_LEN(str) || RSTRING_LEN(str) <= pos)
string.c~: *  call-seq:
string.c~:		*--p = *s++;
string.c~:		p -= clen;
string.c~: *  call-seq:
string.c~:	    e = RSTRING_END(str) - 1;
string.c~: 		*e-- = c;
string.c~: *  call-seq:
string.c~:    if (i == -1) return Qfalse;
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~: * call-seq:
string.c~:	    rb_enc_str_buf_cat(result, p-n, n, enc);
string.c~:            for (q = p-n; q < p; q++) {
string.c~: *  call-seq:
string.c~:		    int n = rb_enc_precise_mbclen(p-1, pend, enc) - 1;
string.c~:			int cc = rb_enc_codepoint(p-1, pend, enc);
string.c~:	len += strlen(enc->name);
string.c~:		int n = rb_enc_precise_mbclen(p-1, pend, enc) - 1;
string.c~:		    int cc = rb_enc_codepoint(p-1, pend, enc);
string.c~:	sprintf(q, ".force_encoding(\"%s\")", enc->name);
string.c~: *  call-seq:
string.c~:		*s = 'A' + (c - 'a');
string.c~:		    *s = 'A' + (c - 'a');
string.c~: *  call-seq:
string.c~: *  uppercase counterparts. The operation is locale insensitive---only
string.c~: *  call-seq:
string.c~:		*s = 'a' + (c - 'A');
string.c~:		    *s = 'a' + (c - 'A');
string.c~: *  call-seq:
string.c~: *  lowercase counterparts. The operation is locale insensitive---only
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~: *  call-seq: 
string.c~: *  call-seq:
string.c~:	if (!t->gen) {
string.c~:	    if (t->p == t->pend) return -1;
string.c~:	    if (t->p < t->pend - 1 && *t->p == '\\') {
string.c~:		t->p++;
string.c~:	    t->now = rb_enc_codepoint(t->p, t->pend, enc);
string.c~:	    t->p += rb_enc_codelen(t->now, enc);
string.c~:	    if (t->p < t->pend - 1 && *t->p == '-') {
string.c~:		t->p++;
string.c~:		if (t->p < t->pend) {
string.c~:		    unsigned int c = rb_enc_codepoint(t->p, t->pend, enc);
string.c~:		    t->p += rb_enc_codelen(c, enc);
string.c~:		    if (t->now > c) continue;
string.c~:		    t->gen = 1;
string.c~:		    t->max = c;
string.c~:	    return t->now;
string.c~:	else if (++t->now < t->max) {
string.c~:	    return t->now;
string.c~:	    t->gen = 0;
string.c~:	    return t->max;
string.c~:    const unsigned int errc = -1;
string.c~:	int offset, save = -1;
string.c~:	    if (c != -1) {
string.c~:		save = -1;
string.c~:	    while (t - buf + tlen >= max) {
string.c~:		offset = t - buf;
string.c~:	RSTRING(str)->as.heap.ptr = buf;
string.c~:	RSTRING(str)->as.heap.len = t - buf;
string.c~:	RSTRING(str)->as.heap.aux.capa = max;
string.c~:	    while (t - buf + tlen >= max) {
string.c~:		offset = t - buf;
string.c~:	    xfree(RSTRING(str)->as.heap.ptr);
string.c~:	RSTRING(str)->as.heap.ptr = buf;
string.c~:	RSTRING(str)->as.heap.len = t - buf;
string.c~:	RSTRING(str)->as.heap.aux.capa = max;
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~: *  strings may use the c1--c2 notation to denote ranges of characters, and
string.c~: *     "hello".tr('a-y', 'b-z')    #=> "ifmmp"
string.c~:    const unsigned int errc = -1;
string.c~: *  call-seq:
string.c~:    STR_SET_LEN(str, t - RSTRING_PTR(str));
string.c~: *  call-seq:
string.c~: *     "hello".delete "ej-m"          #=> "ho"
string.c~: *  call-seq:
string.c~:    save = -1;
string.c~:    if (t - RSTRING_PTR(str) != RSTRING_LEN(str)) {
string.c~:	STR_SET_LEN(str, t - RSTRING_PTR(str));
string.c~: *  call-seq:
string.c~: *     "putters shoot balls".squeeze("m-z")   #=> "puters shot balls"
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~: *  negated. The sequence c1--c2 means all characters between c1 and c2.
string.c~: *     a.count "ej-m"          #=> 4
string.c~: *  call-seq:
string.c~: *  pattern matches. Whenever the pattern matches a zero-length string,
string.c~: *     "1,2,,3,4,,".split(',', -4)     #=> ["1", "2", "", "3", "4", "", ""]
string.c~:		/* Special case - split into chars */
string.c~:		    beg = ptr - bptr;
string.c~:		    end = ptr - bptr;
string.c~:		    rb_ary_push(result, rb_str_subseq(str, beg, end-beg));
string.c~:		    beg = ptr - bptr;
string.c~:		    end = ptr - bptr;
string.c~:	       (end = rb_memsearch(sptr, slen, ptr, eptr - ptr, enc)) >= 0) {
string.c~:	    rb_ary_push(result, rb_str_subseq(str, ptr - RSTRING_PTR(str), end));
string.c~:	beg = ptr - RSTRING_PTR(str);
string.c~:		rb_ary_push(result, rb_str_subseq(str, beg, end-beg));
string.c~:	    for (idx=1; idx < regs->num_regs; idx++) {
string.c~:		if (BEG(idx) == -1) continue;
string.c~:		    tmp = rb_str_subseq(str, BEG(idx), END(idx)-BEG(idx));
string.c~:	    tmp = rb_str_subseq(str, beg, RSTRING_LEN(str)-beg);
string.c~:	       (tmp = RARRAY_PTR(result)[len-1], RSTRING_LEN(tmp) == 0))
string.c~: *  Document-method: lines
string.c~: *  call-seq:
string.c~: *  Document-method: each_line
string.c~: *  call-seq:
string.c~: *  block. If a zero-length record separator is supplied, the string is split
string.c~:	    p = memchr(p, '\n', pend - p);
string.c~:	    line = rb_str_new5(str, s, p - s);
string.c~:	    p -= n;
string.c~:	    line = rb_str_new5(str, s, p - s + (rslen ? rslen : n));
string.c~:	line = rb_str_new5(str, s, pend - s);
string.c~: *  Document-method: bytes
string.c~: *  call-seq:
string.c~: *  Document-method: each_byte
string.c~: *  call-seq:
string.c~: *  Document-method: chars
string.c~: *  call-seq:
string.c~: *  Document-method: each_char
string.c~: *  call-seq:
string.c~: *  Document-method: codepoints
string.c~: *  call-seq:
string.c~: *  Document-method: each_codepoint
string.c~: *  call-seq:
string.c~:    return p - beg;
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~:		pp = rb_enc_left_char_head(p, e-rb_enc_mbminlen(enc), e, enc);
string.c~:		pp = e - rb_enc_mbminlen(enc);
string.c~:		len = e - RSTRING_PTR(str);
string.c~:		if (RSTRING_PTR(str)[len-1] == '\n') {
string.c~:			RSTRING_PTR(str)[RSTRING_LEN(str)-1] == '\r') {
string.c~:		else if (RSTRING_PTR(str)[len-1] == '\r') {
string.c~:	while (len>0 && p[len-1] == '\n') {
string.c~:	    len--;
string.c~:	    if (len>0 && p[len-1] == '\r')
string.c~:		len--;
string.c~:    newline = RSTRING_PTR(rs)[rslen-1];
string.c~:    pp = e - rslen;
string.c~:    if (p[len-1] == newline &&
string.c~:	STR_SET_LEN(str, RSTRING_LEN(str) - rslen);
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~:	STR_SET_LEN(str, t-s);
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~:	while (s < t && ((c = *(t-1)) == '\0' || rb_enc_isspace(c, enc))) t--;
string.c~:	int len = t-RSTRING_PTR(str);
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~:	if (regs->num_regs == 1) {
string.c~:	result = rb_ary_new2(regs->num_regs);
string.c~:	for (i=1; i < regs->num_regs; i++) {
string.c~: *  call-seq:
string.c~:    long last = -1, prev = 0;
string.c~: *  call-seq:
string.c~: *     "-1234".hex    #=> -4660
string.c~: *  call-seq:
string.c~: *     "-377".oct      #=> -255
string.c~:    return rb_str_to_inum(str, -8, Qfalse);
string.c~: *  call-seq:
string.c~: *  Applies a one-way cryptographic hash to <i>str</i> by invoking the standard
string.c~: *  <code>[a-zA-Z0-9./]</code>.
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~: *  Return the <code>Integer</code> ordinal of a one-character string.
string.c~: *  call-seq:
string.c~: *  Returns a basic <em>n</em>-bit checksum of the characters in <i>str</i>,
string.c~: *  <i>str</i> modulo <code>2n - 1</code>. This is not a particularly good
string.c~:	    mod = rb_funcall(mod, '-', 1, INT2FIX(1));
string.c~:           sum &= (((unsigned long)1)<<bits)-1;
string.c~:    n = width - len;
string.c~:    rlen = n - llen;
string.c~:	    llen--;
string.c~:	    llen -= fclen;
string.c~:	    n = fp - f;
string.c~:	    rlen--;
string.c~:	    rlen -= fclen;
string.c~:	    n = fp - f;
string.c~:    STR_SET_LEN(res, p-RSTRING_PTR(res));
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~:					     RSTRING_LEN(str)-pos-RSTRING_LEN(sep)));
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~:	s = e - RSTRING_LEN(tmp);
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~: *    "\xc2\xa1".force_encoding("UTF-8").valid_encoding? => true
string.c~: *    "\xc2".force_encoding("UTF-8").valid_encoding? => false
string.c~: *    "\x80".force_encoding("UTF-8").valid_encoding? => false
string.c~: *  call-seq:
string.c~: *    "abc".force_encoding("UTF-8").ascii_only? => true
string.c~: *    "abc\u{6666}".force_encoding("UTF-8").ascii_only? => false
string.c~: * Document-class: Symbol
string.c~: *  call-seq:
string.c~: *  Equality---If <i>sym</i> and <i>obj</i> are exactly the same
string.c~: *  call-seq:
string.c~: *  call-seq:
string.c~: * call-seq:
string.c~:    return rb_funcall3(obj, (ID)sym, argc - 1, argv + 1);
string.c~: * call-seq:
string.c~:    rb_define_method(rb_cString, "initialize", rb_str_init, -1);
string.c~:    rb_define_method(rb_cString, "[]", rb_str_aref_m, -1);
string.c~:    rb_define_method(rb_cString, "[]=", rb_str_aset_m, -1);
string.c~:    rb_define_method(rb_cString, "match", rb_str_match_m, -1);
string.c~:    rb_define_method(rb_cString, "upto", rb_str_upto, -1);
string.c~:    rb_define_method(rb_cString, "index", rb_str_index_m, -1);
string.c~:    rb_define_method(rb_cString, "rindex", rb_str_rindex_m, -1);
string.c~:    rb_define_method(rb_cString, "to_i", rb_str_to_i, -1);
string.c~:    rb_define_method(rb_cString, "split", rb_str_split_m, -1);
string.c~:    rb_define_method(rb_cString, "lines", rb_str_each_line, -1);
string.c~:    rb_define_method(rb_cString, "start_with?", rb_str_start_with, -1);
string.c~:    rb_define_method(rb_cString, "end_with?", rb_str_end_with, -1);
string.c~:    rb_define_method(rb_cString, "ljust", rb_str_ljust, -1);
string.c~:    rb_define_method(rb_cString, "rjust", rb_str_rjust, -1);
string.c~:    rb_define_method(rb_cString, "center", rb_str_center, -1);
string.c~:    rb_define_method(rb_cString, "sub", rb_str_sub, -1);
string.c~:    rb_define_method(rb_cString, "gsub", rb_str_gsub, -1);
string.c~:    rb_define_method(rb_cString, "chomp", rb_str_chomp, -1);
string.c~:    rb_define_method(rb_cString, "sub!", rb_str_sub_bang, -1);
string.c~:    rb_define_method(rb_cString, "gsub!", rb_str_gsub_bang, -1);
string.c~:    rb_define_method(rb_cString, "chomp!", rb_str_chomp_bang, -1);
string.c~:    rb_define_method(rb_cString, "delete", rb_str_delete, -1);
string.c~:    rb_define_method(rb_cString, "squeeze", rb_str_squeeze, -1);
string.c~:    rb_define_method(rb_cString, "count", rb_str_count, -1);
string.c~:    rb_define_method(rb_cString, "delete!", rb_str_delete_bang, -1);
string.c~:    rb_define_method(rb_cString, "squeeze!", rb_str_squeeze_bang, -1);
string.c~:    rb_define_method(rb_cString, "each_line", rb_str_each_line, -1);
string.c~:    rb_define_method(rb_cString, "sum", rb_str_sum, -1);
string.c~:    rb_define_method(rb_cString, "slice", rb_str_aref_m, -1);
string.c~:    rb_define_method(rb_cString, "slice!", rb_str_slice_bang, -1);
string.c~:    rb_define_variable("$-F", &rb_fs);
string.c~:    rb_define_method(rb_cSymbol, "p-match", patern_equal,1); 
string.c~:    rb_define_method(rb_cSymbol, "[]", sym_aref, -1);
string.c~:    rb_define_method(rb_cSymbol, "slice", sym_aref, -1);
ãã¤ããªã¼ã»ãã¡ã¤ã«string.oã¯ä¸è´ãã¾ãã
ãã¤ããªã¼ã»ãã¡ã¤ã«strlcat.oã¯ä¸è´ãã¾ãã
ãã¤ããªã¼ã»ãã¡ã¤ã«strlcpy.oã¯ä¸è´ãã¾ãã
struct.c:  struct.c -
struct.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
struct.c: *  call-seq:
struct.c:	rb_make_metaclass(nstr, RBASIC(klass)->klass);
struct.c:    rb_define_singleton_method(nstr, "new", rb_class_new_instance, -1);
struct.c:    rb_define_singleton_method(nstr, "[]", rb_class_new_instance, -1);
struct.c:	rb_make_metaclass(klass, RBASIC(super)->klass);
struct.c: *  call-seq:
struct.c:	rb_mem_clear(RSTRUCT_PTR(self)+argc, n-argc);
struct.c:        RBASIC(st)->flags &= ~RSTRUCT_EMBED_LEN_MASK;
struct.c:        RBASIC(st)->flags |= n << RSTRUCT_EMBED_LEN_SHIFT;
struct.c:	rb_mem_clear(st->as.ary, n);
struct.c:	st->as.heap.ptr = ALLOC_N(VALUE, n);
struct.c:	rb_mem_clear(st->as.heap.ptr, n);
struct.c:	st->as.heap.len = n;
struct.c: *  call-seq:
struct.c: *  call-seq:
struct.c: * call-seq:
struct.c: *  call-seq:
struct.c: *  call-seq:
struct.c: *  Attribute Reference---Returns the value of the instance variable
struct.c: *  named by <i>symbol</i>, or indexed (0..length-1) by
struct.c: *  call-seq:
struct.c: *  Attribute Assignment---Assigns to the instance variable named by
struct.c: * call-seq:
struct.c: *      a.values_at(-1, -3, -5, -7)
struct.c: *  call-seq:
struct.c: *  call-seq:
struct.c: *  Equality---Returns <code>true</code> if <i>other_struct</i> is
struct.c: * call-seq:
struct.c: * code-seq:
struct.c: *  call-seq:
struct.c:    rb_define_singleton_method(rb_cStruct, "new", rb_struct_s_def, -1);
struct.c:    rb_define_method(rb_cStruct, "initialize", rb_struct_initialize_m, -1);
struct.c:    rb_define_method(rb_cStruct, "select", rb_struct_select, -1);
struct.c:    rb_define_method(rb_cStruct, "values_at", rb_struct_values_at, -1);
ãã¤ããªã¼ã»ãã¡ã¤ã«struct.oã¯ä¸è´ãã¾ãã
thread.c:  thread.c -
thread.c:  Copyright (C) 2004-2007 Koichi Sasada
thread.c:------------------------------------------------------------------------
thread.c:------------------------------------------------------------------------
thread.c:#define RUBY_THREAD_PRIORITY_MIN -3
thread.c:  native_mutex_unlock(&_th_stored->vm->global_vm_lock)
thread.c:  native_mutex_lock(&_th_stored->vm->global_vm_lock); \
thread.c:  printf(POSITION_FORMAT"%p - %s" POSITION_ARGS, GetCurrentThreadId(), buf); \
thread.c:  printf(POSITION_FORMAT"%#"PRIxVALUE" - %s" POSITION_ARGS, (VALUE)pthread_self(), buf); \
thread.c:    native_mutex_lock(&th->interrupt_lock);
thread.c:    if (th->interrupt_flag) {
thread.c:	native_mutex_unlock(&th->interrupt_lock);
thread.c:	if (old) *old = th->unblock;
thread.c:	th->unblock.func = func;
thread.c:	th->unblock.arg = arg;
thread.c:    native_mutex_unlock(&th->interrupt_lock);
thread.c:    native_mutex_lock(&th->interrupt_lock);
thread.c:    th->unblock = *old;
thread.c:    native_mutex_unlock(&th->interrupt_lock);
thread.c:    native_mutex_lock(&th->interrupt_lock);
thread.c:    if (th->unblock.func) {
thread.c:	(th->unblock.func)(th->unblock.arg);
thread.c:    native_mutex_unlock(&th->interrupt_lock);
thread.c:	th->thrown_errinfo = eTerminateSignal;
thread.c:	th->status = THREAD_TO_KILL;
thread.c:    rb_vm_t *vm = th->vm;
thread.c:    if (vm->main_thread != th) {
thread.c:	       (void *)vm->main_thread, (void *)th);
thread.c:    if (th->keeping_mutexes) {
thread.c:	rb_mutex_unlock_all(th->keeping_mutexes, GET_THREAD());
thread.c:    st_foreach(vm->living_threads, terminate_i, (st_data_t)th);
thread.c:    th->status = THREAD_KILLED;
thread.c:    th->machine_stack_start = th->machine_stack_end = 0;
thread.c:    th->machine_register_stack_start = th->machine_register_stack_end = 0;
thread.c:    if (th->keeping_mutexes) {
thread.c:	rb_mutex_unlock_all(th->keeping_mutexes, th);
thread.c:	th->keeping_mutexes = NULL;
thread.c:    VALUE args = th->first_args;
thread.c:    th->machine_stack_start = stack_start;
thread.c:    th->machine_register_stack_start = register_stack_start;
thread.c:    native_mutex_lock(&th->vm->global_vm_lock);
thread.c:		if (th->first_proc) {
thread.c:		    GetProcPtr(th->first_proc, proc);
thread.c:		    th->errinfo = Qnil;
thread.c:		    th->local_lfp = proc->block.lfp;
thread.c:		    th->local_svar = Qnil;
thread.c:		    th->value = rb_vm_invoke_proc(th, proc, proc->block.self,
thread.c:		    th->value = (*th->first_func)((void *)th->first_args);
thread.c:	    errinfo = th->errinfo;
thread.c:		if (th->safe_level >= 4) {
thread.c:		    th->errinfo = rb_exc_new3(rb_eSecurityError,
thread.c:					      rb_sprintf("Insecure exit at level %d", th->safe_level));
thread.c:	    else if (th->safe_level < 4 &&
thread.c:		     (th->vm->thread_abort_on_exception ||
thread.c:		      th->abort_on_exception || RTEST(ruby_debug))) {
thread.c:	    th->value = Qnil;
thread.c:	th->status = THREAD_KILLED;
thread.c:	main_th = th->vm->main_thread;
thread.c:	if (th->locking_mutex != Qfalse) {
thread.c:		   (void *)th, th->locking_mutex);
thread.c:	    st_delete_wrap(th->vm->living_threads, th->self);
thread.c:	join_th = th->join_list_head;
thread.c:	    switch (join_th->status) {
thread.c:		join_th->status = THREAD_RUNNABLE;
thread.c:	    join_th = join_th->join_list_next;
thread.c:	if (!th->root_fiber) {
thread.c:	    rb_thread_recycle_stack_release(th->stack);
thread.c:	    th->stack = 0;
thread.c:    if (th != main_th) rb_check_deadlock(th->vm);
thread.c:    if (th->vm->main_thread == th) {
thread.c:    native_mutex_unlock(&th->vm->global_vm_lock);
thread.c:    if (OBJ_FROZEN(GET_THREAD()->thgroup)) {
thread.c:    th->first_func = fn;
thread.c:    th->first_proc = fn ? Qfalse : rb_block_proc();
thread.c:    th->first_args = args; /* GC: shouldn't put before above line */
thread.c:    th->priority = GET_THREAD()->priority;
thread.c:    th->thgroup = GET_THREAD()->thgroup;
thread.c:    native_mutex_initialize(&th->interrupt_lock);
thread.c:    st_insert(th->vm->living_threads, thval, (st_data_t) th->thread_id);
thread.c:    if (!th->first_args) {
thread.c:	rb_raise(rb_eThreadError, "uninitialized thread - check `%s#initialize'",
thread.c: *  call-seq:
thread.c:    if (th->first_args) {
thread.c:	VALUE proc = th->first_proc, line, loc;
thread.c:	    rb_raise(rb_eThreadError, "already initialized thread - %s",
thread.c:        rb_raise(rb_eThreadError, "already initialized thread - %s:%d",
thread.c:    rb_thread_t *target_th = p->target, *th = p->waiting;
thread.c:    if (target_th->status != THREAD_KILLED) {
thread.c:	rb_thread_t **pth = &target_th->join_list_head;
thread.c:		*pth = th->join_list_next;
thread.c:	    pth = &(*pth)->join_list_next;
thread.c:    rb_thread_t *target_th = p->target, *th = p->waiting;
thread.c:    double now, limit = p->limit;
thread.c:    while (target_th->status != THREAD_KILLED) {
thread.c:	if (p->forever) {
thread.c:			     (void *)target_th->thread_id);
thread.c:	    sleep_wait_for_interrupt(th, limit - now);
thread.c:		     (void *)target_th->thread_id);
thread.c:    thread_debug("thread_join (thid: %p)\n", (void *)target_th->thread_id);
thread.c:    if (target_th->status != THREAD_KILLED) {
thread.c:	th->join_list_next = target_th->join_list_head;
thread.c:	target_th->join_list_head = th;
thread.c:		 (void *)target_th->thread_id);
thread.c:    if (target_th->errinfo != Qnil) {
thread.c:	VALUE err = target_th->errinfo;
thread.c:	else if (TYPE(target_th->errinfo) == T_NODE) {
thread.c:    return target_th->self;
thread.c: *  call-seq:
thread.c: *  call-seq:
thread.c:    return th->value;
thread.c:    time.tv_usec = (int)((d - (int)d) * 1e6);
thread.c:	time.tv_sec -= 1;
thread.c:    enum rb_thread_status prev_status = th->status;
thread.c:    th->status = deadlockable ? THREAD_STOPPED_FOREVER : THREAD_STOPPED;
thread.c:	    th->vm->sleeper++;
thread.c:	    rb_check_deadlock(th->vm);
thread.c:	    th->vm->sleeper--;
thread.c:    } while (th->status == THREAD_STOPPED_FOREVER);
thread.c:    th->status = prev_status;
thread.c:	tp->tv_sec = ts.tv_sec;
thread.c:	tp->tv_usec = ts.tv_nsec / 1000;
thread.c:    enum rb_thread_status prev_status = th->status;
thread.c:	to.tv_usec -= 1000000;
thread.c:    th->status = THREAD_STOPPED;
thread.c:	tv.tv_sec = to.tv_sec - tvn.tv_sec;
thread.c:	if ((tv.tv_usec = to.tv_usec - tvn.tv_usec) < 0) {
thread.c:	    --tv.tv_sec;
thread.c:    } while (th->status == THREAD_STOPPED);
thread.c:    th->status = prev_status;
thread.c:        return (double)tp.tv_sec + (double)tp.tv_nsec * 1e-9;
thread.c:        return (double)tv.tv_sec + (double)tv.tv_usec * 1e-6;
thread.c:    return GET_THREAD()->exec_signal != 0;
thread.c:	native_mutex_unlock(&th->vm->global_vm_lock);
thread.c:	native_mutex_lock(&th->vm->global_vm_lock);
thread.c:    region->prev_status = th->status;
thread.c:    th->blocking_region_buffer = region;
thread.c:    set_unblock_function(th, func, arg, &region->oldubf);
thread.c:    th->status = THREAD_STOPPED;
thread.c:    native_mutex_unlock(&th->vm->global_vm_lock);
thread.c:    native_mutex_lock(&th->vm->global_vm_lock);
thread.c:    th->blocking_region_buffer = 0;
thread.c:    reset_unblock_function(th, &region->oldubf);
thread.c:    if (th->status == THREAD_STOPPED) {
thread.c:	th->status = region->prev_status;
thread.c: * rb_thread_blocking_region - permit concurrent/parallel execution.
thread.c: *   VM-shutdown request, and so on), `ubf()' is called (`ubf()' means
thread.c: *   "un-blocking function").  `ubf()' should interrupt `func()' execution.
thread.c: *   There are built-in ubfs and you can specify these ubfs.
thread.c: *   However, we can not guarantee our built-in ubfs interrupt
thread.c: *     * rb_thread_interrupted() - check interrupt flag
thread.c: *     * ruby_xalloc(), ruby_xrealloc(), ruby_xfree() -
thread.c: * rb_thread_call_with_gvl - re-enter into Ruby world while releasing GVL.
thread.c: *       NON-Ruby thread to Ruby thread.
thread.c:	fprintf(stderr, "[BUG] rb_thread_call_with_gvl() is called by non-ruby thread\n");
thread.c:    brb = (struct rb_blocking_region_buffer *)th->blocking_region_buffer;
thread.c:    prev_unblock = th->unblock;
thread.c: * ruby_thread_has_gvl_p - check if current native thread has GVL.
thread.c:    if (th && th->blocking_region_buffer == 0) {
thread.c: *  call-seq:
thread.c:    if (GET_VM()->main_thread == th) {
thread.c:	while (rb_signal_buff_size() && !th->exec_signal) native_thread_yield();
thread.c:    if (th->raised_flag) return;
thread.c:    while (th->interrupt_flag) {
thread.c:	enum rb_thread_status status = th->status;
thread.c:	int timer_interrupt = th->interrupt_flag & 0x01;
thread.c:	int finalizer_interrupt = th->interrupt_flag & 0x04;
thread.c:	th->status = THREAD_RUNNABLE;
thread.c:	th->interrupt_flag = 0;
thread.c:	if (th->exec_signal) {
thread.c:	    int sig = th->exec_signal;
thread.c:	    th->exec_signal = 0;
thread.c:	if (th->thrown_errinfo) {
thread.c:	    VALUE err = th->thrown_errinfo;
thread.c:	    th->thrown_errinfo = 0;
thread.c:		th->errinfo = INT2FIX(TAG_FATAL);
thread.c:	th->status = status;
thread.c:	    EXEC_EVENT_HOOK(th, RUBY_EVENT_SWITCH, th->cfp->self, 0, 0);
thread.c:	    if (th->slice > 0) {
thread.c:		th->slice--;
thread.c:		if (th->slice < 0) {
thread.c:		    th->slice++;
thread.c:		    th->slice = th->priority;
thread.c:    if (th->thrown_errinfo != 0 || th->raised_flag) {
thread.c:    th->thrown_errinfo = exc;
thread.c:    rb_thread_raise(2, argv, th->vm->main_thread);
thread.c:    rb_thread_raise(2, argv, th->vm->main_thread);
thread.c:    th->raised_flag = 0;
thread.c:    th->raised_flag = 0;
thread.c:    th->errinfo = sysstack_error;
thread.c:    if (th->raised_flag & RAISED_EXCEPTION) {
thread.c:    th->raised_flag |= RAISED_EXCEPTION;
thread.c:    if (!(th->raised_flag & RAISED_EXCEPTION)) {
thread.c:    th->raised_flag &= ~RAISED_EXCEPTION;
thread.c: *  call-seq:
thread.c: *  call-seq:
thread.c:    if (th != GET_THREAD() && th->safe_level < 4) {
thread.c:    if (th->status == THREAD_TO_KILL || th->status == THREAD_KILLED) {
thread.c:    if (th == th->vm->main_thread) {
thread.c:    thread_debug("rb_thread_kill: %p (%p)\n", (void *)th, (void *)th->thread_id);
thread.c:    th->thrown_errinfo = eKillSignal;
thread.c:    th->status = THREAD_TO_KILL;
thread.c: *  call-seq:
thread.c: *  call-seq:
thread.c:    return rb_thread_kill(GET_THREAD()->self);
thread.c: *  call-seq:
thread.c:    if (th->status == THREAD_KILLED) {
thread.c:    if (th->status != THREAD_TO_KILL) {
thread.c:	th->status = THREAD_RUNNABLE;
thread.c: *  call-seq:
thread.c: *  call-seq:
thread.c:    switch (th->status) {
thread.c:	rb_ary_push(ary, th->self);
thread.c: *  call-seq:
thread.c:    st_foreach(GET_THREAD()->vm->living_threads, thread_list_i, ary);
thread.c:    return GET_THREAD()->self;
thread.c: *  call-seq:
thread.c:    return GET_THREAD()->vm->main_thread->self;
thread.c: *  call-seq:
thread.c: *  command line option <code>-d</code> was specified) all threads will abort
thread.c:    return GET_THREAD()->vm->thread_abort_on_exception ? Qtrue : Qfalse;
thread.c: *  call-seq:
thread.c:    GET_THREAD()->vm->thread_abort_on_exception = RTEST(val);
thread.c: *  call-seq:
thread.c: *  Returns the status of the thread-local ``abort on exception'' condition for
thread.c:    return th->abort_on_exception ? Qtrue : Qfalse;
thread.c: *  call-seq:
thread.c:    th->abort_on_exception = RTEST(val);
thread.c: *  call-seq:
thread.c:    group = th->thgroup;
thread.c:    return th->status == THREAD_KILLED;
thread.c: *  call-seq:
thread.c:	if (!NIL_P(th->errinfo) && !FIXNUM_P(th->errinfo)
thread.c:    return rb_str_new2(thread_status_name(th->status));
thread.c: *  call-seq:
thread.c: *  call-seq:
thread.c:    if (th->status == THREAD_STOPPED || th->status == THREAD_STOPPED_FOREVER)
thread.c: *  call-seq:
thread.c: *  Returns the safe level in effect for <i>thr</i>. Setting thread-local safe
thread.c:    return INT2NUM(th->safe_level);
thread.c: * call-seq:
thread.c:    status = thread_status_name(th->status);
thread.c:    if (!th->local_storage) {
thread.c:    if (st_lookup(th->local_storage, id, &val)) {
thread.c: *  call-seq:
thread.c: *  Attribute Reference---Returns the value of a thread-local variable, using
thread.c:    if (!th->local_storage) {
thread.c:	th->local_storage = st_init_numtable();
thread.c:	st_delete_wrap(th->local_storage, id);
thread.c:    st_insert(th->local_storage, id, val);
thread.c: *  call-seq:
thread.c: *  Attribute Assignment---Sets or creates the value of a thread-local variable,
thread.c: *  call-seq:
thread.c: *  thread-local variable.
thread.c:    if (!th->local_storage) {
thread.c:    if (st_lookup(th->local_storage, id, 0)) {
thread.c:    return vm->living_threads->num_entries;
thread.c:    if (GET_THREAD()->vm->living_threads) {
thread.c:	num = vm_living_thread_num(GET_THREAD()->vm);
thread.c: *  call-seq:
thread.c: *  Returns an an array of the names of the thread-local variables (as Symbols).
thread.c:    if (th->local_storage) {
thread.c:	st_foreach(th->local_storage, thread_keys_i, ary);
thread.c: *  call-seq:
thread.c: *  initial main thread; higher-priority threads will run before
thread.c: *  lower-priority threads.
thread.c:    return INT2NUM(th->priority);
thread.c: *  call-seq:
thread.c: *  Sets the priority of <i>thr</i> to <i>integer</i>. Higher-priority threads
thread.c: *  will run before lower-priority threads.
thread.c: *     a.priority = -1
thread.c: *     b.priority = -2
thread.c:    th->priority = NUM2INT(prio);
thread.c:    th->priority = priority;
thread.c:    th->slice = priority;
thread.c:    return INT2NUM(th->priority);
thread.c: * - Linux 2.2.12 (?)
thread.c: * - NetBSD 1.2 (src/sys/kern/sys_generic.c:1.25)
thread.c: *   http://netbsd.gw.com/cgi-bin/man-cgi?select++NetBSD-4.0
thread.c: * - FreeBSD 2.2 (src/sys/kern/sys_generic.c:1.19)
thread.c: * - OpenBSD 2.0 (src/sys/kern/sys_generic.c:1.4)
thread.c: *   http://www.openbsd.org/cgi-bin/man.cgi?query=select&manpath=OpenBSD+4.4
thread.c: * - HP-UX documents how to allocate fd_set dynamically.
thread.c: *   http://docs.hp.com/en/B2355-60105/select.2.html
thread.c: * - Solaris 8 has select_large_fdset
thread.c: * rb_fd_set may re-allocates bitmap.
thread.c:    fds->maxfd = 0;
thread.c:    fds->fdset = ALLOC(fd_set);
thread.c:    FD_ZERO(fds->fdset);
thread.c:    if (fds->fdset) xfree(fds->fdset);
thread.c:    fds->maxfd = 0;
thread.c:    fds->fdset = 0;
thread.c:    if (fds->fdset) {
thread.c:	MEMZERO(fds->fdset, fd_mask, howmany(fds->maxfd, NFDBITS));
thread.c:	FD_ZERO(fds->fdset);
thread.c:    int o = howmany(fds->maxfd, NFDBITS) * sizeof(fd_mask);
thread.c:	fds->fdset = realloc(fds->fdset, m);
thread.c:	memset((char *)fds->fdset + o, 0, m - o);
thread.c:    if (n >= fds->maxfd) fds->maxfd = n + 1;
thread.c:    FD_SET(n, fds->fdset);
thread.c:    if (n >= fds->maxfd) return;
thread.c:    FD_CLR(n, fds->fdset);
thread.c:    if (n >= fds->maxfd) return 0;
thread.c:    return FD_ISSET(n, fds->fdset) != 0; /* "!= 0" avoids FreeBSD PR 91421 */
thread.c:    dst->maxfd = max;
thread.c:    dst->fdset = realloc(dst->fdset, size);
thread.c:    memcpy(dst->fdset, src, size);
thread.c:        rb_fd_resize(n - 1, readfds);
thread.c:        rb_fd_resize(n - 1, writefds);
thread.c:        rb_fd_resize(n - 1, exceptfds);
thread.c:    set->capa = FD_SETSIZE;
thread.c:    set->fdset = ALLOC(fd_set);
thread.c:    FD_ZERO(set->fdset);
thread.c:    xfree(set->fdset);
thread.c:    set->fdset = NULL;
thread.c:    set->capa = 0;
thread.c:    for (i = 0; i < set->fdset->fd_count; i++) {
thread.c:        if (set->fdset->fd_array[i] == s) {
thread.c:    if (set->fdset->fd_count >= set->capa) {
thread.c:	set->capa = (set->fdset->fd_count / FD_SETSIZE + 1) * FD_SETSIZE;
thread.c:	set->fdset = xrealloc(set->fdset, sizeof(unsigned int) + sizeof(SOCKET) * set->capa);
thread.c:    set->fdset->fd_array[set->fdset->fd_count++] = s;
thread.c:    long d = (a->tv_sec - b->tv_sec);
thread.c:    return (d != 0) ? d : (a->tv_usec - b->tv_usec);
thread.c:    while (rest->tv_usec < wait->tv_usec) {
thread.c:	if (rest->tv_sec <= wait->tv_sec) {
thread.c:	rest->tv_sec -= 1;
thread.c:	rest->tv_usec += 1000 * 1000;
thread.c:    rest->tv_sec -= wait->tv_sec;
thread.c:    rest->tv_usec -= wait->tv_usec;
thread.c:	limit = (double)start_time.tv_sec + (double)start_time.tv_usec*1e-6;
thread.c:	limit += (double)timeout->tv_sec+(double)timeout->tv_usec*1e-6;
thread.c:		} while (__th->interrupt_flag == 0);
thread.c:		double d = limit - timeofday();
thread.c:		wait_rest.tv_usec = (long)((d-(double)wait_rest.tv_sec)*1e6);
thread.c:    SET_MACHINE_STACK_END(&th->machine_stack_end);
thread.c:    th->machine_register_stack_end = rb_ia64_bsp();
thread.c:    setjmp(th->machine_regs);
thread.c:    rb_vm_t *vm = GET_VM(); /* TODO: fix me for Multi-VM */
thread.c:    RUBY_VM_SET_TIMER_INTERRUPT(vm->running_thread);
thread.c:    mth = vm->main_thread;
thread.c:    if (!mth->exec_signal && (sig = rb_get_next_signal()) > 0) {
thread.c:	enum rb_thread_status prev_status = mth->status;
thread.c:	mth->exec_signal = sig;
thread.c:	if (mth->status != THREAD_KILLED) mth->status = THREAD_RUNNABLE;
thread.c:	mth->status = prev_status;
thread.c:    if (vm->prove_profile.enable) {
thread.c:	rb_thread_t *th = vm->running_thread;
thread.c:	if (vm->during_gc) {
thread.c:    rb_vm_t *vm = th->vm;
thread.c:    VALUE thval = th->self;
thread.c:    vm->main_thread = th;
thread.c:    st_foreach(vm->living_threads, atfork, (st_data_t)th);
thread.c:    st_clear(vm->living_threads);
thread.c:    st_insert(vm->living_threads, thval, (st_data_t)th->thread_id);
thread.c:    vm->sleeper = 0;
thread.c: * Document-class: ThreadGroup
thread.c:    group = Data_Make_Struct(klass, struct thgroup, 0, -1, data);
thread.c:    data->enclosed = 0;
thread.c:    data->group = group;
thread.c:    VALUE ary = ((struct thgroup_list_params *)data)->ary;
thread.c:    VALUE group = ((struct thgroup_list_params *)data)->group;
thread.c:    if (th->thgroup == group) {
thread.c: *  call-seq:
thread.c:    st_foreach(GET_THREAD()->vm->living_threads, thgroup_list_i, (st_data_t) & param);
thread.c: *  call-seq:
thread.c:    data->enclosed = 1;
thread.c: *  call-seq:
thread.c:    if (data->enclosed)
thread.c: *  call-seq:
thread.c:    if (data->enclosed) {
thread.c:    if (!th->thgroup) {
thread.c:    if (OBJ_FROZEN(th->thgroup)) {
thread.c:    Data_Get_Struct(th->thgroup, struct thgroup, data);
thread.c:    if (data->enclosed) {
thread.c:    th->thgroup = group;
thread.c: *  Document-class: Mutex
thread.c:	if (mutex->th) {
thread.c:	    const char *err = mutex_unlock(mutex, mutex->th);
thread.c:	native_mutex_destroy(&mutex->lock);
thread.c:	native_cond_destroy(&mutex->cond);
thread.c:    native_mutex_initialize(&mutex->lock);
thread.c:    native_cond_initialize(&mutex->cond);
thread.c: *  call-seq:
thread.c: * call-seq:
thread.c:    return mutex->th ? Qtrue : Qfalse;
thread.c:    if (th->keeping_mutexes) {
thread.c:	mutex->next_mutex = th->keeping_mutexes;
thread.c:    th->keeping_mutexes = mutex;
thread.c: * call-seq:
thread.c:    native_mutex_lock(&mutex->lock);
thread.c:    if (mutex->th == 0) {
thread.c:	mutex->th = GET_THREAD();
thread.c:    native_mutex_unlock(&mutex->lock);
thread.c:    native_mutex_lock(&mutex->lock);
thread.c:    th->transition_for_lock = 0;
thread.c:    while (mutex->th || (mutex->th = th, 0)) {
thread.c:	mutex->cond_waiting++;
thread.c:	native_cond_wait(&mutex->cond, &mutex->lock);
thread.c:	mutex->cond_notified--;
thread.c:    th->transition_for_lock = 1;
thread.c:    native_mutex_unlock(&mutex->lock);
thread.c:    native_mutex_lock(&mutex->lock);
thread.c:    if (mutex->cond_waiting > 0) {
thread.c:	native_cond_broadcast(&mutex->cond);
thread.c:	mutex->cond_notified = mutex->cond_waiting;
thread.c:	mutex->cond_waiting = 0;
thread.c:    native_mutex_unlock(&mutex->lock);
thread.c: * call-seq:
thread.c:	if (mutex->th == GET_THREAD()) {
thread.c:	while (mutex->th != th) {
thread.c:	    enum rb_thread_status prev_status = th->status;
thread.c:	    th->status = THREAD_STOPPED_FOREVER;
thread.c:	    th->vm->sleeper++;
thread.c:	    th->locking_mutex = self;
thread.c:	    if (vm_living_thread_num(th->vm) == th->vm->sleeper) {
thread.c:	    th->transition_for_lock = 1;
thread.c:	    th->transition_for_lock = 0;
thread.c:	    th->locking_mutex = Qfalse;
thread.c:	    if (mutex->th && interrupted == 2) {
thread.c:		rb_check_deadlock(th->vm);
thread.c:	    if (th->status == THREAD_STOPPED_FOREVER) {
thread.c:		th->status = prev_status;
thread.c:	    th->vm->sleeper--;
thread.c:	    if (mutex->th == th) mutex_locked(th, self);
thread.c:    native_mutex_lock(&mutex->lock);
thread.c:    if (mutex->th == 0) {
thread.c:    else if (mutex->th != th) {
thread.c:	mutex->th = 0;
thread.c:	if (mutex->cond_waiting > 0) {
thread.c:	    native_cond_signal(&mutex->cond);
thread.c:	    mutex->cond_waiting--;
thread.c:	    mutex->cond_notified++;
thread.c:    native_mutex_unlock(&mutex->lock);
thread.c:	th_mutex = th->keeping_mutexes;
thread.c:	    th->keeping_mutexes = mutex->next_mutex;
thread.c:		tmp_mutex = th_mutex->next_mutex;
thread.c:		    th_mutex->next_mutex = tmp_mutex->next_mutex;
thread.c:	mutex->next_mutex = NULL;
thread.c: * call-seq:
thread.c:	mutexes = mutex->next_mutex;
thread.c:    end = time(0) - beg;
thread.c: * call-seq:
thread.c: * non-nil or forever.  Raises +ThreadError+ if +mutex+ wasn't locked by
thread.c: * call-seq:
thread.c: * Document-class: Barrier
thread.c:    if (m->th == GET_THREAD()) return Qfalse;
thread.c:    hook->func = func;
thread.c:    hook->flag = events;
thread.c:    hook->data = data;
thread.c:    rb_event_hook_t *hook = th->event_hooks;
thread.c:    rb_event_flag_t flag = th->event_flags & RUBY_EVENT_VM;
thread.c:	flag |= hook->flag;
thread.c:	hook = hook->next;
thread.c:    hook->next = th->event_hooks;
thread.c:    th->event_hooks = hook;
thread.c:	th->event_flags |= RUBY_EVENT_VM;
thread.c:	th->event_flags &= (~RUBY_EVENT_VM);
thread.c:    st_foreach(GET_VM()->living_threads, set_threads_event_flags_i, (st_data_t) flag);
thread.c:    for (; hook; hook = hook->next) {
thread.c:	if (flag & hook->flag) {
thread.c:	    (*hook->func)(flag, hook->data, self, id, klass);
thread.c:    const VALUE errinfo = th->errinfo;
thread.c:    const rb_event_flag_t wait_event = th->event_flags;
thread.c:	exec_event_hooks(th->event_hooks, flag, self, id, klass);
thread.c:	exec_event_hooks(th->vm->event_hooks, flag, self, id, klass);
thread.c:    th->errinfo = errinfo;
thread.c:    hook->next = vm->event_hooks;
thread.c:    vm->event_hooks = hook;
thread.c:	next = hook->next;
thread.c:	if (func == 0 || hook->func == func) {
thread.c:		prev->next = hook->next;
thread.c:		*root = hook->next;
thread.c:    return -1;
thread.c:    int ret = remove_event_hook(&th->event_hooks, func);
thread.c:    rb_event_hook_t *hook = vm->event_hooks;
thread.c:    int ret = remove_event_hook(&vm->event_hooks, func);
thread.c:    if (hook != NULL && vm->event_hooks == NULL) {
thread.c:    st_foreach(GET_VM()->living_threads, clear_trace_func_i, (st_data_t) 0);
thread.c: *  call-seq:
thread.c: *  invoked whenever an event occurs. Events are: <code>c-call</code>
thread.c: *  (call a C-language routine), <code>c-return</code> (return from a
thread.c: *  C-language routine), <code>call</code> (call a Ruby method),
thread.c: *	   printf "%8s %s:%-2d %10s %8s\n", event, file, line, id, classname
thread.c: *      c-call prog.rb:11        new    Class
thread.c: *      c-call prog.rb:11 initialize   Object
thread.c: *    c-return prog.rb:11 initialize   Object
thread.c: *    c-return prog.rb:11        new    Class
thread.c:	return "c-call";
thread.c:	return "c-return";
thread.c:    VALUE eventname = rb_str_new2(get_event_name(p->event));
thread.c:    if (p->event == RUBY_EVENT_C_CALL ||
thread.c:	p->event == RUBY_EVENT_C_RETURN) {
thread.c:	id = p->id;
thread.c:	klass = p->klass;
thread.c:	    klass = RBASIC(klass)->klass;
thread.c:    argv[4] = (p->self && srcfile) ? rb_binding_new() : Qnil;
thread.c:    return rb_proc_call_with_block(p->proc, 6, argv, Qnil);
thread.c:    if ((tracing = th->tracing) != 0 && !always) {
thread.c:	th->tracing = 1;
thread.c:    th->tracing = tracing;
thread.c:    rb_define_singleton_method(rb_cThread, "new", thread_s_new, -1);
thread.c:    rb_define_singleton_method(rb_cThread, "start", thread_start, -2);
thread.c:    rb_define_singleton_method(rb_cThread, "fork", thread_start, -2);
thread.c:    rb_define_method(rb_cThread, "initialize", thread_initialize, -2);
thread.c:    rb_define_method(rb_cThread, "raise", thread_raise_m, -1);
thread.c:    rb_define_method(rb_cThread, "join", thread_join_m, -1);
thread.c:	th->thgroup = th->vm->thgroup_default = rb_obj_alloc(cThGroup);
thread.c:	rb_define_const(cThGroup, "Default", th->thgroup);
thread.c:    rb_define_method(rb_cMutex, "sleep", mutex_sleep, -1);
thread.c:	    rb_thread_lock_t *lp = &GET_THREAD()->vm->global_vm_lock;
thread.c:	    native_mutex_initialize(&GET_THREAD()->interrupt_lock);
thread.c:    if (th->status != THREAD_STOPPED_FOREVER || RUBY_VM_INTERRUPTED(th) || th->transition_for_lock) {
thread.c:    else if (th->locking_mutex) {
thread.c:	GetMutexPtr(th->locking_mutex, mutex);
thread.c:	native_mutex_lock(&mutex->lock);
thread.c:	if (mutex->th == th || (!mutex->th && mutex->cond_notified)) {
thread.c:	native_mutex_unlock(&mutex->lock);
thread.c:    printf("th:%p %d %d %d", th, th->status, th->interrupt_flag, th->transition_for_lock);
thread.c:    if (th->locking_mutex) {
thread.c:	GetMutexPtr(th->locking_mutex, mutex);
thread.c:	native_mutex_lock(&mutex->lock);
thread.c:	printf(" %p %d\n", mutex->th, mutex->cond_notified);
thread.c:	native_mutex_unlock(&mutex->lock);
thread.c:    if (vm_living_thread_num(vm) > vm->sleeper) return;
thread.c:    if (vm_living_thread_num(vm) < vm->sleeper) rb_bug("sleeper must not be more than vm_living_thread_num(vm)");
thread.c:    st_foreach(vm->living_threads, check_deadlock_i, (st_data_t)&found);
thread.c:	printf("%d %d %p %p\n", vm->living_threads->num_entries, vm->sleeper, GET_THREAD(), vm->main_thread);
thread.c:	st_foreach(vm->living_threads, debug_i, (st_data_t)0);
thread.c:	rb_thread_raise(2, argv, vm->main_thread);
thread.c:    VALUE coverage = GET_THREAD()->cfp->iseq->coverage;
thread.c:    if (coverage && RBASIC(coverage)->klass == 0) {
thread.c:	long line = rb_sourceline() - 1;
thread.c:    return GET_VM()->coverages;
thread.c:    GET_VM()->coverages = coverages;
thread.c:    GET_VM()->coverages = Qfalse;
ãã¤ããªã¼ã»ãã¡ã¤ã«thread.oã¯ä¸è´ãã¾ãã
thread_pthread.c:/* -*-c-*- */
thread_pthread.c:  thread_pthread.c -
thread_pthread.c:  Copyright (C) 2004-2007 Koichi Sasada
thread_pthread.c:	rb_bug("native_mutex_unlock return non-zero: %d", r);
thread_pthread.c:	    rb_bug("native_mutex_trylock return non-zero: %d", r);
thread_pthread.c:	rb_bug("native_mutex_initialize return non-zero: %d", r);
thread_pthread.c:	rb_bug("native_mutex_destroy return non-zero: %d", r);
thread_pthread.c:	rb_bug("native_cond_initialize return non-zero: %d", r);
thread_pthread.c:	rb_bug("native_cond_destroy return non-zero: %d", r);
thread_pthread.c:    th->thread_id = pthread_self();
thread_pthread.c:    native_cond_initialize(&th->native_thread_data.sleep_cond);
thread_pthread.c:    pthread_mutex_destroy(&th->interrupt_lock);
thread_pthread.c:    pthread_cond_destroy(&th->native_thread_data.sleep_cond);
thread_pthread.c:	*size -= guard;
thread_pthread.c:    size -= guard;
thread_pthread.c:	    native_main_thread.stack_maxsize = (size_t)rlim.rlim_cur - space;
thread_pthread.c:    {int err = (expr); if (err) {rb_bug("err: %d - %s", err, #expr);}}
thread_pthread.c:	th->machine_stack_start = native_main_thread.stack_start;
thread_pthread.c:	th->machine_stack_maxsize = native_main_thread.stack_maxsize;
thread_pthread.c:	CHECK_ERR(pthread_attr_getstack(&attr, &start, &th->machine_stack_maxsize));
thread_pthread.c:	CHECK_ERR(pthread_attr_getstacksize(&attr, &th->machine_stack_maxsize));
thread_pthread.c:	th->machine_stack_start = start;
thread_pthread.c:    th->machine_register_stack_start = native_main_thread.register_stack_start;
thread_pthread.c:    th->machine_stack_maxsize /= 2;
thread_pthread.c:    th->machine_register_stack_maxsize = th->machine_stack_maxsize;
thread_pthread.c:	    th->thread_id = pthread_self();
thread_pthread.c:	entry->th_area = &th_area;
thread_pthread.c:	entry->cond = &cond;
thread_pthread.c:	entry->next = cached_thread_root;
thread_pthread.c:			cached_thread_root = e->next;
thread_pthread.c:			prev->next = e->next;
thread_pthread.c:		e = e->next;
thread_pthread.c:		cached_thread_root = entry->next;
thread_pthread.c:		*entry->th_area = th;
thread_pthread.c:	    pthread_cond_signal(entry->cond);
thread_pthread.c:        th->machine_stack_maxsize = stack_size - space;
thread_pthread.c:        th->machine_stack_maxsize /= 2;
thread_pthread.c:        th->machine_register_stack_maxsize = th->machine_stack_maxsize;
thread_pthread.c:	thread_debug("create - stack size: %lu\n", (unsigned long)stack_size);
thread_pthread.c:	err = pthread_create(&th->thread_id, &attr, thread_start_func_1, th);
thread_pthread.c:	    pthread_cond_init(&th->native_thread_data.sleep_cond, 0);
thread_pthread.c:	    st_delete_wrap(th->vm->living_threads, th->self);
thread_pthread.c:	    th->status = THREAD_KILLED;
thread_pthread.c:    int priority = 0 - th->priority;
thread_pthread.c:    pthread_getschedparam(th->thread_id, &policy, &sp);
thread_pthread.c:    pthread_setschedparam(th->thread_id, policy, &sp);
thread_pthread.c:    pthread_cond_signal(&th->native_thread_data.sleep_cond);
thread_pthread.c:    thread_debug("ubf_select_each (%p)\n", (void *)th->thread_id);
thread_pthread.c:	pthread_kill(th->thread_id, SIGVTALRM);
thread_pthread.c:	ts.tv_sec = tvn.tv_sec + tv->tv_sec;
thread_pthread.c:	ts.tv_nsec = (tvn.tv_usec + tv->tv_usec) * 1000;
thread_pthread.c:	    ts.tv_nsec -= PER_NANO;
thread_pthread.c:    thread_debug("native_sleep %ld\n", tv ? tv->tv_sec : -1);
thread_pthread.c:	pthread_mutex_lock(&th->interrupt_lock);
thread_pthread.c:	th->unblock.func = ubf_pthread_cond_signal;
thread_pthread.c:	th->unblock.arg = th;
thread_pthread.c:		r = pthread_cond_wait(&th->native_thread_data.sleep_cond,
thread_pthread.c:				      &th->interrupt_lock);
thread_pthread.c:		r = pthread_cond_timedwait(&th->native_thread_data.sleep_cond,
thread_pthread.c:					   &th->interrupt_lock, &ts);
thread_pthread.c:	th->unblock.func = 0;
thread_pthread.c:	th->unblock.arg = 0;
thread_pthread.c:	pthread_mutex_unlock(&th->interrupt_lock);
thread_pthread.c:	thread_debug("%p (%p), ", list->th, list->th->thread_id);
thread_pthread.c:	list = list->next;
thread_pthread.c:    if (!th->native_thread_data.signal_thread_list) {
thread_pthread.c:	    list->th = th;
thread_pthread.c:	    list->prev = &signal_thread_list_anchor;
thread_pthread.c:	    list->next = signal_thread_list_anchor.next;
thread_pthread.c:	    if (list->next) {
thread_pthread.c:		list->next->prev = list;
thread_pthread.c:	    th->native_thread_data.signal_thread_list = list;
thread_pthread.c:    if (th->native_thread_data.signal_thread_list) {
thread_pthread.c:		th->native_thread_data.signal_thread_list;
thread_pthread.c:	    list->prev->next = list->next;
thread_pthread.c:	    if (list->next) {
thread_pthread.c:		list->next->prev = list->prev;
thread_pthread.c:	    th->native_thread_data.signal_thread_list = 0;
thread_pthread.c:	    list->th = 0;
thread_pthread.c:    ts->tv_sec = tv.tv_sec;
thread_pthread.c:    ts->tv_nsec = tv.tv_usec * 1000 + nsec;
thread_pthread.c:    if (ts->tv_nsec >= PER_NANO) {
thread_pthread.c:	ts->tv_sec++;
thread_pthread.c:	ts->tv_nsec -= PER_NANO;
thread_pthread.c:		    ubf_select_each(list->th);
thread_pthread.c:		    list = list->next;
thread_pthread.c:	    rb_bug("rb_thread_create_timer_thread: return non-zero (%d)", err);
thread_pthread.c:    stopped = --system_working <= 0;
thread_pthread.c:	size = th->machine_stack_maxsize;
thread_pthread.c:	base = (char *)th->machine_stack_start - STACK_DIR_UPPER(0, size);
thread_pthread.c:	if (addr > (void *)((char *)base - size) && addr <= base) return 1;
thread_pthread.h:  thread_pthread.h -
thread_pthread.h:  Copyright (C) 2004-2007 Koichi Sasada
thread_win32.c:/* -*-c-*- */
thread_win32.c:  thread_win32.c -
thread_win32.c:  Copyright (C) 2004-2007 Koichi Sasada
thread_win32.c:		    &th->thread_id, 0, FALSE, DUPLICATE_SAME_ACCESS);
thread_win32.c:    th->native_thread_data.interrupt_event = CreateEvent(0, TRUE, FALSE, 0);
thread_win32.c:		 th, GET_THREAD()->thread_id,
thread_win32.c:		 th->native_thread_data.interrupt_event);
thread_win32.c:    if (th && (intr = th->native_thread_data.interrupt_event)) {
thread_win32.c:    if (ret == WAIT_OBJECT_0 + count - 1 && th) {
thread_win32.c:    if (ret == -1 && THREAD_DEBUG) {
thread_win32.c:	    thread_debug("  * error handle %d - %s\n", i,
thread_win32.c:    if (ResumeThread(handle) == -1) {
thread_win32.c:	msec = tv->tv_sec * 1000 + tv->tv_usec / 1000;
thread_win32.c:	native_mutex_lock(&th->interrupt_lock);
thread_win32.c:	th->unblock.func = ubf_handle;
thread_win32.c:	th->unblock.arg = th;
thread_win32.c:	native_mutex_unlock(&th->interrupt_lock);
thread_win32.c:	native_mutex_lock(&th->interrupt_lock);
thread_win32.c:	th->unblock.func = 0;
thread_win32.c:	th->unblock.arg = 0;
thread_win32.c:	native_mutex_unlock(&th->interrupt_lock);
thread_win32.c:    struct cond_event_entry *e = cond->next;
thread_win32.c:	cond->next = e->next;
thread_win32.c:	SetEvent(e->event);
thread_win32.c:    struct cond_event_entry *e = cond->next;
thread_win32.c:    cond->next = 0;
thread_win32.c:	SetEvent(e->event);
thread_win32.c:	e = e->next;
thread_win32.c:    if (cond->next) {
thread_win32.c:	cond->last->next = &entry;
thread_win32.c:	cond->last = &entry;
thread_win32.c:	cond->next = &entry;
thread_win32.c:	cond->last = &entry;
thread_win32.c:    cond->next = 0;
thread_win32.c:    cond->last = 0;
thread_win32.c:    {if (!(expr)) {rb_bug("err: %lu - %s", GetLastError(), #expr);}}
thread_win32.c:    size = end - base;
thread_win32.c:    th->machine_stack_start = (VALUE *)end - 1;
thread_win32.c:    th->machine_stack_maxsize = size - space;
thread_win32.c:    HANDLE intr = th->native_thread_data.interrupt_event;
thread_win32.c:    native_mutex_destroy(&th->interrupt_lock);
thread_win32.c:    thread_debug("close handle - intr: %p, thid: %p\n", intr, th->thread_id);
thread_win32.c:    th->native_thread_data.interrupt_event = 0;
thread_win32.c:    volatile HANDLE thread_id = th->thread_id;
thread_win32.c:    th->native_thread_data.interrupt_event = CreateEvent(0, TRUE, FALSE, 0);
thread_win32.c:		 th->thread_id, th->native_thread_data.interrupt_event);
thread_win32.c:    thread_start_func_2(th, th->machine_stack_start, rb_ia64_bsp());
thread_win32.c:    th->thread_id = w32_create_thread(stack_size, thread_start_func_1, th);
thread_win32.c:    if ((th->thread_id) == 0) {
thread_win32.c:	st_delete_wrap(th->vm->living_threads, th->self);
thread_win32.c:    w32_resume_thread(th->thread_id);
thread_win32.c:		     th, th->thread_id,
thread_win32.c:		     th->native_thread_data.interrupt_event, stack_size);
thread_win32.c:    int priority = th->priority;
thread_win32.c:    if (th->priority > 0) {
thread_win32.c:    else if (th->priority < 0) {
thread_win32.c:    SetThreadPriority(th->thread_id, priority);
thread_win32.c:    w32_set_event(th->native_thread_data.interrupt_event);
thread_win32.c:    int stopped = --system_working <= 0;
thread_win32.h:  thread_win32.h -
thread_win32.h:  Copyright (C) 2004-2007 Koichi Sasada
time.c:  time.c -
time.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
time.c:    tobj->tm_got=0;
time.c:    tobj->ts.tv_sec = 0;
time.c:    tobj->ts.tv_nsec = 0;
time.c: *  Document-method: now
time.c: *  call-seq:
time.c: *     Time.new -> time
time.c: *     a = Time.new      #=> 2007-11-19 07:50:02 -0600
time.c: *     b = Time.new      #=> 2007-11-19 07:50:02 -0600
time.c:    tobj->tm_got=0;
time.c:    tobj->ts.tv_sec = 0;
time.c:    tobj->ts.tv_nsec = 0;
time.c:    if (clock_gettime(CLOCK_REALTIME, &tobj->ts) == -1) {
time.c:        tobj->ts.tv_sec = tv.tv_sec;
time.c:        tobj->ts.tv_nsec = tv.tv_usec * 1000;
time.c:#define NDIV(x,y) (-(-((x)+1)/(y))-1)
time.c:#define NMOD(x,y) ((y)-(-((x)+1)%(y))-1)
time.c:    tobj->ts.tv_sec = sec;
time.c:    tobj->ts.tv_nsec = nsec;
time.c:                f -= 1;
time.c:    if (TYPE(time) == T_DATA && RDATA(time)->dfree == time_free) {
time.c:        t.tv_sec = tobj->ts.tv_sec;
time.c:        t.tv_usec = tobj->ts.tv_nsec / 1000;
time.c:    if (TYPE(time) == T_DATA && RDATA(time)->dfree == time_free) {
time.c:        t = tobj->ts;
time.c: *  call-seq:
time.c: *  non-portable feature allows the offset to be negative on some systems.
time.c: *     Time.at(0)            #=> 1969-12-31 18:00:00 -0600
time.c: *     Time.at(Time.at(0))   #=> 1969-12-31 18:00:00 -0600
time.c: *     Time.at(946702800)    #=> 1999-12-31 23:00:00 -0600
time.c: *     Time.at(-284061600)   #=> 1960-12-31 00:00:00 -0600
time.c:    if (TYPE(time) == T_DATA && RDATA(time)->dfree == time_free) {
time.c:	tobj2->gmt = tobj->gmt;
time.c:	tm->tm_isdst = RTEST(argv[8]) ? 1 : 0;
time.c:	tm->tm_wday = -1;
time.c:	tm->tm_isdst = -1;
time.c:	year -= 1900;
time.c:    tm->tm_year = year;
time.c:	tm->tm_mon = 0;
time.c:	    tm->tm_mon = -1;
time.c:		    tm->tm_mon = i;
time.c:	    if (tm->tm_mon == -1) {
time.c:		    tm->tm_mon = obj2long(s)-1;
time.c:	    tm->tm_mon = obj2long(v[1])-1;
time.c:	tm->tm_mday = 1;
time.c:	tm->tm_mday = obj2long(v[2]);
time.c:    tm->tm_hour = NIL_P(v[3])?0:obj2long(v[3]);
time.c:    tm->tm_min  = NIL_P(v[4])?0:obj2long(v[4]);
time.c:        tm->tm_sec  = NIL_P(v[5])?0:obj2long(v[5]);
time.c:        tm->tm_sec  = NIL_P(v[5])?0:obj2nsec(v[5], nsec);
time.c:	tm->tm_year != year ||
time.c:	tm->tm_year < 69 ||
time.c:	   tm->tm_mon  < 0 || tm->tm_mon  > 11
time.c:	|| tm->tm_mday < 1 || tm->tm_mday > 31
time.c:	|| tm->tm_hour < 0 || tm->tm_hour > 24
time.c:	|| (tm->tm_hour == 24 && (tm->tm_min > 0 || tm->tm_sec > 0))
time.c:	|| tm->tm_min  < 0 || tm->tm_min  > 59
time.c:	|| tm->tm_sec  < 0 || tm->tm_sec  > 60)
time.c:	-1,
time.c:	-1 + 31,
time.c:	-1 + 31 + 28,
time.c:	-1 + 31 + 28 + 31,
time.c:	-1 + 31 + 28 + 31 + 30,
time.c:	-1 + 31 + 28 + 31 + 30 + 31,
time.c:	-1 + 31 + 28 + 31 + 30 + 31 + 30,
time.c:	-1 + 31 + 28 + 31 + 30 + 31 + 30 + 31,
time.c:	-1 + 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31,
time.c:	-1 + 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30,
time.c:	-1 + 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31,
time.c:	-1 + 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30
time.c:	-1,
time.c:	-1 + 31,
time.c:	-1 + 31 + 29,
time.c:	-1 + 31 + 29 + 31,
time.c:	-1 + 31 + 29 + 31 + 30,
time.c:	-1 + 31 + 29 + 31 + 30 + 31,
time.c:	-1 + 31 + 29 + 31 + 30 + 31 + 30,
time.c:	-1 + 31 + 29 + 31 + 30 + 31 + 30 + 31,
time.c:	-1 + 31 + 29 + 31 + 30 + 31 + 30 + 31 + 31,
time.c:	-1 + 31 + 29 + 31 + 30 + 31 + 30 + 31 + 31 + 30,
time.c:	-1 + 31 + 29 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31,
time.c:	-1 + 31 + 29 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30
time.c:    long tm_year = tm->tm_year;
time.c:    int tm_yday = tm->tm_mday;
time.c:	tm_yday += leap_year_yday_offset[tm->tm_mon];
time.c:	tm_yday += common_year_yday_offset[tm->tm_mon];
time.c:     *  (tm_year-70)*31536000 + ((tm_year-69)/4)*86400 -
time.c:     *  ((tm_year-1)/100)*86400 + ((tm_year+299)/400)*86400
time.c:    return tm->tm_sec + tm->tm_min*60 + tm->tm_hour*3600 +
time.c:		    (tm_year-70)*365 +
time.c:		    DIV(tm_year-69,4) -
time.c:		    DIV(tm_year-1,100) +
time.c:    if (a->tm_year != b->tm_year)
time.c:	return a->tm_year < b->tm_year ? -1 : 1;
time.c:    else if (a->tm_mon != b->tm_mon)
time.c:	return a->tm_mon < b->tm_mon ? -1 : 1;
time.c:    else if (a->tm_mday != b->tm_mday)
time.c:	return a->tm_mday < b->tm_mday ? -1 : 1;
time.c:    else if (a->tm_hour != b->tm_hour)
time.c:	return a->tm_hour < b->tm_hour ? -1 : 1;
time.c:    else if (a->tm_min != b->tm_min)
time.c:	return a->tm_min < b->tm_min ? -1 : 1;
time.c:    else if (a->tm_sec != b->tm_sec)
time.c:	return a->tm_sec < b->tm_sec ? -1 : 1;
time.c:    find_dst = 0 < tptr->tm_isdst;
time.c:    guess_hi = ((time_t)-1) < ((time_t)0) ?
time.c:	    guess -= 24 * 60 * 60;
time.c:	    a = (tm_hi.tm_year - tptr->tm_year);
time.c:	    b = (tptr->tm_year - tm_lo.tm_year);
time.c:		a += tm_hi.tm_mon - tptr->tm_mon;
time.c:		b += tptr->tm_mon - tm_lo.tm_mon;
time.c:		    a += tm_hi.tm_mday - tptr->tm_mday;
time.c:		    b += tptr->tm_mday - tm_lo.tm_mday;
time.c:			a += tm_hi.tm_hour - tptr->tm_hour;
time.c:			b += tptr->tm_hour - tm_lo.tm_hour;
time.c:			    a += tm_hi.tm_min - tptr->tm_min;
time.c:			    b += tptr->tm_min - tm_lo.tm_min;
time.c:				a += tm_hi.tm_sec - tptr->tm_sec;
time.c:				b += tptr->tm_sec - tm_lo.tm_sec;
time.c:		guess = guess_hi - 1;
time.c:		guess = guess - range;
time.c:		    guess2 = guess - 2 * 60 * 60;
time.c:			if (tptr->tm_hour != (tm->tm_hour + 2) % 24 ||
time.c:			    tptr->tm_min != tm->tm_min ||
time.c:			    tptr->tm_sec != tm->tm_sec
time.c:			    guess2 -= (tm->tm_hour - tptr->tm_hour) * 60 * 60 +
time.c:				      (tm->tm_min - tptr->tm_min) * 60 +
time.c:				      (tm->tm_sec - tptr->tm_sec);
time.c:			    if (tptr->tm_mday != tm->tm_mday)
time.c:			if ((tptr->tm_hour + 2) % 24 != tm->tm_hour ||
time.c:			    tptr->tm_min != tm->tm_min ||
time.c:			    tptr->tm_sec != tm->tm_sec
time.c:			    guess2 -= (tm->tm_hour - tptr->tm_hour) * 60 * 60 +
time.c:				      (tm->tm_min - tptr->tm_min) * 60 +
time.c:				      (tm->tm_sec - tptr->tm_sec);
time.c:			    if (tptr->tm_mday != tm->tm_mday)
time.c:				guess2 -= 24 * 60 * 60;
time.c:    if (tm_lo.tm_year == tptr->tm_year && tm_lo.tm_mon == tptr->tm_mon) {
time.c:	       (tptr->tm_mday - tm_lo.tm_mday) * 24 * 60 * 60 +
time.c:	       (tptr->tm_hour - tm_lo.tm_hour) * 60 * 60 +
time.c:	       (tptr->tm_min - tm_lo.tm_min) * 60 +
time.c:	       (tptr->tm_sec - tm_lo.tm_sec);
time.c:    else if (tm_hi.tm_year == tptr->tm_year && tm_hi.tm_mon == tptr->tm_mon) {
time.c:	       (tptr->tm_mday - tm_hi.tm_mday) * 24 * 60 * 60 +
time.c:	       (tptr->tm_hour - tm_hi.tm_hour) * 60 * 60 +
time.c:	       (tptr->tm_min - tm_hi.tm_min) * 60 +
time.c:	       (tptr->tm_sec - tm_hi.tm_sec);
time.c:	if ((t = timegm(&buf)) != -1)
time.c:	    tptr->tm_year == tmp->tm_year &&
time.c:	    tptr->tm_mon == tmp->tm_mon &&
time.c:	    tptr->tm_mday == tmp->tm_mday &&
time.c:	    tptr->tm_hour == tmp->tm_hour &&
time.c:	    tptr->tm_min == tmp->tm_min &&
time.c:	    tptr->tm_sec == tmp->tm_sec
time.c:	if ((t = mktime(&buf)) != -1)
time.c:	    tptr->tm_year == tmp->tm_year &&
time.c:	    tptr->tm_mon == tmp->tm_mon &&
time.c:	    tptr->tm_mday == tmp->tm_mday &&
time.c:	    tptr->tm_hour == tmp->tm_hour &&
time.c:	    tptr->tm_min == tmp->tm_min &&
time.c:	    tptr->tm_sec == tmp->tm_sec
time.c: *  call-seq:
time.c: *  be specified by numbers from 1 to 12, or by the three-letter English
time.c: *  month names. Hours are specified on a 24-hour clock (0..23). Raises
time.c: *     Time.utc(2000,"jan",1,20,15,1)  #=> 2000-01-01 20:15:01 UTC
time.c: *     Time.gm(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 UTC
time.c: *  call-seq:
time.c: *     Time.local(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 -0600
time.c: *  call-seq:
time.c:    return LONG2NUM(tobj->ts.tv_sec);
time.c: *  call-seq:
time.c:    return DBL2NUM((double)tobj->ts.tv_sec+(double)tobj->ts.tv_nsec/1e9);
time.c: *  call-seq:
time.c: *     t = Time.now        #=> 2007-11-19 08:03:26 -0600
time.c:    return LONG2NUM(tobj->ts.tv_nsec/1000);
time.c: *  call-seq:
time.c: *     t = Time.now        #=> 2007-11-17 15:18:03 +0900
time.c:    return LONG2NUM(tobj->ts.tv_nsec);
time.c: *  call-seq:
time.c: *     time <=> other_time => -1, 0, +1 
time.c: *  Comparison---Compares <i>time</i> with <i>other_time</i>.
time.c: *     t = Time.now       #=> 2007-11-19 08:12:12 -0600
time.c: *     t2 = t + 2592000   #=> 2007-12-19 08:12:12 -0600
time.c: *     t <=> t2           #=> -1
time.c: *     t = Time.now       #=> 2007-11-19 08:13:38 -0600
time.c: *     t2 = t + 0.1       #=> 2007-11-19 08:13:38 -0600
time.c: *     t <=> t2           #=> -1
time.c:    if (TYPE(time2) == T_DATA && RDATA(time2)->dfree == time_free) {
time.c:	if (tobj1->ts.tv_sec == tobj2->ts.tv_sec) {
time.c:	    if (tobj1->ts.tv_nsec == tobj2->ts.tv_nsec) return INT2FIX(0);
time.c:	    if (tobj1->ts.tv_nsec > tobj2->ts.tv_nsec) return INT2FIX(1);
time.c:	    return INT2FIX(-1);
time.c:	if (tobj1->ts.tv_sec > tobj2->ts.tv_sec) return INT2FIX(1);
time.c:	return INT2FIX(-1);
time.c:	n = -rb_cmpint(cmp, time1, time2);
time.c:	return INT2FIX(-1);
time.c: * call-seq:
time.c:    if (TYPE(time2) == T_DATA && RDATA(time2)->dfree == time_free) {
time.c:	if (tobj1->ts.tv_sec == tobj2->ts.tv_sec) {
time.c:	    if (tobj1->ts.tv_nsec == tobj2->ts.tv_nsec) return Qtrue;
time.c: *  call-seq:
time.c: *     t = Time.now                        #=> 2007-11-19 08:15:23 -0600
time.c: *     t = Time.gm(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 UTC
time.c: *     t = Time.now                        #=> 2007-11-19 08:16:03 -0600
time.c: *     t = Time.gm(2000,1,1,20,15,1)       #=> 2000-01-01 20:15:01 UTC
time.c:    if (tobj->gmt) return Qtrue;
time.c: * call-seq:
time.c:    hash = tobj->ts.tv_sec ^ tobj->ts.tv_nsec;
time.c:    if (TYPE(time) != T_DATA || RDATA(time)->dfree != time_free) {
time.c: *  call-seq:
time.c: *     t = Time.gm(2000, "jan", 1, 20, 15, 1)  #=> 2000-01-01 20:15:01 UTC
time.c: *     t.localtime                             #=> 2000-01-01 14:15:01 -0600
time.c:    if (!tobj->gmt) {
time.c:	if (tobj->tm_got)
time.c:    t = tobj->ts.tv_sec;
time.c:    tobj->tm = *tm_tmp;
time.c:    tobj->tm_got = 1;
time.c:    tobj->gmt = 0;
time.c: *  call-seq:
time.c: *     t = Time.now   #=> 2007-11-19 08:18:31 -0600
time.c: *     t.gmtime       #=> 2007-11-19 14:18:31 UTC
time.c: *     t = Time.now   #=> 2007-11-19 08:18:51 -0600
time.c: *     t.utc          #=> 2007-11-19 14:18:51 UTC
time.c:    if (tobj->gmt) {
time.c:	if (tobj->tm_got)
time.c:    t = tobj->ts.tv_sec;
time.c:    tobj->tm = *tm_tmp;
time.c:    tobj->tm_got = 1;
time.c:    tobj->gmt = 1;
time.c: *  call-seq:
time.c: *     t = Time.gm(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 UTC
time.c: *     l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600
time.c: *  call-seq:
time.c: *     t = Time.local(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 -0600
time.c: *     y = t.getgm                        #=> 2000-01-02 02:15:01 UTC
time.c: *  call-seq:
time.c:    if (tobj->tm_got == 0) {
time.c:	time_get_tm(time, tobj->gmt);
time.c:    s = ASCTIME(&tobj->tm, buf);
time.c: *  call-seq:
time.c: *  ``<code>%Y-%m-%d</code> <code>%H:%M:%S</code> <code>%z</code>''
time.c: *  ``<code>%Y-%m-%d</code> <code>%H:%M:%S</code> <code>UTC</code>''
time.c: *     Time.now.to_s       #=> "2007-10-05 16:09:51 +0900"
time.c: *     Time.now.utc.to_s   #=> "2007-10-05 07:09:51 UTC"
time.c:    if (tobj->tm_got == 0) {
time.c:	time_get_tm(time, tobj->gmt);
time.c:    if (tobj->gmt == 1) {
time.c:	len = rb_strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S UTC",
time.c:			  &tobj->tm, &tobj->ts, tobj->gmt);
time.c:	len = rb_strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S %z",
time.c:			  &tobj->tm, &tobj->ts, tobj->gmt);
time.c:	v = -v;
time.c:	sign = -sign;
time.c:		 sign < 0 ? "-" : "+", v);
time.c:	sec = tobj->ts.tv_sec - sec_off;
time.c:	nsec = tobj->ts.tv_nsec - nsec_off;
time.c:	if (sec > tobj->ts.tv_sec)
time.c:	    rb_raise(rb_eRangeError, "time - %f out of Time range", v);
time.c:	sec = tobj->ts.tv_sec + sec_off;
time.c:	nsec = tobj->ts.tv_nsec + nsec_off;
time.c:	if (sec < tobj->ts.tv_sec)
time.c:    if (tobj->gmt) {
time.c:	tobj->gmt = 1;
time.c: *  call-seq:
time.c: *  Addition---Adds some number of seconds (possibly fractional) to
time.c: *     t = Time.now         #=> 2007-11-19 08:22:21 -0600
time.c: *     t + (60 * 60 * 24)   #=> 2007-11-20 08:22:21 -0600
time.c:    if (TYPE(time2) == T_DATA && RDATA(time2)->dfree == time_free) {
time.c: *  call-seq:
time.c: *     time - other_time => float
time.c: *     time - numeric    => time
time.c: *  Difference---Returns a new time that represents the difference
time.c: *     t = Time.now       #=> 2007-11-19 08:23:10 -0600
time.c: *     t2 = t + 2592000   #=> 2007-12-19 08:23:10 -0600
time.c: *     t2 - t             #=> 2592000.0
time.c: *     t2 - 2592000       #=> 2007-11-19 08:23:10 -0600
time.c:    if (TYPE(time2) == T_DATA && RDATA(time2)->dfree == time_free) {
time.c:        if (tobj->ts.tv_sec < tobj2->ts.tv_sec)
time.c:            f = -(double)(unsigned_time_t)(tobj2->ts.tv_sec - tobj->ts.tv_sec);
time.c:            f = (double)(unsigned_time_t)(tobj->ts.tv_sec - tobj2->ts.tv_sec);
time.c:	f += ((double)tobj->ts.tv_nsec - (double)tobj2->ts.tv_nsec)*1e-9;
time.c:    return time_add(tobj, time2, -1);
time.c: * call-seq:
time.c: *     t = Time.now       #=> 2007-11-19 08:23:57 -0600
time.c: *     t.succ             #=> 2007-11-19 08:23:58 -0600
time.c:    gmt = tobj->gmt;
time.c:    time = rb_time_nano_new(tobj->ts.tv_sec + 1, tobj->ts.tv_nsec);
time.c:    tobj->gmt = gmt;
time.c: *  call-seq:
time.c: *     t = Time.now   #=> 2007-11-19 08:25:02 -0600
time.c:    if (tobj->tm_got == 0) {
time.c:	time_get_tm(time, tobj->gmt);
time.c:    return INT2FIX(tobj->tm.tm_sec);
time.c: *  call-seq:
time.c: *     t = Time.now   #=> 2007-11-19 08:25:51 -0600
time.c:    if (tobj->tm_got == 0) {
time.c:	time_get_tm(time, tobj->gmt);
time.c:    return INT2FIX(tobj->tm.tm_min);
time.c: *  call-seq:
time.c: *     t = Time.now   #=> 2007-11-19 08:26:20 -0600
time.c:    if (tobj->tm_got == 0) {
time.c:	time_get_tm(time, tobj->gmt);
time.c:    return INT2FIX(tobj->tm.tm_hour);
time.c: *  call-seq:
time.c: *     t = Time.now   #=> 2007-11-19 08:27:03 -0600
time.c:    if (tobj->tm_got == 0) {
time.c:	time_get_tm(time, tobj->gmt);
time.c:    return INT2FIX(tobj->tm.tm_mday);
time.c: *  call-seq:
time.c: *     t = Time.now   #=> 2007-11-19 08:27:30 -0600
time.c:    if (tobj->tm_got == 0) {
time.c:	time_get_tm(time, tobj->gmt);
time.c:    return INT2FIX(tobj->tm.tm_mon+1);
time.c: *  call-seq:
time.c: *     t = Time.now   #=> 2007-11-19 08:27:51 -0600
time.c:    if (tobj->tm_got == 0) {
time.c:	time_get_tm(time, tobj->gmt);
time.c:    return LONG2NUM((long)tobj->tm.tm_year+1900);
time.c: *  call-seq:
time.c: *     t = Time.now   #=> 2007-11-20 02:35:35 -0600
time.c:    if (tobj->tm_got == 0) {
time.c:	time_get_tm(time, tobj->gmt);
time.c:    return INT2FIX(tobj->tm.tm_wday);
time.c:    if (tobj->tm_got == 0) {\
time.c:	time_get_tm(time, tobj->gmt);\
time.c:    return (tobj->tm.tm_wday == (n)) ? Qtrue : Qfalse;\
time.c: *  call-seq:
time.c: *     t = Time.local(1990, 4, 1)       #=> 1990-04-01 00:00:00 -0600
time.c: *  call-seq:
time.c: *     t = Time.local(2003, 8, 4)       #=> 2003-08-04 00:00:00 -0500
time.c: *  call-seq:
time.c: *     t = Time.local(1991, 2, 19)      #=> 1991-02-19 00:00:00 -0600
time.c: *  call-seq:
time.c: *     t = Time.local(1993, 2, 24)      #=> 1993-02-24 00:00:00 -0600
time.c: *  call-seq:
time.c: *     t = Time.local(1995, 12, 21)     #=> 1995-12-21 00:00:00 -0600
time.c: *  call-seq:
time.c: *     t = Time.local(1987, 12, 18)     #=> 1987-12-18 00:00:00 -0600
time.c: *  call-seq:
time.c: *     t = Time.local(2006, 6, 10)      #=> 2006-06-10 00:00:00 -0500
time.c: *  call-seq:
time.c: *     t = Time.now   #=> 2007-11-19 08:32:31 -0600
time.c:    if (tobj->tm_got == 0) {
time.c:	time_get_tm(time, tobj->gmt);
time.c:    return INT2FIX(tobj->tm.tm_yday+1);
time.c: *  call-seq:
time.c:    if (tobj->tm_got == 0) {
time.c:	time_get_tm(time, tobj->gmt);
time.c:    return tobj->tm.tm_isdst?Qtrue:Qfalse;
time.c: *  call-seq:
time.c:    if (tobj->tm_got == 0) {
time.c:	time_get_tm(time, tobj->gmt);
time.c:    if (tobj->gmt == 1) {
time.c:    return rb_str_new2(tobj->tm.tm_zone);
time.c:    return rb_str_new2(tzname[daylight && tobj->tm.tm_isdst]);
time.c:		      &tobj->tm, &tobj->ts, tobj->gmt);
time.c: *  call-seq:
time.c: *     t = Time.gm(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 UTC
time.c: *     l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600
time.c: *     l.gmt_offset                    #=> -21600
time.c:    if (tobj->tm_got == 0) {
time.c:	time_get_tm(time, tobj->gmt);
time.c:    if (tobj->gmt == 1) {
time.c:	return INT2NUM(tobj->tm.tm_gmtoff);
time.c:	l = &tobj->tm;
time.c:	t = tobj->ts.tv_sec;
time.c:	if (l->tm_year != u->tm_year)
time.c:	    off = l->tm_year < u->tm_year ? -1 : 1;
time.c:	else if (l->tm_mon != u->tm_mon)
time.c:	    off = l->tm_mon < u->tm_mon ? -1 : 1;
time.c:	else if (l->tm_mday != u->tm_mday)
time.c:	    off = l->tm_mday < u->tm_mday ? -1 : 1;
time.c:	off = off * 24 + l->tm_hour - u->tm_hour;
time.c:	off = off * 60 + l->tm_min - u->tm_min;
time.c:	off = off * 60 + l->tm_sec - u->tm_sec;
time.c: *  call-seq:
time.c: *  Returns a ten-element <i>array</i> of values for <i>time</i>:
time.c: *     t = Time.now     #=> 2007-11-19 08:36:01 -0600
time.c:    if (tobj->tm_got == 0) {
time.c:	time_get_tm(time, tobj->gmt);
time.c:		    INT2FIX(tobj->tm.tm_sec),
time.c:		    INT2FIX(tobj->tm.tm_min),
time.c:		    INT2FIX(tobj->tm.tm_hour),
time.c:		    INT2FIX(tobj->tm.tm_mday),
time.c:		    INT2FIX(tobj->tm.tm_mon+1),
time.c:		    LONG2NUM((long)tobj->tm.tm_year+1900),
time.c:		    INT2FIX(tobj->tm.tm_wday),
time.c:		    INT2FIX(tobj->tm.tm_yday+1),
time.c:		    tobj->tm.tm_isdst?Qtrue:Qfalse,
time.c: *  call-seq:
time.c: *    %a - The abbreviated weekday name (``Sun'')
time.c: *    %A - The  full  weekday  name (``Sunday'')
time.c: *    %b - The abbreviated month name (``Jan'')
time.c: *    %B - The  full  month  name (``January'')
time.c: *    %c - The preferred local date and time representation
time.c: *    %d - Day of the month (01..31)
time.c: *    %F - Equivalent to %Y-%m-%d (the ISO 8601 date format)
time.c: *    %H - Hour of the day, 24-hour clock (00..23)
time.c: *    %I - Hour of the day, 12-hour clock (01..12)
time.c: *    %j - Day of the year (001..366)
time.c: *    %L - Millisecond of the second (000..999)
time.c: *    %m - Month of the year (01..12)
time.c: *    %M - Minute of the hour (00..59)
time.c: *    %N - Fractional seconds digits, default is 9 digits (nanosecond)
time.c: *    %p - Meridian indicator (``AM''  or  ``PM'')
time.c: *    %P - Meridian indicator (``am''  or  ``pm'')
time.c: *    %s - Number of seconds since 1970-01-01 00:00:00 UTC.
time.c: *    %S - Second of the minute (00..60)
time.c: *    %U - Week  number  of the current year,
time.c: *    %W - Week  number  of the current year,
time.c: *    %w - Day of the week (Sunday is 0, 0..6)
time.c: *    %x - Preferred representation for the date alone, no time
time.c: *    %X - Preferred representation for the time alone, no date
time.c: *    %y - Year without a century (00..99)
time.c: *    %Y - Year with century
time.c: *    %Z - Time zone name
time.c: *    %% - Literal ``%'' character
time.c: *     t = Time.now                        #=> 2007-11-19 08:37:48 -0600
time.c:    if (tobj->tm_got == 0) {
time.c:	time_get_tm(time, tobj->gmt);
time.c:	    len = rb_strftime_alloc(&buf, p, &tobj->tm, &tobj->ts, tobj->gmt);
time.c:	    if (p > fmt) rb_str_cat(str, fmt, p - fmt);
time.c:			       	&tobj->tm, &tobj->ts, tobj->gmt);
time.c:    t = tobj->ts.tv_sec;
time.c:    if ((tm->tm_year & 0xffff) != tm->tm_year)
time.c:        rb_raise(rb_eArgError, "year too big to marshal: %ld", (long)tm->tm_year);
time.c:	tobj->gmt    << 30 | /*  1 */
time.c:	tm->tm_year  << 14 | /* 16 */
time.c:	tm->tm_mon   << 10 | /*  4 */
time.c:	tm->tm_mday  <<  5 | /*  5 */
time.c:	tm->tm_hour;         /*  5 */
time.c:    s = tm->tm_min   << 26 | /*  6 */
time.c:	tm->tm_sec   << 20 | /*  6 */
time.c:	tobj->ts.tv_nsec / 1000;    /* 20 */
time.c:    nsec = tobj->ts.tv_nsec % 1000;
time.c:         * submicro is formatted in fixed-point packed BCD (without sign).
time.c: * call-seq:
time.c:	s |= buf[i]<<(8*(i-4));
time.c:    tobj->tm_got = 0;
time.c:    tobj->gmt = gmt;
time.c:    tobj->ts.tv_sec = sec;
time.c:    tobj->ts.tv_nsec = nsec;
time.c: * call-seq:
time.c: *  this fact when comparing times with each other---times that are
time.c:    rb_define_singleton_method(rb_cTime, "now", rb_class_new_instance, -1);
time.c:    rb_define_singleton_method(rb_cTime, "at", time_s_at, -1);
time.c:    rb_define_singleton_method(rb_cTime, "utc", time_s_mkutc, -1);
time.c:    rb_define_singleton_method(rb_cTime, "gm", time_s_mkutc, -1);
time.c:    rb_define_singleton_method(rb_cTime, "local", time_s_mktime, -1);
time.c:    rb_define_singleton_method(rb_cTime, "mktime", time_s_mktime, -1);
time.c:    rb_define_method(rb_cTime, "-", time_minus, 1);
time.c:    rb_define_method(rb_cTime, "_dump", time_dump, -1);
ãã¤ããªã¼ã»ãã¡ã¤ã«time.oã¯ä¸è´ãã¾ãã
transcode.c:  transcode.c -
transcode.c:/* may carry conversion state (e.g. for iso-2022-jp) */
transcode.c:    ((tc)->transcoder->max_input <= sizeof((tc)->readbuf.ary) ? \
transcode.c:     (tc)->readbuf.ary : \
transcode.c:     (tc)->readbuf.ptr)
transcode.c:    ((tc)->transcoder->max_output <= sizeof((tc)->writebuf.ary) ? \
transcode.c:     (tc)->writebuf.ary : \
transcode.c:     (tc)->writebuf.ptr)
transcode.c:    ((tc)->transcoder->max_output <= sizeof((tc)->writebuf.ary) ? \
transcode.c:     sizeof((tc)->writebuf.ary) : \
transcode.c:     (tc)->transcoder->max_output)
transcode.c:    ((tc)->transcoder->state_size <= sizeof((tc)->state) ? \
transcode.c:     (void *)&(tc)->state : \
transcode.c:     (tc)->state.ptr)
transcode.c:        entry->sname = sname;
transcode.c:        entry->dname = dname;
transcode.c:        entry->lib = NULL;
transcode.c:        entry->transcoder = NULL;
transcode.c:    const char *const sname = tr->src_encoding;
transcode.c:    const char *const dname = tr->dst_encoding;
transcode.c:    if (entry->transcoder) {
transcode.c:    entry->transcoder = tr;
transcode.c:    entry->lib = lib;
transcode.c:	rb_raise(rb_eArgError, "invalid library name - %s",
transcode.c:    if (st_lookup(bfs->visited, (st_data_t)dname, &val)) {
transcode.c:    q->enc = dname;
transcode.c:    q->next = NULL;
transcode.c:    *bfs->queue_last_ptr = q;
transcode.c:    bfs->queue_last_ptr = &q->next;
transcode.c:    st_add_direct(bfs->visited, (st_data_t)dname, (st_data_t)bfs->base_enc);
transcode.c:    int pathlen = -1;
transcode.c:        return -1;
transcode.c:    q->enc = sname;
transcode.c:    q->next = NULL;
transcode.c:    bfs.queue_last_ptr = &q->next;
transcode.c:        bfs.queue = q->next;
transcode.c:        if (!st_lookup(transcoder_table, (st_data_t)q->enc, &val)) {
transcode.c:            st_add_direct(bfs.visited, (st_data_t)dname, (st_data_t)q->enc);
transcode.c:        bfs.base_enc = q->enc;
transcode.c:        bfs.queue = q->next;
transcode.c:            callback((const char *)val, enc, --depth, arg);
transcode.c:    return pathlen; /* is -1 if not found */
transcode.c:    if (entry->transcoder)
transcode.c:        return entry->transcoder;
transcode.c:    if (entry->lib) {
transcode.c:        const char *lib = entry->lib;
transcode.c:        entry->lib = NULL;
transcode.c:        memcpy(path, transcoder_lib_prefix, sizeof(transcoder_lib_prefix) - 1);
transcode.c:        memcpy(path + sizeof(transcoder_lib_prefix) - 1, lib, len + 1);
transcode.c:    if (entry->transcoder)
transcode.c:        return entry->transcoder;
transcode.c:    if (encoding_equal(encname, "UTF-8")) {
transcode.c:        *repl_encname_ptr = "UTF-8";
transcode.c:        *repl_encname_ptr = "US-ASCII";
transcode.c:    if (inchar_start - in_start < tc->recognized_len) {
transcode.c:        MEMCPY(TRANSCODING_READBUF(tc) + tc->recognized_len,
transcode.c:               inchar_start, unsigned char, in_p - inchar_start);
transcode.c:        ptr = inchar_start - tc->recognized_len;
transcode.c:    *char_len_ptr = tc->recognized_len + (in_p - inchar_start);
transcode.c:    const rb_transcoder *tr = tc->transcoder;
transcode.c:    int unitlen = tr->input_unit_length;
transcode.c:        tc->resume_position = (num); \
transcode.c:        if (0 < in_p - inchar_start) \
transcode.c:            MEMMOVE(TRANSCODING_READBUF(tc)+tc->recognized_len, \
transcode.c:                   inchar_start, unsigned char, in_p - inchar_start); \
transcode.c:        tc->recognized_len += in_p - inchar_start; \
transcode.c:            tc->recognized_len -= readagain_len; \
transcode.c:            tc->readagain_len = readagain_len; \
transcode.c:        while (out_stop - out_p < 1) { SUSPEND(econv_destination_buffer_full, num); } \
transcode.c:#define next_table (tc->next_table)
transcode.c:#define next_info (tc->next_info)
transcode.c:#define next_byte (tc->next_byte)
transcode.c:#define writebuf_len (tc->writebuf_len)
transcode.c:#define writebuf_off (tc->writebuf_off)
transcode.c:    switch (tc->resume_position) {
transcode.c:        tc->recognized_len = 0;
transcode.c:	next_table = tr->conv_tree_start;
transcode.c:#define BYTE_ADDR(index) (tr->byte_array + (index))
transcode.c:#define WORD_ADDR(index) (tr->word_array + INFO2WORDINDEX(index))
transcode.c:#define BL_OFFSET(byte) (BL_BASE[2+(byte)-BL_MIN_BYTE])
transcode.c:            tc->output_index = 0;
transcode.c:            while (tc->output_index < STR1_LENGTH(BYTE_ADDR(STR1_BYTEINDEX(next_info)))) {
transcode.c:                SUSPEND_OBUF(28); *out_p++ = BYTE_ADDR(STR1_BYTEINDEX(next_info))[1+tc->output_index];
transcode.c:                tc->output_index++;
transcode.c:	    next_info = (VALUE)(*tr->func_ii)(TRANSCODING_STATE(tc), next_info);
transcode.c:                next_info = (VALUE)(*tr->func_si)(TRANSCODING_STATE(tc), char_start, (size_t)char_len);
transcode.c:            if (tr->max_output <= out_stop - out_p)
transcode.c:                out_p += tr->func_io(TRANSCODING_STATE(tc),
transcode.c:                    next_info, out_p, out_stop - out_p);
transcode.c:                writebuf_len = tr->func_io(TRANSCODING_STATE(tc),
transcode.c:                if (tr->max_output <= out_stop - out_p) {
transcode.c:                    out_p += tr->func_so(TRANSCODING_STATE(tc),
transcode.c:                        out_p, out_stop - out_p);
transcode.c:                    writebuf_len = tr->func_so(TRANSCODING_STATE(tc),
transcode.c:            if (tc->recognized_len + (in_p - inchar_start) <= unitlen) {
transcode.c:                if (tc->recognized_len + (in_p - inchar_start) < unitlen)
transcode.c:                while ((opt & ECONV_PARTIAL_INPUT) && tc->recognized_len + (in_stop - inchar_start) < unitlen) {
transcode.c:                if (tc->recognized_len + (in_stop - inchar_start) <= unitlen) {
transcode.c:                    in_p = inchar_start + (unitlen - tc->recognized_len);
transcode.c:                invalid_len = tc->recognized_len + (in_p - inchar_start);
transcode.c:                discard_len = ((invalid_len - 1) / unitlen) * unitlen;
transcode.c:                readagain_len = invalid_len - discard_len;
transcode.c:    if (tr->finish_func) {
transcode.c:        if (tr->max_output <= out_stop - out_p) {
transcode.c:            out_p += tr->finish_func(TRANSCODING_STATE(tc),
transcode.c:                out_p, out_stop - out_p);
transcode.c:            writebuf_len = tr->finish_func(TRANSCODING_STATE(tc),
transcode.c:    if (tc->readagain_len) {
transcode.c:        unsigned char *readagain_buf = ALLOCA_N(unsigned char, tc->readagain_len);
transcode.c:        const unsigned char *readagain_stop = readagain_buf + tc->readagain_len;
transcode.c:        MEMCPY(readagain_buf, TRANSCODING_READBUF(tc) + tc->recognized_len,
transcode.c:               unsigned char, tc->readagain_len);
transcode.c:        tc->readagain_len = 0;
transcode.c:            MEMCPY(TRANSCODING_READBUF(tc) + tc->recognized_len + tc->readagain_len,
transcode.c:                   readagain_pos, unsigned char, readagain_stop - readagain_pos);
transcode.c:            tc->readagain_len += readagain_stop - readagain_pos;
transcode.c:    tc->transcoder = tr;
transcode.c:    tc->flags = flags;
transcode.c:    if (TRANSCODING_STATE_EMBED_MAX < tr->state_size)
transcode.c:        tc->state.ptr = xmalloc(tr->state_size);
transcode.c:    if (tr->state_init_func) {
transcode.c:        (tr->state_init_func)(TRANSCODING_STATE(tc)); /* xxx: check return value */
transcode.c:    tc->resume_position = 0;
transcode.c:    tc->recognized_len = 0;
transcode.c:    tc->readagain_len = 0;
transcode.c:    tc->writebuf_len = 0;
transcode.c:    tc->writebuf_off = 0;
transcode.c:    if (sizeof(tc->readbuf.ary) < tr->max_input) {
transcode.c:        tc->readbuf.ptr = xmalloc(tr->max_input);
transcode.c:    if (sizeof(tc->writebuf.ary) < tr->max_output) {
transcode.c:        tc->writebuf.ptr = xmalloc(tr->max_output);
transcode.c:    const rb_transcoder *tr = tc->transcoder;
transcode.c:    if (tr->state_fini_func) {
transcode.c:        (tr->state_fini_func)(TRANSCODING_STATE(tc)); /* check return value? */
transcode.c:    if (TRANSCODING_STATE_EMBED_MAX < tr->state_size)
transcode.c:        xfree(tc->state.ptr);
transcode.c:    if (sizeof(tc->readbuf.ary) < tr->max_input)
transcode.c:        xfree(tc->readbuf.ptr);
transcode.c:    if (sizeof(tc->writebuf.ary) < tr->max_output)
transcode.c:        xfree(tc->writebuf.ptr);
transcode.c:    ec->flags = 0;
transcode.c:    ec->source_encoding_name = NULL;
transcode.c:    ec->destination_encoding_name = NULL;
transcode.c:    ec->started = 0;
transcode.c:    ec->replacement_str = NULL;
transcode.c:    ec->replacement_len = 0;
transcode.c:    ec->replacement_enc = NULL;
transcode.c:    ec->replacement_allocated = 0;
transcode.c:    ec->in_buf_start = NULL;
transcode.c:    ec->in_data_start = NULL;
transcode.c:    ec->in_data_end = NULL;
transcode.c:    ec->in_buf_end = NULL;
transcode.c:    ec->num_allocated = n_hint;
transcode.c:    ec->num_trans = 0;
transcode.c:    ec->elems = ALLOC_N(rb_econv_elem_t, ec->num_allocated);
transcode.c:    ec->num_finished = 0;
transcode.c:    ec->last_tc = NULL;
transcode.c:    ec->last_error.result = econv_source_buffer_empty;
transcode.c:    ec->last_error.error_tc = NULL;
transcode.c:    ec->last_error.source_encoding = NULL;
transcode.c:    ec->last_error.destination_encoding = NULL;
transcode.c:    ec->last_error.error_bytes_start = NULL;
transcode.c:    ec->last_error.error_bytes_len = 0;
transcode.c:    ec->last_error.readagain_len = 0;
transcode.c:    ec->source_encoding = NULL;
transcode.c:    ec->destination_encoding = NULL;
transcode.c:    if (ec->num_trans == ec->num_allocated) {
transcode.c:        n = ec->num_allocated * 2;
transcode.c:        REALLOC_N(ec->elems, rb_econv_elem_t, n);
transcode.c:        ec->num_allocated = n;
transcode.c:    MEMMOVE(ec->elems+i+1, ec->elems+i, rb_econv_elem_t, ec->num_trans-i);
transcode.c:    ec->elems[i].tc = rb_transcoding_open_by_transcoder(tr, 0);
transcode.c:    ec->elems[i].out_buf_start = p;
transcode.c:    ec->elems[i].out_buf_end = p + bufsize;
transcode.c:    ec->elems[i].out_data_start = p;
transcode.c:    ec->elems[i].out_data_end = p;
transcode.c:    ec->elems[i].last_result = econv_source_buffer_empty;
transcode.c:    ec->num_trans++;
transcode.c:    if (!DECORATOR_P(tr->src_encoding, tr->dst_encoding))
transcode.c:        for (j = ec->num_trans-1; i <= j; j--) {
transcode.c:            rb_transcoding *tc = ec->elems[j].tc;
transcode.c:            const rb_transcoder *tr2 = tc->transcoder;
transcode.c:            if (!DECORATOR_P(tr2->src_encoding, tr2->dst_encoding)) {
transcode.c:                ec->last_tc = tc;
transcode.c:        ret = rb_econv_add_transcoder_at(ec, tr, ec->num_trans);
transcode.c:        if (ret == -1) {
transcode.c:    if (!toarg->entries) {
transcode.c:        toarg->entries = ALLOC_N(transcoder_entry_t *, depth+1+toarg->num_additional);
transcode.c:    toarg->entries[depth] = get_transcoder_entry(sname, dname);
transcode.c:    ec->flags = ecflags;
transcode.c:    ec->source_encoding_name = sname;
transcode.c:    ec->destination_encoding_name = dname;
transcode.c:        return -1;
transcode.c:        return -1;
transcode.c:        return -1;
transcode.c:    if (num_decorators == -1)
transcode.c:        if (rb_econv_decorate_at_last(ec, decorators[i]) == -1) {
transcode.c:    ec->flags |= ecflags & ~ECONV_ERROR_HANDLER_MASK;
transcode.c:        for (i = start; i < ec->num_trans; i++) {
transcode.c:            rb_econv_elem_t *te = &ec->elems[i];
transcode.c:                rb_econv_elem_t *prev_te = &ec->elems[i-1];
transcode.c:                ipp = (const unsigned char **)&prev_te->out_data_start;
transcode.c:                is = prev_te->out_data_end;
transcode.c:            if (i == ec->num_trans-1) {
transcode.c:                if (te->out_buf_start != te->out_data_start) {
transcode.c:                    int len = te->out_data_end - te->out_data_start;
transcode.c:                    int off = te->out_data_start - te->out_buf_start;
transcode.c:                    MEMMOVE(te->out_buf_start, te->out_data_start, unsigned char, len);
transcode.c:                    te->out_data_start = te->out_buf_start;
transcode.c:                    te->out_data_end -= off;
transcode.c:                opp = &te->out_data_end;
transcode.c:                os = te->out_buf_end;
transcode.c:            if (ec->num_finished != i)
transcode.c:            te->last_result = res = rb_transcoding_convert(te->tc, ipp, is, opp, os, f);
transcode.c:                ec->num_finished = i+1;
transcode.c:    return -1;
transcode.c:    if (ec->elems[0].last_result == econv_after_output)
transcode.c:        ec->elems[0].last_result = econv_source_buffer_empty;
transcode.c:    needreport_index = -1;
transcode.c:    for (i = ec->num_trans-1; 0 <= i; i--) {
transcode.c:        switch (ec->elems[i].last_result) {
transcode.c:    if (ec->elems[ec->num_trans-1].last_result == econv_destination_buffer_full &&
transcode.c:    } while (needreport_index != -1 && needreport_index != ec->num_trans-1);
transcode.c:    for (i = ec->num_trans-1; 0 <= i; i--) {
transcode.c:        if (ec->elems[i].last_result != econv_source_buffer_empty) {
transcode.c:            rb_econv_result_t res = ec->elems[i].last_result;
transcode.c:                ec->elems[i].last_result = econv_source_buffer_empty;
transcode.c:        *result_position_ptr = -1;
transcode.c:    memset(&ec->last_error, 0, sizeof(ec->last_error));
transcode.c:    if (ec->num_trans == 0) {
transcode.c:        if (ec->in_buf_start && ec->in_data_start != ec->in_data_end) {
transcode.c:            if (output_stop - *output_ptr < ec->in_data_end - ec->in_data_start) {
transcode.c:                len = output_stop - *output_ptr;
transcode.c:                memcpy(*output_ptr, ec->in_data_start, len);
transcode.c:                ec->in_data_start += len;
transcode.c:            len = ec->in_data_end - ec->in_data_start;
transcode.c:            memcpy(*output_ptr, ec->in_data_start, len);
transcode.c:            ec->in_data_start = ec->in_data_end = ec->in_buf_start;
transcode.c:        if (output_stop - *output_ptr < input_stop - *input_ptr) {
transcode.c:            len = output_stop - *output_ptr;
transcode.c:            len = input_stop - *input_ptr;
transcode.c:    if (ec->elems[ec->num_trans-1].out_data_start) {
transcode.c:        unsigned char *data_start = ec->elems[ec->num_trans-1].out_data_start;
transcode.c:        unsigned char *data_end = ec->elems[ec->num_trans-1].out_data_end;
transcode.c:            if (output_stop - *output_ptr < data_end - data_start) {
transcode.c:                len = output_stop - *output_ptr;
transcode.c:                ec->elems[ec->num_trans-1].out_data_start += len;
transcode.c:            len = data_end - data_start;
transcode.c:            ec->elems[ec->num_trans-1].out_data_start =
transcode.c:                ec->elems[ec->num_trans-1].out_data_end = 
transcode.c:                ec->elems[ec->num_trans-1].out_buf_start;
transcode.c:    if (ec->in_buf_start && 
transcode.c:        ec->in_data_start != ec->in_data_end) {
transcode.c:        res = rb_trans_conv(ec, (const unsigned char **)&ec->in_data_start, ec->in_data_end, output_ptr, output_stop,
transcode.c:        ec->num_trans == 1) {
transcode.c:    ec->last_error.result = res;
transcode.c:        rb_transcoding *error_tc = ec->elems[result_position].tc;
transcode.c:        ec->last_error.error_tc = error_tc;
transcode.c:        ec->last_error.source_encoding = error_tc->transcoder->src_encoding;
transcode.c:        ec->last_error.destination_encoding = error_tc->transcoder->dst_encoding;
transcode.c:        ec->last_error.error_bytes_start = TRANSCODING_READBUF(error_tc);
transcode.c:        ec->last_error.error_bytes_len = error_tc->recognized_len;
transcode.c:        ec->last_error.readagain_len = error_tc->readagain_len;
transcode.c:    if (encoding_equal(ec->last_error.source_encoding, "UTF-32BE")) {
transcode.c:        utf = ec->last_error.error_bytes_start;
transcode.c:        utf_len = ec->last_error.error_bytes_len;
transcode.c:        utf = allocate_converted_string(ec->last_error.source_encoding, "UTF-32BE",
transcode.c:                ec->last_error.error_bytes_start, ec->last_error.error_bytes_len,
transcode.c:            return -1;
transcode.c:        if (utf != utfbuf && utf != ec->last_error.error_bytes_start)
transcode.c:        ret = rb_econv_insert_output(ec, (unsigned char *)charef_buf, strlen(charef_buf), "US-ASCII");
transcode.c:        if (ret == -1)
transcode.c:        utf_len -= 4;
transcode.c:    return -1;
transcode.c:    ec->started = 1;
transcode.c:        switch (ec->flags & ECONV_INVALID_MASK) {
transcode.c:        switch (ec->flags & ECONV_UNDEF_MASK) {
transcode.c:    rb_transcoding *tc = ec->last_tc;
transcode.c:    tr = tc->transcoder;
transcode.c:    if (tr->asciicompat_type == asciicompat_encoder)
transcode.c:        return tr->src_encoding;
transcode.c:    return tr->dst_encoding;
transcode.c:    dst_len = dp - dst_str;
transcode.c:        dst_len = dp - dst_str;
transcode.c:/* result: 0:success -1:failure */
transcode.c:    ec->started = 1;
transcode.c:            return -1;
transcode.c:    last_trans_index = ec->num_trans-1;
transcode.c:    if (ec->num_trans == 0) {
transcode.c:        buf_start_p = &ec->in_buf_start;
transcode.c:        data_start_p = &ec->in_data_start;
transcode.c:        data_end_p = &ec->in_data_end;
transcode.c:        buf_end_p = &ec->in_buf_end;
transcode.c:    else if (ec->elems[last_trans_index].tc->transcoder->asciicompat_type == asciicompat_encoder) {
transcode.c:        tc = ec->elems[last_trans_index].tc;
transcode.c:        need += tc->readagain_len;
transcode.c:            buf_start_p = &ec->in_buf_start;
transcode.c:            data_start_p = &ec->in_data_start;
transcode.c:            data_end_p = &ec->in_data_end;
transcode.c:            buf_end_p = &ec->in_buf_end;
transcode.c:            rb_econv_elem_t *ee = &ec->elems[last_trans_index-1];
transcode.c:            buf_start_p = &ee->out_buf_start;
transcode.c:            data_start_p = &ee->out_data_start;
transcode.c:            data_end_p = &ee->out_data_end;
transcode.c:            buf_end_p = &ee->out_buf_end;
transcode.c:        rb_econv_elem_t *ee = &ec->elems[last_trans_index];
transcode.c:        buf_start_p = &ee->out_buf_start;
transcode.c:        data_start_p = &ee->out_data_start;
transcode.c:        data_end_p = &ee->out_data_end;
transcode.c:        buf_end_p = &ee->out_buf_end;
transcode.c:        tc = ec->elems[last_trans_index].tc;
transcode.c:    else if (*buf_end_p - *data_end_p < need) {
transcode.c:        MEMMOVE(*buf_start_p, *data_start_p, unsigned char, *data_end_p - *data_start_p);
transcode.c:        *data_end_p = *buf_start_p + (*data_end_p - *data_start_p);
transcode.c:        if (*buf_end_p - *data_end_p < need) {
transcode.c:            size_t s = (*data_end_p - *buf_start_p) + need;
transcode.c:            *data_end_p = buf + (*data_end_p - *buf_start_p);
transcode.c:    if (tc && tc->transcoder->asciicompat_type == asciicompat_encoder) {
transcode.c:        memcpy(*data_end_p, TRANSCODING_READBUF(tc)+tc->recognized_len, tc->readagain_len);
transcode.c:        *data_end_p += tc->readagain_len;
transcode.c:        tc->readagain_len = 0;
transcode.c:    return -1;
transcode.c:    if (ec->replacement_allocated) {
transcode.c:        xfree((void *)ec->replacement_str);
transcode.c:    for (i = 0; i < ec->num_trans; i++) {
transcode.c:        rb_transcoding_close(ec->elems[i].tc);
transcode.c:        if (ec->elems[i].out_buf_start)
transcode.c:            xfree(ec->elems[i].out_buf_start);
transcode.c:    xfree(ec->in_buf_start);
transcode.c:    xfree(ec->elems);
transcode.c:    if (ec->num_trans == 0)
transcode.c:    return ec->elems[0].tc->readagain_len;
transcode.c:    if (ec->num_trans == 0 || n == 0)
transcode.c:    tc = ec->elems[0].tc;
transcode.c:    memcpy(p, TRANSCODING_READBUF(tc) + tc->recognized_len + tc->readagain_len - n, n);
transcode.c:    tc->readagain_len -= n;
transcode.c:    if (DECORATOR_P(entry->sname, entry->dname))
transcode.c:    if (tr && tr->asciicompat_type == asciicompat_decoder) {
transcode.c:        data->ascii_compat_name = tr->dst_encoding;
transcode.c:     * For ISO-2022-JP, there is ISO-2022-JP -> stateless-ISO-2022-JP and no others.
transcode.c:    if (table2->num_entries != 1)
transcode.c:        if (ec->destination_encoding)
transcode.c:            rb_enc_associate(dst, ec->destination_encoding);
transcode.c:    if (ec->last_tc)
transcode.c:        max_output = ec->last_tc->transcoder->max_output;
transcode.c:        if (rb_str_capacity(dst) - dlen < (size_t)len + max_output) {
transcode.c:        off += sp - ss;
transcode.c:        len -= sp - ss;
transcode.c:        rb_str_set_len(dst, dlen + (dp - ds));
transcode.c:    if (ec->started != 0)
transcode.c:        return -1;
transcode.c:        return -1;
transcode.c:    if (ec->num_trans == 0)
transcode.c:    tr = ec->elems[0].tc->transcoder;
transcode.c:    if (!DECORATOR_P(tr->src_encoding, tr->dst_encoding) &&
transcode.c:        tr->asciicompat_type == asciicompat_decoder)
transcode.c:    if (ec->num_trans == 0)
transcode.c:    tr = ec->elems[ec->num_trans-1].tc->transcoder;
transcode.c:    if (!DECORATOR_P(tr->src_encoding, tr->dst_encoding) &&
transcode.c:        tr->asciicompat_type == asciicompat_encoder)
transcode.c:        return rb_econv_decorate_at(ec, decorator_name, ec->num_trans-1);
transcode.c:    return rb_econv_decorate_at(ec, decorator_name, ec->num_trans);
transcode.c:    if (ec->flags & ECONV_UNIVERSAL_NEWLINE_DECORATOR) {
transcode.c:        if (entry->transcoder)
transcode.c:            trs[n++] = entry->transcoder;
transcode.c:    if (ec->flags & ECONV_CRLF_NEWLINE_DECORATOR) {
transcode.c:        if (entry->transcoder)
transcode.c:            trs[n++] = entry->transcoder;
transcode.c:    if (ec->flags & ECONV_CR_NEWLINE_DECORATOR) {
transcode.c:        if (entry->transcoder)
transcode.c:            trs[n++] = entry->transcoder;
transcode.c:    num_trans = ec->num_trans;
transcode.c:            if (trs[k] == ec->elems[i].tc->transcoder)
transcode.c:            ec->elems[j] = ec->elems[i];
transcode.c:            rb_transcoding_close(ec->elems[i].tc);
transcode.c:            xfree(ec->elems[i].out_buf_start);
transcode.c:            ec->num_trans--;
transcode.c:    ec->flags &= ~(ECONV_UNIVERSAL_NEWLINE_DECORATOR|ECONV_CRLF_NEWLINE_DECORATOR|ECONV_CR_NEWLINE_DECORATOR);
transcode.c:        rb_str_cat2(mesg, "no-conversion");
transcode.c:    if (ec->last_error.result == econv_invalid_byte_sequence ||
transcode.c:        ec->last_error.result == econv_incomplete_input) {
transcode.c:        const char *err = (const char *)ec->last_error.error_bytes_start;
transcode.c:        size_t error_len = ec->last_error.error_bytes_len;
transcode.c:        size_t readagain_len = ec->last_error.readagain_len;
transcode.c:        if (ec->last_error.result == econv_incomplete_input) {
transcode.c:                    ec->last_error.source_encoding);
transcode.c:                    ec->last_error.source_encoding);
transcode.c:                    ec->last_error.source_encoding);
transcode.c:        rb_ivar_set(exc, rb_intern("incomplete_input"), ec->last_error.result == econv_incomplete_input ? Qtrue : Qfalse);
transcode.c:        rb_ivar_set(exc, rb_intern("source_encoding_name"), rb_str_new2(ec->last_error.source_encoding));
transcode.c:        rb_ivar_set(exc, rb_intern("destination_encoding_name"), rb_str_new2(ec->last_error.destination_encoding));
transcode.c:        idx = rb_enc_find_index(ec->last_error.source_encoding);
transcode.c:        idx = rb_enc_find_index(ec->last_error.destination_encoding);
transcode.c:    if (ec->last_error.result == econv_undefined_conversion) {
transcode.c:        VALUE bytes = rb_str_new((const char *)ec->last_error.error_bytes_start,
transcode.c:                                 ec->last_error.error_bytes_len);
transcode.c:                ec->last_error.source_encoding,
transcode.c:                ec->last_error.destination_encoding);
transcode.c:        if (strcmp(ec->last_error.source_encoding,
transcode.c:                   ec->source_encoding_name) != 0 ||
transcode.c:            strcmp(ec->last_error.destination_encoding,
transcode.c:                   ec->destination_encoding_name) != 0) {
transcode.c:                        ec->source_encoding_name,
transcode.c:                        ec->destination_encoding_name);
transcode.c:        idx = rb_enc_find_index(ec->last_error.source_encoding);
transcode.c:    size_t len = (*out_pos - *out_start_ptr);
transcode.c:    if (ec->replacement_str)
transcode.c:    tc = ec->last_tc;
transcode.c:        tr = tc->transcoder;
transcode.c:        enc = rb_enc_find(tr->dst_encoding);
transcode.c:    ec->replacement_str = replacement;
transcode.c:    ec->replacement_len = len;
transcode.c:    ec->replacement_enc = repl_enc;
transcode.c:    ec->replacement_allocated = 0;
transcode.c:            return -1;
transcode.c:    if (ec->replacement_allocated) {
transcode.c:        xfree((void *)ec->replacement_str);
transcode.c:    ec->replacement_allocated = 1;
transcode.c:    ec->replacement_str = str2;
transcode.c:    ec->replacement_len = len2;
transcode.c:    ec->replacement_enc = encname2;
transcode.c:    if (make_replacement(ec) == -1)
transcode.c:        return -1;
transcode.c:    ret = rb_econv_insert_output(ec, ec->replacement_str, ec->replacement_len, ec->replacement_enc);
transcode.c:    if (ret == -1)
transcode.c:        return -1;
transcode.c:    last_tc = ec->last_tc;
transcode.c:    max_output = last_tc ? last_tc->transcoder->max_output : 1;
transcode.c:/* sample transcode_loop implementation in byte-by-byte stream style */
transcode.c:    last_tc = ec->last_tc;
transcode.c:    max_output = last_tc ? last_tc->transcoder->max_output : 1;
transcode.c:            ptr += p - &input_byte;
transcode.c: *  String-specific code
transcode.c:        if (ret == -1) {
transcode.c:	    return -1;
transcode.c:            return NIL_P(arg2) ? -1 : dencidx;
transcode.c:            return NIL_P(arg2) ? -1 : dencidx;
transcode.c:        rb_raise(rb_eArgError, "not fully converted, %"PRIdPTRDIFF" bytes left", sp+slen-fromp);
transcode.c:    rb_str_set_len(dest, bp - buf);
transcode.c:        opt = rb_check_convert_type(argv[argc-1], T_HASH, "Hash", "to_hash");
transcode.c:            argc--;
transcode.c: *  call-seq:
transcode.c: *  call-seq:
transcode.c: *    undefined characters with their (upper-case hexadecimal) numeric
transcode.c:	RBASIC(newstr)->klass = rb_obj_class(str);
transcode.c:    RBASIC(newstr)->klass = rb_obj_class(str);
transcode.c: * call-seq:
transcode.c: *   Encoding::Converter.asciicompat_encoding("ISO-2022-JP") #=> #<Encoding:stateless-ISO-2022-JP>
transcode.c: *   Encoding::Converter.asciicompat_encoding("UTF-16BE") #=> #<Encoding:UTF-8>
transcode.c: *   Encoding::Converter.asciicompat_encoding("UTF-8") #=> nil
transcode.c:    if (num_decorators == -1)
transcode.c:        return -1;
transcode.c:        VALUE pair = RARRAY_PTR(convpath)[n-1];
transcode.c:		return -1;
transcode.c:	    if (!DECORATOR_P(tr->src_encoding, tr->dst_encoding) &&
transcode.c:		    tr->asciicompat_type == asciicompat_encoder) {
transcode.c:		n--;
transcode.c:		rb_ary_store(convpath, len + num_decorators - 1, pair);
transcode.c:	    rb_ary_store(convpath, len + num_decorators - 1, pair);
transcode.c: * call-seq:
transcode.c: *   Encoding::Converter.search_convpath(source_encoding, destination_encoding)         -> ary
transcode.c: *   Encoding::Converter.search_convpath(source_encoding, destination_encoding, opt)    -> ary
transcode.c: *   p Encoding::Converter.search_convpath("ISO-8859-1", "EUC-JP")
transcode.c: *   #=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],
transcode.c: *   #    [#<Encoding:UTF-8>, #<Encoding:EUC-JP>]]
transcode.c: *   p Encoding::Converter.search_convpath("ISO-8859-1", "EUC-JP", universal_newline: true)
transcode.c: *   #=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],
transcode.c: *   #    [#<Encoding:UTF-8>, #<Encoding:EUC-JP>],
transcode.c: *   p Encoding::Converter.search_convpath("ISO-8859-1", "UTF-32BE", universal_newline: true)
transcode.c: *   #=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],
transcode.c: *   #    [#<Encoding:UTF-8>, #<Encoding:UTF-32BE>]]
transcode.c:    if (decorate_convpath(convpath, ecflags) == -1)
transcode.c: * result: >=0:success -1:failure
transcode.c:    if (a->ret == -1)
transcode.c:    ret = rb_econv_add_converter(a->ec, sname, dname, a->index);
transcode.c:    a->ret = ret;
transcode.c:                rb_raise(rb_eArgError, "not a 2-element array in convpath");
transcode.c:            ret = rb_econv_add_converter(ec, sname, dname, ec->num_trans);
transcode.c:            if (ret == -1)
transcode.c:            int j = ec->num_trans;
transcode.c:            arg.index = ec->num_trans;
transcode.c:            if (ret == -1 || arg.ret == -1)
transcode.c:                *sname_p = ec->elems[j].tc->transcoder->src_encoding;
transcode.c:            *dname_p = ec->elems[ec->num_trans-1].tc->transcoder->dst_encoding;
transcode.c:    ec->source_encoding_name = *sname_p;
transcode.c:    ec->destination_encoding_name = *dname_p;
transcode.c: * call-seq:
transcode.c: * - two-element arrays which contain encodings or encoding names, or
transcode.c: * - strings representing decorator names.
transcode.c: * The option integer should be logical-or of constants such as
transcode.c: *   - '&' -> '&amp;'
transcode.c: *   - '<' -> '&lt;'
transcode.c: *   - '>' -> '&gt;'
transcode.c: *   - undefined characters in destination_encoding -> hexadecimal CharRef such as &#xHH;
transcode.c: *   - '&' -> '&amp;'
transcode.c: *   - '<' -> '&lt;'
transcode.c: *   - '>' -> '&gt;'
transcode.c: *   - '"' -> '&quot;'
transcode.c: *   - undefined characters in destination_encoding -> hexadecimal CharRef such as &#xHH;
transcode.c: *   # UTF-16BE to UTF-8
transcode.c: *   ec = Encoding::Converter.new("UTF-16BE", "UTF-8")
transcode.c: *   ec = Encoding::Converter.new("UTF-16BE", "UTF-8", :universal_newline => true)
transcode.c: *   p ec.convpath #=> [[#<Encoding:UTF-16BE>, #<Encoding:UTF-8>],
transcode.c: *   ec = Encoding::Converter.new("UTF-8", "UTF-16BE", :crlf_newline => true)
transcode.c: *                 #    [#<Encoding:UTF-8>, #<Encoding:UTF-16BE>]]
transcode.c: *   ec = Encoding::Converter.new(["universal_newline", ["EUC-JP", "UTF-8"], ["UTF-8", "UTF-16BE"]])
transcode.c: *                 #    [#<Encoding:EUC-JP>, #<Encoding:UTF-8>],
transcode.c: *                 #    [#<Encoding:UTF-8>, #<Encoding:UTF-16BE>]]
transcode.c:    ec->source_encoding = senc;
transcode.c:    ec->destination_encoding = denc;
transcode.c: * call-seq:
transcode.c: *   ec.inspect         -> string
transcode.c: *   ec = Encoding::Converter.new("iso-8859-1", "utf-8")
transcode.c: *   puts ec.inspect    #=> #<Encoding::Converter: ISO-8859-1 to UTF-8>
transcode.c:        const char *sname = ec->source_encoding_name;
transcode.c:        const char *dname = ec->destination_encoding_name;
transcode.c:        econv_description(sname, dname, ec->flags, str);
transcode.c:#define IS_ECONV(obj) (RDATA(obj)->dfree == (RUBY_DATA_FUNC)econv_free)
transcode.c: * call-seq:
transcode.c: *   ec.source_encoding -> encoding
transcode.c:    if (!ec->source_encoding) 
transcode.c:    return rb_enc_from_encoding(ec->source_encoding);
transcode.c: * call-seq:
transcode.c: *   ec.destination_encoding -> encoding
transcode.c:    if (!ec->destination_encoding) 
transcode.c:    return rb_enc_from_encoding(ec->destination_encoding);
transcode.c: * call-seq:
transcode.c: *   ec.convpath        -> ary
transcode.c: *   ec = Encoding::Converter.new("ISo-8859-1", "EUC-JP", crlf_newline: true)
transcode.c: *   #=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],
transcode.c: *   #    [#<Encoding:UTF-8>, #<Encoding:EUC-JP>],
transcode.c: * In the above example, [#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>] means
transcode.c: * a converter from ISO-8859-1 to UTF-8.
transcode.c:    for (i = 0; i < ec->num_trans; i++) {
transcode.c:        const rb_transcoder *tr = ec->elems[i].tc->transcoder;
transcode.c:        if (DECORATOR_P(tr->src_encoding, tr->dst_encoding))
transcode.c:            v = rb_str_new_cstr(tr->dst_encoding);
transcode.c:            v = rb_assoc_new(make_encobj(tr->src_encoding), make_encobj(tr->dst_encoding));
transcode.c: * call-seq:
transcode.c: *   ec.primitive_convert(source_buffer, destination_buffer) -> symbol
transcode.c: *   ec.primitive_convert(source_buffer, destination_buffer, destination_byteoffset) -> symbol
transcode.c: *   ec.primitive_convert(source_buffer, destination_buffer, destination_byteoffset, destination_bytesize) -> symbol
transcode.c: *   ec.primitive_convert(source_buffer, destination_buffer, destination_byteoffset, destination_bytesize, opt) -> symbol
transcode.c: * - invalid byte sequence found in source buffer (:invalid_byte_sequence)
transcode.c: * - unexpected end of source buffer (:incomplete_input)
transcode.c: * - character not representable in output encoding (:undefined_conversion)
transcode.c: * - after some output is generated, before input is done (:after_output)
transcode.c: * - destination buffer is full (:destination_buffer_full)
transcode.c: *   this occur only when destination_bytesize is non-nil.
transcode.c: * - source buffer is empty (:source_buffer_empty)
transcode.c: * - conversion is finished (:finished)
transcode.c: *   ec = Encoding::Converter.new("UTF-8", "UTF-16BE")
transcode.c: *   ec = Encoding::Converter.new("UTF-8", "UTF-16BE")
transcode.c:    rb_str_set_len(output, op-(unsigned char *)RSTRING_PTR(output));
transcode.c:        rb_str_drop_bytes(input, ip - (unsigned char *)RSTRING_PTR(input));
transcode.c:    if (ec->destination_encoding) {
transcode.c:        rb_enc_associate(output, ec->destination_encoding);
transcode.c: * call-seq:
transcode.c: *   ec.convert(source_string) -> destination_string
transcode.c: *   ec = Encoding::Converter.new("utf-8", "euc-jp")
transcode.c: *   ec = Encoding::Converter.new("euc-jp", "utf-8")
transcode.c: *   ec = Encoding::Converter.new("utf-8", "iso-2022-jp")
transcode.c: *   puts ec.convert("\xE3").dump       #=> "".force_encoding("ISO-2022-JP")
transcode.c: *   puts ec.convert("\x81").dump       #=> "".force_encoding("ISO-2022-JP")
transcode.c: *   puts ec.convert("\x82").dump       #=> "\e$B$\"".force_encoding("ISO-2022-JP")
transcode.c: *   puts ec.finish.dump                #=> "\e(B".force_encoding("ISO-2022-JP")
transcode.c: * call-seq:
transcode.c: *   ec.finish -> string
transcode.c: *   ec = Encoding::Converter.new("utf-8", "iso-2022-jp")
transcode.c: * call-seq:
transcode.c: *   ec.primitive_errinfo -> array
transcode.c: * as a 5-element array:
transcode.c: * For example, a converter from EUC-JP to ISO-8859-1 converts
transcode.c: * a string as follows: EUC-JP -> UTF-8 -> ISO-8859-1.
transcode.c: * So [enc1, enc2] is either ["EUC-JP", "UTF-8"] or ["UTF-8", "ISO-8859-1"].
transcode.c: *   # \xff is invalid as EUC-JP.
transcode.c: *   ec = Encoding::Converter.new("EUC-JP", "Shift_JIS")
transcode.c: *   #=> [:invalid_byte_sequence, "EUC-JP", "UTF-8", "\xFF", ""]
transcode.c: *   # HIRAGANA LETTER A (\xa4\xa2 in EUC-JP) is not representable in ISO-8859-1.
transcode.c: *   # Since this error is occur in UTF-8 to ISO-8859-1 conversion,
transcode.c: *   # error_bytes is HIRAGANA LETTER A in UTF-8 (\xE3\x81\x82).
transcode.c: *   ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")
transcode.c: *   #=> [:undefined_conversion, "UTF-8", "ISO-8859-1", "\xE3\x81\x82", ""]
transcode.c: *   ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")
transcode.c: *   #=> [:incomplete_input, "EUC-JP", "UTF-8", "\xA4", ""]
transcode.c: *   ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")
transcode.c: *   # \xd8\x00\x00@ is invalid as UTF-16BE because
transcode.c: *   ec = Encoding::Converter.new("UTF-16BE", "UTF-8")
transcode.c: *   #=> [:invalid_byte_sequence, "UTF-16BE", "UTF-8", "\xD8\x00", "\x00"]
transcode.c: *   # Similar to UTF-16BE, \x00\xd8@\x00 is invalid as UTF-16LE.
transcode.c: *   ec = Encoding::Converter.new("UTF-16LE", "UTF-8")
transcode.c: *   #=> [:invalid_byte_sequence, "UTF-16LE", "UTF-8", "\x00\xD8", "@\x00"]
transcode.c:    rb_ary_store(ary, 0, econv_result_to_symbol(ec->last_error.result));
transcode.c:    if (ec->last_error.source_encoding)
transcode.c:        rb_ary_store(ary, 1, rb_str_new2(ec->last_error.source_encoding));
transcode.c:    if (ec->last_error.destination_encoding)
transcode.c:        rb_ary_store(ary, 2, rb_str_new2(ec->last_error.destination_encoding));
transcode.c:    if (ec->last_error.error_bytes_start) {
transcode.c:        rb_ary_store(ary, 3, rb_str_new((const char *)ec->last_error.error_bytes_start, ec->last_error.error_bytes_len));
transcode.c:        rb_ary_store(ary, 4, rb_str_new((const char *)ec->last_error.error_bytes_start + ec->last_error.error_bytes_len, ec->last_error.readagain_len));
transcode.c: * call-seq:
transcode.c: *   ec.insert_output(string) -> nil
transcode.c: *  ec = Encoding::Converter.new("utf-8", "iso-8859-1")
transcode.c: *  ec = Encoding::Converter.new("utf-8", "iso-2022-jp")
transcode.c: *  src = "\u{306F 3041 3068 2661 3002}" # U+2661 is not representable in iso-2022-jp
transcode.c: *  puts "[#{dst.dump}, #{src.dump}]"   #=> ["\e$B$O$!$H".force_encoding("ISO-2022-JP"), "\xE3\x80\x82"]
transcode.c: *  puts "[#{dst.dump}, #{src.dump}]"   #=> ["\e$B$O$!$H\e(B?\e$B!#\e(B".force_encoding("ISO-2022-JP"), ""]
transcode.c:    if (ret == -1) {
transcode.c: * call-seq
transcode.c: *   ec = Encoding::Converter.new("utf-16le", "iso-8859-1")
transcode.c: *   p ec.primitive_errinfo     #=> [:invalid_byte_sequence, "UTF-16LE", "UTF-8", "\x00\xD8", "a\x00"]
transcode.c:    if (ec->source_encoding) {
transcode.c:        rb_enc_associate(str, ec->source_encoding);
transcode.c: * call-seq:
transcode.c: *   ec.last_error -> exception or nil
transcode.c: *  ec = Encoding::Converter.new("utf-8", "iso-8859-1")
transcode.c: *  p ec.last_error      #=> #<Encoding::InvalidByteSequenceError: "\xF1" followed by "a" on UTF-8>
transcode.c: * call-seq:
transcode.c: *   ec.replacement -> string
transcode.c: *  ec = Encoding::Converter.new("euc-jp", "us-ascii")
transcode.c: *  ec = Encoding::Converter.new("euc-jp", "utf-8")
transcode.c:    if (ret == -1) {
transcode.c:    enc = rb_enc_find(ec->replacement_enc);
transcode.c:    return rb_enc_str_new((const char *)ec->replacement_str, (long)ec->replacement_len, enc);
transcode.c: * call-seq:
transcode.c: *  ec = Encoding::Converter.new("utf-8", "us-ascii", :undef => :replace)
transcode.c:    if (ret == -1) {
transcode.c: * call-seq:
transcode.c: *   ecerr.source_encoding_name         -> string
transcode.c: * call-seq:
transcode.c: *   ecerr.source_encoding              -> encoding
transcode.c: *  ec = Encoding::Converter.new("ISO-8859-1", "EUC-JP") # ISO-8859-1 -> UTF-8 -> EUC-JP
transcode.c: *    ec.convert("\xa0") # NO-BREAK SPACE, which is available in UTF-8 but not in EUC-JP.
transcode.c: *    p $!.source_encoding              #=> #<Encoding:UTF-8>
transcode.c: *    p $!.destination_encoding         #=> #<Encoding:EUC-JP>
transcode.c: *    p $!.source_encoding_name         #=> "UTF-8"
transcode.c: *    p $!.destination_encoding_name    #=> "EUC-JP"
transcode.c: * call-seq:
transcode.c: *   ecerr.destination_encoding_name         -> string
transcode.c: * call-seq:
transcode.c: *   ecerr.destination_encoding         -> string
transcode.c: * call-seq:
transcode.c: *   ecerr.error_char         -> string
transcode.c: * Returns the one-character string which cause Encoding::UndefinedConversionError.
transcode.c: *  ec = Encoding::Converter.new("ISO-8859-1", "EUC-JP")
transcode.c: *    p $!.error_char.encoding  #=> #<Encoding:UTF-8>
transcode.c: * call-seq:
transcode.c: *   ecerr.error_bytes         -> string
transcode.c: *  ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")
transcode.c: *    p $!      #=> #<Encoding::InvalidByteSequenceError: "\xA1" followed by "\xFF" on EUC-JP>
transcode.c: * call-seq:
transcode.c: *   ecerr.readagain_bytes         -> string
transcode.c: * call-seq:
transcode.c: *   ecerr.incomplete_input?         -> true or false
transcode.c: *  ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")
transcode.c: *    p $!      #=> #<Encoding::InvalidByteSequenceError: "\xA1" followed by "z" on EUC-JP>
transcode.c: *    p $!      #=> #<Encoding::InvalidByteSequenceError: incomplete "\xA1" on EUC-JP>
transcode.c:    rb_define_method(rb_cString, "encode", str_encode, -1);
transcode.c:    rb_define_method(rb_cString, "encode!", str_encode_bang, -1);
transcode.c:    rb_define_singleton_method(rb_cEncodingConverter, "search_convpath", econv_s_search_convpath, -1);
transcode.c:    rb_define_method(rb_cEncodingConverter, "initialize", econv_init, -1);
transcode.c:    rb_define_method(rb_cEncodingConverter, "primitive_convert", econv_primitive_convert, -1);
transcode.c:    rb_define_method(rb_cEncodingConverter, "putback", econv_putback, -1);
ãã¤ããªã¼ã»ãã¡ã¤ã«transcode.oã¯ä¸è´ãã¾ãã
transcode_data.h:  transcode_data.h -
transcode_data.h:#define FOURbt	(0x06)		/* four bytes payload, UTF-8 only, macros start at getBT0 */
transcode_data.h:#define makeSTR1LEN(len) ((len)-4)
transcode_data.h:#define getBT0(a)	((((a)>> 5)&0x07)|0xF0)   /* for UTF-8 only!!! */
transcode_data.h:#define ONETRAIL       /* legal but undefined if one more trailing UTF-8 */
transcode_data.h:#define TWOTRAIL       /* legal but undefined if two more trailing UTF-8 */
transcode_data.h:#define THREETRAIL     /* legal but undefined if three more trailing UTF-8 */
transcode_data.h:  asciicompat_converter,        /* ASCII-compatible -> ASCII-compatible */
transcode_data.h:  asciicompat_decoder,          /* ASCII-incompatible -> ASCII-compatible */
transcode_data.h:  asciicompat_encoder           /* ASCII-compatible -> ASCII-incompatible */
transcode_data.h:  /* ASCII-incompatible -> ASCII-incompatible is intentionally ommitted. */
transcode_data.h:    VALUE (*func_ii)(void*, VALUE); /* info  -> info   */
transcode_data.h:    VALUE (*func_si)(void*, const unsigned char*, size_t); /* start -> info   */
transcode_data.h:    ssize_t (*func_io)(void*, VALUE, const unsigned char*, size_t); /* info  -> output */
transcode_data.h:    ssize_t (*func_so)(void*, const unsigned char*, size_t, unsigned char*, size_t); /* start -> output */
transcode_data.h:    ssize_t (*finish_func)(void*, unsigned char*, size_t); /* -> output */
transcode_data.h:    ssize_t (*resetsize_func)(void*); /* -> len */
transcode_data.h:    ssize_t (*resetstate_func)(void*, unsigned char*, size_t); /* -> output */
transdb.h:rb_declare_transcoder("Big5", "UTF-8", "big5");
transdb.h:rb_declare_transcoder("UTF-8", "Big5", "big5");
transdb.h:rb_declare_transcoder("GB2312", "UTF-8", "chinese");
transdb.h:rb_declare_transcoder("GB12345", "UTF-8", "chinese");
transdb.h:rb_declare_transcoder("UTF-8", "GB2312", "chinese");
transdb.h:rb_declare_transcoder("UTF-8", "GB12345", "chinese");
transdb.h:rb_declare_transcoder("GB18030", "UTF-8", "gb18030");
transdb.h:rb_declare_transcoder("UTF-8", "GB18030", "gb18030");
transdb.h:rb_declare_transcoder("GBK", "UTF-8", "gbk");
transdb.h:rb_declare_transcoder("UTF-8", "GBK", "gbk");
transdb.h:rb_declare_transcoder("ISO-2022-JP", "stateless-ISO-2022-JP", "iso2022");
transdb.h:rb_declare_transcoder("stateless-ISO-2022-JP", "ISO-2022-JP", "iso2022");
transdb.h:rb_declare_transcoder("stateless-ISO-2022-JP", "EUC-JP", "iso2022");
transdb.h:rb_declare_transcoder("EUC-JP", "stateless-ISO-2022-JP", "iso2022");
transdb.h:rb_declare_transcoder("EUC-JP", "Shift_JIS", "japanese");
transdb.h:rb_declare_transcoder("Shift_JIS", "EUC-JP", "japanese");
transdb.h:rb_declare_transcoder("EUC-JP", "UTF-8", "japanese_euc");
transdb.h:rb_declare_transcoder("eucJP-ms", "UTF-8", "japanese_euc");
transdb.h:rb_declare_transcoder("CP51932", "UTF-8", "japanese_euc");
transdb.h:rb_declare_transcoder("UTF-8", "EUC-JP", "japanese_euc");
transdb.h:rb_declare_transcoder("UTF-8", "eucJP-ms", "japanese_euc");
transdb.h:rb_declare_transcoder("UTF-8", "CP51932", "japanese_euc");
transdb.h:rb_declare_transcoder("Shift_JIS", "UTF-8", "japanese_sjis");
transdb.h:rb_declare_transcoder("Windows-31J", "UTF-8", "japanese_sjis");
transdb.h:rb_declare_transcoder("UTF-8", "Shift_JIS", "japanese_sjis");
transdb.h:rb_declare_transcoder("UTF-8", "Windows-31J", "japanese_sjis");
transdb.h:rb_declare_transcoder("UTF-8", "EUC-KR", "korean");
transdb.h:rb_declare_transcoder("EUC-KR", "UTF-8", "korean");
transdb.h:rb_declare_transcoder("UTF-8", "CP949", "korean");
transdb.h:rb_declare_transcoder("CP949", "UTF-8", "korean");
transdb.h:rb_declare_transcoder("US-ASCII", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "US-ASCII", "single_byte");
transdb.h:rb_declare_transcoder("ASCII-8BIT", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "ASCII-8BIT", "single_byte");
transdb.h:rb_declare_transcoder("ISO-8859-1", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "ISO-8859-1", "single_byte");
transdb.h:rb_declare_transcoder("ISO-8859-2", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "ISO-8859-2", "single_byte");
transdb.h:rb_declare_transcoder("ISO-8859-3", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "ISO-8859-3", "single_byte");
transdb.h:rb_declare_transcoder("ISO-8859-4", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "ISO-8859-4", "single_byte");
transdb.h:rb_declare_transcoder("ISO-8859-5", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "ISO-8859-5", "single_byte");
transdb.h:rb_declare_transcoder("ISO-8859-6", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "ISO-8859-6", "single_byte");
transdb.h:rb_declare_transcoder("ISO-8859-7", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "ISO-8859-7", "single_byte");
transdb.h:rb_declare_transcoder("ISO-8859-8", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "ISO-8859-8", "single_byte");
transdb.h:rb_declare_transcoder("ISO-8859-9", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "ISO-8859-9", "single_byte");
transdb.h:rb_declare_transcoder("ISO-8859-10", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "ISO-8859-10", "single_byte");
transdb.h:rb_declare_transcoder("ISO-8859-11", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "ISO-8859-11", "single_byte");
transdb.h:rb_declare_transcoder("ISO-8859-13", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "ISO-8859-13", "single_byte");
transdb.h:rb_declare_transcoder("ISO-8859-14", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "ISO-8859-14", "single_byte");
transdb.h:rb_declare_transcoder("ISO-8859-15", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "ISO-8859-15", "single_byte");
transdb.h:rb_declare_transcoder("WINDOWS-874", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "WINDOWS-874", "single_byte");
transdb.h:rb_declare_transcoder("WINDOWS-1250", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "WINDOWS-1250", "single_byte");
transdb.h:rb_declare_transcoder("WINDOWS-1251", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "WINDOWS-1251", "single_byte");
transdb.h:rb_declare_transcoder("WINDOWS-1252", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "WINDOWS-1252", "single_byte");
transdb.h:rb_declare_transcoder("WINDOWS-1253", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "WINDOWS-1253", "single_byte");
transdb.h:rb_declare_transcoder("WINDOWS-1254", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "WINDOWS-1254", "single_byte");
transdb.h:rb_declare_transcoder("WINDOWS-1255", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "WINDOWS-1255", "single_byte");
transdb.h:rb_declare_transcoder("WINDOWS-1256", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "WINDOWS-1256", "single_byte");
transdb.h:rb_declare_transcoder("WINDOWS-1257", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "WINDOWS-1257", "single_byte");
transdb.h:rb_declare_transcoder("IBM437", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "IBM437", "single_byte");
transdb.h:rb_declare_transcoder("IBM775", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "IBM775", "single_byte");
transdb.h:rb_declare_transcoder("IBM852", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "IBM852", "single_byte");
transdb.h:rb_declare_transcoder("IBM855", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "IBM855", "single_byte");
transdb.h:rb_declare_transcoder("IBM857", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "IBM857", "single_byte");
transdb.h:rb_declare_transcoder("IBM860", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "IBM860", "single_byte");
transdb.h:rb_declare_transcoder("IBM861", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "IBM861", "single_byte");
transdb.h:rb_declare_transcoder("IBM862", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "IBM862", "single_byte");
transdb.h:rb_declare_transcoder("IBM863", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "IBM863", "single_byte");
transdb.h:rb_declare_transcoder("IBM865", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "IBM865", "single_byte");
transdb.h:rb_declare_transcoder("IBM866", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "IBM866", "single_byte");
transdb.h:rb_declare_transcoder("IBM869", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "IBM869", "single_byte");
transdb.h:rb_declare_transcoder("MACCROATIAN", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "MACCROATIAN", "single_byte");
transdb.h:rb_declare_transcoder("MACCYRILLIC", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "MACCYRILLIC", "single_byte");
transdb.h:rb_declare_transcoder("MACGREEK", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "MACGREEK", "single_byte");
transdb.h:rb_declare_transcoder("MACICELAND", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "MACICELAND", "single_byte");
transdb.h:rb_declare_transcoder("MACROMAN", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "MACROMAN", "single_byte");
transdb.h:rb_declare_transcoder("MACROMANIA", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "MACROMANIA", "single_byte");
transdb.h:rb_declare_transcoder("MACTURKISH", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "MACTURKISH", "single_byte");
transdb.h:rb_declare_transcoder("MACUKRAINE", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "MACUKRAINE", "single_byte");
transdb.h:rb_declare_transcoder("KOI8-U", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "KOI8-U", "single_byte");
transdb.h:rb_declare_transcoder("KOI8-R", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "KOI8-R", "single_byte");
transdb.h:rb_declare_transcoder("TIS-620", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "TIS-620", "single_byte");
transdb.h:rb_declare_transcoder("CP850", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "CP850", "single_byte");
transdb.h:rb_declare_transcoder("CP852", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "CP852", "single_byte");
transdb.h:rb_declare_transcoder("CP855", "UTF-8", "single_byte");
transdb.h:rb_declare_transcoder("UTF-8", "CP855", "single_byte");
transdb.h:rb_declare_transcoder("UTF-16BE", "UTF-8", "utf_16_32");
transdb.h:rb_declare_transcoder("UTF-8", "UTF-16BE", "utf_16_32");
transdb.h:rb_declare_transcoder("UTF-16LE", "UTF-8", "utf_16_32");
transdb.h:rb_declare_transcoder("UTF-8", "UTF-16LE", "utf_16_32");
transdb.h:rb_declare_transcoder("UTF-32BE", "UTF-8", "utf_16_32");
transdb.h:rb_declare_transcoder("UTF-8", "UTF-32BE", "utf_16_32");
transdb.h:rb_declare_transcoder("UTF-32LE", "UTF-8", "utf_16_32");
transdb.h:rb_declare_transcoder("UTF-8", "UTF-32LE", "utf_16_32");
uncommon.mk:RUBYLIB       = -
uncommon.mk:RUBYOPT       = -
uncommon.mk:STATIC_RUBY   = static-ruby
uncommon.mk:LIBRUBY_EXTS  = ./.libruby-with-ext.time
uncommon.mk:ID_H_TARGET   = -id.h-
uncommon.mk:SCRIPT_ARGS   =	--dest-dir="$(DESTDIR)" \
uncommon.mk:		--extout="$(EXTOUT)" \
uncommon.mk:		--mflags="$(MFLAGS)" \
uncommon.mk:		--make-flags="$(MAKEFLAGS)"
uncommon.mk:EXTMK_ARGS    =	$(SCRIPT_ARGS) --extension $(EXTS) --extstatic $(EXTSTATIC) \
uncommon.mk:		--make-flags="MINIRUBY='$(MINIRUBY)'" --
uncommon.mk:		--data-mode=$(INSTALL_DATA_MODE) \
uncommon.mk:		--prog-mode=$(INSTALL_PROG_MODE) \
uncommon.mk:		--installed-list $(INSTALLED_LIST)
uncommon.mk:PRE_LIBRUBY_UPDATE = $(MINIRUBY) -e 'ARGV[1] or File.unlink(ARGV[0]) rescue nil' -- \
uncommon.mk:COMPILE_PRELUDE = $(MINIRUBY) -I$(srcdir) -rrbconfig $(srcdir)/tool/compile_prelude.rb
uncommon.mk:	@$(MINIRUBY) $(srcdir)/ext/extmk.rb --make="$(MAKE)" --command-output=$@ $(EXTMK_ARGS)
uncommon.mk:	$(MINIRUBY) -e 'p $$:'
uncommon.mk:	@$(NM) -Pgp $(OBJS) | awk 'BEGIN{print "#!"}; $$2~/^[BD]$$/{print $$1}' | sort -u -o $@
uncommon.mk:install: install-nodoc $(RDOCTARGET)
uncommon.mk:install-all: install-nodoc install-doc
uncommon.mk:install-nodoc: pre-install-nodoc do-install-nodoc post-install-nodoc
uncommon.mk:pre-install-nodoc:: pre-install-local pre-install-ext
uncommon.mk:do-install-nodoc: $(PREP)
uncommon.mk:	$(INSTRUBY) --make="$(MAKE)" $(INSTRUBY_ARGS) --mantype="$(MANTYPE)"
uncommon.mk:post-install-nodoc:: post-install-local post-install-ext
uncommon.mk:install-local: pre-install-local do-install-local post-install-local
uncommon.mk:pre-install-local:: pre-install-bin pre-install-lib pre-install-man
uncommon.mk:do-install-local: $(PREP)
uncommon.mk:	$(INSTRUBY) --make="$(MAKE)" $(INSTRUBY_ARGS) --install=local --mantype="$(MANTYPE)"
uncommon.mk:post-install-local:: post-install-bin post-install-lib post-install-man
uncommon.mk:install-ext: pre-install-ext do-install-ext post-install-ext
uncommon.mk:pre-install-ext:: pre-install-ext-arch pre-install-ext-comm
uncommon.mk:do-install-ext: $(PREP)
uncommon.mk:	$(INSTRUBY) --make="$(MAKE)" $(INSTRUBY_ARGS) --install=ext
uncommon.mk:post-install-ext:: post-install-ext-arch post-install-ext-comm
uncommon.mk:install-arch: pre-install-arch do-install-arch post-install-arch
uncommon.mk:pre-install-arch:: pre-install-bin pre-install-ext-arch
uncommon.mk:do-install-arch: $(PREP)
uncommon.mk:	$(INSTRUBY) --make="$(MAKE)" $(INSTRUBY_ARGS) --install=bin --install=ext-arch
uncommon.mk:post-install-arch:: post-install-bin post-install-ext-arch
uncommon.mk:install-comm: pre-install-comm do-install-comm post-install-comm
uncommon.mk:pre-install-comm:: pre-install-lib pre-install-ext-comm pre-install-man
uncommon.mk:do-install-comm: $(PREP)
uncommon.mk:	$(INSTRUBY) --make="$(MAKE)" $(INSTRUBY_ARGS) --install=lib --install=ext-comm --install=man
uncommon.mk:post-install-comm:: post-install-lib post-install-ext-comm post-install-man
uncommon.mk:install-bin: pre-install-bin do-install-bin post-install-bin
uncommon.mk:pre-install-bin:: install-prereq
uncommon.mk:do-install-bin: $(PREP)
uncommon.mk:	$(INSTRUBY) --make="$(MAKE)" $(INSTRUBY_ARGS) --install=bin
uncommon.mk:post-install-bin::
uncommon.mk:install-lib: pre-install-lib do-install-lib post-install-lib
uncommon.mk:pre-install-lib:: install-prereq
uncommon.mk:do-install-lib: $(PREP)
uncommon.mk:	$(INSTRUBY) --make="$(MAKE)" $(INSTRUBY_ARGS) --install=lib
uncommon.mk:post-install-lib::
uncommon.mk:install-ext-comm: pre-install-ext-comm do-install-ext-comm post-install-ext-comm
uncommon.mk:pre-install-ext-comm:: install-prereq
uncommon.mk:do-install-ext-comm: $(PREP)
uncommon.mk:	$(INSTRUBY) --make="$(MAKE)" $(INSTRUBY_ARGS) --install=ext-comm
uncommon.mk:post-install-ext-comm::
uncommon.mk:install-ext-arch: pre-install-ext-arch do-install-ext-arch post-install-ext-arch
uncommon.mk:pre-install-ext-arch:: install-prereq
uncommon.mk:do-install-ext-arch: $(PREP)
uncommon.mk:	$(INSTRUBY) --make="$(MAKE)" $(INSTRUBY_ARGS) --install=ext-arch
uncommon.mk:post-install-ext-arch::
uncommon.mk:install-man: pre-install-man do-install-man post-install-man
uncommon.mk:pre-install-man:: install-prereq
uncommon.mk:do-install-man: $(PREP)
uncommon.mk:	$(INSTRUBY) --make="$(MAKE)" $(INSTRUBY_ARGS) --install=man --mantype="$(MANTYPE)"
uncommon.mk:post-install-man::
uncommon.mk:what-where: no-install
uncommon.mk:no-install: no-install-nodoc no-install-doc
uncommon.mk:what-where-all: no-install-all
uncommon.mk:no-install-all: no-install-nodoc
uncommon.mk:what-where-nodoc: no-install-nodoc
uncommon.mk:no-install-nodoc: pre-no-install-nodoc dont-install-nodoc post-no-install-nodoc
uncommon.mk:pre-no-install-nodoc:: pre-no-install-local pre-no-install-ext
uncommon.mk:dont-install-nodoc:  $(PREP)
uncommon.mk:	$(INSTRUBY) -n --make="$(MAKE)" $(INSTRUBY_ARGS) --mantype="$(MANTYPE)"
uncommon.mk:post-no-install-nodoc:: post-no-install-local post-no-install-ext
uncommon.mk:what-where-local: no-install-local
uncommon.mk:no-install-local: pre-no-install-local dont-install-local post-no-install-local
uncommon.mk:pre-no-install-local:: pre-no-install-bin pre-no-install-lib pre-no-install-man
uncommon.mk:dont-install-local: $(PREP)
uncommon.mk:	$(INSTRUBY) -n --make="$(MAKE)" $(INSTRUBY_ARGS) --install=local --mantype="$(MANTYPE)"
uncommon.mk:post-no-install-local:: post-no-install-bin post-no-install-lib post-no-install-man
uncommon.mk:what-where-ext: no-install-ext
uncommon.mk:no-install-ext: pre-no-install-ext dont-install-ext post-no-install-ext
uncommon.mk:pre-no-install-ext:: pre-no-install-ext-arch pre-no-install-ext-comm
uncommon.mk:dont-install-ext: $(PREP)
uncommon.mk:	$(INSTRUBY) -n --make="$(MAKE)" $(INSTRUBY_ARGS) --install=ext
uncommon.mk:post-no-install-ext:: post-no-install-ext-arch post-no-install-ext-comm
uncommon.mk:what-where-arch: no-install-arch
uncommon.mk:no-install-arch: pre-no-install-arch dont-install-arch post-no-install-arch
uncommon.mk:pre-no-install-arch:: pre-no-install-bin pre-no-install-ext-arch
uncommon.mk:dont-install-arch: $(PREP)
uncommon.mk:	$(INSTRUBY) -n --make="$(MAKE)" $(INSTRUBY_ARGS) --install=bin --install=ext-arch
uncommon.mk:post-no-install-arch:: post-no-install-lib post-no-install-man post-no-install-ext-arch
uncommon.mk:what-where-comm: no-install-comm
uncommon.mk:no-install-comm: pre-no-install-comm dont-install-comm post-no-install-comm
uncommon.mk:pre-no-install-comm:: pre-no-install-lib pre-no-install-ext-comm pre-no-install-man
uncommon.mk:dont-install-comm: $(PREP)
uncommon.mk:	$(INSTRUBY) -n --make="$(MAKE)" $(INSTRUBY_ARGS) --install=lib --install=ext-comm --install=man
uncommon.mk:post-no-install-comm:: post-no-install-lib post-no-install-ext-comm post-no-install-man
uncommon.mk:what-where-bin: no-install-bin
uncommon.mk:no-install-bin: pre-no-install-bin dont-install-bin post-no-install-bin
uncommon.mk:pre-no-install-bin:: install-prereq
uncommon.mk:dont-install-bin: $(PREP)
uncommon.mk:	$(INSTRUBY) -n --make="$(MAKE)" $(INSTRUBY_ARGS) --install=bin
uncommon.mk:post-no-install-bin::
uncommon.mk:what-where-lib: no-install-lib
uncommon.mk:no-install-lib: pre-no-install-lib dont-install-lib post-no-install-lib
uncommon.mk:pre-no-install-lib:: install-prereq
uncommon.mk:dont-install-lib: $(PREP)
uncommon.mk:	$(INSTRUBY) -n --make="$(MAKE)" $(INSTRUBY_ARGS) --install=lib
uncommon.mk:post-no-install-lib::
uncommon.mk:what-where-ext-comm: no-install-ext-comm
uncommon.mk:no-install-ext-comm: pre-no-install-ext-comm dont-install-ext-comm post-no-install-ext-comm
uncommon.mk:pre-no-install-ext-comm:: install-prereq
uncommon.mk:dont-install-ext-comm: $(PREP)
uncommon.mk:	$(INSTRUBY) -n --make="$(MAKE)" $(INSTRUBY_ARGS) --install=ext-comm
uncommon.mk:post-no-install-ext-comm::
uncommon.mk:what-where-ext-arch: no-install-ext-arch
uncommon.mk:no-install-ext-arch: pre-no-install-ext-arch dont-install-ext-arch post-no-install-ext-arch
uncommon.mk:pre-no-install-ext-arch:: install-prereq
uncommon.mk:dont-install-ext-arch: $(PREP)
uncommon.mk:	$(INSTRUBY) -n --make="$(MAKE)" $(INSTRUBY_ARGS) --install=ext-arch
uncommon.mk:post-no-install-ext-arch::
uncommon.mk:what-where-man: no-install-man
uncommon.mk:no-install-man: pre-no-install-man dont-install-man post-no-install-man
uncommon.mk:pre-no-install-man:: install-prereq
uncommon.mk:dont-install-man: $(PREP)
uncommon.mk:	$(INSTRUBY) -n --make="$(MAKE)" $(INSTRUBY_ARGS) --install=man --mantype="$(MANTYPE)"
uncommon.mk:post-no-install-man::
uncommon.mk:install-doc: rdoc pre-install-doc do-install-doc post-install-doc
uncommon.mk:pre-install-doc:: install-prereq
uncommon.mk:do-install-doc: $(PROGRAM)
uncommon.mk:	$(INSTRUBY) --make="$(MAKE)" $(INSTRUBY_ARGS) --install=rdoc --rdoc-output="$(RDOCOUT)"
uncommon.mk:post-install-doc::
uncommon.mk:	$(RUNRUBY) "$(srcdir)/bin/rdoc" --all --ri --op "$(RDOCOUT)" "$(srcdir)"
uncommon.mk:what-where-doc: no-install-doc
uncommon.mk:no-install-doc: pre-no-install-doc dont-install-doc post-no-install-doc
uncommon.mk:pre-no-install-doc:: install-prereq
uncommon.mk:dont-install-doc:: $(PREP)
uncommon.mk:	$(INSTRUBY) -n --make="$(MAKE)" $(INSTRUBY_ARGS) --install=rdoc --rdoc-output="$(RDOCOUT)"
uncommon.mk:post-no-install-doc::
uncommon.mk:CLEAR_INSTALLED_LIST = clear-installed-list
uncommon.mk:install-prereq: $(CLEAR_INSTALLED_LIST)
uncommon.mk:clear-installed-list:
uncommon.mk:clean: clean-ext clean-local clean-enc clean-golf clean-rdoc clean-extout
uncommon.mk:clean-local::
uncommon.mk:clean-ext::
uncommon.mk:clean-enc:
uncommon.mk:	@-$(MAKE) -f $(ENC_MK) $(MFLAGS) clean
uncommon.mk:clean-golf:
uncommon.mk:clean-rdoc:
uncommon.mk:clean-extout:
uncommon.mk:	@-$(RMDIRS) $(EXTOUT)/$(arch)
uncommon.mk:distclean: distclean-ext distclean-local distclean-enc distclean-golf distclean-extout
uncommon.mk:distclean-local:: clean-local
uncommon.mk:distclean-ext::
uncommon.mk:distclean-enc: clean-enc
uncommon.mk:	@-$(MAKE) -f $(ENC_MK) $(MFLAGS) distclean
uncommon.mk:distclean-golf: clean-golf
uncommon.mk:distclean-rdoc:
uncommon.mk:distclean-extout: clean-extout
uncommon.mk:	@-$(RMDIRS) $(EXTOUT)
uncommon.mk:realclean:: realclean-ext realclean-local realclean-enc realclean-golf realclean-extout
uncommon.mk:realclean-local:: distclean-local
uncommon.mk:realclean-ext::
uncommon.mk:realclean-enc:: distclean-enc
uncommon.mk:realclean-golf: distclean-golf
uncommon.mk:realclean-extout: distclean-extout
uncommon.mk:check: test test-all
uncommon.mk:	$(BOOTSTRAPRUBY) "$(srcdir)/bootstraptest/runner.rb" --ruby="$(MINIRUBY)" $(OPTS)
uncommon.mk:btest-ruby: miniruby$(EXEEXT) $(RBCONFIG) $(PROGRAM) PHONY
uncommon.mk:	@$(RUNRUBY) "$(srcdir)/bootstraptest/runner.rb" --ruby="$(PROGRAM) -I$(srcdir)/lib" -q $(OPTS)
uncommon.mk:test-sample: miniruby$(EXEEXT) $(RBCONFIG) $(PROGRAM) PHONY
uncommon.mk:test-knownbug: miniruby$(EXEEXT) $(PROGRAM) $(RBCONFIG) PHONY
uncommon.mk:	$(MINIRUBY) "$(srcdir)/bootstraptest/runner.rb" --ruby="$(PROGRAM)" $(OPTS) $(srcdir)/KNOWNBUGS.rb
uncommon.mk:test: test-sample btest-ruby test-knownbug
uncommon.mk:test-all:
uncommon.mk:	$(RUNRUBY) -C "$(EXTCONFDIR)" $(EXTCONF) $(EXTCONFARGS)
uncommon.mk:	@$(MINIRUBY) $(srcdir)/mkconfig.rb -timestamp=$@ \
uncommon.mk:		-install_name=$(RUBY_INSTALL_NAME) \
uncommon.mk:		-so_name=$(RUBY_SO_NAME) rbconfig.rb
uncommon.mk:	$(MAKE) -f $(ENC_MK) RUBY="$(MINIRUBY)" MINIRUBY="$(MINIRUBY)" $(MFLAGS) $@
uncommon.mk:	$(MINIRUBY) $(srcdir)/enc/make_encmake.rb --builtin-encs="$(BUILTIN_ENCOBJS)" --builtin-transes="$(BUILTIN_TRANSOBJS)" $@ $(ENCS)
uncommon.mk:.PHONY: test install install-nodoc install-doc dist
uncommon.mk:	$(YACC) -d $(YFLAGS) -o y.tab.c $(<:\=/)
uncommon.mk:	sed -f $(srcdir)/tool/ytab.sed -e "/^#/s!y\.tab\.c!$@!" y.tab.c > $@.new
uncommon.mk:	sed -e "/^#line.*y\.tab\.h/d;/^#line.*parse\.y/d" y.tab.h > $(@:.c=.h).new
uncommon.mk:	$(CC) $(CFLAGS) -c $<
uncommon.mk:# when I use -I., there is confliction at "OpenFile" 
uncommon.mk:newline.c: $(srcdir)/enc/trans/newline.trans $(srcdir)/tool/transcode-tblgen.rb
uncommon.mk:INSNS2VMOPT = --srcdir="$(srcdir)"
uncommon.mk:srcs: parse.c lex.c newline.c $(srcdir)/ext/ripper/ripper.c srcs-enc
uncommon.mk:srcs-enc: $(ENC_MK)
uncommon.mk:	$(MAKE) -f $(ENC_MK) RUBY="$(MINIRUBY)" MINIRUBY="$(MINIRUBY)" $(MFLAGS) srcs
uncommon.mk:	$(MINIRUBY) $(srcdir)/tool/generic_erb.rb -c -o $@ $(srcdir)/template/encdb.h.tmpl $(srcdir)/enc enc
uncommon.mk:transdb.h: $(PREP) srcs-enc $(srcdir)/tool/generic_erb.rb $(srcdir)/template/transdb.h.tmpl
uncommon.mk:	$(MINIRUBY) $(srcdir)/tool/generic_erb.rb -c -o $@ $(srcdir)/template/transdb.h.tmpl $(srcdir)/enc/trans enc/trans
uncommon.mk:# 	$(BASERUBY) $(srcdir)/tool/generic_erb.rb --if-change --output=$@ \
uncommon.mk:# 		$(srcdir)/template/id.h.tmpl --vpath=$(VPATH) parse.h
uncommon.mk:	@-$(BASERUBY) $(srcdir)/tool/file2lastrev.rb --revision.h "$(@D)" > "$@.tmp"
uncommon.mk:	cd $(srcdir)/ext/ripper && $(exec) $(MAKE) -f depend $(MFLAGS) top_srcdir=../.. srcdir=.
uncommon.mk:	$(BASERUBY) $(srcdir)/benchmark/driver.rb -v \
uncommon.mk:	            --executables="$(COMPARE_RUBY); $(RUNRUBY)" \
uncommon.mk:	            --pattern='bm_' --directory=$(srcdir)/benchmark $(OPTS)
uncommon.mk:benchmark-each: $(PROGRAM) PHONY
uncommon.mk:	$(BASERUBY) $(srcdir)/benchmark/driver.rb -v \
uncommon.mk:	            --executables="$(COMPARE_RUBY); $(RUNRUBY)" \
uncommon.mk:	            --pattern=$(ITEM) --directory=$(srcdir)/benchmark $(OPTS)
uncommon.mk:	$(BASERUBY) $(srcdir)/benchmark/driver.rb -v \
uncommon.mk:	            --executables="$(COMPARE_RUBY); $(RUNRUBY)" \
uncommon.mk:	            --pattern='bmx_' --directory=$(srcdir)/benchmark $(OPTS)
uncommon.mk:	gdb -x run.gdb --quiet --args $(MINIRUBY) $(TESTRUN_SCRIPT)
uncommon.mk:gdb-ruby: $(PROGRAM) run.gdb PHONY
uncommon.mk:	gdb -x run.gdb --quiet --args $(PROGRAM) $(TESTRUN_SCRIPT)
uncommon.mk:	$(BASERUBY) $(srcdir)/tool/make-snapshot tmp $(RELNAME)
uncommon.mk:	-@$(MAKE) $(MFLAGS) REVISION_FORCE=PHONY "$(srcdir)/revision.h"
uncommon.mk:	@echo "  gdb-ruby:        runs test.rb by ruby under gdb"
uncommon.mk:	@echo "  check:           equals make test test-all"
uncommon.mk:	@echo "  test-all:        all ruby tests"
uncommon.mk:	@echo "  test-rubyspec    run RubySpec test suite"
uncommon.mk:	@echo "  update-rubyspec  update local copy of RubySpec"
uncommon.mk:	@echo "  install-nodoc:   install without rdoc"
uncommon.mk:	@echo "  http://redmine.ruby-lang.org/wiki/ruby/DeveloperHowto"
ãã¤ããªã¼ã»ãã¡ã¤ã«unicode.oã¯ä¸è´ãã¾ãã
ãã¤ããªã¼ã»ãã¡ã¤ã«us_ascii.oã¯ä¸è´ãã¾ãã
ãã¤ããªã¼ã»ãã¡ã¤ã«utf_8.oã¯ä¸è´ãã¾ãã
util.c:  util.c -
util.c:  Copyright (C) 1993-2008 Yukihiro Matsumoto
util.c:    while (len-- && *s >= '0' && *s <= '7') {
util.c:	retval |= *s++ - '0';
util.c:    *retlen = s - start;
util.c:    while (len-- && *s && (tmp = strchr(hexdigit, *s))) {
util.c:	retval |= (tmp - hexdigit) & 15;
util.c:    *retlen = s - start;
util.c:        /*0*/ -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
util.c:        /*1*/ -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
util.c:        /*2*/ -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
util.c:        /*3*/  0, 1, 2, 3, 4, 5, 6, 7, 8, 9,-1,-1,-1,-1,-1,-1,
util.c:        /*4*/ -1,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,
util.c:        /*5*/ 25,26,27,28,29,30,31,32,33,34,35,-1,-1,-1,-1,-1,
util.c:        /*6*/ -1,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,
util.c:        /*7*/ 25,26,27,28,29,30,31,32,33,34,35,-1,-1,-1,-1,-1,
util.c:        /*8*/ -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
util.c:        /*9*/ -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
util.c:        /*a*/ -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
util.c:        /*b*/ -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
util.c:        /*c*/ -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
util.c:        /*d*/ -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
util.c:        /*e*/ -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
util.c:        /*f*/ -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
util.c:        if (d == -1 || base <= d) {
util.c:            *retlen = (str-1) - start;
util.c:    *retlen = (str-1) - start;
util.c:    else if (c == '-') {
util.c:        sign = -1;
util.c:        ret = -ret;
util.c: * Suffix appending for in-place editing under MS-DOS and OS/2 (and now NT!).
util.c: else              mmkind = -1;\
util.c:#define PUSH(ll,rr) do { top->LL = (ll); top->RR = (rr); ++top; } while (0)  /* Push L,l,R,r */
util.c:#define POP(ll,rr)  do { --top; ll = top->LL; rr = top->RR; } while (0)      /* Pop L,l,R,r */
util.c:  char *R = (char*)base + size*(nel-1); /* right end of current region */
util.c:    t = (r - l + size) / size;  /* number of elements */
util.c:    if ((t = (*cmp)(l,m,d)) < 0) {                           /*3-5-?*/
util.c:      if ((t = (*cmp)(m,r,d)) < 0) {                         /*3-5-7*/
util.c:	fail: goto loopA;                                    /*3-5-7*/
util.c:	if ((*cmp)(l,r,d) <= 0) {mmswap(m,r); goto loopA;}     /*3-5-4*/
util.c:	mmrot3(r,m,l); goto loopA;                           /*3-5-2*/
util.c:      goto loopB;                                            /*3-5-5*/
util.c:    if (t > 0) {                                             /*7-5-?*/
util.c:      if ((t = (*cmp)(m,r,d)) > 0) {                         /*7-5-3*/
util.c:	  while (l<r) {mmswap(l,r); l+=size; r-=size;}  /* reverse region */
util.c:	fail2: mmswap(l,r); goto loopA;                      /*7-5-3*/
util.c:	if ((*cmp)(l,r,d) <= 0) {mmswap(l,m); goto loopB;}   /*7-5-8*/
util.c:	mmrot3(l,m,r); goto loopA;                           /*7-5-6*/
util.c:      mmswap(l,r); goto loopA;                               /*7-5-5*/
util.c:    if ((t = (*cmp)(m,r,d)) < 0)  {goto loopA;}              /*5-5-7*/
util.c:    if (t > 0) {mmswap(l,r); goto loopB;}                    /*5-5-3*/
util.c:    /* determining splitting type in case 5-5-5 */           /*5-5-5*/
util.c:      if ((l += size) == r)      goto nxt;                   /*5-5-5*/
util.c:      if ((t = (*cmp)(l,m,d)) > 0) {mmswap(l,r); l = L; goto loopA;}/*575-5*/
util.c:      if (t < 0)                 {mmswap(L,l); l = L; goto loopB;}  /*535-5*/
util.c:	  {l -= size; if (l != m) mmswap(m,l); l -= size; goto fin;}
util.c:	if (l == (r -= size))
util.c:	  {l -= size; if (l != m) mmswap(m,l); l -= size; goto fin;}
util.c:	if (l == (r -= size))
util.c:	if (l-L < R-r) {PUSH(r,R); R = l;} /* sort left side first */
util.c:/* On a machine with IEEE extended-precision registers, it is
util.c: * necessary to specify double-precision (53-bit) rounding precision
util.c: * necessary to #include "float.h" or another system-dependent header
util.c:/* strtod for IEEE-, VAX-, and IBM-arithmetic machines.
util.c: * broken by the IEEE round-even rule.  Otherwise ties are broken by
util.c: * Point Numbers Accurately" [Proc. ACM SIGPLAN '90, pp. 92-101].
util.c: *	1. We only require IEEE, IBM, or VAX double-precision
util.c: *		arithmetic (not IEEE double-extended).
util.c: *	2. We get by with floating-point arithmetic in a case that
util.c: *		Clinger missed -- when we're computing d * 10^n
util.c: *		compute (d*10^k) * 10^(e-k) with just one roundoff.
util.c: *	3. Rather than a bit-at-a-time adjustment of the binary
util.c: *		result in the hard case, we use floating-point
util.c: *		for ten-to-e (just some small tables, e.g. of 10^k
util.c: * #define IEEE_LITTLE_ENDIAN for IEEE-arithmetic machines where the least
util.c: * #define IEEE_BIG_ENDIAN for IEEE-arithmetic machines where the most
util.c: * #define Long int on machines with 32-bit ints and 64-bit longs.
util.c: * #define IBM for IBM mainframe-style floating-point arithmetic.
util.c: * #define VAX for VAX-style floating-point arithmetic (D_floating).
util.c: * #define No_leftright to omit left-right logic in fast floating-point
util.c: *	that use extended-precision instructions to compute rounded
util.c: * #define ROUND_BIASED for IEEE-format with biased rounding.
util.c: * #define Inaccurate_Divide for IEEE-format with correctly rounded
util.c: *	#define Just_16 to store 16 bits per 32-bit Long when doing
util.c: *	high-precision integer arithmetic.  Whether this speeds things
util.c: * #define KR_headers for old-style C function headers.
util.c: *	directly -- and assumed always to succeed.
util.c: *	such as decimal-to-binary conversion of a very long string of
util.c: *	all dtoa conversions in single-threaded executions with 8-byte
util.c: *	pointers, PRIVATE_MEM >= 7400 appears to suffice; with 4-byte
util.c: *	appropriately -- to the most significant word of a quiet NaN.
util.c: *	(On HP Series 700/800 machines, -DNAN_WORD0=0x7ff40000 works.)
util.c: *	If you #define NO_IEEE_Scale on a machine that uses IEEE-format
util.c: *	floating-point numbers and flushes underflows to zero rather
util.c: *	optimizing compilers (e.g., gcc 2.95.1 under -O2).
util.c: *	inexact or when it is a numeric value rounded to +-infinity).
util.c: *	the result overflows to +-Infinity or underflows to 0.
util.c:#define PRIVATE_mem ((PRIVATE_MEM+sizeof(double)-1)/sizeof(double))
util.c:/* Quick_max = floor((P-1)*log(FLT_RADIX)/log(10) - 1) */
util.c:/* Int_max = floor(P*log(FLT_RADIX)/log(10) - 1) */
util.c:#define Emin (-1022)
util.c:#define Big0 (Frac_mask1 | Exp_msk1*(DBL_MAX_EXP+Bias-1))
util.c:/* When Pack_32 is not defined, we store 16 bits per 32-bit Long.
util.c:        freelist[k] = rv->next;
util.c:        rv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(ULong));
util.c:        len = (sizeof(Bigint) + (x-1)*sizeof(ULong) + sizeof(double) - 1)
util.c:        if (pmem_next - private_mem + len <= PRIVATE_mem) {
util.c:        rv->k = k;
util.c:        rv->maxwds = x;
util.c:    rv->sign = rv->wds = 0;
util.c:        v->next = freelist[v->k];
util.c:        freelist[v->k] = v;
util.c:#define Bcopy(x,y) memcpy((char *)&x->sign, (char *)&y->sign, \
util.c:y->wds*sizeof(Long) + 2*sizeof(int))
util.c:    wds = b->wds;
util.c:    x = b->x;
util.c:        if (wds >= b->maxwds) {
util.c:            b1 = Balloc(b->k+1);
util.c:        b->x[wds++] = carry;
util.c:        b->wds = wds;
util.c:    b->x[0] = y9;
util.c:    b->wds = 1;
util.c:    b->x[0] = y9 & 0xffff;
util.c:    b->wds = (b->x[1] = y9 >> 16) ? 2 : 1;
util.c:            b = multadd(b, 10, *s++ - '0');
util.c:        b = multadd(b, 10, *s++ - '0');
util.c:    b->x[0] = i;
util.c:    b->wds = 1;
util.c:    if (a->wds < b->wds) {
util.c:    k = a->k;
util.c:    wa = a->wds;
util.c:    wb = b->wds;
util.c:    if (wc > a->maxwds)
util.c:    for (x = c->x, xa = x + wc; x < xa; x++)
util.c:    xa = a->x;
util.c:    xb = b->x;
util.c:    xc0 = c->x;
util.c:    for (xc0 = c->x, xc = xc0 + wc; wc > 0 && !*--xc; --wc) ;
util.c:    c->wds = wc;
util.c:        b = multadd(b, p05[i-1], 0);
util.c:            p5->next = 0;
util.c:        p5->next = 0;
util.c:        if (!(p51 = p5->next)) {
util.c:            if (!(p51 = p5->next)) {
util.c:                p51 = p5->next = mult(p5,p5);
util.c:                p51->next = 0;
util.c:            p51 = p5->next = mult(p5,p5);
util.c:            p51->next = 0;
util.c:    k1 = b->k;
util.c:    n1 = n + b->wds + 1;
util.c:    for (i = b->maxwds; n1 > i; i <<= 1)
util.c:    x1 = b1->x;
util.c:    x = b->x;
util.c:    xe = x + b->wds;
util.c:        k1 = 32 - k;
util.c:        k1 = 16 - k;
util.c:    b1->wds = n1 - 1;
util.c:    i = a->wds;
util.c:    j = b->wds;
util.c:    if (i > 1 && !a->x[i-1])
util.c:        Bug("cmp called with a->x[a->wds-1] == 0");
util.c:    if (j > 1 && !b->x[j-1])
util.c:        Bug("cmp called with b->x[b->wds-1] == 0");
util.c:    if (i -= j)
util.c:    xa0 = a->x;
util.c:    xb0 = b->x;
util.c:        if (*--xa != *--xb)
util.c:            return *xa < *xb ? -1 : 1;
util.c:        c->wds = 1;
util.c:        c->x[0] = 0;
util.c:    c = Balloc(a->k);
util.c:    c->sign = i;
util.c:    wa = a->wds;
util.c:    xa = a->x;
util.c:    wb = b->wds;
util.c:    xb = b->x;
util.c:    xc = c->x;
util.c:        y = (ULLong)*xa++ - *xb++ - borrow;
util.c:        y = *xa++ - borrow;
util.c:        y = (*xa & 0xffff) - (*xb & 0xffff) - borrow;
util.c:        z = (*xa++ >> 16) - (*xb++ >> 16) - borrow;
util.c:        y = (*xa & 0xffff) - borrow;
util.c:        z = (*xa++ >> 16) - borrow;
util.c:        y = *xa++ - *xb++ - borrow;
util.c:        y = *xa++ - borrow;
util.c:    while (!*--xc)
util.c:        wa--;
util.c:    c->wds = wa;
util.c:    L = (word0(x) & Exp_mask) - (P-1)*Exp_msk1;
util.c:        L = -L >> Exp_shift;
util.c:            L -= Exp_shift;
util.c:            word1(a) = L >= 31 ? 1 : 1 << 31 - L;
util.c:    xa0 = a->x;
util.c:    xa = xa0 + a->wds;
util.c:    y = *--xa;
util.c:    *e = 32 - k;
util.c:        d0 = Exp_1 | y >> (Ebits - k);
util.c:        w = xa > xa0 ? *--xa : 0;
util.c:        d1 = y << ((32-Ebits) + k) | w >> (Ebits - k);
util.c:    z = xa > xa0 ? *--xa : 0;
util.c:    if (k -= Ebits) {
util.c:        d0 = Exp_1 | y << k | z >> (32 - k);
util.c:        y = xa > xa0 ? *--xa : 0;
util.c:        d1 = z << k | y >> (32 - k);
util.c:        z = xa > xa0 ? *--xa : 0;
util.c:        d0 = Exp_1 | y << k - Ebits | z >> Ebits + 16 - k;
util.c:        w = xa > xa0 ? *--xa : 0;
util.c:        y = xa > xa0 ? *--xa : 0;
util.c:        d1 = z << k + 16 - Ebits | w << k - Ebits | y >> 16 + Ebits - k;
util.c:    z = xa > xa0 ? *--xa : 0;
util.c:    w = xa > xa0 ? *--xa : 0;
util.c:    k -= Ebits + 16;
util.c:    d0 = Exp_1 | y << k + 16 | z << k | w >> 16 - k;
util.c:    y = xa > xa0 ? *--xa : 0;
util.c:    x = b->x;
util.c:            x[0] = y | z << (32 - k);
util.c:        b->wds = (x[1] = z) ? 2 : 1;
util.c:        b->wds = 1;
util.c:                x[0] = y | z << 32 - k & 0xffff;
util.c:                x[1] = z >> k - 16 & 0xffff;
util.c:                x[1] = y >> 16 | z << 16 - k & 0xffff;
util.c:        --i;
util.c:    b->wds = i + 1;
util.c:        *e = (de - Bias - (P-1) << 2) + k;
util.c:        *bits = 4*P + 8 - k - hi0bits(word0(d) & Frac_mask);
util.c:        *e = de - Bias - (P-1) + k;
util.c:        *bits = P - k;
util.c:        *e = de - Bias - (P-1) + 1 + k;
util.c:        *bits = 32*i - hi0bits(x[i-1]);
util.c:        *bits = (i+2)*16 - hi0bits(x[i]);
util.c:    k = ka - kb + 32*(a->wds - b->wds);
util.c:    k = ka - kb + 16*(a->wds - b->wds);
util.c:        k = -k;
util.c:        k = -k;
util.c:static const double tinytens[] = { 1e-16, 1e-32, 1e-64, 1e-128,
util.c:    9007199254740992.*9007199254740992.e-256
util.c:    /* = 2^106 * 1e-53 */
util.c:    1e-256
util.c:static const double tinytens[] = { 1e-16, 1e-32, 1e-64 };
util.c:static const double tinytens[] = { 1e-16, 1e-32 };
util.c:            c += 'a' - 'A';
util.c:            c -= '0';
util.c:            c += 10 - 'a';
util.c:            c += 10 - 'A';
util.c:          case '-':
util.c:            y = 10*y + c - '0';
util.c:            z = 10*z + c - '0';
util.c:    s1 = localeconv()->decimal_point;
util.c:            if (c -= '0') {
util.c:          case '-':
util.c:                L = c - '0';
util.c:                    L = 10*L + c - '0';
util.c:                if (s - s1 > 8 || L > 19999)
util.c:                    e = -e;
util.c:                    --s;
util.c:    e1 = e -= nf;
util.c:     * decimal point, followed by nd-nd0 digits.  The number we're
util.c:        dval(rv) = tens[k - 9] * dval(rv) + z;
util.c:                    rv = -rv;
util.c:            i = DBL_DIG - nd;
util.c:                    rv = -rv;
util.c:                e -= i;
util.c:                word0(rv) -= P*Exp_msk1;
util.c:                        > Exp_msk1*(DBL_MAX_EXP+Bias-1-P))
util.c:        else if (e >= -Ten_pmax) {
util.c:                rv = -rv;
util.c:            /* rv = */ rounded_quotient(dval(rv), tens[-e]);
util.c:    e1 += nd - k;
util.c:                  case 3: /* toward -infinity */
util.c:            word0(rv) -= P*Exp_msk1;
util.c:                    > Exp_msk1*(DBL_MAX_EXP+Bias-P))
util.c:            if (z > Exp_msk1*(DBL_MAX_EXP+Bias-1-P)) {
util.c:        e1 = -e1;
util.c:            if (scale && (j = 2*P + 1 - ((word0(rv) & Exp_mask)
util.c:                        word0(rv) &= 0xffffffff << (j-32);
util.c:    /* Now the hard part -- adjusting rv to the correct value.*/
util.c:        bd = Balloc(bd0->k);
util.c:            bb2 = bb5 = -e;
util.c:            bd2 -= bbe;
util.c:        j = bbe - scale;
util.c:        i = j + bbbits - 1; /* logb(rv) */
util.c:            j += P - Emin;
util.c:            j = P + 1 - bbbits;
util.c:        j = 1 + 4*P - 3 - bbbits + ((bbe + bbbits - 1) & 3);
util.c:        j = P + 1 - bbbits;
util.c:        i = j + bbbits - 1; /* logb(rv) */
util.c:            j += P - Emin;
util.c:            j = P + 1 - bbbits;
util.c:            bb2 -= i;
util.c:            bd2 -= i;
util.c:            bs2 -= i;
util.c:        dsign = delta->sign;
util.c:        delta->sign = 0;
util.c:                if (!delta->x[0] && delta->wds <= 1) {
util.c:                    adj = -1.;
util.c:                                adj = -0.5;
util.c:                        word0(adj) += (2*P+1)*Exp_msk1 - y;
util.c:                        word0(rv) -= P*Exp_msk1;
util.c:                word0(adj) += (2*P+1)*Exp_msk1 - y;
util.c:                    dval(rv) -= adj;
util.c:                word0(rv) -= P*Exp_msk1;
util.c:                dval(rv) -= adj;
util.c:            /* Error is less than half an ulp -- check for
util.c:                if (!delta->x[0] && delta->wds <= 1)
util.c:            if (!delta->x[0] && delta->wds <= 1) {
util.c:            /* exactly half-way between */
util.c:                        ? (0xffffffff & (0xffffffff << (2*P+1-(y>>Exp_shift)))) :
util.c:                    /*boundary case -- increment exponent*/
util.c:                /* boundary case -- decrement exponent */
util.c:                L -= Exp_msk1;
util.c:                L = (word0(rv) & Exp_mask) - Exp_msk1;
util.c:                dval(rv) -= ulp(dval(rv));
util.c:            dsign = 1 - dsign;
util.c:                dval(aadj1) = -1.;
util.c:                /* special case -- power of FLT_RADIX to be */
util.c:                dval(aadj1) = -aadj;
util.c:            dval(aadj1) = dsign ? aadj : -aadj;
util.c:                aadj1 -= 0.5;
util.c:              case 3: /* towards -infinity */
util.c:        if (y == Exp_msk1*(DBL_MAX_EXP+Bias-1)) {
util.c:            word0(rv) -= P*Exp_msk1;
util.c:                    Exp_msk1*(DBL_MAX_EXP+Bias-P)) {
util.c:                    dval(aadj1) = dsign ? aadj : -aadj;
util.c:                word0(aadj1) += (2*P+1)*Exp_msk1 - y;
util.c:                    word0(rv) -= P*Exp_msk1;
util.c:             * correctly round rv + adj in some half-way cases.
util.c:             * y <= (P-1)*Exp_msk1), we must adjust aadj to avoid
util.c:             * example: 1.2e-307 .
util.c:            if (y <= (P-1)*Exp_msk1 && aadj > 1.) {
util.c:                    aadj1 = -aadj1;
util.c:            aadj -= L;
util.c:        word0(rv0) = Exp_1 - 2*P*Exp_msk1;
util.c:        dval(rv0) = 1e-300;
util.c:    return sign ? -dval(rv) : dval(rv);
util.c:    n = S->wds;
util.c:    /*debug*/ if (b->wds > n)
util.c:    if (b->wds < n)
util.c:    sx = S->x;
util.c:    sxe = sx + --n;
util.c:    bx = b->x;
util.c:            y = *bx - (ys & FFFFFFFF) - borrow;
util.c:            y = (*bx & 0xffff) - (ys & 0xffff) - borrow;
util.c:            z = (*bx >> 16) - (zs & 0xffff) - borrow;
util.c:            y = *bx - (ys & 0xffff) - borrow;
util.c:            bx = b->x;
util.c:            while (--bxe > bx && !*bxe)
util.c:                --n;
util.c:            b->wds = n;
util.c:        bx = b->x;
util.c:        sx = S->x;
util.c:            y = *bx - (ys & FFFFFFFF) - borrow;
util.c:            y = (*bx & 0xffff) - (ys & 0xffff) - borrow;
util.c:            z = (*bx >> 16) - (zs & 0xffff) - borrow;
util.c:            y = *bx - (ys & 0xffff) - borrow;
util.c:        bx = b->x;
util.c:            while (--bxe > bx && !*bxe)
util.c:                --n;
util.c:            b->wds = n;
util.c: * Inspired by "How to Print Floating-Point Numbers Accurately" by
util.c: * Guy L. Steele, Jr. and Jon L. White [Proc. ACM SIGPLAN '90, pp. 112-126].
util.c: *     round-nearest rule will give the same floating-point value
util.c: *  5. When converting floating-point integers less than 1e16,
util.c: *     we use floating-point arithmetic rather than resorting
util.c: *     to multiple-precision integers.
util.c: *     to get by with floating-point arithmetic; we resort to
util.c: *     multiple-precision integer arithmetic only if we cannot
util.c: *     guarantee that the floating-point calculation has given
util.c: *     something like 10^(k-15) that we must resort to the Long
util.c:    to the end of the return value.  If d is +-Infinity or NaN,
util.c:            round-nearest mode) with the tests of mode 0 to
util.c:            -DHonor_FLT_ROUNDS, modes 4 and 5 behave the same
util.c:        6-9 ==> Debugging modes similar to mode - 4:  don't try
util.c:            fast floating-point estimate (if applicable).
util.c:        Values of mode other than 0-9 are treated as mode 0.
util.c:        if (j = 11 - hi0bits(word0(d2) & Frac_mask))
util.c:        /* log(x)   ~=~ log(1.5) + (x-1.5)/1.5
util.c:         *      ~=~ log(1.5)/log(10) + (x-1.5)/(1.5*log(10))
util.c:         * log10(d) = (i-Bias)*log(2)/log(10) + log10(d2)
util.c:         * k = (i - Bias)*0.301029995663981
util.c:         *  + ( (d2-1.5)*0.289529654602168 + 0.176091259055681 );
util.c:         * The error in the first-order Taylor series approximation
util.c:         * (i - Bias) by 0.301029995663981; since |i - Bias| <= 1077,
util.c:         * and 1077 * 0.30103 * 2^-52 ~=~ 7.2e-14,
util.c:         * adding 1e-13 to the constant term more than suffices.
util.c:        i -= Bias;
util.c:        i = bbits + be + (Bias + (P-1) - 1);
util.c:        x = i > 32  ? word0(d) << (64 - i) | word1(d) >> (i - 32)
util.c:	    : word1(d) << (32 - i);
util.c:        word0(d2) -= 31*Exp_msk1; /* adjust exponent */
util.c:        i -= (Bias + (P-1) - 1) + 1;
util.c:    ds = (dval(d2)-1.5)*0.289529654602168 + 0.1760912590558 + i*0.301029995663981;
util.c:        k--;    /* want k = floor(ds) */
util.c:            k--;
util.c:    j = bbits - i - 1;
util.c:        b2 = -j;
util.c:        b2 -= k;
util.c:        b5 = -k;
util.c:        mode -= 4;
util.c:    ilim = ilim1 = -1;
util.c:        ilim1 = i - 1;
util.c:        /* Try to get by with floating-point arithmetic. */
util.c:                j &= Bletch - 1;
util.c:                dval(d) /= bigtens[n_bigtens-1];
util.c:        else if ((j1 = -k) != 0) {
util.c:            k--;
util.c:        word0(eps) -= (P-1)*Exp_msk1;
util.c:            dval(d) -= 5.;
util.c:            if (dval(d) < -dval(eps))
util.c:            dval(eps) = 0.5/tens[ilim-1] - dval(eps);
util.c:                dval(d) -= L;
util.c:                if (1. - dval(d) < dval(eps))
util.c:            dval(eps) *= tens[ilim-1];
util.c:                if (!(dval(d) -= L))
util.c:                    else if (dval(d) < 0.5 - dval(eps)) {
util.c:                        while (*--s == '0') ;
util.c:            dval(d) -= L*ds;
util.c:                L--;
util.c:                    while (*--s == '9')
util.c:            denorm ? be + (Bias + (P-1) - 1 + 1) :
util.c:            1 + 4*P - 3 - bbits + ((bbits + be - 1) & 3);
util.c:            1 + P - bbits;
util.c:        b2 -= i;
util.c:        m2 -= i;
util.c:        s2 -= i;
util.c:            if ((j = b5 - m5) != 0)
util.c:    if ((i = ((s5 ? 32 - hi0bits(S->x[S->wds-1]) : 1) + s2) & 0x1f) != 0)
util.c:        i = 32 - i;
util.c:    if ((i = ((s5 ? 32 - hi0bits(S->x[S->wds-1]) : 1) + s2) & 0xf) != 0)
util.c:        i = 16 - i;
util.c:        i -= 4;
util.c:            k--;
util.c:            k = -1 - ndigits;
util.c:        /* Compute mlo -- check for special case
util.c:            mhi = Balloc(mhi->k);
util.c:            j1 = delta->sign ? 1 : cmp(b, delta);
util.c:                else if (!b->x[0] && b->wds <= 1)
util.c:                if (!b->x[0] && b->wds <= 1) {
util.c:            if (!b->x[0] && b->wds <= 1) {
util.c:        while (*--s == '9')
util.c:        while (*--s == '0') ;
util.c:	len = end - str;
ãã¤ããªã¼ã»ãã¡ã¤ã«util.oã¯ä¸è´ãã¾ãã
variable.c:  variable.c -
variable.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
variable.c:  Copyright (C) 2000  Information-technology Promotion Agency, Japan
variable.c:	if (fc->track == rb_cObject) break;
variable.c:	if (RCLASS_IV_TBL(fc->track) &&
variable.c:	    st_lookup(RCLASS_IV_TBL(fc->track), classpath, &tmp)) {
variable.c:	tmp = rb_str_dup(rb_id2str(fc->name));
variable.c:	fc = fc->prev;
variable.c:    if (value == res->klass) {
variable.c:	res->path = fc_path(res, key);
variable.c:		if (list->track == value) return ST_CONTINUE;
variable.c:		list = list->prev;
variable.c:	    arg.klass = res->klass;
variable.c:		res->path = arg.path;
variable.c: *  call-seq:
variable.c:		s = rb_class2name(RBASIC(klass)->klass);
variable.c:	id = rb_intern2(pbeg, p-pbeg);
variable.c:	    rb_raise(rb_eArgError, "undefined class/module %.*s", (int)(p-path), path);
variable.c:	entry->id = id;
variable.c:	entry->var = var;
variable.c:	var->counter = 1;
variable.c:	var->data = 0;
variable.c:	var->getter = undef_getter;
variable.c:	var->setter = undef_setter;
variable.c:	var->marker = undef_marker;
variable.c:	var->block_trace = 0;
variable.c:	var->trace = 0;
variable.c:    var->getter = val_getter;
variable.c:    var->setter = val_setter;
variable.c:    var->marker = val_marker;
variable.c:    var->data = (void*)val;
variable.c:    var->data = (void*)val;
variable.c:    rb_name_error(id, "%s is a read-only variable", rb_id2name(id));
variable.c:    struct global_variable *var = entry->var;
variable.c:    (*var->marker)(var->data);
variable.c:    trace = var->trace;
variable.c:	if (trace->data) rb_gc_mark_maybe(trace->data);
variable.c:	trace = trace->next;
variable.c:    struct global_variable *gvar = rb_global_entry(id)->var;
variable.c:    gvar->data = (void*)var;
variable.c:    gvar->getter = getter?(gvar_getter_t *)getter:var_getter;
variable.c:    gvar->setter = setter?(gvar_setter_t *)setter:var_setter;
variable.c:    gvar->marker = var_marker;
variable.c: *  call-seq:
variable.c:    trace->next = entry->var->trace;
variable.c:    trace->func = rb_trace_eval;
variable.c:    trace->data = cmd;
variable.c:    trace->removed = 0;
variable.c:    entry->var->trace = trace;
variable.c:    struct trace_var *trace = var->trace;
variable.c:    while (trace->next) {
variable.c:	next = trace->next;
variable.c:	if (next->removed) {
variable.c:	    trace->next = next->next;
variable.c:    var->trace = t.next;
variable.c: *  call-seq:
variable.c:    trace = (entry = (struct global_entry *)data)->var->trace;
variable.c:	    struct trace_var *next = trace->next;
variable.c:	    rb_ary_push(ary, (VALUE)trace->data);
variable.c:	    trace->removed = 1;
variable.c:	if (!entry->var->block_trace) remove_trace(entry->var);
variable.c:	    if (trace->data == cmd) {
variable.c:		trace->removed = 1;
variable.c:		if (!entry->var->block_trace) remove_trace(entry->var);
variable.c:	    trace = trace->next;
variable.c:    struct global_variable *var = entry->var;
variable.c:    return (*var->getter)(entry->id, var->data, var);
variable.c:    struct trace_var *trace = data->trace;
variable.c:	(*trace->func)(trace->data, data->val);
variable.c:	trace = trace->next;
variable.c:    var->block_trace = 0;
variable.c:    struct global_variable *var = entry->var;
variable.c:    (*var->setter)(val, entry->id, var->data, var);
variable.c:    if (var->trace && !var->block_trace) {
variable.c:	var->block_trace = 1;
variable.c:	trace.trace = var->trace;
variable.c:    if (entry->var->getter == undef_getter) return Qfalse;
variable.c: *  call-seq:
variable.c:	entry1->id = name1;
variable.c:    else if ((entry1 = (struct global_entry *)data1)->var != entry2->var) {
variable.c:	struct global_variable *var = entry1->var;
variable.c:	if (var->block_trace) {
variable.c:	var->counter--;
variable.c:	if (var->counter == 0) {
variable.c:	    struct trace_var *trace = var->trace;
variable.c:		struct trace_var *next = trace->next;
variable.c:    entry2->var->counter++;
variable.c:    entry1->var = entry2->var;
variable.c:    if (tbl->num_entries == 0) {
variable.c:        if (tbl->num_entries == 0)
variable.c:            index = iv_index_tbl->num_entries;
variable.c:                RBASIC(obj)->flags |= ROBJECT_EMBED;
variable.c:                ptr = ROBJECT(obj)->as.ary;
variable.c:                    iv_index_tbl->num_entries < newsize) {
variable.c:                    newsize = iv_index_tbl->num_entries;
variable.c:                if (RBASIC(obj)->flags & ROBJECT_EMBED) {
variable.c:                    RBASIC(obj)->flags &= ~ROBJECT_EMBED;
variable.c:                    ROBJECT(obj)->as.heap.ivptr = newptr;
variable.c:                    REALLOC_N(ROBJECT(obj)->as.heap.ivptr, VALUE, newsize);
variable.c:                    newptr = ROBJECT(obj)->as.heap.ivptr;
variable.c:                ROBJECT(obj)->as.heap.numiv = newsize;
variable.c:                ROBJECT(obj)->as.heap.iv_index_tbl = iv_index_tbl;
variable.c:    if (index < ROBJECT_NUMIV(data->obj)) {
variable.c:        VALUE val = ROBJECT_IVPTR(data->obj)[index];
variable.c:            return (data->func)(key, val, data->arg);
variable.c: *  call-seq:
variable.c: *  call-seq:
variable.c: * call-seq:
variable.c:    if (RDATA(av)->dmark != (RUBY_DATA_FUNC)rb_mark_tbl ||
variable.c:	RDATA(av)->dfree != (RUBY_DATA_FUNC)st_free_table) {
variable.c:	if (tbl->num_entries == 0) {
variable.c:    file = load->nd_lit;
variable.c:    file = load->nd_lit;
variable.c:    return rb_require_safe(file, load->nd_nth);
variable.c:    return load && (file = load->nd_lit) ? file : Qnil;
variable.c: *  call-seq:
variable.c:    ary = rb_ary_new2(tbl->num_entries);
variable.c: *  call-seq:
variable.c:	return RBASIC(c)->klass;
variable.c: *  call-seq:
variable.c: *  call-seq:
ãã¤ããªã¼ã»ãã¡ã¤ã«variable.oã¯ä¸è´ãã¾ãã
version.c:  version.c -
version.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
version.c:#define MKSTR(type) rb_obj_freeze(rb_usascii_str_new(ruby_##type, sizeof(ruby_##type)-1))
version.h:#define RUBY_RELEASE_DATE "2009-07-16"
version.h:    "ruby - Copyright (C) "	    \
version.h:    STRINGIZE(RUBY_BIRTH_YEAR)"-"   \
ãã¤ããªã¼ã»ãã¡ã¤ã«version.oã¯ä¸è´ãã¾ãã
vm.c:  vm.c -
vm.c:  Copyright (C) 2004-2007 Koichi Sasada
vm.c:		  Qnil, th->cfp->lfp[0], 0,
vm.c:		  th->cfp->sp, 0, 1);
vm.c:    th->cfp->pc = (VALUE *)&finish_insn_seq[0];
vm.c:    if (iseq->type != ISEQ_TYPE_TOP) {
vm.c:		  th->top_self, 0, iseq->iseq_encoded,
vm.c:		  th->cfp->sp, 0, iseq->local_size);
vm.c:        CHECK_STACK_OVERFLOW(th->cfp, iseq->stack_max);
vm.c:    rb_block_t * const block = th->base_block;
vm.c:    vm_push_frame(th, iseq, VM_FRAME_MAGIC_EVAL, block->self,
vm.c:		  GC_GUARDED_PTR(block->dfp), iseq->iseq_encoded,
vm.c:		  th->cfp->sp, block->lfp, iseq->local_size);
vm.c:	th->cfp->dfp[-1] = (VALUE)cref;
vm.c:    CHECK_STACK_OVERFLOW(th->cfp, iseq->stack_max);
vm.c:    GetEnvPtr(bind->env, env);
vm.c:    th->base_block = &env->block;
vm.c:    th->base_block = 0;
vm.c:    if (bind && iseq->local_size > 0) {
vm.c:	bind->env = rb_vm_make_env_object(th, th->cfp);
vm.c:    CHECK_STACK_OVERFLOW(th->cfp, iseq->stack_max);
vm.c:	if (RUBY_VM_NORMAL_ISEQ_P(cfp->iseq)) {
vm.c:    if (RUBY_VM_NORMAL_ISEQ_P(cfp->iseq)) {
vm.c:	if (RUBY_VM_NORMAL_ISEQ_P(cfp->iseq)) {
vm.c:	if ((cfp->flag & VM_FRAME_FLAG_PASSED) == 0) {
vm.c:  (!((th)->stack < (env) && (env) < ((th)->stack + (th)->stack_size)))
vm.c:	RUBY_FREE_UNLESS_NULL(env->env);
vm.c:	if (env->env) {
vm.c:	    RUBY_GC_INFO("env->env\n");
vm.c:	    rb_gc_mark_locations(env->env, env->env + env->env_size);
vm.c:	RUBY_GC_INFO("env->prev_envval\n");
vm.c:	RUBY_MARK_UNLESS_NULL(env->prev_envval);
vm.c:	RUBY_MARK_UNLESS_NULL(env->block.self);
vm.c:	RUBY_MARK_UNLESS_NULL(env->block.proc);
vm.c:	if (env->block.iseq) {
vm.c:	    if (BUILTIN_TYPE(env->block.iseq) == T_NODE) {
vm.c:		RUBY_MARK_UNLESS_NULL((VALUE)env->block.iseq);
vm.c:		RUBY_MARK_UNLESS_NULL(env->block.iseq->self);
vm.c:    env->env = 0;
vm.c:    env->prev_envval = 0;
vm.c:    env->block.iseq = 0;
vm.c:    printf("---\n");
vm.c:    printf("envptr: %p\n", (void *)&env->block.dfp[0]);
vm.c:    printf("orphan: %p\n", (void *)env->block.dfp[1]);
vm.c:    printf("inheap: %p\n", (void *)env->block.dfp[2]);
vm.c:    printf("envval: %10p ", (void *)env->block.dfp[3]);
vm.c:    dp(env->block.dfp[3]);
vm.c:    printf("penvv : %10p ", (void *)env->block.dfp[4]);
vm.c:    dp(env->block.dfp[4]);
vm.c:    printf("lfp:    %10p\n", (void *)env->block.lfp);
vm.c:    printf("dfp:    %10p\n", (void *)env->block.dfp);
vm.c:    if (env->block.dfp[4]) {
vm.c:	check_env_value(env->block.dfp[4]);
vm.c:	    while (pcfp->dfp != penvptr) {
vm.c:		if (pcfp->dfp == 0) {
vm.c:	    cfp->lfp = pcfp->lfp;
vm.c:	    *envptr = GC_GUARDED_PTR(pcfp->dfp);
vm.c:    if (!RUBY_VM_NORMAL_ISEQ_P(cfp->iseq)) {
vm.c:	local_size = cfp->iseq->local_size;
vm.c:    env->env_size = local_size + 1 + 2;
vm.c:    env->local_size = local_size;
vm.c:    env->env = ALLOC_N(VALUE, env->env_size);
vm.c:    env->prev_envval = penvval;
vm.c:	env->env[i] = envptr[-local_size + i];
vm.c:	fprintf(stderr, "%2d ", &envptr[-local_size + i] - th->stack); dp(env->env[i]);
vm.c:	if (RUBY_VM_NORMAL_ISEQ_P(cfp->iseq)) {
vm.c:	    envptr[-local_size + i] = 0;
vm.c:    nenvptr = &env->env[i - 1];
vm.c:    cfp->dfp = nenvptr;
vm.c:	cfp->lfp = nenvptr;
vm.c:    env->block.self = cfp->self;
vm.c:    env->block.lfp = cfp->lfp;
vm.c:    env->block.dfp = cfp->dfp;
vm.c:    env->block.iseq = cfp->iseq;
vm.c:    if (!RUBY_VM_NORMAL_ISEQ_P(cfp->iseq)) {
vm.c:	env->block.iseq = 0;
vm.c:    for (i = 0; i < env->block.iseq->local_table_size; i++) {
vm.c:	ID lid = env->block.iseq->local_table[i];
vm.c:    if (env->prev_envval) {
vm.c:	GetEnvPtr(env->prev_envval, prevenv);
vm.c:    envval = vm_make_env_each(th, cfp, cfp->dfp, cfp->lfp);
vm.c:    rb_control_frame_t *cfp = th->cfp;
vm.c:    VALUE proc = block->proc;
vm.c:    if (block->proc) {
vm.c:	return block->proc;
vm.c:    block->proc = proc;
vm.c:    if (block->proc) {
vm.c:    if (GC_GUARDED_PTR_REF(cfp->lfp[0])) {
vm.c:	if (!RUBY_VM_CLASS_SPECIAL_P(cfp->lfp[0])) {
vm.c:		th, (rb_block_t *)GC_GUARDED_PTR_REF(*cfp->lfp));
vm.c:	    *cfp->lfp = GC_GUARDED_PTR(&p->block);
vm.c:    proc->blockprocval = blockprocval;
vm.c:    proc->block.self = block->self;
vm.c:    proc->block.lfp = block->lfp;
vm.c:    proc->block.dfp = block->dfp;
vm.c:    proc->block.iseq = block->iseq;
vm.c:    proc->block.proc = procval;
vm.c:    proc->envval = envval;
vm.c:    proc->safe_level = th->safe_level;
vm.c:	if (th->stack < block->dfp && block->dfp < th->stack + th->stack_size) {
vm.c:	    rb_bug("invalid ptr: block->dfp");
vm.c:	if (th->stack < block->lfp && block->lfp < th->stack + th->stack_size) {
vm.c:	    rb_bug("invalid ptr: block->lfp");
vm.c:/* C -> Ruby: block */
vm.c:    if (BUILTIN_TYPE(block->iseq) != T_NODE) {
vm.c:	const rb_iseq_t *iseq = block->iseq;
vm.c:	int i, opt_pc, arg_size = iseq->arg_size;
vm.c:	int type = block_proc_is_lambda(block->proc) ?
vm.c:	cfp = th->cfp;
vm.c:	CHECK_STACK_OVERFLOW(cfp, argc + iseq->stack_max);
vm.c:	    cfp->sp[i] = argv[i];
vm.c:	opt_pc = vm_yield_setup_args(th, iseq, argc, cfp->sp, blockptr,
vm.c:		      self, GC_GUARDED_PTR(block->dfp),
vm.c:		      iseq->iseq_encoded + opt_pc, cfp->sp + arg_size, block->lfp,
vm.c:		      iseq->local_size - arg_size);
vm.c:	    th->cfp->dfp[-1] = (VALUE)cref;
vm.c:    const rb_block_t *blockptr = GC_GUARDED_PTR_REF(th->cfp->lfp[0]);
vm.c:    return invoke_block_from_c(th, blockptr, blockptr->self, argc, argv, 0, cref);
vm.c:    return invoke_block_from_c(th, blockptr, blockptr->self, argc, argv, 0, 0);
vm.c:    volatile int stored_safe = th->safe_level;
vm.c:    rb_control_frame_t * volatile cfp = th->cfp;
vm.c:	if (!proc->is_from_method) {
vm.c:	    th->safe_level = proc->safe_level;
vm.c:	val = invoke_block_from_c(th, &proc->block, self, argc, argv, blockptr, 0);
vm.c:    if (!proc->is_from_method) {
vm.c:	th->safe_level = stored_safe;
vm.c:	if (state == TAG_RETURN && proc->is_lambda) {
vm.c:	    VALUE err = th->errinfo;
vm.c:	    if (escape_dfp == cfp->dfp) {
vm.c:		th->errinfo = Qnil;
vm.c:		th->cfp = cfp;
vm.c:    while (cfp->pc == 0) {
vm.c:    return lfp_svar_get(th, cfp ? cfp->lfp : 0, key);
vm.c:    lfp_svar_set(th, cfp ? cfp->lfp : 0, key, val);
vm.c:    return vm_cfp_svar_get(th, th->cfp, key);
vm.c:    vm_cfp_svar_set(th, th->cfp, key, val);
vm.c:    const rb_iseq_t *iseq = cfp->iseq;
vm.c:	size_t pos = cfp->pc - cfp->iseq->iseq_encoded;
vm.c:	for (i = 0; i < iseq->insn_info_size; i++) {
vm.c:	    if (iseq->insn_info_table[i].position == pos) {
vm.c:		line_no = iseq->insn_info_table[i - 1].line_no;
vm.c:	line_no = iseq->insn_info_table[i - 1].line_no;
vm.c:	if (cfp->iseq != 0) {
vm.c:	    if (cfp->pc != 0) {
vm.c:		rb_iseq_t *iseq = cfp->iseq;
vm.c:		file = RSTRING_PTR(iseq->filename);
vm.c:				 file, line_no, RSTRING_PTR(iseq->name));
vm.c:			     rb_id2name(cfp->method_id));
vm.c:    const rb_control_frame_t *cfp = th->cfp;
vm.c:    const rb_control_frame_t *top_of_cfp = (void *)(th->stack + th->stack_size);
vm.c:    top_of_cfp -= 2;
vm.c:	while (lev-- >= 0) {
vm.c:			    top_of_cfp, RSTRING_PTR(th->vm->progname), 0, ary);
vm.c:    rb_control_frame_t *cfp = rb_vm_get_ruby_level_next_cfp(th, th->cfp);
vm.c:	return RSTRING_PTR(cfp->iseq->filename);
vm.c:    rb_control_frame_t *cfp = rb_vm_get_ruby_level_next_cfp(th, th->cfp);
vm.c:    rb_control_frame_t *cfp = rb_vm_get_ruby_level_next_cfp(th, th->cfp);
vm.c:    return vm_get_cref(cfp->iseq, cfp->lfp, cfp->dfp);
vm.c:	dp(cref->nd_clss);
vm.c:	printf("%ld\n", cref->nd_visi);
vm.c:	cref = cref->nd_next;
vm.c:    rb_control_frame_t *cfp = rb_vm_get_ruby_level_next_cfp(th, th->cfp);
vm.c:    return vm_get_cbase(cfp->iseq, cfp->lfp, cfp->dfp);
vm.c:	val = GET_THREAD()->tag->retval;
vm.c:    rb_control_frame_t *cfp = th->cfp;
vm.c:    VALUE *dfp = GC_GUARDED_PTR_REF(*cfp->dfp);
vm.c:    th->state = TAG_BREAK;
vm.c:    th->errinfo = (VALUE)NEW_THROW_OBJECT(Qnil, (VALUE)dfp, TAG_BREAK);
vm.c:	nd_type(node->nd_body->nd_body) == NODE_CFUNC) {
vm.c:  F1 - F3 : pushed by VM
vm.c:	if ((state = th->state) != 0) {
vm.c:	    th->state = 0;
vm.c:	err = th->errinfo;
vm.c:	while (th->cfp->pc == 0 || th->cfp->iseq == 0) {
vm.c:	    th->cfp++;
vm.c:	cfp = th->cfp;
vm.c:	epc = cfp->pc - cfp->iseq->iseq_encoded;
vm.c:	    if (cfp->dfp == escape_dfp) {
vm.c:		    if ((cfp + 1)->pc != &finish_insn_seq[0]) {
vm.c:			SET_THROWOBJ_CATCH_POINT(err, (VALUE)(cfp + 1)->dfp);
vm.c:			th->errinfo = Qnil;
vm.c:			th->cfp += 2;
vm.c:		    *th->cfp->sp++ = (GET_THROWOBJ_VAL(err));
vm.c:		    th->errinfo = Qnil;
vm.c:	    for (i = 0; i < cfp->iseq->catch_table_size; i++) {
vm.c:		entry = &cfp->iseq->catch_table[i];
vm.c:		if (entry->start < epc && entry->end >= epc) {
vm.c:		    if (entry->type == CATCH_TYPE_RESCUE ||
vm.c:			entry->type == CATCH_TYPE_ENSURE) {
vm.c:			catch_iseqval = entry->iseq;
vm.c:			cont_pc = entry->cont;
vm.c:			cont_sp = entry->sp;
vm.c:	    for (i = 0; i < cfp->iseq->catch_table_size; i++) {
vm.c:		entry = &cfp->iseq->catch_table[i];
vm.c:		if (entry->start < epc && entry->end >= epc) {
vm.c:		    if (entry->type == CATCH_TYPE_ENSURE) {
vm.c:			catch_iseqval = entry->iseq;
vm.c:			cont_pc = entry->cont;
vm.c:			cont_sp = entry->sp;
vm.c:		    else if (entry->type == CATCH_TYPE_RETRY) {
vm.c:			if (cfp->dfp == escape_dfp) {
vm.c:			    cfp->pc = cfp->iseq->iseq_encoded + entry->cont;
vm.c:			    th->errinfo = Qnil;
vm.c:	    for (i = 0; i < cfp->iseq->catch_table_size; i++) {
vm.c:		entry = &cfp->iseq->catch_table[i];
vm.c:		if (entry->start < epc && entry->end >= epc) {
vm.c:		    if (entry->type == CATCH_TYPE_ENSURE) {
vm.c:			catch_iseqval = entry->iseq;
vm.c:			cont_pc = entry->cont;
vm.c:			cont_sp = entry->sp;
vm.c:		    else if (entry->type == type) {
vm.c:			cfp->pc = cfp->iseq->iseq_encoded + entry->cont;
vm.c:			cfp->sp = cfp->bp + entry->sp;
vm.c:			    *th->cfp->sp++ = (GET_THROWOBJ_VAL(err));
vm.c:			th->errinfo = Qnil;
vm.c:	    for (i = 0; i < cfp->iseq->catch_table_size; i++) {
vm.c:		entry = &cfp->iseq->catch_table[i];
vm.c:		if (entry->start < epc && entry->end >= epc) {
vm.c:		    if (entry->type == CATCH_TYPE_ENSURE) {
vm.c:			catch_iseqval = entry->iseq;
vm.c:			cont_pc = entry->cont;
vm.c:			cont_sp = entry->sp;
vm.c:	    cfp->sp = cfp->bp + cont_sp;
vm.c:	    cfp->pc = cfp->iseq->iseq_encoded + cont_pc;
vm.c:	    cfp->sp[0] = err;
vm.c:			  cfp->self, (VALUE)cfp->dfp, catch_iseq->iseq_encoded,
vm.c:			  cfp->sp + 1 /* push value */, cfp->lfp, catch_iseq->local_size - 1);
vm.c:	    th->errinfo = Qnil;
vm.c:	    th->cfp++;
vm.c:	    if (th->cfp->pc != &finish_insn_seq[0]) {
vm.c:		th->errinfo = err;
vm.c:    rb_control_frame_t *cfp = th->cfp;
vm.c:    rb_iseq_t *iseq = cfp->iseq;
vm.c:	if (idp) *idp = cfp->method_id;
vm.c:	if (klassp) *klassp = cfp->method_class;
vm.c:	if (iseq->defined_method_id) {
vm.c:	    if (idp) *idp = iseq->defined_method_id;
vm.c:	    if (klassp) *klassp = iseq->klass;
vm.c:	if (iseq->local_iseq == iseq) {
vm.c:	iseq = iseq->parent_iseq;
vm.c:    const rb_control_frame_t *cfp = th->cfp;
vm.c:    if (cfp->iseq != 0) {
vm.c:	if (cfp->pc != 0) {
vm.c:	    rb_iseq_t *iseq = cfp->iseq;
vm.c:	    char *file = RSTRING_PTR(iseq->filename);
vm.c:			     file, line_no, RSTRING_PTR(iseq->name));
vm.c:    else if (cfp->method_id) {
vm.c:			 RSTRING_PTR(rb_class_name(cfp->method_class)),
vm.c:			 rb_id2name(cfp->method_id));
vm.c:    const rb_control_frame_t *reg_cfp = th->cfp;
vm.c:		  recv, (VALUE)blockptr, 0, reg_cfp->sp, 0, 1);
vm.c:	st_free_table(vmobj->living_threads);
vm.c:	vmobj->living_threads = 0;
vm.c:	rb_gc_mark(hook->data);
vm.c:	hook = hook->next;
vm.c:    RUBY_GC_INFO("-------------------------------------------------\n");
vm.c:	if (vm->living_threads) {
vm.c:	    st_foreach(vm->living_threads, vm_mark_each_thread_func, 0);
vm.c:	RUBY_MARK_UNLESS_NULL(vm->thgroup_default);
vm.c:	RUBY_MARK_UNLESS_NULL(vm->mark_object_ary);
vm.c:	RUBY_MARK_UNLESS_NULL(vm->load_path);
vm.c:	RUBY_MARK_UNLESS_NULL(vm->loaded_features);
vm.c:	RUBY_MARK_UNLESS_NULL(vm->top_self);
vm.c:	RUBY_MARK_UNLESS_NULL(vm->coverages);
vm.c:	rb_gc_mark_locations(vm->special_exceptions, vm->special_exceptions + ruby_special_error_count);
vm.c:	if (vm->loading_table) {
vm.c:	    rb_mark_tbl(vm->loading_table);
vm.c:	mark_event_hooks(vm->event_hooks);
vm.c:	    if (vm->trap_list[i].cmd)
vm.c:		rb_gc_mark(vm->trap_list[i].cmd);
vm.c:    vm->src_encoding_index = -1;
vm.c:	return thread_recycle_stack_slot[--thread_recycle_stack_count];
vm.c:	if (!th->root_fiber) {
vm.c:	    RUBY_FREE_UNLESS_NULL(th->stack);
vm.c:	if (th->locking_mutex != Qfalse) {
vm.c:	    rb_bug("thread_free: locking_mutex must be NULL (%p:%ld)", (void *)th, th->locking_mutex);
vm.c:	if (th->keeping_mutexes != NULL) {
vm.c:	    rb_bug("thread_free: keeping_mutexes must be NULL (%p:%ld)", (void *)th, th->locking_mutex);
vm.c:	if (th->local_storage) {
vm.c:	    st_free_table(th->local_storage);
vm.c:	    VALUE *ptr = th->value_cache_ptr;
vm.c:		RBASIC(v)->flags = 0;
vm.c:		RBASIC(v)->klass = 0;
vm.c:	if (th->vm && th->vm->main_thread == th) {
vm.c:	if (th->stack) {
vm.c:	    VALUE *p = th->stack;
vm.c:	    VALUE *sp = th->cfp->sp;
vm.c:	    rb_control_frame_t *cfp = th->cfp;
vm.c:	    rb_control_frame_t *limit_cfp = (void *)(th->stack + th->stack_size);
vm.c:	    rb_gc_mark_locations(p, p + th->mark_stack_len);
vm.c:		rb_gc_mark(cfp->proc);
vm.c:	RUBY_MARK_UNLESS_NULL(th->first_proc);
vm.c:	if (th->first_proc) RUBY_MARK_UNLESS_NULL(th->first_args);
vm.c:	RUBY_MARK_UNLESS_NULL(th->thgroup);
vm.c:	RUBY_MARK_UNLESS_NULL(th->value);
vm.c:	RUBY_MARK_UNLESS_NULL(th->errinfo);
vm.c:	RUBY_MARK_UNLESS_NULL(th->thrown_errinfo);
vm.c:	RUBY_MARK_UNLESS_NULL(th->local_svar);
vm.c:	RUBY_MARK_UNLESS_NULL(th->top_self);
vm.c:	RUBY_MARK_UNLESS_NULL(th->top_wrapper);
vm.c:	RUBY_MARK_UNLESS_NULL(th->fiber);
vm.c:	RUBY_MARK_UNLESS_NULL(th->root_fiber);
vm.c:	RUBY_MARK_UNLESS_NULL(th->stat_insn_usage);
vm.c:	RUBY_MARK_UNLESS_NULL(th->last_status);
vm.c:	RUBY_MARK_UNLESS_NULL(th->locking_mutex);
vm.c:	rb_mark_tbl(th->local_storage);
vm.c:	if (GET_THREAD() != th && th->machine_stack_start && th->machine_stack_end) {
vm.c:	    rb_gc_mark_locations((VALUE *)&th->machine_regs,
vm.c:				 (VALUE *)(&th->machine_regs) +
vm.c:				 sizeof(th->machine_regs) / sizeof(VALUE));
vm.c:	mark_event_hooks(th->event_hooks);
vm.c:    th->self = self;
vm.c:    th->stack_size = RUBY_VM_THREAD_STACK_SIZE;
vm.c:    th->stack = thread_recycle_stack(th->stack_size);
vm.c:    th->cfp = (void *)(th->stack + th->stack_size);
vm.c:		  th->stack, 0, 1);
vm.c:    th->status = THREAD_RUNNABLE;
vm.c:    th->errinfo = Qnil;
vm.c:    th->last_status = Qnil;
vm.c:    th->value_cache_ptr = &th->value_cache[0];
vm.c:    rb_vm_t *vm = GET_THREAD()->vm;
vm.c:    th->vm = vm;
vm.c:    th->top_wrapper = 0;
vm.c:    th->top_self = rb_vm_top_self();
vm.c:    VALUE klass = cref->nd_clss;
vm.c:    int noex = (int)cref->nd_visi;
vm.c:    COPY_CREF(miseq->cref_stack, cref);
vm.c:    miseq->klass = klass;
vm.c:    miseq->defined_method_id = id;
vm.c:    newbody = NEW_NODE(RUBY_VM_METHOD_NODE, 0, miseq->self, 0);
vm.c:    th__->cfp++; expr; th__->cfp--; \
vm.c:	rb_control_frame_t *cfp = rb_vm_get_ruby_level_next_cfp(th, th->cfp);
vm.c:	blockptr->iseq = blockiseq;
vm.c:	blockptr->proc = 0;
vm.c:    RBASIC(fcore)->flags = T_ICLASS;
vm.c:	vm->self = Data_Wrap_Struct(rb_cRubyVM, rb_vm_mark, vm_free, vm);
vm.c:	th_self = th->self = Data_Wrap_Struct(rb_cThread, rb_thread_mark, thread_free, th);
vm.c:	vm->main_thread = th;
vm.c:	vm->running_thread = th;
vm.c:	th->vm = vm;
vm.c:	th->top_wrapper = 0;
vm.c:	th->top_self = rb_vm_top_self();
vm.c:	vm->living_threads = st_init_numtable();
vm.c:	st_insert(vm->living_threads, th_self, (st_data_t) th->thread_id);
vm.c:	th->cfp->iseq = iseq;
vm.c:	th->cfp->pc = iseq->iseq_encoded;
vm.c:	th->cfp->self = th->top_self;
vm.c:    vm->objspace = rb_objspace_alloc();
vm.c:    th->vm = vm;
vm.c:    return GET_VM()->top_self;
vm.c:    vm->top_self = rb_obj_alloc(rb_cObject);
vm.c:    vm->mark_object_ary = rb_ary_tmp_new(1);
vm.c:    return &vm->verbose;
vm.c:    return &vm->debug;
vm.inc:/* -*-c-*- *********************************************************/
vm.inc:  ----
vm.inc:    val = *(GET_LFP() - idx);
vm.inc:    (*(GET_LFP() - idx)) = val;
vm.inc:    val = *(dfp2 - idx);
vm.inc:    *(dfp2 - idx) = val;
vm.inc:    ret = iseq->self;
vm.inc:    for (i = num - 1; i >= 0; i--) {
vm.inc:    RBASIC(ary)->klass = 0;
vm.inc:        rb_ary_store(ary, cnt-i-1, TOPN(i));
vm.inc:    for (i = num; i > 0; i -= 2) {
vm.inc:	const VALUE v = TOPN(i - 2);
vm.inc:	const VALUE k = TOPN(i - 1);
vm.inc:    TOPN(n-1) = val;
vm.inc:	    expr_type = "instance-variable";
vm.inc:	    expr_type = "global-variable";
vm.inc:	      if (!(method->nd_noex & NOEX_PRIVATE)) {
vm.inc:		  if (!((method->nd_noex & NOEX_PROTECTED) &&
vm.inc:	      if (ip->defined_method_id) {
vm.inc:	      ip = ip->parent_iseq;
vm.inc:	      VALUE klass = vm_search_normal_superclass(ip->klass, GET_SELF());
vm.inc:	      if (rb_method_boundp(klass, ip->defined_method_id, 0)) {
vm.inc:	      expr_type = "global-variable";
vm.inc:    COPY_CREF(class_iseq->cref_stack, vm_cref_push(th, klass, NOEX_PUBLIC));
vm.inc:		  class_iseq->iseq_encoded, GET_SP(), 0,
vm.inc:		  class_iseq->local_size);
vm.inc:	if (reg_cfp->sp != reg_cfp->bp) {
vm.inc:		   VM_SP_CNT(th, reg_cfp->sp), VM_SP_CNT(th, reg_cfp->bp));
vm.inc:    th->cfp++;
vm.inc:    if (ic->ic_vmstat == GET_VM_STATE_VERSION()) {
vm.inc:	val = ic->ic_value;
vm.inc:    if (ic->ic_vmstat) {
vm.inc:	val = ic->ic_value;
vm.inc:    ic->ic_value = val;
vm.inc:    ic->ic_vmstat = GET_VM_STATE_VERSION() - ruby_vm_const_missing_count;
vm.inc:    if (GET_CFP()->bp != GET_DFP() + 1) {
vm.inc:	VALUE *new_dfp = GET_CFP()->bp - 1;
vm.inc:	    ((VALUE)0x01 << ((sizeof(VALUE) * CHAR_BIT) - 1))) {
vm.inc:	c = a - b;
vm.inc:		    div = -x / -y;
vm.inc:		    div = -(x / -y);
vm.inc:		    div = -(-x / y);
vm.inc:	    mod = x - div * y;
vm.inc:		div -= 1;
vm.inc:		    div = -x / -y;
vm.inc:		    div = -(x / -y);
vm.inc:		    div = -(-x / y);
vm.inc:	    mod = x - div * y;
vm.inc:		div -= 1;
vm.inc:		mod = x - z * y;
vm.inc:	    div = (x - mod) / y;
vm.inc:		div -= 1.0;
vm.inc:	VALUE err = th->errinfo;
vm.inc:	th->errinfo = Qnil;
ãã¤ããªã¼ã»ãã¡ã¤ã«vm.oã¯ä¸è´ãã¾ãã
vm_core.h:  vm_core.h - 
vm_core.h:  Copyright (C) 2004-2007 Koichi Sasada
vm_core.h:     *  arg_rest       = M+N+1 // or -1 if no rest arg
vm_core.h:     *  arg_block      = M+N + 1 + O + 1 // -1 if no block arg
vm_core.h:    VALUE orig;			/* non-NULL if its data have origin */
vm_core.h:#define VM_FRAME_TYPE(cfp) ((cfp)->flag & VM_FRAME_MAGIC_MASK)
vm_core.h:#define RUBY_VM_NEXT_CONTROL_FRAME(cfp) (cfp-1)
vm_core.h:  ((rb_control_frame_t *)((th)->stack + (th)->stack_size))
vm_core.h:#define RUBY_VM_GET_BLOCK_PTR_IN_CFP(cfp) ((rb_block_t *)(&(cfp)->self))
vm_core.h:  ((rb_control_frame_t *)((VALUE *)(b) - 5))
vm_core.h:#define SDR() rb_vmdebug_stack_dump_raw(GET_THREAD(), GET_THREAD()->cfp)
vm_core.h:#define sysstack_error GET_VM()->special_exceptions[ruby_error_sysstack]
vm_core.h:    th->vm->running_thread = th; \
vm_core.h:#define RUBY_VM_SET_INTERRUPT(th) ((th)->interrupt_flag |= 0x02)
vm_core.h:#define RUBY_VM_SET_TIMER_INTERRUPT(th) ((th)->interrupt_flag |= 0x01)
vm_core.h:#define RUBY_VM_SET_FINALIZER_INTERRUPT(th) ((th)->interrupt_flag |= 0x04)
vm_core.h:#define RUBY_VM_INTERRUPTED(th) ((th)->interrupt_flag & 0x02)
vm_core.h:  if (UNLIKELY(th->interrupt_flag)) { \
vm_core.h:    rb_event_flag_t wait_event__ = th->event_flags; \
vm_dump.c:  vm_dump.c -
vm_dump.c:  Copyright (C) 2004-2007 Koichi Sasada
vm_dump.c:  ((rb_control_frame_t *)(th->stack + th->stack_size) - (rb_control_frame_t *)(cfp))
vm_dump.c:    int pc = -1, bp = -1, line = 0;
vm_dump.c:    ptrdiff_t lfp = cfp->lfp - th->stack;
vm_dump.c:    ptrdiff_t dfp = cfp->dfp - th->stack;
vm_dump.c:    const char *magic, *iseq_name = "-", *selfstr = "-", *biseq_name = "-";
vm_dump.c:    if (cfp->block_iseq != 0 && BUILTIN_TYPE(cfp->block_iseq) != T_NODE) {
vm_dump.c:	biseq_name = "";	/* RSTRING(cfp->block_iseq->name)->ptr; */
vm_dump.c:    if (lfp < 0 || lfp > th->stack_size) {
vm_dump.c:	lfp = (ptrdiff_t)cfp->lfp;
vm_dump.c:    if (dfp < 0 || dfp > th->stack_size) {
vm_dump.c:	dfp = (ptrdiff_t)cfp->dfp;
vm_dump.c:    if (cfp->bp) {
vm_dump.c:	bp = cfp->bp - th->stack;
vm_dump.c:	magic = "------";
vm_dump.c:	tmp = rb_inspect(cfp->self);
vm_dump.c:    else if (cfp->iseq != 0) {
vm_dump.c:	if (RUBY_VM_IFUNC_P(cfp->iseq)) {
vm_dump.c:	    pc = cfp->pc - cfp->iseq->iseq_encoded;
vm_dump.c:	    iseq_name = RSTRING_PTR(cfp->iseq->name);
vm_dump.c:		snprintf(posbuf, MAX_POSBUF, "%s:%d", RSTRING_PTR(cfp->iseq->filename), line);
vm_dump.c:    else if (cfp->method_id) {
vm_dump.c:	iseq_name = rb_id2name(cfp->method_id);
vm_dump.c:	snprintf(posbuf, MAX_POSBUF, ":%s", rb_id2name(cfp->method_id));
vm_dump.c:	line = -1;
vm_dump.c:	    ((rb_control_frame_t *)(th->stack + th->stack_size) - cfp));
vm_dump.c:    if (pc == -1) {
vm_dump.c:	fprintf(stderr, "p:---- ");
vm_dump.c:    fprintf(stderr, "s:%04"PRIdPTRDIFF" b:%04d ", (cfp->sp - th->stack), bp);
vm_dump.c:    fprintf(stderr, "%-6s", magic);
vm_dump.c:	fprintf(stderr, "iseq: %-24s ", iseq_name);
vm_dump.c:	fprintf(stderr, "self: %-24s ", selfstr);
vm_dump.c:	fprintf(stderr, "%-1s ", biseq_name);
vm_dump.c:    VALUE *sp = cfp->sp, *bp = cfp->bp;
vm_dump.c:    VALUE *lfp = cfp->lfp;
vm_dump.c:    VALUE *dfp = cfp->dfp;
vm_dump.c:    fprintf(stderr, "-- stack frame ------------\n");
vm_dump.c:    for (p = st = th->stack; p < sp; p++) {
vm_dump.c:	fprintf(stderr, "%04ld (%p): %08"PRIxVALUE, (long)(p - st), p, *p);
vm_dump.c:	if (th->stack <= t && t < sp) {
vm_dump.c:	    fprintf(stderr, " (= %ld)", (long)((VALUE *)GC_GUARDED_PTR_REF(t) - th->stack));
vm_dump.c:	    fprintf(stderr, " <- lfp");
vm_dump.c:	    fprintf(stderr, " <- dfp");
vm_dump.c:	    fprintf(stderr, " <- bp");	/* should not be */
vm_dump.c:    fprintf(stderr, "-- control frame ----------\n");
vm_dump.c:    while ((void *)cfp < (void *)(th->stack + th->stack_size)) {
vm_dump.c:    fprintf(stderr, "---------------------------\n");
vm_dump.c:    rb_vmdebug_stack_dump_raw(th, th->cfp);
vm_dump.c:    fprintf(stderr, "-- env --------------------\n");
vm_dump.c:	fprintf(stderr, "--\n");
vm_dump.c:	for (i = 0; i < env->env_size; i++) {
vm_dump.c:	    fprintf(stderr, "%04d: %08lx (%p)", -env->local_size + i, env->env[i],
vm_dump.c:		   (void *)&env->env[i]);
vm_dump.c:	    if (&env->env[i] == lfp)
vm_dump.c:		fprintf(stderr, " <- lfp");
vm_dump.c:	    if (&env->env[i] == dfp)
vm_dump.c:		fprintf(stderr, " <- dfp");
vm_dump.c:	if (env->prev_envval != 0) {
vm_dump.c:	    GetEnvPtr(env->prev_envval, env);
vm_dump.c:    fprintf(stderr, "---------------------------\n");
vm_dump.c:    VALUE val = rb_inspect(proc->block.self);
vm_dump.c:    fprintf(stderr, "-- proc -------------------\n");
vm_dump.c:    GetEnvPtr(proc->envval, env);
vm_dump.c:    rb_vmdebug_env_dump_raw(env, proc->block.lfp, proc->block.dfp);
vm_dump.c:    rb_vmdebug_stack_dump_raw(th, th->cfp);
vm_dump.c:    VALUE *sp = cfp->sp;
vm_dump.c:    VALUE *lfp = cfp->lfp;
vm_dump.c:    VALUE *dfp = cfp->dfp;
vm_dump.c:    rb_iseq_t *iseq = cfp->iseq;
vm_dump.c:	    name = rb_id2name(cfp->method_id);
vm_dump.c:	argc = iseq->argc;
vm_dump.c:	local_size = iseq->local_size;
vm_dump.c:	name = RSTRING_PTR(iseq->name);
vm_dump.c:	VALUE *ptr = dfp - local_size;
vm_dump.c:	for (; i < local_size - 1; i++) {
vm_dump.c:	ptr = cfp->bp;
vm_dump.c:		    (ptr - th->stack));
vm_dump.c:	if ((th)->stack + (th)->stack_size > (VALUE *)(cfp + 2)) {
vm_dump.c:    rb_control_frame_t *cfp = th->cfp;
vm_dump.c:    int pc = -1;
vm_dump.c:    int lfp = cfp->lfp - th->stack;
vm_dump.c:    int dfp = cfp->dfp - th->stack;
vm_dump.c:    if (RUBY_VM_NORMAL_ISEQ_P(cfp->iseq)) {
vm_dump.c:	pc = cfp->pc - cfp->iseq->iseq_encoded;
vm_dump.c:    if (lfp < 0 || lfp > th->stack_size)
vm_dump.c:	lfp = -1;
vm_dump.c:    if (dfp < 0 || dfp > th->stack_size)
vm_dump.c:	dfp = -1;
vm_dump.c:    cfpi = ((rb_control_frame_t *)(th->stack + th->stack_size)) - cfp;
vm_dump.c:	    pc, (cfp->sp - th->stack), lfp, dfp, cfpi);
vm_dump.c:    rb_iseq_t *iseq = cfp->iseq;
vm_dump.c:	VALUE *seq = iseq->iseq;
vm_dump.c:	int pc = cfp->pc - iseq->iseq_encoded;
vm_dump.c:    vm_stack_dump_each(th, th->cfp);
vm_dump.c:	("--------------------------------------------------------------\n");
vm_dump.c: *   -1(Fixnum) => count,      # insn usage
vm_dump.c:    static int prev_insn = -1;
vm_dump.c:    if ((cv = rb_hash_aref(ihash, INT2FIX(-1))) == Qnil) {
vm_dump.c:    rb_hash_aset(ihash, INT2FIX(-1), INT2FIX(FIX2INT(cv) + 1));
vm_dump.c:    if (prev_insn != -1) {
vm_dump.c:		snfprintf(stderr, buff, 0x10, "%d %s %-4s", i, getsetstr[j],
vm_dump.c:    cfp = th->cfp;
vm_dump.c:    fprintf(stderr, "pc : %p, sp : %p\n", (void *)cfp->pc, (void *)cfp->sp);
vm_dump.c:    fprintf(stderr, "cfp: %p, lfp: %p, dfp: %p\n", (void *)cfp, (void *)cfp->lfp, (void *)cfp->dfp);
vm_dump.c:    if (GET_THREAD()->vm) {
vm_dump.c:	    fprintf(stderr, "-- Ruby level backtrace information"
vm_dump.c:		    "-----------------------------------------\n");
vm_dump.c:	fprintf(stderr, "-- C level backtrace information "
vm_dump.c:		"-------------------------------------------\n");
ãã¤ããªã¼ã»ãã¡ã¤ã«vm_dump.oã¯ä¸è´ãã¾ãã
vm_eval.c:  vm_eval.c -
vm_eval.c:  Copyright (C) 1993-2007 Yukihiro Matsumoto
vm_eval.c:  Copyright (C) 2000  Information-technology Promotion Agency, Japan
vm_eval.c:		  argc, (void *)th->passed_block);
vm_eval.c:    if (th->passed_block) {
vm_eval.c:	blockptr = th->passed_block;
vm_eval.c:	th->passed_block = 0;
vm_eval.c:	VALUE iseqval = (VALUE)body->nd_body;
vm_eval.c:	reg_cfp = th->cfp;
vm_eval.c:	*reg_cfp->sp++ = recv;
vm_eval.c:	    *reg_cfp->sp++ = argv[i];
vm_eval.c:	    rb_control_frame_t *reg_cfp = th->cfp;
vm_eval.c:			      recv, (VALUE)blockptr, 0, reg_cfp->sp, 0, 1);
vm_eval.c:	    cfp->method_id = oid;
vm_eval.c:	    cfp->method_class = klass;
vm_eval.c:	    val = call_cfunc(body->nd_cfnc, recv, body->nd_argc, argc, argv);
vm_eval.c:	    if (reg_cfp != th->cfp + 1) {
vm_eval.c:		SDR2(th->cfp-5);
vm_eval.c:		rb_bug("cfp consistency error - call0");
vm_eval.c:		th->cfp = reg_cfp;
vm_eval.c:	val = rb_ivar_set(recv, body->nd_vid, argv[0]);
vm_eval.c:	val = rb_attr_get(recv, body->nd_vid);
vm_eval.c:	val = vm_call_bmethod(th, oid, body->nd_cval,
vm_eval.c:	body = body->nd_body;
vm_eval.c:    VALUE recv = th->cfp->self;
vm_eval.c:    rb_control_frame_t *cfp = th->cfp;
vm_eval.c:    if (!cfp->iseq) {
vm_eval.c:	klass = cfp->method_class;
vm_eval.c:	    klass = vm_search_normal_superclass(cfp->method_class, recv);
vm_eval.c:	id = cfp->method_id;
vm_eval.c:    return vm_call0(th, klass, recv, id, (ID)body->nd_file,
vm_eval.c:		    argc, argv, body->nd_body, CALL_SUPER);
vm_eval.c:    if (ent->mid == mid && ent->klass == klass) {
vm_eval.c:	if (!ent->method)
vm_eval.c:	id = ent->mid0;
vm_eval.c:	noex = ent->method->nd_noex;
vm_eval.c:	klass = ent->method->nd_clss;
vm_eval.c:	body = ent->method->nd_body;
vm_eval.c:	noex = method->nd_noex;
vm_eval.c:	klass = method->nd_clss;
vm_eval.c:	body = method->nd_body;
vm_eval.c:		    defined_class = RBASIC(defined_class)->klass;
vm_eval.c:		    self = th->cfp->self;
vm_eval.c:	    if (NOEX_SAFE(noex) > th->safe_level) {
vm_eval.c: *  call-seq:
vm_eval.c:    raise_method_missing(th, argc, argv, obj, th->method_missing_reason);
vm_eval.c:	    args[n++] = rb_ary_new4(argc - 1, argv + 1);
vm_eval.c:	    th->cfp = RUBY_VM_PREVIOUS_CONTROL_FRAME(th->cfp);
vm_eval.c:    th->method_missing_reason = call_status;
vm_eval.c:    th->passed_block = 0;
vm_eval.c:    th->passed_block = 0;
vm_eval.c:    VALUE self = RUBY_VM_PREVIOUS_CONTROL_FRAME(GET_THREAD()->cfp)->self;
vm_eval.c:    vid = *argv++; argc--;
vm_eval.c: *  call-seq:
vm_eval.c: *  call-seq:
vm_eval.c: *  call-seq:
vm_eval.c:    rb_control_frame_t *cfp = th->cfp;
vm_eval.c:	    rb_block_t *blockptr = RUBY_VM_GET_BLOCK_PTR_IN_CFP(th->cfp);
vm_eval.c:	    blockptr->iseq = (void *)node;
vm_eval.c:	    blockptr->proc = 0;
vm_eval.c:	    th->passed_block = blockptr;
vm_eval.c:	VALUE err = th->errinfo;
vm_eval.c:	    VALUE *cdfp = cfp->dfp;
vm_eval.c:		th->state = 0;
vm_eval.c:		th->errinfo = Qnil;
vm_eval.c:		th->cfp = cfp;
vm_eval.c:	    VALUE *cdfp = cfp->dfp;
vm_eval.c:		th->state = 0;
vm_eval.c:		th->errinfo = Qnil;
vm_eval.c:		th->cfp = cfp;
vm_eval.c:    return rb_call(CLASS_OF(arg->obj), arg->obj, arg->mid,
vm_eval.c:		   arg->argc, arg->argv, CALL_FCALL);
vm_eval.c:    parse_in_eval = th->parse_in_eval;
vm_eval.c:    mild_compile_error = th->mild_compile_error;
vm_eval.c:		envval = bind->env;
vm_eval.c:	    th->base_block = &env->block;
vm_eval.c:	    rb_control_frame_t *cfp = rb_vm_get_ruby_level_next_cfp(th, th->cfp);
vm_eval.c:		th->base_block = &block;
vm_eval.c:		th->base_block->self = self;
vm_eval.c:		th->base_block->iseq = cfp->iseq;	/* TODO */
vm_eval.c:	th->parse_in_eval++;
vm_eval.c:	th->mild_compile_error++;
vm_eval.c:	th->mild_compile_error--;
vm_eval.c:	th->parse_in_eval--;
vm_eval.c:	th->base_block = 0;
vm_eval.c:	if (bind && iseq->local_size > 0) {
vm_eval.c:	    bind->env = rb_vm_make_env_object(th, th->cfp);
vm_eval.c:	CHECK_STACK_OVERFLOW(th->cfp, iseq->stack_max);
vm_eval.c:    th->mild_compile_error = mild_compile_error;
vm_eval.c:    th->parse_in_eval = parse_in_eval;
vm_eval.c:	    VALUE errinfo = th->errinfo;
vm_eval.c:		    (bt2 = vm_backtrace(th, -2), RARRAY_LEN(bt2) > 0)) {
vm_eval.c: *  call-seq:
vm_eval.c:    VALUE self = th->top_self;
vm_eval.c:    VALUE wrapper = th->top_wrapper;
vm_eval.c:    th->top_wrapper = rb_module_new();
vm_eval.c:    th->top_self = rb_obj_clone(rb_vm_top_self());
vm_eval.c:    rb_extend_object(th->top_self, th->top_wrapper);
vm_eval.c:    th->top_self = self;
vm_eval.c:    th->top_wrapper = wrapper;
vm_eval.c:    if ((blockptr = GC_GUARDED_PTR_REF(th->cfp->lfp[0])) != 0) {
vm_eval.c:	th->cfp->lfp[0] = GC_GUARDED_PTR(&block);
vm_eval.c: *  call-seq:
vm_eval.c: *  call-seq:
vm_eval.c: *  call-seq:
vm_eval.c: *  call-seq:
vm_eval.c: *  call-seq:
vm_eval.c:    struct rb_vm_tag *tt = th->tag;
vm_eval.c:	if (tt->tag == tag) {
vm_eval.c:	    tt->retval = value;
vm_eval.c:	tt = tt->prev;
vm_eval.c:    th->errinfo = NEW_THROW_OBJECT(tag, 0, TAG_THROW);
vm_eval.c: *  call-seq:
vm_eval.c: *       routine(n-1)
vm_eval.c:    rb_control_frame_t *saved_cfp = th->cfp;
vm_eval.c:    th->tag->tag = tag;
vm_eval.c:    else if (state == TAG_THROW && RNODE(th->errinfo)->u1.value == tag) {
vm_eval.c:	th->cfp = saved_cfp;
vm_eval.c:	val = th->tag->retval;
vm_eval.c:	th->errinfo = Qnil;
vm_eval.c: *  call-seq:
vm_eval.c: *  Returns the current execution stack---an array containing strings in
vm_eval.c:    ary = vm_backtrace(GET_THREAD(), -1);
vm_eval.c:    return vm_backtrace(GET_THREAD(), -1);
vm_eval.c: *  call-seq:
vm_eval.c:	vm_get_ruby_level_caller_cfp(th, RUBY_VM_PREVIOUS_CONTROL_FRAME(th->cfp));
vm_eval.c:	if (cfp->iseq) {
vm_eval.c:	    for (i = 0; i < cfp->iseq->local_table_size; i++) {
vm_eval.c:		ID lid = cfp->iseq->local_table[i];
vm_eval.c:	if (cfp->lfp != cfp->dfp) {
vm_eval.c:	    VALUE *dfp = GC_GUARDED_PTR_REF(cfp->dfp[0]);
vm_eval.c:		while (cfp->dfp != dfp) {
vm_eval.c: *  call-seq:
vm_eval.c:    rb_control_frame_t *cfp = th->cfp;
vm_eval.c:	(cfp->lfp[0] & 0x02) == 0 &&
vm_eval.c:	GC_GUARDED_PTR_REF(cfp->lfp[0])) {
vm_eval.c:    rb_define_global_function("eval", rb_f_eval, -1);
vm_eval.c:    rb_define_global_function("catch", rb_f_catch, -1);
vm_eval.c:    rb_define_global_function("throw", rb_f_throw, -1);
vm_eval.c:    rb_define_method(rb_cBasicObject, "instance_eval", rb_obj_instance_eval, -1);
vm_eval.c:    rb_define_method(rb_cBasicObject, "instance_exec", rb_obj_instance_exec, -1);
vm_eval.c:    rb_define_private_method(rb_cBasicObject, "method_missing", rb_method_missing, -1);
vm_eval.c:    rb_define_method(rb_cBasicObject, "__send__", rb_f_send, -1);
vm_eval.c:    rb_define_method(rb_mKernel, "send", rb_f_send, -1);
vm_eval.c:    rb_define_method(rb_mKernel, "public_send", rb_f_public_send, -1);
vm_eval.c:    rb_define_method(rb_cModule, "module_exec", rb_mod_module_exec, -1);
vm_eval.c:    rb_define_method(rb_cModule, "class_exec", rb_mod_module_exec, -1);
vm_eval.c:    rb_define_method(rb_cModule, "module_eval", rb_mod_module_eval, -1);
vm_eval.c:    rb_define_method(rb_cModule, "class_eval", rb_mod_module_eval, -1);
vm_eval.c:    rb_define_global_function("caller", rb_f_caller, -1);
vm_exec.c:/* -*-c-*- */
vm_exec.c:  vm_exec.c -
vm_exec.c:  Copyright (C) 2004-2007 Koichi Sasada
vm_exec.c:  REG_CFP = th->cfp; \
vm_exec.c:  reg_pc  = reg_cfp->pc; \
vm_exec.c:#define SET_PC(x) (reg_cfp->pc = REG_PC = (x))
vm_exec.c:    reg_cfp = th->cfp;
vm_exec.c:    reg_pc = reg_cfp->pc;
vm_exec.c:    register rb_control_frame_t *reg_cfp = th->cfp;
vm_exec.c:	    VALUE err = th->errinfo;
vm_exec.c:	    th->errinfo = Qnil;
vm_exec.c:    if (VM_FRAME_TYPE(th->cfp) != VM_FRAME_MAGIC_FINISH) {
vm_exec.c:    ret = *(th->cfp->sp-1); /* pop */
vm_exec.c:    th->cfp++; /* pop cf */
vm_exec.h:  vm.h -
vm_exec.h:  Copyright (C) 2004-2007 Koichi Sasada
vm_exec.h:  asm volatile("jmp *%0;\t# -- inseted by vm.h\t[length = 2]" : : "r" (addr))
vm_exec.h:#define VM_SP_CNT(th, sp) ((sp) - (th)->stack)
vm_exec.h:    th->errinfo = (VALUE)(exc); \
vm_insnhelper.c:  vm_insnhelper.c - instruction helper functions.
vm_insnhelper.c:    rb_control_frame_t * const cfp = th->cfp = th->cfp - 1;
vm_insnhelper.c:    cfp->pc = (VALUE *)pc;
vm_insnhelper.c:    cfp->sp = sp + 1;
vm_insnhelper.c:    cfp->bp = sp + 1;
vm_insnhelper.c:    cfp->iseq = (rb_iseq_t *) iseq;
vm_insnhelper.c:    cfp->flag = type;
vm_insnhelper.c:    cfp->self = self;
vm_insnhelper.c:    cfp->lfp = lfp;
vm_insnhelper.c:    cfp->dfp = sp;
vm_insnhelper.c:    cfp->proc = 0;
vm_insnhelper.c:    cfp->prof_time_self = clock();
vm_insnhelper.c:    cfp->prof_time_chld = 0;
vm_insnhelper.c:    rb_control_frame_t *cfp = th->cfp;
vm_insnhelper.c:    if (RUBY_VM_NORMAL_ISEQ_P(cfp->iseq)) {
vm_insnhelper.c:	rb_control_frame_t *cfp = th->cfp;
vm_insnhelper.c:	cfp->prof_time_self = current_time - cfp->prof_time_self;
vm_insnhelper.c:	(cfp+1)->prof_time_chld += cfp->prof_time_self;
vm_insnhelper.c:	cfp->iseq->profile.count++;
vm_insnhelper.c:	cfp->iseq->profile.time_cumu = cfp->prof_time_self;
vm_insnhelper.c:	cfp->iseq->profile.time_self = cfp->prof_time_self - cfp->prof_time_chld;
vm_insnhelper.c:    th->cfp = RUBY_VM_PREVIOUS_CONTROL_FRAME(th->cfp);
vm_insnhelper.c:    if (LIKELY(iseq->arg_simple & 0x01)) { \
vm_insnhelper.c:	if (orig_argc != iseq->argc) { \
vm_insnhelper.c:	    rb_raise(rb_eArgError, "wrong number of arguments (%d for %d)", orig_argc, iseq->argc); \
vm_insnhelper.c:    const int m = iseq->argc;
vm_insnhelper.c:    th->mark_stack_len = argc + iseq->arg_size;
vm_insnhelper.c:    if (argc < (m + iseq->arg_post_len)) { /* check with post arg */
vm_insnhelper.c:		 argc, m + iseq->arg_post_len);
vm_insnhelper.c:    argc -= m;
vm_insnhelper.c:    if (iseq->arg_post_len) {
vm_insnhelper.c:	if (!(orig_argc < iseq->arg_post_start)) {
vm_insnhelper.c:	MEMCPY(&orig_argv[iseq->arg_post_start], &argv[argc -= iseq->arg_post_len],
vm_insnhelper.c:	       VALUE, iseq->arg_post_len);
vm_insnhelper.c:    if (iseq->arg_opts) {
vm_insnhelper.c:	const int opts = iseq->arg_opts - 1 /* no opt */;
vm_insnhelper.c:	if (iseq->arg_rest == -1 && argc > opts) {
vm_insnhelper.c:		     orig_argc, m + opts + iseq->arg_post_len);
vm_insnhelper.c:	    argc -= opts;
vm_insnhelper.c:	    opt_pc = iseq->arg_opt_table[opts]; /* no opt */
vm_insnhelper.c:	    opt_pc = iseq->arg_opt_table[argc];
vm_insnhelper.c:    if (iseq->arg_rest != -1) {
vm_insnhelper.c:	orig_argv[iseq->arg_rest] = rb_ary_new4(argc, argv);
vm_insnhelper.c:    if (block && iseq->arg_block != -1) {
vm_insnhelper.c:		     orig_argc, m + iseq->arg_post_len);
vm_insnhelper.c:	    if (blockptr->proc == 0) {
vm_insnhelper.c:		*block = &proc->block;
vm_insnhelper.c:		blockval = blockptr->proc;
vm_insnhelper.c:	orig_argv[iseq->arg_block] = blockval; /* Proc or nil */
vm_insnhelper.c:    th->mark_stack_len = 0;
vm_insnhelper.c:	    proc = *(--cfp->sp);
vm_insnhelper.c:		blockptr = &po->block;
vm_insnhelper.c:		RUBY_VM_GET_BLOCK_PTR_IN_CFP(cfp)->proc = proc;
vm_insnhelper.c:	    blockptr->iseq = blockiseq;
vm_insnhelper.c:	    blockptr->proc = 0;
vm_insnhelper.c:	VALUE ary = *(cfp->sp - 1);
vm_insnhelper.c:	    cfp->sp -= 1;
vm_insnhelper.c:		*cfp->sp++ = ptr[i];
vm_insnhelper.c:	    argc += i-1;
vm_insnhelper.c:      case -2:
vm_insnhelper.c:      case -1:
vm_insnhelper.c:    if (th->event_flags & RUBY_EVENT_C_RETURN) {
vm_insnhelper.c:	_th->tag = _tag.prev;
vm_insnhelper.c:			  recv, (VALUE) blockptr, 0, reg_cfp->sp, 0, 1);
vm_insnhelper.c:	cfp->method_id = oid;
vm_insnhelper.c:	cfp->method_class = klass;
vm_insnhelper.c:	reg_cfp->sp -= num + 1;
vm_insnhelper.c:	val = call_cfunc(mn->nd_cfnc, recv, mn->nd_argc, num, reg_cfp->sp + 1);
vm_insnhelper.c:	if (reg_cfp != th->cfp + 1) {
vm_insnhelper.c:	    rb_bug("cfp consistency error - send");
vm_insnhelper.c:    rb_control_frame_t *cfp = th->cfp;
vm_insnhelper.c:    (cfp-2)->method_id = id;
vm_insnhelper.c:    (cfp-2)->method_class = klass;
vm_insnhelper.c:    rb_control_frame_t * const reg_cfp = th->cfp;
vm_insnhelper.c:    th->method_missing_reason = opt;
vm_insnhelper.c:    th->passed_block = blockptr;
vm_insnhelper.c:    VALUE *sp, *rsp = cfp->sp - argc;
vm_insnhelper.c:    CHECK_STACK_OVERFLOW(cfp, iseq->stack_max);
vm_insnhelper.c:    sp = rsp + iseq->arg_size;
vm_insnhelper.c:		      iseq->local_size, iseq->arg_size);
vm_insnhelper.c:	for (i = 0; i < iseq->local_size - iseq->arg_size; i++) {
vm_insnhelper.c:		      iseq->iseq_encoded + opt_pc, sp, 0, 0);
vm_insnhelper.c:	cfp->sp = rsp - 1 /* recv */;
vm_insnhelper.c:	th->cfp++; /* pop cf */
vm_insnhelper.c:	p_rsp = th->cfp->sp;
vm_insnhelper.c:	for (i=0; i < (sp - rsp); i++) {
vm_insnhelper.c:	sp -= rsp - p_rsp;
vm_insnhelper.c:	for (i = 0; i < iseq->local_size - iseq->arg_size; i++) {
vm_insnhelper.c:		      iseq->iseq_encoded + opt_pc, sp, 0, 0);
vm_insnhelper.c:	if ((mn->nd_noex == 0)) {
vm_insnhelper.c:	    node = mn->nd_body;
vm_insnhelper.c:		vm_setup_method(th, cfp, num, blockptr, flag, (VALUE)node->nd_body, recv);
vm_insnhelper.c:		val = vm_call_cfunc(th, cfp, num, id, (ID)mn->nd_file, recv, mn->nd_clss, flag, node, blockptr);
vm_insnhelper.c:		val = rb_ivar_set(recv, node->nd_vid, *(cfp->sp - 1));
vm_insnhelper.c:		cfp->sp -= 2;
vm_insnhelper.c:		val = rb_attr_get(recv, node->nd_vid);
vm_insnhelper.c:		cfp->sp -= 1;
vm_insnhelper.c:		MEMCPY(argv, cfp->sp - num, VALUE, num);
vm_insnhelper.c:		cfp->sp += - num - 1;
vm_insnhelper.c:		val = vm_call_bmethod(th, (ID)mn->nd_file, node->nd_cval, recv, mn->nd_clss, num, argv, blockptr);
vm_insnhelper.c:		klass = RCLASS_SUPER(mn->nd_clss);
vm_insnhelper.c:		(mn->nd_noex & NOEX_MASK) & NOEX_PRIVATE) {
vm_insnhelper.c:	    else if (((mn->nd_noex & NOEX_MASK) & NOEX_PROTECTED) &&
vm_insnhelper.c:		VALUE defined_class = mn->nd_clss;
vm_insnhelper.c:		    defined_class = RBASIC(defined_class)->klass;
vm_insnhelper.c:		if (!rb_obj_is_kind_of(cfp->self, rb_class_real(defined_class))) {
vm_insnhelper.c:	    else if ((noex_safe = NOEX_SAFE(mn->nd_noex)) > th->safe_level &&
vm_insnhelper.c:	    vm_method_missing_args(th, argv, num - 1, 0, stat);
vm_insnhelper.c:    if (*mn && nd_type((*mn)->nd_body) == NODE_CFUNC) {
vm_insnhelper.c:	NODE *node = (*mn)->nd_body;
vm_insnhelper.c:	if (node->nd_cfnc == rb_f_send) {
vm_insnhelper.c:	    int i = *num - 1;
vm_insnhelper.c:		MEMMOVE(&TOPN(i), &TOPN(i-1), VALUE, i);
vm_insnhelper.c:	    *num -= 1;
vm_insnhelper.c:	return proc->is_lambda;
vm_insnhelper.c:    NODE *ifunc = (NODE *) block->iseq;
vm_insnhelper.c:    int lambda = block_proc_is_lambda(block->proc);
vm_insnhelper.c:	if (blockargptr->proc) {
vm_insnhelper.c:	    blockarg = blockargptr->proc;
vm_insnhelper.c:		  self, (VALUE)block->dfp,
vm_insnhelper.c:		  0, th->cfp->sp, block->lfp, 1);
vm_insnhelper.c:    val = (*ifunc->nd_cfnc) (arg, ifunc->nd_tval, argc, argv, blockarg);
vm_insnhelper.c:    th->cfp++;
vm_insnhelper.c:/*--
vm_insnhelper.c:    const int m = iseq->argc;
vm_insnhelper.c:    const int r = iseq->arg_rest;
vm_insnhelper.c:    int len = iseq->arg_post_len;
vm_insnhelper.c:    int start = iseq->arg_post_start;
vm_insnhelper.c:    int rsize = argc > m ? argc - m : 0;    /* # of arguments which did not consumed yet */
vm_insnhelper.c:    rsize -= psize;
vm_insnhelper.c:    if (iseq->arg_opts) {
vm_insnhelper.c:	const int opts = iseq->arg_opts - 1;
vm_insnhelper.c:	    opt_pc = iseq->arg_opt_table[opts];
vm_insnhelper.c:	    opt_pc = iseq->arg_opt_table[rsize];
vm_insnhelper.c:    rsize -= osize;
vm_insnhelper.c:    if (r == -1) {
vm_insnhelper.c:    const int m = iseq->argc;
vm_insnhelper.c:    th->mark_stack_len = argc;
vm_insnhelper.c:    if (!(iseq->arg_simple & 0x02) &&          /* exclude {|a|} */
vm_insnhelper.c:            (m + iseq->arg_post_len) > 0 &&    /* this process is meaningful */
vm_insnhelper.c:        th->mark_stack_len = argc = RARRAY_LEN(ary);
vm_insnhelper.c:        CHECK_STACK_OVERFLOW(th->cfp, argc);
vm_insnhelper.c:    if (iseq->arg_rest == -1 && iseq->arg_opts == 0) {
vm_insnhelper.c:        const int arg_size = iseq->arg_size;
vm_insnhelper.c:            th->mark_stack_len = argc = arg_size;
vm_insnhelper.c:        int r = iseq->arg_rest;
vm_insnhelper.c:        if (iseq->arg_post_len || 
vm_insnhelper.c:                iseq->arg_opts) { /* TODO: implement simple version for (iseq->arg_post_len==0 && iseq->arg_opts > 0) */
vm_insnhelper.c:                argv[r] = rb_ary_new4(argc-r, &argv[r]);
vm_insnhelper.c:        th->mark_stack_len = iseq->arg_size;
vm_insnhelper.c:    if (iseq->arg_block != -1) {
vm_insnhelper.c:            procval = blockptr->proc;
vm_insnhelper.c:        argv[iseq->arg_block] = procval;
vm_insnhelper.c:    th->mark_stack_len = 0;
vm_insnhelper.c:	printf("iseq argc: %d\n", iseq->argc);
vm_insnhelper.c:	printf("iseq opts: %d\n", iseq->arg_opts);
vm_insnhelper.c:	printf("iseq rest: %d\n", iseq->arg_rest);
vm_insnhelper.c:	printf("iseq post: %d\n", iseq->arg_post_len);
vm_insnhelper.c:	printf("iseq blck: %d\n", iseq->arg_block);
vm_insnhelper.c:	printf("iseq smpl: %d\n", iseq->arg_simple);
vm_insnhelper.c:    if (GET_ISEQ()->local_iseq->type != ISEQ_TYPE_METHOD || block == 0) {
vm_insnhelper.c:    iseq = block->iseq;
vm_insnhelper.c:	const int arg_size = iseq->arg_size;
vm_insnhelper.c:	VALUE * const rsp = GET_SP() - argc;
vm_insnhelper.c:	CHECK_STACK_OVERFLOW(GET_CFP(), iseq->stack_max);
vm_insnhelper.c:				     block_proc_is_lambda(block->proc));
vm_insnhelper.c:		      VM_FRAME_MAGIC_BLOCK, block->self, (VALUE) block->dfp,
vm_insnhelper.c:		      iseq->iseq_encoded + opt_pc, rsp + arg_size, block->lfp,
vm_insnhelper.c:		      iseq->local_size - arg_size);
vm_insnhelper.c:	VALUE val = vm_yield_with_cfunc(th, block, block->self, argc, STACK_ADDR_FROM_TOP(argc), 0);
vm_insnhelper.c:    if (lfp && th->local_lfp != lfp) {
vm_insnhelper.c:	svar = &lfp[-1];
vm_insnhelper.c:	svar = &th->local_svar;
vm_insnhelper.c:	return svar->u1.value;
vm_insnhelper.c:	return svar->u2.value;
vm_insnhelper.c:	const VALUE hash = svar->u3.value;
vm_insnhelper.c:	svar->u1.value = val;
vm_insnhelper.c:	svar->u2.value = val;
vm_insnhelper.c:	VALUE hash = svar->u3.value;
vm_insnhelper.c:	    svar->u3.value = hash = rb_hash_new();
vm_insnhelper.c:		rb_bug("unexpected back-ref");
vm_insnhelper.c:	    cref = iseq->cref_stack;
vm_insnhelper.c:	else if (dfp[-1] != Qnil) {
vm_insnhelper.c:	    cref = (NODE *)dfp[-1];
vm_insnhelper.c:    rb_control_frame_t *cfp = vm_get_ruby_level_caller_cfp(th, th->cfp);
vm_insnhelper.c:    cref->nd_file = 0;
vm_insnhelper.c:    cref->nd_visi = noex;
vm_insnhelper.c:	cref->nd_next = vm_get_cref(cfp->iseq, cfp->lfp, cfp->dfp);
vm_insnhelper.c:	if ((klass = cref->nd_clss) != 0) {
vm_insnhelper.c:	cref = cref->nd_next;
vm_insnhelper.c:	const NODE *root_cref = vm_get_cref(iseq, th->cfp->lfp, th->cfp->dfp);
vm_insnhelper.c:	while (cref && cref->nd_next) {
vm_insnhelper.c:	    klass = cref->nd_clss;
vm_insnhelper.c:	    cref = cref->nd_next;
vm_insnhelper.c:	klass = root_cref->nd_clss;
vm_insnhelper.c:	    klass = CLASS_OF(th->cfp->self);
vm_insnhelper.c:    while (cref && cref->nd_next &&
vm_insnhelper.c:	   (NIL_P(cref->nd_clss) || FL_TEST(cref->nd_clss, FL_SINGLETON))) {
vm_insnhelper.c:	cref = cref->nd_next;
vm_insnhelper.c:	if (!cref->nd_next) {
vm_insnhelper.c:    klass = cref->nd_clss;
vm_insnhelper.c:	if (LIKELY(klass == ic->ic_class) &&
vm_insnhelper.c:	    LIKELY(GET_VM_STATE_VERSION() == ic->ic_vmstat)) {
vm_insnhelper.c:	    mn = ic->ic_method;
vm_insnhelper.c:	    ic->ic_class = klass;
vm_insnhelper.c:	    ic->ic_method = mn;
vm_insnhelper.c:	    ic->ic_vmstat = GET_VM_STATE_VERSION();
vm_insnhelper.c:	    if (BUILTIN_TYPE(k) == T_ICLASS && RBASIC(k)->klass == klass) {
vm_insnhelper.c:    while (ip && !ip->klass) {
vm_insnhelper.c:	ip = ip->parent_iseq;
vm_insnhelper.c:    id = ip->defined_method_id;
vm_insnhelper.c:    if (ip != ip->local_iseq) {
vm_insnhelper.c:	while (lcfp->iseq != ip) {
vm_insnhelper.c:	    VALUE *tdfp = GET_PREV_DFP(lcfp->dfp);
vm_insnhelper.c:		if (lcfp->dfp == tdfp) {
vm_insnhelper.c:	id = lcfp->method_id;
vm_insnhelper.c:	klass = vm_search_normal_superclass(lcfp->method_class, recv);
vm_insnhelper.c:	klass = vm_search_normal_superclass(ip->klass, recv);
vm_insnhelper.c:		if (cfp->iseq->type != ISEQ_TYPE_BLOCK) {
vm_insnhelper.c:		    base_iseq = base_iseq->parent_iseq;
vm_insnhelper.c:		    while ((VALUE *) cfp < th->stack + th->stack_size) {
vm_insnhelper.c:			if (cfp->dfp == dfp) {
vm_insnhelper.c:		    pt = cfp->dfp;
vm_insnhelper.c:		    while ((VALUE *)cfp < th->stack + th->stack_size) {
vm_insnhelper.c:			if (cfp->dfp == dfp) {
vm_insnhelper.c:			    VALUE epc = epc = cfp->pc - cfp->iseq->iseq_encoded;
vm_insnhelper.c:			    rb_iseq_t *iseq = cfp->iseq;
vm_insnhelper.c:			    for (i=0; i<iseq->catch_table_size; i++) {
vm_insnhelper.c:				struct iseq_catch_table_entry *entry = &iseq->catch_table[i];
vm_insnhelper.c:				if (entry->type == CATCH_TYPE_BREAK &&
vm_insnhelper.c:				    entry->start < epc && entry->end >= epc) {
vm_insnhelper.c:				    if (entry->cont == epc) {
vm_insnhelper.c:		    rb_vm_localjump_error("break from proc-closure", throwobj, TAG_BREAK);
vm_insnhelper.c:		while ((VALUE *) cfp < th->stack + th->stack_size) {
vm_insnhelper.c:		    if (cfp->lfp == lfp) {
vm_insnhelper.c:				if (cfp->dfp == tdfp) {
vm_insnhelper.c:				    dfp = cfp->dfp;
vm_insnhelper.c:		    if (cfp->dfp == lfp && cfp->iseq->type == ISEQ_TYPE_METHOD) {
vm_insnhelper.c:	th->state = state;
vm_insnhelper.c:	    th->state = FIX2INT(err);
vm_insnhelper.c:	    th->state = TAG_THROW;
vm_insnhelper.c:	    th->state = GET_THROWOBJ_STATE(err);
vm_insnhelper.c:	    th->state = TAG_RAISE;
vm_insnhelper.c:	    /*th->state = FIX2INT(rb_ivar_get(err, idThrowState));*/
vm_insnhelper.c:    VALUE *base = cfp->sp, *ptr;
vm_insnhelper.c:    cfp->sp += space_size;
vm_insnhelper.c:	/* post: ..., nil ,ary[-1], ..., ary[0..-num] # top */
vm_insnhelper.c:	    for (i=0; i<num-len; i++) {
vm_insnhelper.c:	    VALUE v = ptr[len - j - 1];
vm_insnhelper.c:	    *base = rb_ary_new4(len - j, ptr);
vm_insnhelper.c:	/* normal: ary[num..-1], ary[num-2], ary[num-3], ..., ary[0] # top */
vm_insnhelper.c:	VALUE *bptr = &base[space_size - 1];
vm_insnhelper.c:		    *bptr-- = Qnil;
vm_insnhelper.c:	    *bptr-- = ptr[i];
vm_insnhelper.c:		*bptr = rb_ary_new4(len - num, ptr + num);
vm_insnhelper.c:    if (mn && nd_type(mn->nd_body) == NODE_CFUNC &&
vm_insnhelper.c:	mn->nd_body->nd_cfnc == func) {
vm_insnhelper.c~:  vm_insnhelper.c - instruction helper functions.
vm_insnhelper.c~:    rb_control_frame_t * const cfp = th->cfp = th->cfp - 1;
vm_insnhelper.c~:    cfp->pc = (VALUE *)pc;
vm_insnhelper.c~:    cfp->sp = sp + 1;
vm_insnhelper.c~:    cfp->bp = sp + 1;
vm_insnhelper.c~:    cfp->iseq = (rb_iseq_t *) iseq;
vm_insnhelper.c~:    cfp->flag = type;
vm_insnhelper.c~:    cfp->self = self;
vm_insnhelper.c~:    cfp->lfp = lfp;
vm_insnhelper.c~:    cfp->dfp = sp;
vm_insnhelper.c~:    cfp->proc = 0;
vm_insnhelper.c~:    cfp->prof_time_self = clock();
vm_insnhelper.c~:    cfp->prof_time_chld = 0;
vm_insnhelper.c~:    rb_control_frame_t *cfp = th->cfp;
vm_insnhelper.c~:    if (RUBY_VM_NORMAL_ISEQ_P(cfp->iseq)) {
vm_insnhelper.c~:	rb_control_frame_t *cfp = th->cfp;
vm_insnhelper.c~:	cfp->prof_time_self = current_time - cfp->prof_time_self;
vm_insnhelper.c~:	(cfp+1)->prof_time_chld += cfp->prof_time_self;
vm_insnhelper.c~:	cfp->iseq->profile.count++;
vm_insnhelper.c~:	cfp->iseq->profile.time_cumu = cfp->prof_time_self;
vm_insnhelper.c~:	cfp->iseq->profile.time_self = cfp->prof_time_self - cfp->prof_time_chld;
vm_insnhelper.c~:    th->cfp = RUBY_VM_PREVIOUS_CONTROL_FRAME(th->cfp);
vm_insnhelper.c~:    if (LIKELY(iseq->arg_simple & 0x01)) { \
vm_insnhelper.c~:	if (orig_argc != iseq->argc) { \
vm_insnhelper.c~:	    rb_raise(rb_eArgError, "wrong number of arguments (%d for %d)", orig_argc, iseq->argc); \
vm_insnhelper.c~:    const int m = iseq->argc;
vm_insnhelper.c~:    th->mark_stack_len = argc + iseq->arg_size;
vm_insnhelper.c~:    if (argc < (m + iseq->arg_post_len)) { /* check with post arg */
vm_insnhelper.c~:		 argc, m + iseq->arg_post_len);
vm_insnhelper.c~:    argc -= m;
vm_insnhelper.c~:    if (iseq->arg_post_len) {
vm_insnhelper.c~:	if (!(orig_argc < iseq->arg_post_start)) {
vm_insnhelper.c~:	MEMCPY(&orig_argv[iseq->arg_post_start], &argv[argc -= iseq->arg_post_len],
vm_insnhelper.c~:	       VALUE, iseq->arg_post_len);
vm_insnhelper.c~:    if (iseq->arg_opts) {
vm_insnhelper.c~:	const int opts = iseq->arg_opts - 1 /* no opt */;
vm_insnhelper.c~:	if (iseq->arg_rest == -1 && argc > opts) {
vm_insnhelper.c~:		     orig_argc, m + opts + iseq->arg_post_len);
vm_insnhelper.c~:	    argc -= opts;
vm_insnhelper.c~:	    opt_pc = iseq->arg_opt_table[opts]; /* no opt */
vm_insnhelper.c~:	    opt_pc = iseq->arg_opt_table[argc];
vm_insnhelper.c~:    if (iseq->arg_rest != -1) {
vm_insnhelper.c~:	orig_argv[iseq->arg_rest] = rb_ary_new4(argc, argv);
vm_insnhelper.c~:    if (block && iseq->arg_block != -1) {
vm_insnhelper.c~:		     orig_argc, m + iseq->arg_post_len);
vm_insnhelper.c~:	    if (blockptr->proc == 0) {
vm_insnhelper.c~:		*block = &proc->block;
vm_insnhelper.c~:		blockval = blockptr->proc;
vm_insnhelper.c~:	orig_argv[iseq->arg_block] = blockval; /* Proc or nil */
vm_insnhelper.c~:    th->mark_stack_len = 0;
vm_insnhelper.c~:	    proc = *(--cfp->sp);
vm_insnhelper.c~:		blockptr = &po->block;
vm_insnhelper.c~:		RUBY_VM_GET_BLOCK_PTR_IN_CFP(cfp)->proc = proc;
vm_insnhelper.c~:	    blockptr->iseq = blockiseq;
vm_insnhelper.c~:	    blockptr->proc = 0;
vm_insnhelper.c~:	VALUE ary = *(cfp->sp - 1);
vm_insnhelper.c~:	    cfp->sp -= 1;
vm_insnhelper.c~:		*cfp->sp++ = ptr[i];
vm_insnhelper.c~:	    argc += i-1;
vm_insnhelper.c~:      case -2:
vm_insnhelper.c~:      case -1:
vm_insnhelper.c~:    if (th->event_flags & RUBY_EVENT_C_RETURN) {
vm_insnhelper.c~:	_th->tag = _tag.prev;
vm_insnhelper.c~:			  recv, (VALUE) blockptr, 0, reg_cfp->sp, 0, 1);
vm_insnhelper.c~:	cfp->method_id = oid;
vm_insnhelper.c~:	cfp->method_class = klass;
vm_insnhelper.c~:	reg_cfp->sp -= num + 1;
vm_insnhelper.c~:	val = call_cfunc(mn->nd_cfnc, recv, mn->nd_argc, num, reg_cfp->sp + 1);
vm_insnhelper.c~:	if (reg_cfp != th->cfp + 1) {
vm_insnhelper.c~:	    rb_bug("cfp consistency error - send");
vm_insnhelper.c~:    rb_control_frame_t *cfp = th->cfp;
vm_insnhelper.c~:    (cfp-2)->method_id = id;
vm_insnhelper.c~:    (cfp-2)->method_class = klass;
vm_insnhelper.c~:    rb_control_frame_t * const reg_cfp = th->cfp;
vm_insnhelper.c~:    th->method_missing_reason = opt;
vm_insnhelper.c~:    th->passed_block = blockptr;
vm_insnhelper.c~:    VALUE *sp, *rsp = cfp->sp - argc;
vm_insnhelper.c~:    CHECK_STACK_OVERFLOW(cfp, iseq->stack_max);
vm_insnhelper.c~:    sp = rsp + iseq->arg_size;
vm_insnhelper.c~:		      iseq->local_size, iseq->arg_size);
vm_insnhelper.c~:	for (i = 0; i < iseq->local_size - iseq->arg_size; i++) {
vm_insnhelper.c~:		      iseq->iseq_encoded + opt_pc, sp, 0, 0);
vm_insnhelper.c~:	cfp->sp = rsp - 1 /* recv */;
vm_insnhelper.c~:	th->cfp++; /* pop cf */
vm_insnhelper.c~:	p_rsp = th->cfp->sp;
vm_insnhelper.c~:	for (i=0; i < (sp - rsp); i++) {
vm_insnhelper.c~:	sp -= rsp - p_rsp;
vm_insnhelper.c~:	for (i = 0; i < iseq->local_size - iseq->arg_size; i++) {
vm_insnhelper.c~:		      iseq->iseq_encoded + opt_pc, sp, 0, 0);
vm_insnhelper.c~:	if ((mn->nd_noex == 0)) {
vm_insnhelper.c~:	    node = mn->nd_body;
vm_insnhelper.c~:		vm_setup_method(th, cfp, num, blockptr, flag, (VALUE)node->nd_body, recv);
vm_insnhelper.c~:		val = vm_call_cfunc(th, cfp, num, id, (ID)mn->nd_file, recv, mn->nd_clss, flag, node, blockptr);
vm_insnhelper.c~:		val = rb_ivar_set(recv, node->nd_vid, *(cfp->sp - 1));
vm_insnhelper.c~:		cfp->sp -= 2;
vm_insnhelper.c~:		val = rb_attr_get(recv, node->nd_vid);
vm_insnhelper.c~:		cfp->sp -= 1;
vm_insnhelper.c~:		MEMCPY(argv, cfp->sp - num, VALUE, num);
vm_insnhelper.c~:		cfp->sp += - num - 1;
vm_insnhelper.c~:		val = vm_call_bmethod(th, (ID)mn->nd_file, node->nd_cval, recv, mn->nd_clss, num, argv, blockptr);
vm_insnhelper.c~:		klass = RCLASS_SUPER(mn->nd_clss);
vm_insnhelper.c~:		(mn->nd_noex & NOEX_MASK) & NOEX_PRIVATE) {
vm_insnhelper.c~:	    else if (((mn->nd_noex & NOEX_MASK) & NOEX_PROTECTED) &&
vm_insnhelper.c~:		VALUE defined_class = mn->nd_clss;
vm_insnhelper.c~:		    defined_class = RBASIC(defined_class)->klass;
vm_insnhelper.c~:		if (!rb_obj_is_kind_of(cfp->self, rb_class_real(defined_class))) {
vm_insnhelper.c~:	    else if ((noex_safe = NOEX_SAFE(mn->nd_noex)) > th->safe_level &&
vm_insnhelper.c~:	    vm_method_missing_args(th, argv, num - 1, 0, stat);
vm_insnhelper.c~:    if (*mn && nd_type((*mn)->nd_body) == NODE_CFUNC) {
vm_insnhelper.c~:	NODE *node = (*mn)->nd_body;
vm_insnhelper.c~:	if (node->nd_cfnc == rb_f_send) {
vm_insnhelper.c~:	    int i = *num - 1;
vm_insnhelper.c~:		MEMMOVE(&TOPN(i), &TOPN(i-1), VALUE, i);
vm_insnhelper.c~:	    *num -= 1;
vm_insnhelper.c~:	return proc->is_lambda;
vm_insnhelper.c~:    NODE *ifunc = (NODE *) block->iseq;
vm_insnhelper.c~:    int lambda = block_proc_is_lambda(block->proc);
vm_insnhelper.c~:	if (blockargptr->proc) {
vm_insnhelper.c~:	    blockarg = blockargptr->proc;
vm_insnhelper.c~:		  self, (VALUE)block->dfp,
vm_insnhelper.c~:		  0, th->cfp->sp, block->lfp, 1);
vm_insnhelper.c~:    val = (*ifunc->nd_cfnc) (arg, ifunc->nd_tval, argc, argv, blockarg);
vm_insnhelper.c~:    th->cfp++;
vm_insnhelper.c~:/*--
vm_insnhelper.c~:    const int m = iseq->argc;
vm_insnhelper.c~:    const int r = iseq->arg_rest;
vm_insnhelper.c~:    int len = iseq->arg_post_len;
vm_insnhelper.c~:    int start = iseq->arg_post_start;
vm_insnhelper.c~:    int rsize = argc > m ? argc - m : 0;    /* # of arguments which did not consumed yet */
vm_insnhelper.c~:    rsize -= psize;
vm_insnhelper.c~:    if (iseq->arg_opts) {
vm_insnhelper.c~:	const int opts = iseq->arg_opts - 1;
vm_insnhelper.c~:	    opt_pc = iseq->arg_opt_table[opts];
vm_insnhelper.c~:	    opt_pc = iseq->arg_opt_table[rsize];
vm_insnhelper.c~:    rsize -= osize;
vm_insnhelper.c~:    if (r == -1) {
vm_insnhelper.c~:    const int m = iseq->argc;
vm_insnhelper.c~:    th->mark_stack_len = argc;
vm_insnhelper.c~:    if (!(iseq->arg_simple & 0x02) &&          /* exclude {|a|} */
vm_insnhelper.c~:            (m + iseq->arg_post_len) > 0 &&    /* this process is meaningful */
vm_insnhelper.c~:        th->mark_stack_len = argc = RARRAY_LEN(ary);
vm_insnhelper.c~:        CHECK_STACK_OVERFLOW(th->cfp, argc);
vm_insnhelper.c~:    if (iseq->arg_rest == -1 && iseq->arg_opts == 0) {
vm_insnhelper.c~:        const int arg_size = iseq->arg_size;
vm_insnhelper.c~:            th->mark_stack_len = argc = arg_size;
vm_insnhelper.c~:        int r = iseq->arg_rest;
vm_insnhelper.c~:        if (iseq->arg_post_len || 
vm_insnhelper.c~:                iseq->arg_opts) { /* TODO: implement simple version for (iseq->arg_post_len==0 && iseq->arg_opts > 0) */
vm_insnhelper.c~:                argv[r] = rb_ary_new4(argc-r, &argv[r]);
vm_insnhelper.c~:        th->mark_stack_len = iseq->arg_size;
vm_insnhelper.c~:    if (iseq->arg_block != -1) {
vm_insnhelper.c~:            procval = blockptr->proc;
vm_insnhelper.c~:        argv[iseq->arg_block] = procval;
vm_insnhelper.c~:    th->mark_stack_len = 0;
vm_insnhelper.c~:	printf("iseq argc: %d\n", iseq->argc);
vm_insnhelper.c~:	printf("iseq opts: %d\n", iseq->arg_opts);
vm_insnhelper.c~:	printf("iseq rest: %d\n", iseq->arg_rest);
vm_insnhelper.c~:	printf("iseq post: %d\n", iseq->arg_post_len);
vm_insnhelper.c~:	printf("iseq blck: %d\n", iseq->arg_block);
vm_insnhelper.c~:	printf("iseq smpl: %d\n", iseq->arg_simple);
vm_insnhelper.c~:    if (GET_ISEQ()->local_iseq->type != ISEQ_TYPE_METHOD || block == 0) {
vm_insnhelper.c~:    iseq = block->iseq;
vm_insnhelper.c~:	const int arg_size = iseq->arg_size;
vm_insnhelper.c~:	VALUE * const rsp = GET_SP() - argc;
vm_insnhelper.c~:	CHECK_STACK_OVERFLOW(GET_CFP(), iseq->stack_max);
vm_insnhelper.c~:				     block_proc_is_lambda(block->proc));
vm_insnhelper.c~:		      VM_FRAME_MAGIC_BLOCK, block->self, (VALUE) block->dfp,
vm_insnhelper.c~:		      iseq->iseq_encoded + opt_pc, rsp + arg_size, block->lfp,
vm_insnhelper.c~:		      iseq->local_size - arg_size);
vm_insnhelper.c~:	VALUE val = vm_yield_with_cfunc(th, block, block->self, argc, STACK_ADDR_FROM_TOP(argc), 0);
vm_insnhelper.c~:    if (lfp && th->local_lfp != lfp) {
vm_insnhelper.c~:	svar = &lfp[-1];
vm_insnhelper.c~:	svar = &th->local_svar;
vm_insnhelper.c~:	return svar->u1.value;
vm_insnhelper.c~:	return svar->u2.value;
vm_insnhelper.c~:	const VALUE hash = svar->u3.value;
vm_insnhelper.c~:	svar->u1.value = val;
vm_insnhelper.c~:	svar->u2.value = val;
vm_insnhelper.c~:	VALUE hash = svar->u3.value;
vm_insnhelper.c~:	    svar->u3.value = hash = rb_hash_new();
vm_insnhelper.c~:		rb_bug("unexpected back-ref");
vm_insnhelper.c~:	    cref = iseq->cref_stack;
vm_insnhelper.c~:	else if (dfp[-1] != Qnil) {
vm_insnhelper.c~:	    cref = (NODE *)dfp[-1];
vm_insnhelper.c~:    rb_control_frame_t *cfp = vm_get_ruby_level_caller_cfp(th, th->cfp);
vm_insnhelper.c~:    cref->nd_file = 0;
vm_insnhelper.c~:    cref->nd_visi = noex;
vm_insnhelper.c~:	cref->nd_next = vm_get_cref(cfp->iseq, cfp->lfp, cfp->dfp);
vm_insnhelper.c~:	if ((klass = cref->nd_clss) != 0) {
vm_insnhelper.c~:	cref = cref->nd_next;
vm_insnhelper.c~:	const NODE *root_cref = vm_get_cref(iseq, th->cfp->lfp, th->cfp->dfp);
vm_insnhelper.c~:	while (cref && cref->nd_next) {
vm_insnhelper.c~:	    klass = cref->nd_clss;
vm_insnhelper.c~:	    cref = cref->nd_next;
vm_insnhelper.c~:	klass = root_cref->nd_clss;
vm_insnhelper.c~:	    klass = CLASS_OF(th->cfp->self);
vm_insnhelper.c~:    while (cref && cref->nd_next &&
vm_insnhelper.c~:	   (NIL_P(cref->nd_clss) || FL_TEST(cref->nd_clss, FL_SINGLETON))) {
vm_insnhelper.c~:	cref = cref->nd_next;
vm_insnhelper.c~:	if (!cref->nd_next) {
vm_insnhelper.c~:    klass = cref->nd_clss;
vm_insnhelper.c~:	if (LIKELY(klass == ic->ic_class) &&
vm_insnhelper.c~:	    LIKELY(GET_VM_STATE_VERSION() == ic->ic_vmstat)) {
vm_insnhelper.c~:	    mn = ic->ic_method;
vm_insnhelper.c~:	    ic->ic_class = klass;
vm_insnhelper.c~:	    ic->ic_method = mn;
vm_insnhelper.c~:	    ic->ic_vmstat = GET_VM_STATE_VERSION();
vm_insnhelper.c~:	    if (BUILTIN_TYPE(k) == T_ICLASS && RBASIC(k)->klass == klass) {
vm_insnhelper.c~:    while (ip && !ip->klass) {
vm_insnhelper.c~:	ip = ip->parent_iseq;
vm_insnhelper.c~:    id = ip->defined_method_id;
vm_insnhelper.c~:    if (ip != ip->local_iseq) {
vm_insnhelper.c~:	while (lcfp->iseq != ip) {
vm_insnhelper.c~:	    VALUE *tdfp = GET_PREV_DFP(lcfp->dfp);
vm_insnhelper.c~:		if (lcfp->dfp == tdfp) {
vm_insnhelper.c~:	id = lcfp->method_id;
vm_insnhelper.c~:	klass = vm_search_normal_superclass(lcfp->method_class, recv);
vm_insnhelper.c~:	klass = vm_search_normal_superclass(ip->klass, recv);
vm_insnhelper.c~:		if (cfp->iseq->type != ISEQ_TYPE_BLOCK) {
vm_insnhelper.c~:		    base_iseq = base_iseq->parent_iseq;
vm_insnhelper.c~:		    while ((VALUE *) cfp < th->stack + th->stack_size) {
vm_insnhelper.c~:			if (cfp->dfp == dfp) {
vm_insnhelper.c~:		    pt = cfp->dfp;
vm_insnhelper.c~:		    while ((VALUE *)cfp < th->stack + th->stack_size) {
vm_insnhelper.c~:			if (cfp->dfp == dfp) {
vm_insnhelper.c~:			    VALUE epc = epc = cfp->pc - cfp->iseq->iseq_encoded;
vm_insnhelper.c~:			    rb_iseq_t *iseq = cfp->iseq;
vm_insnhelper.c~:			    for (i=0; i<iseq->catch_table_size; i++) {
vm_insnhelper.c~:				struct iseq_catch_table_entry *entry = &iseq->catch_table[i];
vm_insnhelper.c~:				if (entry->type == CATCH_TYPE_BREAK &&
vm_insnhelper.c~:				    entry->start < epc && entry->end >= epc) {
vm_insnhelper.c~:				    if (entry->cont == epc) {
vm_insnhelper.c~:		    rb_vm_localjump_error("break from proc-closure", throwobj, TAG_BREAK);
vm_insnhelper.c~:		while ((VALUE *) cfp < th->stack + th->stack_size) {
vm_insnhelper.c~:		    if (cfp->lfp == lfp) {
vm_insnhelper.c~:				if (cfp->dfp == tdfp) {
vm_insnhelper.c~:				    dfp = cfp->dfp;
vm_insnhelper.c~:		    if (cfp->dfp == lfp && cfp->iseq->type == ISEQ_TYPE_METHOD) {
vm_insnhelper.c~:	th->state = state;
vm_insnhelper.c~:	    th->state = FIX2INT(err);
vm_insnhelper.c~:	    th->state = TAG_THROW;
vm_insnhelper.c~:	    th->state = GET_THROWOBJ_STATE(err);
vm_insnhelper.c~:	    th->state = TAG_RAISE;
vm_insnhelper.c~:	    /*th->state = FIX2INT(rb_ivar_get(err, idThrowState));*/
vm_insnhelper.c~:    VALUE *base = cfp->sp, *ptr;
vm_insnhelper.c~:    cfp->sp += space_size;
vm_insnhelper.c~:	/* post: ..., nil ,ary[-1], ..., ary[0..-num] # top */
vm_insnhelper.c~:	    for (i=0; i<num-len; i++) {
vm_insnhelper.c~:	    VALUE v = ptr[len - j - 1];
vm_insnhelper.c~:	    *base = rb_ary_new4(len - j, ptr);
vm_insnhelper.c~:	/* normal: ary[num..-1], ary[num-2], ary[num-3], ..., ary[0] # top */
vm_insnhelper.c~:	VALUE *bptr = &base[space_size - 1];
vm_insnhelper.c~:		    *bptr-- = Qnil;
vm_insnhelper.c~:	    *bptr-- = ptr[i];
vm_insnhelper.c~:		*bptr = rb_ary_new4(len - num, ptr + num);
vm_insnhelper.c~:    if (mn && nd_type(mn->nd_body) == NODE_CFUNC &&
vm_insnhelper.c~:	mn->nd_body->nd_cfnc == func) {
vm_insnhelper.h:  insnhelper.h - helper macros to implement each instructions
vm_insnhelper.h:  Copyright (C) 2004-2007 Koichi Sasada
vm_insnhelper.h:#define TOPN(n) (*(GET_SP()-(n)-1))
vm_insnhelper.h:#define STACK_ADDR_FROM_TOP(n) (GET_SP()-(n))
vm_insnhelper.h:#define REG_PC  (REG_CFP->pc)
vm_insnhelper.h:#define REG_SP  (REG_CFP->sp)
vm_insnhelper.h:#define REG_LFP (REG_CFP->lfp)
vm_insnhelper.h:#define REG_DFP (REG_CFP->dfp)
vm_insnhelper.h:  REG_CFP = th->cfp; \
vm_insnhelper.h:#define GET_PC_COUNT()     (REG_PC - GET_ISEQ()->iseq_encoded)
vm_insnhelper.h:#define DEC_SP(x)  (REG_SP -= (USAGE_ANALYSIS_REGISTER_HELPER(1, 1, (x))))
vm_insnhelper.h:#define GET_SP_COUNT() (REG_SP - th->stack)
vm_insnhelper.h:#define GET_ISEQ() (GET_CFP()->iseq)
vm_insnhelper.h:#define GET_SELF() (USAGE_ANALYSIS_REGISTER_HELPER(5, 0, GET_CFP()->self))
vm_insnhelper.h:  c1->nd_clss = __tmp_c2->nd_clss; \
vm_insnhelper.h:  c1->nd_visi = __tmp_c2->nd_visi; \
vm_insnhelper.h:  c1->nd_next = __tmp_c2->nd_next; \
vm_insnhelper.h:#define HEAP_CLASS_OF(obj) RBASIC(obj)->klass
vm_method.c:#define ruby_running (GET_VM()->running)
vm_method.c:	ent->mid = 0;
vm_method.c:	if (ent->oklass == klass && ent->mid == id) {
vm_method.c:	    ent->mid = 0;
vm_method.c:	if (ent->mid == id) {
vm_method.c:	    ent->mid = 0;
vm_method.c:	if (ent->klass == klass || ent->oklass == klass) {
vm_method.c:	    ent->mid = 0;
vm_method.c:     *   nd_file : original id   // RBASIC()->klass (TODO: dirty hack)
vm_method.c:	method->nd_file = (void *)mid;
vm_method.c:	/* check re-definition */
vm_method.c:		if (nd_type(old_node->nd_body->nd_body) == NODE_CFUNC) {
vm_method.c:		if (RTEST(ruby_verbose) && node && old_node->nd_cnt == 0 && old_node->nd_body) {
vm_method.c:    n = n->nd_body;
vm_method.c:    return (rb_alloc_func_t)n->nd_cfnc;
vm_method.c:    if ((fbody = search_method(klass, id, 0)) == 0 || !fbody->nd_body) {
vm_method.c:	ent->klass = klass;
vm_method.c:	ent->mid = ent->mid0 = id;
vm_method.c:	ent->method = 0;
vm_method.c:	ent->oklass = 0;
vm_method.c:    method = fbody->nd_body;
vm_method.c:	ent->klass = klass;
vm_method.c:	ent->mid = id;
vm_method.c:	ent->mid0 = fbody->nd_oid;
vm_method.c:	ent->method = body = method;
vm_method.c:	ent->oklass = method->nd_clss;
vm_method.c:	*idp = fbody->nd_oid;
vm_method.c:    if (ent->mid == id && ent->klass == klass) {
vm_method.c:	if (ent->method) return ent->method;
vm_method.c:	if (!body || !body->nd_body) body = 0;
vm_method.c:    if (nd_type(body->nd_body->nd_body) == NODE_CFUNC) {
vm_method.c: *  call-seq:
vm_method.c:    /* obsolete - no use */
vm_method.c:    if (!fbody || !fbody->nd_body) {
vm_method.c:    if (fbody->nd_body->nd_noex != noex) {
vm_method.c:	if (nd_type(fbody->nd_body->nd_body) == NODE_CFUNC) {
vm_method.c:	    fbody->nd_body->nd_noex = noex;
vm_method.c:	if (ex && (method->nd_noex & NOEX_PRIVATE)) {
vm_method.c:    if (!body || !body->nd_body) {
vm_method.c: *  call-seq:
vm_method.c: *  superclasses and mixed-in modules for a possible receiver.
vm_method.c: *  call-seq:
vm_method.c: *  call-seq:
vm_method.c:	if (VISI_CHECK(method->nd_noex, NOEX_PUBLIC))
vm_method.c: *  call-seq:
vm_method.c:	if (VISI_CHECK(method->nd_noex, NOEX_PRIVATE))
vm_method.c: *  call-seq:
vm_method.c:	if (VISI_CHECK(method->nd_noex, NOEX_PROTECTED))
vm_method.c:    if (!orig_fbody || !orig_fbody->nd_body) {
vm_method.c:    if (!orig_fbody || !orig_fbody->nd_body) {
vm_method.c:    orig_fbody->nd_cnt++;
vm_method.c:	    if (RTEST(ruby_verbose) && node->nd_cnt == 0 && node->nd_body) {
vm_method.c:	    if (nd_type(node->nd_body->nd_body) == NODE_CFUNC) {
vm_method.c:		  method = NEW_METHOD(orig_fbody->nd_body->nd_body,
vm_method.c:			     orig_fbody->nd_body->nd_clss,
vm_method.c:			     NOEX_WITH_SAFE(orig_fbody->nd_body->nd_noex)), def));
vm_method.c:    method->nd_file = (void *)def;
vm_method.c: *  call-seq:
vm_method.c: *  call-seq:
vm_method.c: *  call-seq:
vm_method.c: *  call-seq:
vm_method.c: *  call-seq:
vm_method.c: *  call-seq:
vm_method.c: *  call-seq:
vm_method.c: *  call-seq:
vm_method.c: *  independently. The instance-method versions are made private. If
vm_method.c:	    if (fbody == 0 || fbody->nd_body == 0) {
vm_method.c:	    if (nd_type(fbody->nd_body->nd_body) != NODE_ZSUPER) {
vm_method.c:	rb_add_method(rb_singleton_class(module), id, fbody->nd_body->nd_body,
vm_method.c:    if (node && (node->nd_noex & NOEX_BASIC))
vm_method.c: *  call-seq:
vm_method.c:    rb_define_method(rb_mKernel, "respond_to?", obj_respond_to, -1);
vm_method.c:    rb_define_private_method(rb_cModule, "remove_method", rb_mod_remove_method, -1);
vm_method.c:    rb_define_private_method(rb_cModule, "undef_method", rb_mod_undef_method, -1);
vm_method.c:    rb_define_private_method(rb_cModule, "public", rb_mod_public, -1);
vm_method.c:    rb_define_private_method(rb_cModule, "protected", rb_mod_protected, -1);
vm_method.c:    rb_define_private_method(rb_cModule, "private", rb_mod_private, -1);
vm_method.c:    rb_define_private_method(rb_cModule, "module_function", rb_mod_modfunc, -1);
vm_method.c:    rb_define_method(rb_cModule, "public_class_method", rb_mod_public_method, -1);
vm_method.c:    rb_define_method(rb_cModule, "private_class_method", rb_mod_private_method, -1);
vm_method.c:    rb_define_singleton_method(rb_vm_top_self(), "public", top_public, -1);
vm_method.c:    rb_define_singleton_method(rb_vm_top_self(), "private", top_private, -1);
vm_opts.h:/*-*-c-*-*/
vm_opts.h:  vm_opts.h - VM optimize option
vm_opts.h:  Copyright (C) 2004-2007 Koichi Sasada
vmtc.inc:/* -*-c-*- *********************************************************/
vmtc.inc:  ----
